var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp.call(b, prop2))
      __defNormalProp(a, prop2, b[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop2))
        __defNormalProp(a, prop2, b[prop2]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
var style$1 = /* @__PURE__ */ (() => `@charset "UTF-8";
.resize-observer[data-v-b329ee4c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}
.resize-observer[data-v-b329ee4c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}
.v-popper__popper{z-index:10000;top:0;left:0;outline:none}
.v-popper__popper.v-popper__popper--hidden{visibility:hidden;opacity:0;transition:opacity .15s,visibility .15s;pointer-events:none}
.v-popper__popper.v-popper__popper--shown{visibility:visible;opacity:1;transition:opacity .15s}
.v-popper__popper.v-popper__popper--skip-transition,.v-popper__popper.v-popper__popper--skip-transition>.v-popper__wrapper{transition:none!important}
.v-popper__backdrop{position:absolute;top:0;left:0;width:100%;height:100%;display:none}
.v-popper__inner{position:relative;box-sizing:border-box;overflow-y:auto}
.v-popper__inner>div{position:relative;z-index:1;max-width:inherit;max-height:inherit}
.v-popper__arrow-container{position:absolute;width:10px;height:10px}
.v-popper__popper--arrow-overflow .v-popper__arrow-container,.v-popper__popper--no-positioning .v-popper__arrow-container{display:none}
.v-popper__arrow-inner,.v-popper__arrow-outer{border-style:solid;position:absolute;top:0;left:0;width:0;height:0}
.v-popper__arrow-inner{visibility:hidden;border-width:7px}
.v-popper__arrow-outer{border-width:6px}
.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner{left:-2px}
.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-outer,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{left:-1px}
.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-outer{border-bottom-width:0;border-left-color:transparent!important;border-right-color:transparent!important;border-bottom-color:transparent!important}
.v-popper__popper[data-popper-placement^=top] .v-popper__arrow-inner{top:-2px}
.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-container{top:0}
.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{border-top-width:0;border-left-color:transparent!important;border-right-color:transparent!important;border-top-color:transparent!important}
.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-inner{top:-4px}
.v-popper__popper[data-popper-placement^=bottom] .v-popper__arrow-outer{top:-6px}
.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner{top:-2px}
.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-outer,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{top:-1px}
.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{border-left-width:0;border-left-color:transparent!important;border-top-color:transparent!important;border-bottom-color:transparent!important}
.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-inner{left:-4px}
.v-popper__popper[data-popper-placement^=right] .v-popper__arrow-outer{left:-6px}
.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-container{right:-10px}
.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner,.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-outer{border-right-width:0;border-top-color:transparent!important;border-right-color:transparent!important;border-bottom-color:transparent!important}
.v-popper__popper[data-popper-placement^=left] .v-popper__arrow-inner{left:-2px}
.v-popper--theme-dropdown .v-popper__inner{background:#fff;color:#000;border-radius:6px;border:1px solid #ddd;box-shadow:0 6px 30px #0000001a}
.v-popper--theme-dropdown .v-popper__arrow-inner{visibility:visible;border-color:#fff}
.v-popper--theme-dropdown .v-popper__arrow-outer{border-color:#ddd}
.v-popper--theme-tooltip .v-popper__inner{background:rgba(0,0,0,.8);color:#fff;border-radius:6px;padding:7px 12px 6px}
.v-popper--theme-tooltip .v-popper__arrow-outer{border-color:#000c}
.fui-row *,
.fui-row :after,
.fui-row :before {
  box-sizing: border-box;
}
.fui-row {
  display: flex;
  flex-wrap: wrap;
  margin-right: -10px;
  margin-left: -10px;
}
.fui-row.small-padding, .fui-row.small-gutters {
  margin-right: -5px;
  margin-left: -5px;
}
.fui-row.small-padding > .fui-col,
.fui-row.small-padding > [class^=fui-col-], .fui-row.small-gutters > .fui-col,
.fui-row.small-gutters > [class^=fui-col-] {
  padding-right: 5px;
  padding-left: 5px;
}
.fui-row.no-padding, .fui-row.no-gutters {
  margin-right: 0;
  margin-left: 0;
}
.fui-row.no-padding > .fui-col,
.fui-row.no-padding > [class^=fui-col-], .fui-row.no-gutters > .fui-col,
.fui-row.no-gutters > [class^=fui-col-] {
  padding-right: 0;
  padding-left: 0;
}
.fui-col,
[class^=fui-col-] {
  position: relative;
  width: 100%;
  min-height: 1px;
  padding-right: 10px;
  padding-left: 10px;
}
.fui-col-1 {
  flex: 0 0 8.3333333333%;
  max-width: 8.3333333333%;
}
.fui-col-2 {
  flex: 0 0 16.6666666667%;
  max-width: 16.6666666667%;
}
.fui-col-3 {
  flex: 0 0 25%;
  max-width: 25%;
}
.fui-col-4 {
  flex: 0 0 33.3333333333%;
  max-width: 33.3333333333%;
}
.fui-col-5 {
  flex: 0 0 41.6666666667%;
  max-width: 41.6666666667%;
}
.fui-col-6 {
  flex: 0 0 50%;
  max-width: 50%;
}
.fui-col-7 {
  flex: 0 0 58.3333333333%;
  max-width: 58.3333333333%;
}
.fui-col-8 {
  flex: 0 0 66.6666666667%;
  max-width: 66.6666666667%;
}
.fui-col-9 {
  flex: 0 0 75%;
  max-width: 75%;
}
.fui-col-10 {
  flex: 0 0 83.3333333333%;
  max-width: 83.3333333333%;
}
.fui-col-11 {
  flex: 0 0 91.6666666667%;
  max-width: 91.6666666667%;
}
.fui-col-12 {
  flex: 0 0 100%;
  max-width: 100%;
}
.fui-col-auto {
  flex-basis: 0;
  flex-grow: 1;
  max-width: 100%;
}
.v-popper--theme-tooltip .v-popper__inner {
  background-color: #1c2e36;
  padding: 4px 8px;
  font-size: 12px;
  color: #fff;
  border-radius: 3px;
}
.v-popper--theme-tooltip .v-popper__arrow-outer {
  border-color: #1c2e36;
}
/*!
 * Font Awesome Pro 5.13.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license (Commercial License)
 */
.fa,
.fas,
.far,
.fal,
.fad,
.fab {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  display: inline-block;
  font-style: normal;
  font-variant: normal;
  text-rendering: auto;
  line-height: 1;
}
.fa-lg {
  font-size: 1.33333em;
  line-height: 0.75em;
  vertical-align: -0.0667em;
}
.fa-xs {
  font-size: 0.75em;
}
.fa-sm {
  font-size: 0.875em;
}
.fa-1x {
  font-size: 1em;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-6x {
  font-size: 6em;
}
.fa-7x {
  font-size: 7em;
}
.fa-8x {
  font-size: 8em;
}
.fa-9x {
  font-size: 9em;
}
.fa-10x {
  font-size: 10em;
}
.fa-fw {
  text-align: center;
  width: 1.25em;
}
.fa-ul {
  list-style-type: none;
  margin-left: 2.5em;
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  left: -2em;
  position: absolute;
  text-align: center;
  width: 2em;
  line-height: inherit;
}
.fa-border {
  border: solid 0.08em #eee;
  border-radius: 0.1em;
  padding: 0.2em 0.25em 0.15em;
}
.fa-pull-left {
  float: left;
}
.fa-pull-right {
  float: right;
}
.fa.fa-pull-left,
.fas.fa-pull-left,
.far.fa-pull-left,
.fal.fa-pull-left,
.fab.fa-pull-left {
  margin-right: 0.3em;
}
.fa.fa-pull-right,
.fas.fa-pull-right,
.far.fa-pull-right,
.fal.fa-pull-right,
.fab.fa-pull-right {
  margin-left: 0.3em;
}
.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
  animation: fa-spin 2s infinite linear;
}
.fa-pulse {
  -webkit-animation: fa-spin 1s infinite steps(8);
  animation: fa-spin 1s infinite steps(8);
}
@-webkit-keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
  transform: rotate(90deg);
}
.fa-rotate-180 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
  transform: rotate(180deg);
}
.fa-rotate-270 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  transform: scale(1, -1);
}
.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  transform: scale(-1, -1);
}
:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical,
:root .fa-flip-both {
  filter: none;
}
.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}
.fa-stack-1x,
.fa-stack-2x {
  left: 0;
  position: absolute;
  text-align: center;
  width: 100%;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #fff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
readers do not read off random characters that represent icons */
.fa-500px:before {
  content: "\\f26e";
}
.fa-abacus:before {
  content: "\\f640";
}
.fa-accessible-icon:before {
  content: "\\f368";
}
.fa-accusoft:before {
  content: "\\f369";
}
.fa-acorn:before {
  content: "\\f6ae";
}
.fa-acquisitions-incorporated:before {
  content: "\\f6af";
}
.fa-ad:before {
  content: "\\f641";
}
.fa-address-book:before {
  content: "\\f2b9";
}
.fa-address-card:before {
  content: "\\f2bb";
}
.fa-adjust:before {
  content: "\\f042";
}
.fa-adn:before {
  content: "\\f170";
}
.fa-adobe:before {
  content: "\\f778";
}
.fa-adversal:before {
  content: "\\f36a";
}
.fa-affiliatetheme:before {
  content: "\\f36b";
}
.fa-air-conditioner:before {
  content: "\\f8f4";
}
.fa-air-freshener:before {
  content: "\\f5d0";
}
.fa-airbnb:before {
  content: "\\f834";
}
.fa-alarm-clock:before {
  content: "\\f34e";
}
.fa-alarm-exclamation:before {
  content: "\\f843";
}
.fa-alarm-plus:before {
  content: "\\f844";
}
.fa-alarm-snooze:before {
  content: "\\f845";
}
.fa-album:before {
  content: "\\f89f";
}
.fa-album-collection:before {
  content: "\\f8a0";
}
.fa-algolia:before {
  content: "\\f36c";
}
.fa-alicorn:before {
  content: "\\f6b0";
}
.fa-alien:before {
  content: "\\f8f5";
}
.fa-alien-monster:before {
  content: "\\f8f6";
}
.fa-align-center:before {
  content: "\\f037";
}
.fa-align-justify:before {
  content: "\\f039";
}
.fa-align-left:before {
  content: "\\f036";
}
.fa-align-right:before {
  content: "\\f038";
}
.fa-align-slash:before {
  content: "\\f846";
}
.fa-alipay:before {
  content: "\\f642";
}
.fa-allergies:before {
  content: "\\f461";
}
.fa-amazon:before {
  content: "\\f270";
}
.fa-amazon-pay:before {
  content: "\\f42c";
}
.fa-ambulance:before {
  content: "\\f0f9";
}
.fa-american-sign-language-interpreting:before {
  content: "\\f2a3";
}
.fa-amilia:before {
  content: "\\f36d";
}
.fa-amp-guitar:before {
  content: "\\f8a1";
}
.fa-analytics:before {
  content: "\\f643";
}
.fa-anchor:before {
  content: "\\f13d";
}
.fa-android:before {
  content: "\\f17b";
}
.fa-angel:before {
  content: "\\f779";
}
.fa-angellist:before {
  content: "\\f209";
}
.fa-angle-double-down:before {
  content: "\\f103";
}
.fa-angle-double-left:before {
  content: "\\f100";
}
.fa-angle-double-right:before {
  content: "\\f101";
}
.fa-angle-double-up:before {
  content: "\\f102";
}
.fa-angle-down:before {
  content: "\\f107";
}
.fa-angle-left:before {
  content: "\\f104";
}
.fa-angle-right:before {
  content: "\\f105";
}
.fa-angle-up:before {
  content: "\\f106";
}
.fa-angry:before {
  content: "\\f556";
}
.fa-angrycreative:before {
  content: "\\f36e";
}
.fa-angular:before {
  content: "\\f420";
}
.fa-ankh:before {
  content: "\\f644";
}
.fa-app-store:before {
  content: "\\f36f";
}
.fa-app-store-ios:before {
  content: "\\f370";
}
.fa-apper:before {
  content: "\\f371";
}
.fa-apple:before {
  content: "\\f179";
}
.fa-apple-alt:before {
  content: "\\f5d1";
}
.fa-apple-crate:before {
  content: "\\f6b1";
}
.fa-apple-pay:before {
  content: "\\f415";
}
.fa-archive:before {
  content: "\\f187";
}
.fa-archway:before {
  content: "\\f557";
}
.fa-arrow-alt-circle-down:before {
  content: "\\f358";
}
.fa-arrow-alt-circle-left:before {
  content: "\\f359";
}
.fa-arrow-alt-circle-right:before {
  content: "\\f35a";
}
.fa-arrow-alt-circle-up:before {
  content: "\\f35b";
}
.fa-arrow-alt-down:before {
  content: "\\f354";
}
.fa-arrow-alt-from-bottom:before {
  content: "\\f346";
}
.fa-arrow-alt-from-left:before {
  content: "\\f347";
}
.fa-arrow-alt-from-right:before {
  content: "\\f348";
}
.fa-arrow-alt-from-top:before {
  content: "\\f349";
}
.fa-arrow-alt-left:before {
  content: "\\f355";
}
.fa-arrow-alt-right:before {
  content: "\\f356";
}
.fa-arrow-alt-square-down:before {
  content: "\\f350";
}
.fa-arrow-alt-square-left:before {
  content: "\\f351";
}
.fa-arrow-alt-square-right:before {
  content: "\\f352";
}
.fa-arrow-alt-square-up:before {
  content: "\\f353";
}
.fa-arrow-alt-to-bottom:before {
  content: "\\f34a";
}
.fa-arrow-alt-to-left:before {
  content: "\\f34b";
}
.fa-arrow-alt-to-right:before {
  content: "\\f34c";
}
.fa-arrow-alt-to-top:before {
  content: "\\f34d";
}
.fa-arrow-alt-up:before {
  content: "\\f357";
}
.fa-arrow-circle-down:before {
  content: "\\f0ab";
}
.fa-arrow-circle-left:before {
  content: "\\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\\f0aa";
}
.fa-arrow-down:before {
  content: "\\f063";
}
.fa-arrow-from-bottom:before {
  content: "\\f342";
}
.fa-arrow-from-left:before {
  content: "\\f343";
}
.fa-arrow-from-right:before {
  content: "\\f344";
}
.fa-arrow-from-top:before {
  content: "\\f345";
}
.fa-arrow-left:before {
  content: "\\f060";
}
.fa-arrow-right:before {
  content: "\\f061";
}
.fa-arrow-square-down:before {
  content: "\\f339";
}
.fa-arrow-square-left:before {
  content: "\\f33a";
}
.fa-arrow-square-right:before {
  content: "\\f33b";
}
.fa-arrow-square-up:before {
  content: "\\f33c";
}
.fa-arrow-to-bottom:before {
  content: "\\f33d";
}
.fa-arrow-to-left:before {
  content: "\\f33e";
}
.fa-arrow-to-right:before {
  content: "\\f340";
}
.fa-arrow-to-top:before {
  content: "\\f341";
}
.fa-arrow-up:before {
  content: "\\f062";
}
.fa-arrows:before {
  content: "\\f047";
}
.fa-arrows-alt:before {
  content: "\\f0b2";
}
.fa-arrows-alt-h:before {
  content: "\\f337";
}
.fa-arrows-alt-v:before {
  content: "\\f338";
}
.fa-arrows-h:before {
  content: "\\f07e";
}
.fa-arrows-v:before {
  content: "\\f07d";
}
.fa-artstation:before {
  content: "\\f77a";
}
.fa-assistive-listening-systems:before {
  content: "\\f2a2";
}
.fa-asterisk:before {
  content: "\\f069";
}
.fa-asymmetrik:before {
  content: "\\f372";
}
.fa-at:before {
  content: "\\f1fa";
}
.fa-atlas:before {
  content: "\\f558";
}
.fa-atlassian:before {
  content: "\\f77b";
}
.fa-atom:before {
  content: "\\f5d2";
}
.fa-atom-alt:before {
  content: "\\f5d3";
}
.fa-audible:before {
  content: "\\f373";
}
.fa-audio-description:before {
  content: "\\f29e";
}
.fa-autoprefixer:before {
  content: "\\f41c";
}
.fa-avianex:before {
  content: "\\f374";
}
.fa-aviato:before {
  content: "\\f421";
}
.fa-award:before {
  content: "\\f559";
}
.fa-aws:before {
  content: "\\f375";
}
.fa-axe:before {
  content: "\\f6b2";
}
.fa-axe-battle:before {
  content: "\\f6b3";
}
.fa-baby:before {
  content: "\\f77c";
}
.fa-baby-carriage:before {
  content: "\\f77d";
}
.fa-backpack:before {
  content: "\\f5d4";
}
.fa-backspace:before {
  content: "\\f55a";
}
.fa-backward:before {
  content: "\\f04a";
}
.fa-bacon:before {
  content: "\\f7e5";
}
.fa-bacteria:before {
  content: "\uF959";
}
.fa-bacterium:before {
  content: "\uF95A";
}
.fa-badge:before {
  content: "\\f335";
}
.fa-badge-check:before {
  content: "\\f336";
}
.fa-badge-dollar:before {
  content: "\\f645";
}
.fa-badge-percent:before {
  content: "\\f646";
}
.fa-badge-sheriff:before {
  content: "\\f8a2";
}
.fa-badger-honey:before {
  content: "\\f6b4";
}
.fa-bags-shopping:before {
  content: "\\f847";
}
.fa-bahai:before {
  content: "\\f666";
}
.fa-balance-scale:before {
  content: "\\f24e";
}
.fa-balance-scale-left:before {
  content: "\\f515";
}
.fa-balance-scale-right:before {
  content: "\\f516";
}
.fa-ball-pile:before {
  content: "\\f77e";
}
.fa-ballot:before {
  content: "\\f732";
}
.fa-ballot-check:before {
  content: "\\f733";
}
.fa-ban:before {
  content: "\\f05e";
}
.fa-band-aid:before {
  content: "\\f462";
}
.fa-bandcamp:before {
  content: "\\f2d5";
}
.fa-banjo:before {
  content: "\\f8a3";
}
.fa-barcode:before {
  content: "\\f02a";
}
.fa-barcode-alt:before {
  content: "\\f463";
}
.fa-barcode-read:before {
  content: "\\f464";
}
.fa-barcode-scan:before {
  content: "\\f465";
}
.fa-bars:before {
  content: "\\f0c9";
}
.fa-baseball:before {
  content: "\\f432";
}
.fa-baseball-ball:before {
  content: "\\f433";
}
.fa-basketball-ball:before {
  content: "\\f434";
}
.fa-basketball-hoop:before {
  content: "\\f435";
}
.fa-bat:before {
  content: "\\f6b5";
}
.fa-bath:before {
  content: "\\f2cd";
}
.fa-battery-bolt:before {
  content: "\\f376";
}
.fa-battery-empty:before {
  content: "\\f244";
}
.fa-battery-full:before {
  content: "\\f240";
}
.fa-battery-half:before {
  content: "\\f242";
}
.fa-battery-quarter:before {
  content: "\\f243";
}
.fa-battery-slash:before {
  content: "\\f377";
}
.fa-battery-three-quarters:before {
  content: "\\f241";
}
.fa-battle-net:before {
  content: "\\f835";
}
.fa-bed:before {
  content: "\\f236";
}
.fa-bed-alt:before {
  content: "\\f8f7";
}
.fa-bed-bunk:before {
  content: "\\f8f8";
}
.fa-bed-empty:before {
  content: "\\f8f9";
}
.fa-beer:before {
  content: "\\f0fc";
}
.fa-behance:before {
  content: "\\f1b4";
}
.fa-behance-square:before {
  content: "\\f1b5";
}
.fa-bell:before {
  content: "\\f0f3";
}
.fa-bell-exclamation:before {
  content: "\\f848";
}
.fa-bell-on:before {
  content: "\\f8fa";
}
.fa-bell-plus:before {
  content: "\\f849";
}
.fa-bell-school:before {
  content: "\\f5d5";
}
.fa-bell-school-slash:before {
  content: "\\f5d6";
}
.fa-bell-slash:before {
  content: "\\f1f6";
}
.fa-bells:before {
  content: "\\f77f";
}
.fa-betamax:before {
  content: "\\f8a4";
}
.fa-bezier-curve:before {
  content: "\\f55b";
}
.fa-bible:before {
  content: "\\f647";
}
.fa-bicycle:before {
  content: "\\f206";
}
.fa-biking:before {
  content: "\\f84a";
}
.fa-biking-mountain:before {
  content: "\\f84b";
}
.fa-bimobject:before {
  content: "\\f378";
}
.fa-binoculars:before {
  content: "\\f1e5";
}
.fa-biohazard:before {
  content: "\\f780";
}
.fa-birthday-cake:before {
  content: "\\f1fd";
}
.fa-bitbucket:before {
  content: "\\f171";
}
.fa-bitcoin:before {
  content: "\\f379";
}
.fa-bity:before {
  content: "\\f37a";
}
.fa-black-tie:before {
  content: "\\f27e";
}
.fa-blackberry:before {
  content: "\\f37b";
}
.fa-blanket:before {
  content: "\\f498";
}
.fa-blender:before {
  content: "\\f517";
}
.fa-blender-phone:before {
  content: "\\f6b6";
}
.fa-blind:before {
  content: "\\f29d";
}
.fa-blinds:before {
  content: "\\f8fb";
}
.fa-blinds-open:before {
  content: "\\f8fc";
}
.fa-blinds-raised:before {
  content: "\\f8fd";
}
.fa-blog:before {
  content: "\\f781";
}
.fa-blogger:before {
  content: "\\f37c";
}
.fa-blogger-b:before {
  content: "\\f37d";
}
.fa-bluetooth:before {
  content: "\\f293";
}
.fa-bluetooth-b:before {
  content: "\\f294";
}
.fa-bold:before {
  content: "\\f032";
}
.fa-bolt:before {
  content: "\\f0e7";
}
.fa-bomb:before {
  content: "\\f1e2";
}
.fa-bone:before {
  content: "\\f5d7";
}
.fa-bone-break:before {
  content: "\\f5d8";
}
.fa-bong:before {
  content: "\\f55c";
}
.fa-book:before {
  content: "\\f02d";
}
.fa-book-alt:before {
  content: "\\f5d9";
}
.fa-book-dead:before {
  content: "\\f6b7";
}
.fa-book-heart:before {
  content: "\\f499";
}
.fa-book-medical:before {
  content: "\\f7e6";
}
.fa-book-open:before {
  content: "\\f518";
}
.fa-book-reader:before {
  content: "\\f5da";
}
.fa-book-spells:before {
  content: "\\f6b8";
}
.fa-book-user:before {
  content: "\\f7e7";
}
.fa-bookmark:before {
  content: "\\f02e";
}
.fa-books:before {
  content: "\\f5db";
}
.fa-books-medical:before {
  content: "\\f7e8";
}
.fa-boombox:before {
  content: "\\f8a5";
}
.fa-boot:before {
  content: "\\f782";
}
.fa-booth-curtain:before {
  content: "\\f734";
}
.fa-bootstrap:before {
  content: "\\f836";
}
.fa-border-all:before {
  content: "\\f84c";
}
.fa-border-bottom:before {
  content: "\\f84d";
}
.fa-border-center-h:before {
  content: "\\f89c";
}
.fa-border-center-v:before {
  content: "\\f89d";
}
.fa-border-inner:before {
  content: "\\f84e";
}
.fa-border-left:before {
  content: "\\f84f";
}
.fa-border-none:before {
  content: "\\f850";
}
.fa-border-outer:before {
  content: "\\f851";
}
.fa-border-right:before {
  content: "\\f852";
}
.fa-border-style:before {
  content: "\\f853";
}
.fa-border-style-alt:before {
  content: "\\f854";
}
.fa-border-top:before {
  content: "\\f855";
}
.fa-bow-arrow:before {
  content: "\\f6b9";
}
.fa-bowling-ball:before {
  content: "\\f436";
}
.fa-bowling-pins:before {
  content: "\\f437";
}
.fa-box:before {
  content: "\\f466";
}
.fa-box-alt:before {
  content: "\\f49a";
}
.fa-box-ballot:before {
  content: "\\f735";
}
.fa-box-check:before {
  content: "\\f467";
}
.fa-box-fragile:before {
  content: "\\f49b";
}
.fa-box-full:before {
  content: "\\f49c";
}
.fa-box-heart:before {
  content: "\\f49d";
}
.fa-box-open:before {
  content: "\\f49e";
}
.fa-box-tissue:before {
  content: "\uF95B";
}
.fa-box-up:before {
  content: "\\f49f";
}
.fa-box-usd:before {
  content: "\\f4a0";
}
.fa-boxes:before {
  content: "\\f468";
}
.fa-boxes-alt:before {
  content: "\\f4a1";
}
.fa-boxing-glove:before {
  content: "\\f438";
}
.fa-brackets:before {
  content: "\\f7e9";
}
.fa-brackets-curly:before {
  content: "\\f7ea";
}
.fa-braille:before {
  content: "\\f2a1";
}
.fa-brain:before {
  content: "\\f5dc";
}
.fa-bread-loaf:before {
  content: "\\f7eb";
}
.fa-bread-slice:before {
  content: "\\f7ec";
}
.fa-briefcase:before {
  content: "\\f0b1";
}
.fa-briefcase-medical:before {
  content: "\\f469";
}
.fa-bring-forward:before {
  content: "\\f856";
}
.fa-bring-front:before {
  content: "\\f857";
}
.fa-broadcast-tower:before {
  content: "\\f519";
}
.fa-broom:before {
  content: "\\f51a";
}
.fa-browser:before {
  content: "\\f37e";
}
.fa-brush:before {
  content: "\\f55d";
}
.fa-btc:before {
  content: "\\f15a";
}
.fa-buffer:before {
  content: "\\f837";
}
.fa-bug:before {
  content: "\\f188";
}
.fa-building:before {
  content: "\\f1ad";
}
.fa-bullhorn:before {
  content: "\\f0a1";
}
.fa-bullseye:before {
  content: "\\f140";
}
.fa-bullseye-arrow:before {
  content: "\\f648";
}
.fa-bullseye-pointer:before {
  content: "\\f649";
}
.fa-burger-soda:before {
  content: "\\f858";
}
.fa-burn:before {
  content: "\\f46a";
}
.fa-buromobelexperte:before {
  content: "\\f37f";
}
.fa-burrito:before {
  content: "\\f7ed";
}
.fa-bus:before {
  content: "\\f207";
}
.fa-bus-alt:before {
  content: "\\f55e";
}
.fa-bus-school:before {
  content: "\\f5dd";
}
.fa-business-time:before {
  content: "\\f64a";
}
.fa-buy-n-large:before {
  content: "\\f8a6";
}
.fa-buysellads:before {
  content: "\\f20d";
}
.fa-cabinet-filing:before {
  content: "\\f64b";
}
.fa-cactus:before {
  content: "\\f8a7";
}
.fa-calculator:before {
  content: "\\f1ec";
}
.fa-calculator-alt:before {
  content: "\\f64c";
}
.fa-calendar:before {
  content: "\\f133";
}
.fa-calendar-alt:before {
  content: "\\f073";
}
.fa-calendar-check:before {
  content: "\\f274";
}
.fa-calendar-day:before {
  content: "\\f783";
}
.fa-calendar-edit:before {
  content: "\\f333";
}
.fa-calendar-exclamation:before {
  content: "\\f334";
}
.fa-calendar-minus:before {
  content: "\\f272";
}
.fa-calendar-plus:before {
  content: "\\f271";
}
.fa-calendar-star:before {
  content: "\\f736";
}
.fa-calendar-times:before {
  content: "\\f273";
}
.fa-calendar-week:before {
  content: "\\f784";
}
.fa-camcorder:before {
  content: "\\f8a8";
}
.fa-camera:before {
  content: "\\f030";
}
.fa-camera-alt:before {
  content: "\\f332";
}
.fa-camera-home:before {
  content: "\\f8fe";
}
.fa-camera-movie:before {
  content: "\\f8a9";
}
.fa-camera-polaroid:before {
  content: "\\f8aa";
}
.fa-camera-retro:before {
  content: "\\f083";
}
.fa-campfire:before {
  content: "\\f6ba";
}
.fa-campground:before {
  content: "\\f6bb";
}
.fa-canadian-maple-leaf:before {
  content: "\\f785";
}
.fa-candle-holder:before {
  content: "\\f6bc";
}
.fa-candy-cane:before {
  content: "\\f786";
}
.fa-candy-corn:before {
  content: "\\f6bd";
}
.fa-cannabis:before {
  content: "\\f55f";
}
.fa-capsules:before {
  content: "\\f46b";
}
.fa-car:before {
  content: "\\f1b9";
}
.fa-car-alt:before {
  content: "\\f5de";
}
.fa-car-battery:before {
  content: "\\f5df";
}
.fa-car-building:before {
  content: "\\f859";
}
.fa-car-bump:before {
  content: "\\f5e0";
}
.fa-car-bus:before {
  content: "\\f85a";
}
.fa-car-crash:before {
  content: "\\f5e1";
}
.fa-car-garage:before {
  content: "\\f5e2";
}
.fa-car-mechanic:before {
  content: "\\f5e3";
}
.fa-car-side:before {
  content: "\\f5e4";
}
.fa-car-tilt:before {
  content: "\\f5e5";
}
.fa-car-wash:before {
  content: "\\f5e6";
}
.fa-caravan:before {
  content: "\\f8ff";
}
.fa-caravan-alt:before {
  content: "\uF900";
}
.fa-caret-circle-down:before {
  content: "\\f32d";
}
.fa-caret-circle-left:before {
  content: "\\f32e";
}
.fa-caret-circle-right:before {
  content: "\\f330";
}
.fa-caret-circle-up:before {
  content: "\\f331";
}
.fa-caret-down:before {
  content: "\\f0d7";
}
.fa-caret-left:before {
  content: "\\f0d9";
}
.fa-caret-right:before {
  content: "\\f0da";
}
.fa-caret-square-down:before {
  content: "\\f150";
}
.fa-caret-square-left:before {
  content: "\\f191";
}
.fa-caret-square-right:before {
  content: "\\f152";
}
.fa-caret-square-up:before {
  content: "\\f151";
}
.fa-caret-up:before {
  content: "\\f0d8";
}
.fa-carrot:before {
  content: "\\f787";
}
.fa-cars:before {
  content: "\\f85b";
}
.fa-cart-arrow-down:before {
  content: "\\f218";
}
.fa-cart-plus:before {
  content: "\\f217";
}
.fa-cash-register:before {
  content: "\\f788";
}
.fa-cassette-tape:before {
  content: "\\f8ab";
}
.fa-cat:before {
  content: "\\f6be";
}
.fa-cat-space:before {
  content: "\uF901";
}
.fa-cauldron:before {
  content: "\\f6bf";
}
.fa-cc-amazon-pay:before {
  content: "\\f42d";
}
.fa-cc-amex:before {
  content: "\\f1f3";
}
.fa-cc-apple-pay:before {
  content: "\\f416";
}
.fa-cc-diners-club:before {
  content: "\\f24c";
}
.fa-cc-discover:before {
  content: "\\f1f2";
}
.fa-cc-jcb:before {
  content: "\\f24b";
}
.fa-cc-mastercard:before {
  content: "\\f1f1";
}
.fa-cc-paypal:before {
  content: "\\f1f4";
}
.fa-cc-stripe:before {
  content: "\\f1f5";
}
.fa-cc-visa:before {
  content: "\\f1f0";
}
.fa-cctv:before {
  content: "\\f8ac";
}
.fa-centercode:before {
  content: "\\f380";
}
.fa-centos:before {
  content: "\\f789";
}
.fa-certificate:before {
  content: "\\f0a3";
}
.fa-chair:before {
  content: "\\f6c0";
}
.fa-chair-office:before {
  content: "\\f6c1";
}
.fa-chalkboard:before {
  content: "\\f51b";
}
.fa-chalkboard-teacher:before {
  content: "\\f51c";
}
.fa-charging-station:before {
  content: "\\f5e7";
}
.fa-chart-area:before {
  content: "\\f1fe";
}
.fa-chart-bar:before {
  content: "\\f080";
}
.fa-chart-line:before {
  content: "\\f201";
}
.fa-chart-line-down:before {
  content: "\\f64d";
}
.fa-chart-network:before {
  content: "\\f78a";
}
.fa-chart-pie:before {
  content: "\\f200";
}
.fa-chart-pie-alt:before {
  content: "\\f64e";
}
.fa-chart-scatter:before {
  content: "\\f7ee";
}
.fa-check:before {
  content: "\\f00c";
}
.fa-check-circle:before {
  content: "\\f058";
}
.fa-check-double:before {
  content: "\\f560";
}
.fa-check-square:before {
  content: "\\f14a";
}
.fa-cheese:before {
  content: "\\f7ef";
}
.fa-cheese-swiss:before {
  content: "\\f7f0";
}
.fa-cheeseburger:before {
  content: "\\f7f1";
}
.fa-chess:before {
  content: "\\f439";
}
.fa-chess-bishop:before {
  content: "\\f43a";
}
.fa-chess-bishop-alt:before {
  content: "\\f43b";
}
.fa-chess-board:before {
  content: "\\f43c";
}
.fa-chess-clock:before {
  content: "\\f43d";
}
.fa-chess-clock-alt:before {
  content: "\\f43e";
}
.fa-chess-king:before {
  content: "\\f43f";
}
.fa-chess-king-alt:before {
  content: "\\f440";
}
.fa-chess-knight:before {
  content: "\\f441";
}
.fa-chess-knight-alt:before {
  content: "\\f442";
}
.fa-chess-pawn:before {
  content: "\\f443";
}
.fa-chess-pawn-alt:before {
  content: "\\f444";
}
.fa-chess-queen:before {
  content: "\\f445";
}
.fa-chess-queen-alt:before {
  content: "\\f446";
}
.fa-chess-rook:before {
  content: "\\f447";
}
.fa-chess-rook-alt:before {
  content: "\\f448";
}
.fa-chevron-circle-down:before {
  content: "\\f13a";
}
.fa-chevron-circle-left:before {
  content: "\\f137";
}
.fa-chevron-circle-right:before {
  content: "\\f138";
}
.fa-chevron-circle-up:before {
  content: "\\f139";
}
.fa-chevron-double-down:before {
  content: "\\f322";
}
.fa-chevron-double-left:before {
  content: "\\f323";
}
.fa-chevron-double-right:before {
  content: "\\f324";
}
.fa-chevron-double-up:before {
  content: "\\f325";
}
.fa-chevron-down:before {
  content: "\\f078";
}
.fa-chevron-left:before {
  content: "\\f053";
}
.fa-chevron-right:before {
  content: "\\f054";
}
.fa-chevron-square-down:before {
  content: "\\f329";
}
.fa-chevron-square-left:before {
  content: "\\f32a";
}
.fa-chevron-square-right:before {
  content: "\\f32b";
}
.fa-chevron-square-up:before {
  content: "\\f32c";
}
.fa-chevron-up:before {
  content: "\\f077";
}
.fa-child:before {
  content: "\\f1ae";
}
.fa-chimney:before {
  content: "\\f78b";
}
.fa-chrome:before {
  content: "\\f268";
}
.fa-chromecast:before {
  content: "\\f838";
}
.fa-church:before {
  content: "\\f51d";
}
.fa-circle:before {
  content: "\\f111";
}
.fa-circle-notch:before {
  content: "\\f1ce";
}
.fa-city:before {
  content: "\\f64f";
}
.fa-clarinet:before {
  content: "\\f8ad";
}
.fa-claw-marks:before {
  content: "\\f6c2";
}
.fa-clinic-medical:before {
  content: "\\f7f2";
}
.fa-clipboard:before {
  content: "\\f328";
}
.fa-clipboard-check:before {
  content: "\\f46c";
}
.fa-clipboard-list:before {
  content: "\\f46d";
}
.fa-clipboard-list-check:before {
  content: "\\f737";
}
.fa-clipboard-prescription:before {
  content: "\\f5e8";
}
.fa-clipboard-user:before {
  content: "\\f7f3";
}
.fa-clock:before {
  content: "\\f017";
}
.fa-clone:before {
  content: "\\f24d";
}
.fa-closed-captioning:before {
  content: "\\f20a";
}
.fa-cloud:before {
  content: "\\f0c2";
}
.fa-cloud-download:before {
  content: "\\f0ed";
}
.fa-cloud-download-alt:before {
  content: "\\f381";
}
.fa-cloud-drizzle:before {
  content: "\\f738";
}
.fa-cloud-hail:before {
  content: "\\f739";
}
.fa-cloud-hail-mixed:before {
  content: "\\f73a";
}
.fa-cloud-meatball:before {
  content: "\\f73b";
}
.fa-cloud-moon:before {
  content: "\\f6c3";
}
.fa-cloud-moon-rain:before {
  content: "\\f73c";
}
.fa-cloud-music:before {
  content: "\\f8ae";
}
.fa-cloud-rain:before {
  content: "\\f73d";
}
.fa-cloud-rainbow:before {
  content: "\\f73e";
}
.fa-cloud-showers:before {
  content: "\\f73f";
}
.fa-cloud-showers-heavy:before {
  content: "\\f740";
}
.fa-cloud-sleet:before {
  content: "\\f741";
}
.fa-cloud-snow:before {
  content: "\\f742";
}
.fa-cloud-sun:before {
  content: "\\f6c4";
}
.fa-cloud-sun-rain:before {
  content: "\\f743";
}
.fa-cloud-upload:before {
  content: "\\f0ee";
}
.fa-cloud-upload-alt:before {
  content: "\\f382";
}
.fa-clouds:before {
  content: "\\f744";
}
.fa-clouds-moon:before {
  content: "\\f745";
}
.fa-clouds-sun:before {
  content: "\\f746";
}
.fa-cloudscale:before {
  content: "\\f383";
}
.fa-cloudsmith:before {
  content: "\\f384";
}
.fa-cloudversify:before {
  content: "\\f385";
}
.fa-club:before {
  content: "\\f327";
}
.fa-cocktail:before {
  content: "\\f561";
}
.fa-code:before {
  content: "\\f121";
}
.fa-code-branch:before {
  content: "\\f126";
}
.fa-code-commit:before {
  content: "\\f386";
}
.fa-code-merge:before {
  content: "\\f387";
}
.fa-codepen:before {
  content: "\\f1cb";
}
.fa-codiepie:before {
  content: "\\f284";
}
.fa-coffee:before {
  content: "\\f0f4";
}
.fa-coffee-pot:before {
  content: "\uF902";
}
.fa-coffee-togo:before {
  content: "\\f6c5";
}
.fa-coffin:before {
  content: "\\f6c6";
}
.fa-coffin-cross:before {
  content: "\uF951";
}
.fa-cog:before {
  content: "\\f013";
}
.fa-cogs:before {
  content: "\\f085";
}
.fa-coin:before {
  content: "\\f85c";
}
.fa-coins:before {
  content: "\\f51e";
}
.fa-columns:before {
  content: "\\f0db";
}
.fa-comet:before {
  content: "\uF903";
}
.fa-comment:before {
  content: "\\f075";
}
.fa-comment-alt:before {
  content: "\\f27a";
}
.fa-comment-alt-check:before {
  content: "\\f4a2";
}
.fa-comment-alt-dollar:before {
  content: "\\f650";
}
.fa-comment-alt-dots:before {
  content: "\\f4a3";
}
.fa-comment-alt-edit:before {
  content: "\\f4a4";
}
.fa-comment-alt-exclamation:before {
  content: "\\f4a5";
}
.fa-comment-alt-lines:before {
  content: "\\f4a6";
}
.fa-comment-alt-medical:before {
  content: "\\f7f4";
}
.fa-comment-alt-minus:before {
  content: "\\f4a7";
}
.fa-comment-alt-music:before {
  content: "\\f8af";
}
.fa-comment-alt-plus:before {
  content: "\\f4a8";
}
.fa-comment-alt-slash:before {
  content: "\\f4a9";
}
.fa-comment-alt-smile:before {
  content: "\\f4aa";
}
.fa-comment-alt-times:before {
  content: "\\f4ab";
}
.fa-comment-check:before {
  content: "\\f4ac";
}
.fa-comment-dollar:before {
  content: "\\f651";
}
.fa-comment-dots:before {
  content: "\\f4ad";
}
.fa-comment-edit:before {
  content: "\\f4ae";
}
.fa-comment-exclamation:before {
  content: "\\f4af";
}
.fa-comment-lines:before {
  content: "\\f4b0";
}
.fa-comment-medical:before {
  content: "\\f7f5";
}
.fa-comment-minus:before {
  content: "\\f4b1";
}
.fa-comment-music:before {
  content: "\\f8b0";
}
.fa-comment-plus:before {
  content: "\\f4b2";
}
.fa-comment-slash:before {
  content: "\\f4b3";
}
.fa-comment-smile:before {
  content: "\\f4b4";
}
.fa-comment-times:before {
  content: "\\f4b5";
}
.fa-comments:before {
  content: "\\f086";
}
.fa-comments-alt:before {
  content: "\\f4b6";
}
.fa-comments-alt-dollar:before {
  content: "\\f652";
}
.fa-comments-dollar:before {
  content: "\\f653";
}
.fa-compact-disc:before {
  content: "\\f51f";
}
.fa-compass:before {
  content: "\\f14e";
}
.fa-compass-slash:before {
  content: "\\f5e9";
}
.fa-compress:before {
  content: "\\f066";
}
.fa-compress-alt:before {
  content: "\\f422";
}
.fa-compress-arrows-alt:before {
  content: "\\f78c";
}
.fa-compress-wide:before {
  content: "\\f326";
}
.fa-computer-classic:before {
  content: "\\f8b1";
}
.fa-computer-speaker:before {
  content: "\\f8b2";
}
.fa-concierge-bell:before {
  content: "\\f562";
}
.fa-confluence:before {
  content: "\\f78d";
}
.fa-connectdevelop:before {
  content: "\\f20e";
}
.fa-construction:before {
  content: "\\f85d";
}
.fa-container-storage:before {
  content: "\\f4b7";
}
.fa-contao:before {
  content: "\\f26d";
}
.fa-conveyor-belt:before {
  content: "\\f46e";
}
.fa-conveyor-belt-alt:before {
  content: "\\f46f";
}
.fa-cookie:before {
  content: "\\f563";
}
.fa-cookie-bite:before {
  content: "\\f564";
}
.fa-copy:before {
  content: "\\f0c5";
}
.fa-copyright:before {
  content: "\\f1f9";
}
.fa-corn:before {
  content: "\\f6c7";
}
.fa-cotton-bureau:before {
  content: "\\f89e";
}
.fa-couch:before {
  content: "\\f4b8";
}
.fa-cow:before {
  content: "\\f6c8";
}
.fa-cowbell:before {
  content: "\\f8b3";
}
.fa-cowbell-more:before {
  content: "\\f8b4";
}
.fa-cpanel:before {
  content: "\\f388";
}
.fa-creative-commons:before {
  content: "\\f25e";
}
.fa-creative-commons-by:before {
  content: "\\f4e7";
}
.fa-creative-commons-nc:before {
  content: "\\f4e8";
}
.fa-creative-commons-nc-eu:before {
  content: "\\f4e9";
}
.fa-creative-commons-nc-jp:before {
  content: "\\f4ea";
}
.fa-creative-commons-nd:before {
  content: "\\f4eb";
}
.fa-creative-commons-pd:before {
  content: "\\f4ec";
}
.fa-creative-commons-pd-alt:before {
  content: "\\f4ed";
}
.fa-creative-commons-remix:before {
  content: "\\f4ee";
}
.fa-creative-commons-sa:before {
  content: "\\f4ef";
}
.fa-creative-commons-sampling:before {
  content: "\\f4f0";
}
.fa-creative-commons-sampling-plus:before {
  content: "\\f4f1";
}
.fa-creative-commons-share:before {
  content: "\\f4f2";
}
.fa-creative-commons-zero:before {
  content: "\\f4f3";
}
.fa-credit-card:before {
  content: "\\f09d";
}
.fa-credit-card-blank:before {
  content: "\\f389";
}
.fa-credit-card-front:before {
  content: "\\f38a";
}
.fa-cricket:before {
  content: "\\f449";
}
.fa-critical-role:before {
  content: "\\f6c9";
}
.fa-croissant:before {
  content: "\\f7f6";
}
.fa-crop:before {
  content: "\\f125";
}
.fa-crop-alt:before {
  content: "\\f565";
}
.fa-cross:before {
  content: "\\f654";
}
.fa-crosshairs:before {
  content: "\\f05b";
}
.fa-crow:before {
  content: "\\f520";
}
.fa-crown:before {
  content: "\\f521";
}
.fa-crutch:before {
  content: "\\f7f7";
}
.fa-crutches:before {
  content: "\\f7f8";
}
.fa-css3:before {
  content: "\\f13c";
}
.fa-css3-alt:before {
  content: "\\f38b";
}
.fa-cube:before {
  content: "\\f1b2";
}
.fa-cubes:before {
  content: "\\f1b3";
}
.fa-curling:before {
  content: "\\f44a";
}
.fa-cut:before {
  content: "\\f0c4";
}
.fa-cuttlefish:before {
  content: "\\f38c";
}
.fa-d-and-d:before {
  content: "\\f38d";
}
.fa-d-and-d-beyond:before {
  content: "\\f6ca";
}
.fa-dagger:before {
  content: "\\f6cb";
}
.fa-dailymotion:before {
  content: "\uF952";
}
.fa-dashcube:before {
  content: "\\f210";
}
.fa-database:before {
  content: "\\f1c0";
}
.fa-deaf:before {
  content: "\\f2a4";
}
.fa-debug:before {
  content: "\\f7f9";
}
.fa-deer:before {
  content: "\\f78e";
}
.fa-deer-rudolph:before {
  content: "\\f78f";
}
.fa-delicious:before {
  content: "\\f1a5";
}
.fa-democrat:before {
  content: "\\f747";
}
.fa-deploydog:before {
  content: "\\f38e";
}
.fa-deskpro:before {
  content: "\\f38f";
}
.fa-desktop:before {
  content: "\\f108";
}
.fa-desktop-alt:before {
  content: "\\f390";
}
.fa-dev:before {
  content: "\\f6cc";
}
.fa-deviantart:before {
  content: "\\f1bd";
}
.fa-dewpoint:before {
  content: "\\f748";
}
.fa-dharmachakra:before {
  content: "\\f655";
}
.fa-dhl:before {
  content: "\\f790";
}
.fa-diagnoses:before {
  content: "\\f470";
}
.fa-diamond:before {
  content: "\\f219";
}
.fa-diaspora:before {
  content: "\\f791";
}
.fa-dice:before {
  content: "\\f522";
}
.fa-dice-d10:before {
  content: "\\f6cd";
}
.fa-dice-d12:before {
  content: "\\f6ce";
}
.fa-dice-d20:before {
  content: "\\f6cf";
}
.fa-dice-d4:before {
  content: "\\f6d0";
}
.fa-dice-d6:before {
  content: "\\f6d1";
}
.fa-dice-d8:before {
  content: "\\f6d2";
}
.fa-dice-five:before {
  content: "\\f523";
}
.fa-dice-four:before {
  content: "\\f524";
}
.fa-dice-one:before {
  content: "\\f525";
}
.fa-dice-six:before {
  content: "\\f526";
}
.fa-dice-three:before {
  content: "\\f527";
}
.fa-dice-two:before {
  content: "\\f528";
}
.fa-digg:before {
  content: "\\f1a6";
}
.fa-digging:before {
  content: "\\f85e";
}
.fa-digital-ocean:before {
  content: "\\f391";
}
.fa-digital-tachograph:before {
  content: "\\f566";
}
.fa-diploma:before {
  content: "\\f5ea";
}
.fa-directions:before {
  content: "\\f5eb";
}
.fa-disc-drive:before {
  content: "\\f8b5";
}
.fa-discord:before {
  content: "\\f392";
}
.fa-discourse:before {
  content: "\\f393";
}
.fa-disease:before {
  content: "\\f7fa";
}
.fa-divide:before {
  content: "\\f529";
}
.fa-dizzy:before {
  content: "\\f567";
}
.fa-dna:before {
  content: "\\f471";
}
.fa-do-not-enter:before {
  content: "\\f5ec";
}
.fa-dochub:before {
  content: "\\f394";
}
.fa-docker:before {
  content: "\\f395";
}
.fa-dog:before {
  content: "\\f6d3";
}
.fa-dog-leashed:before {
  content: "\\f6d4";
}
.fa-dollar-sign:before {
  content: "\\f155";
}
.fa-dolly:before {
  content: "\\f472";
}
.fa-dolly-empty:before {
  content: "\\f473";
}
.fa-dolly-flatbed:before {
  content: "\\f474";
}
.fa-dolly-flatbed-alt:before {
  content: "\\f475";
}
.fa-dolly-flatbed-empty:before {
  content: "\\f476";
}
.fa-donate:before {
  content: "\\f4b9";
}
.fa-door-closed:before {
  content: "\\f52a";
}
.fa-door-open:before {
  content: "\\f52b";
}
.fa-dot-circle:before {
  content: "\\f192";
}
.fa-dove:before {
  content: "\\f4ba";
}
.fa-download:before {
  content: "\\f019";
}
.fa-draft2digital:before {
  content: "\\f396";
}
.fa-drafting-compass:before {
  content: "\\f568";
}
.fa-dragon:before {
  content: "\\f6d5";
}
.fa-draw-circle:before {
  content: "\\f5ed";
}
.fa-draw-polygon:before {
  content: "\\f5ee";
}
.fa-draw-square:before {
  content: "\\f5ef";
}
.fa-dreidel:before {
  content: "\\f792";
}
.fa-dribbble:before {
  content: "\\f17d";
}
.fa-dribbble-square:before {
  content: "\\f397";
}
.fa-drone:before {
  content: "\\f85f";
}
.fa-drone-alt:before {
  content: "\\f860";
}
.fa-dropbox:before {
  content: "\\f16b";
}
.fa-drum:before {
  content: "\\f569";
}
.fa-drum-steelpan:before {
  content: "\\f56a";
}
.fa-drumstick:before {
  content: "\\f6d6";
}
.fa-drumstick-bite:before {
  content: "\\f6d7";
}
.fa-drupal:before {
  content: "\\f1a9";
}
.fa-dryer:before {
  content: "\\f861";
}
.fa-dryer-alt:before {
  content: "\\f862";
}
.fa-duck:before {
  content: "\\f6d8";
}
.fa-dumbbell:before {
  content: "\\f44b";
}
.fa-dumpster:before {
  content: "\\f793";
}
.fa-dumpster-fire:before {
  content: "\\f794";
}
.fa-dungeon:before {
  content: "\\f6d9";
}
.fa-dyalog:before {
  content: "\\f399";
}
.fa-ear:before {
  content: "\\f5f0";
}
.fa-ear-muffs:before {
  content: "\\f795";
}
.fa-earlybirds:before {
  content: "\\f39a";
}
.fa-ebay:before {
  content: "\\f4f4";
}
.fa-eclipse:before {
  content: "\\f749";
}
.fa-eclipse-alt:before {
  content: "\\f74a";
}
.fa-edge:before {
  content: "\\f282";
}
.fa-edit:before {
  content: "\\f044";
}
.fa-egg:before {
  content: "\\f7fb";
}
.fa-egg-fried:before {
  content: "\\f7fc";
}
.fa-eject:before {
  content: "\\f052";
}
.fa-elementor:before {
  content: "\\f430";
}
.fa-elephant:before {
  content: "\\f6da";
}
.fa-ellipsis-h:before {
  content: "\\f141";
}
.fa-ellipsis-h-alt:before {
  content: "\\f39b";
}
.fa-ellipsis-v:before {
  content: "\\f142";
}
.fa-ellipsis-v-alt:before {
  content: "\\f39c";
}
.fa-ello:before {
  content: "\\f5f1";
}
.fa-ember:before {
  content: "\\f423";
}
.fa-empire:before {
  content: "\\f1d1";
}
.fa-empty-set:before {
  content: "\\f656";
}
.fa-engine-warning:before {
  content: "\\f5f2";
}
.fa-envelope:before {
  content: "\\f0e0";
}
.fa-envelope-open:before {
  content: "\\f2b6";
}
.fa-envelope-open-dollar:before {
  content: "\\f657";
}
.fa-envelope-open-text:before {
  content: "\\f658";
}
.fa-envelope-square:before {
  content: "\\f199";
}
.fa-envira:before {
  content: "\\f299";
}
.fa-equals:before {
  content: "\\f52c";
}
.fa-eraser:before {
  content: "\\f12d";
}
.fa-erlang:before {
  content: "\\f39d";
}
.fa-ethereum:before {
  content: "\\f42e";
}
.fa-ethernet:before {
  content: "\\f796";
}
.fa-etsy:before {
  content: "\\f2d7";
}
.fa-euro-sign:before {
  content: "\\f153";
}
.fa-evernote:before {
  content: "\\f839";
}
.fa-exchange:before {
  content: "\\f0ec";
}
.fa-exchange-alt:before {
  content: "\\f362";
}
.fa-exclamation:before {
  content: "\\f12a";
}
.fa-exclamation-circle:before {
  content: "\\f06a";
}
.fa-exclamation-square:before {
  content: "\\f321";
}
.fa-exclamation-triangle:before {
  content: "\\f071";
}
.fa-expand:before {
  content: "\\f065";
}
.fa-expand-alt:before {
  content: "\\f424";
}
.fa-expand-arrows:before {
  content: "\\f31d";
}
.fa-expand-arrows-alt:before {
  content: "\\f31e";
}
.fa-expand-wide:before {
  content: "\\f320";
}
.fa-expeditedssl:before {
  content: "\\f23e";
}
.fa-external-link:before {
  content: "\\f08e";
}
.fa-external-link-alt:before {
  content: "\\f35d";
}
.fa-external-link-square:before {
  content: "\\f14c";
}
.fa-external-link-square-alt:before {
  content: "\\f360";
}
.fa-eye:before {
  content: "\\f06e";
}
.fa-eye-dropper:before {
  content: "\\f1fb";
}
.fa-eye-evil:before {
  content: "\\f6db";
}
.fa-eye-slash:before {
  content: "\\f070";
}
.fa-facebook:before {
  content: "\\f09a";
}
.fa-facebook-f:before {
  content: "\\f39e";
}
.fa-facebook-messenger:before {
  content: "\\f39f";
}
.fa-facebook-square:before {
  content: "\\f082";
}
.fa-fan:before {
  content: "\\f863";
}
.fa-fan-table:before {
  content: "\uF904";
}
.fa-fantasy-flight-games:before {
  content: "\\f6dc";
}
.fa-farm:before {
  content: "\\f864";
}
.fa-fast-backward:before {
  content: "\\f049";
}
.fa-fast-forward:before {
  content: "\\f050";
}
.fa-faucet:before {
  content: "\uF905";
}
.fa-faucet-drip:before {
  content: "\uF906";
}
.fa-fax:before {
  content: "\\f1ac";
}
.fa-feather:before {
  content: "\\f52d";
}
.fa-feather-alt:before {
  content: "\\f56b";
}
.fa-fedex:before {
  content: "\\f797";
}
.fa-fedora:before {
  content: "\\f798";
}
.fa-female:before {
  content: "\\f182";
}
.fa-field-hockey:before {
  content: "\\f44c";
}
.fa-fighter-jet:before {
  content: "\\f0fb";
}
.fa-figma:before {
  content: "\\f799";
}
.fa-file:before {
  content: "\\f15b";
}
.fa-file-alt:before {
  content: "\\f15c";
}
.fa-file-archive:before {
  content: "\\f1c6";
}
.fa-file-audio:before {
  content: "\\f1c7";
}
.fa-file-certificate:before {
  content: "\\f5f3";
}
.fa-file-chart-line:before {
  content: "\\f659";
}
.fa-file-chart-pie:before {
  content: "\\f65a";
}
.fa-file-check:before {
  content: "\\f316";
}
.fa-file-code:before {
  content: "\\f1c9";
}
.fa-file-contract:before {
  content: "\\f56c";
}
.fa-file-csv:before {
  content: "\\f6dd";
}
.fa-file-download:before {
  content: "\\f56d";
}
.fa-file-edit:before {
  content: "\\f31c";
}
.fa-file-excel:before {
  content: "\\f1c3";
}
.fa-file-exclamation:before {
  content: "\\f31a";
}
.fa-file-export:before {
  content: "\\f56e";
}
.fa-file-image:before {
  content: "\\f1c5";
}
.fa-file-import:before {
  content: "\\f56f";
}
.fa-file-invoice:before {
  content: "\\f570";
}
.fa-file-invoice-dollar:before {
  content: "\\f571";
}
.fa-file-medical:before {
  content: "\\f477";
}
.fa-file-medical-alt:before {
  content: "\\f478";
}
.fa-file-minus:before {
  content: "\\f318";
}
.fa-file-music:before {
  content: "\\f8b6";
}
.fa-file-pdf:before {
  content: "\\f1c1";
}
.fa-file-plus:before {
  content: "\\f319";
}
.fa-file-powerpoint:before {
  content: "\\f1c4";
}
.fa-file-prescription:before {
  content: "\\f572";
}
.fa-file-search:before {
  content: "\\f865";
}
.fa-file-signature:before {
  content: "\\f573";
}
.fa-file-spreadsheet:before {
  content: "\\f65b";
}
.fa-file-times:before {
  content: "\\f317";
}
.fa-file-upload:before {
  content: "\\f574";
}
.fa-file-user:before {
  content: "\\f65c";
}
.fa-file-video:before {
  content: "\\f1c8";
}
.fa-file-word:before {
  content: "\\f1c2";
}
.fa-files-medical:before {
  content: "\\f7fd";
}
.fa-fill:before {
  content: "\\f575";
}
.fa-fill-drip:before {
  content: "\\f576";
}
.fa-film:before {
  content: "\\f008";
}
.fa-film-alt:before {
  content: "\\f3a0";
}
.fa-film-canister:before {
  content: "\\f8b7";
}
.fa-filter:before {
  content: "\\f0b0";
}
.fa-fingerprint:before {
  content: "\\f577";
}
.fa-fire:before {
  content: "\\f06d";
}
.fa-fire-alt:before {
  content: "\\f7e4";
}
.fa-fire-extinguisher:before {
  content: "\\f134";
}
.fa-fire-smoke:before {
  content: "\\f74b";
}
.fa-firefox:before {
  content: "\\f269";
}
.fa-firefox-browser:before {
  content: "\uF907";
}
.fa-fireplace:before {
  content: "\\f79a";
}
.fa-first-aid:before {
  content: "\\f479";
}
.fa-first-order:before {
  content: "\\f2b0";
}
.fa-first-order-alt:before {
  content: "\\f50a";
}
.fa-firstdraft:before {
  content: "\\f3a1";
}
.fa-fish:before {
  content: "\\f578";
}
.fa-fish-cooked:before {
  content: "\\f7fe";
}
.fa-fist-raised:before {
  content: "\\f6de";
}
.fa-flag:before {
  content: "\\f024";
}
.fa-flag-alt:before {
  content: "\\f74c";
}
.fa-flag-checkered:before {
  content: "\\f11e";
}
.fa-flag-usa:before {
  content: "\\f74d";
}
.fa-flame:before {
  content: "\\f6df";
}
.fa-flashlight:before {
  content: "\\f8b8";
}
.fa-flask:before {
  content: "\\f0c3";
}
.fa-flask-poison:before {
  content: "\\f6e0";
}
.fa-flask-potion:before {
  content: "\\f6e1";
}
.fa-flickr:before {
  content: "\\f16e";
}
.fa-flipboard:before {
  content: "\\f44d";
}
.fa-flower:before {
  content: "\\f7ff";
}
.fa-flower-daffodil:before {
  content: "\\f800";
}
.fa-flower-tulip:before {
  content: "\\f801";
}
.fa-flushed:before {
  content: "\\f579";
}
.fa-flute:before {
  content: "\\f8b9";
}
.fa-flux-capacitor:before {
  content: "\\f8ba";
}
.fa-fly:before {
  content: "\\f417";
}
.fa-fog:before {
  content: "\\f74e";
}
.fa-folder:before {
  content: "\\f07b";
}
.fa-folder-download:before {
  content: "\uF953";
}
.fa-folder-minus:before {
  content: "\\f65d";
}
.fa-folder-open:before {
  content: "\\f07c";
}
.fa-folder-plus:before {
  content: "\\f65e";
}
.fa-folder-times:before {
  content: "\\f65f";
}
.fa-folder-tree:before {
  content: "\\f802";
}
.fa-folder-upload:before {
  content: "\uF954";
}
.fa-folders:before {
  content: "\\f660";
}
.fa-font:before {
  content: "\\f031";
}
.fa-font-awesome:before {
  content: "\\f2b4";
}
.fa-font-awesome-alt:before {
  content: "\\f35c";
}
.fa-font-awesome-flag:before {
  content: "\\f425";
}
.fa-font-awesome-logo-full:before {
  content: "\\f4e6";
}
.fa-font-case:before {
  content: "\\f866";
}
.fa-fonticons:before {
  content: "\\f280";
}
.fa-fonticons-fi:before {
  content: "\\f3a2";
}
.fa-football-ball:before {
  content: "\\f44e";
}
.fa-football-helmet:before {
  content: "\\f44f";
}
.fa-forklift:before {
  content: "\\f47a";
}
.fa-fort-awesome:before {
  content: "\\f286";
}
.fa-fort-awesome-alt:before {
  content: "\\f3a3";
}
.fa-forumbee:before {
  content: "\\f211";
}
.fa-forward:before {
  content: "\\f04e";
}
.fa-foursquare:before {
  content: "\\f180";
}
.fa-fragile:before {
  content: "\\f4bb";
}
.fa-free-code-camp:before {
  content: "\\f2c5";
}
.fa-freebsd:before {
  content: "\\f3a4";
}
.fa-french-fries:before {
  content: "\\f803";
}
.fa-frog:before {
  content: "\\f52e";
}
.fa-frosty-head:before {
  content: "\\f79b";
}
.fa-frown:before {
  content: "\\f119";
}
.fa-frown-open:before {
  content: "\\f57a";
}
.fa-fulcrum:before {
  content: "\\f50b";
}
.fa-function:before {
  content: "\\f661";
}
.fa-funnel-dollar:before {
  content: "\\f662";
}
.fa-futbol:before {
  content: "\\f1e3";
}
.fa-galactic-republic:before {
  content: "\\f50c";
}
.fa-galactic-senate:before {
  content: "\\f50d";
}
.fa-galaxy:before {
  content: "\uF908";
}
.fa-game-board:before {
  content: "\\f867";
}
.fa-game-board-alt:before {
  content: "\\f868";
}
.fa-game-console-handheld:before {
  content: "\\f8bb";
}
.fa-gamepad:before {
  content: "\\f11b";
}
.fa-gamepad-alt:before {
  content: "\\f8bc";
}
.fa-garage:before {
  content: "\uF909";
}
.fa-garage-car:before {
  content: "\uF90A";
}
.fa-garage-open:before {
  content: "\uF90B";
}
.fa-gas-pump:before {
  content: "\\f52f";
}
.fa-gas-pump-slash:before {
  content: "\\f5f4";
}
.fa-gavel:before {
  content: "\\f0e3";
}
.fa-gem:before {
  content: "\\f3a5";
}
.fa-genderless:before {
  content: "\\f22d";
}
.fa-get-pocket:before {
  content: "\\f265";
}
.fa-gg:before {
  content: "\\f260";
}
.fa-gg-circle:before {
  content: "\\f261";
}
.fa-ghost:before {
  content: "\\f6e2";
}
.fa-gift:before {
  content: "\\f06b";
}
.fa-gift-card:before {
  content: "\\f663";
}
.fa-gifts:before {
  content: "\\f79c";
}
.fa-gingerbread-man:before {
  content: "\\f79d";
}
.fa-git:before {
  content: "\\f1d3";
}
.fa-git-alt:before {
  content: "\\f841";
}
.fa-git-square:before {
  content: "\\f1d2";
}
.fa-github:before {
  content: "\\f09b";
}
.fa-github-alt:before {
  content: "\\f113";
}
.fa-github-square:before {
  content: "\\f092";
}
.fa-gitkraken:before {
  content: "\\f3a6";
}
.fa-gitlab:before {
  content: "\\f296";
}
.fa-gitter:before {
  content: "\\f426";
}
.fa-glass:before {
  content: "\\f804";
}
.fa-glass-champagne:before {
  content: "\\f79e";
}
.fa-glass-cheers:before {
  content: "\\f79f";
}
.fa-glass-citrus:before {
  content: "\\f869";
}
.fa-glass-martini:before {
  content: "\\f000";
}
.fa-glass-martini-alt:before {
  content: "\\f57b";
}
.fa-glass-whiskey:before {
  content: "\\f7a0";
}
.fa-glass-whiskey-rocks:before {
  content: "\\f7a1";
}
.fa-glasses:before {
  content: "\\f530";
}
.fa-glasses-alt:before {
  content: "\\f5f5";
}
.fa-glide:before {
  content: "\\f2a5";
}
.fa-glide-g:before {
  content: "\\f2a6";
}
.fa-globe:before {
  content: "\\f0ac";
}
.fa-globe-africa:before {
  content: "\\f57c";
}
.fa-globe-americas:before {
  content: "\\f57d";
}
.fa-globe-asia:before {
  content: "\\f57e";
}
.fa-globe-europe:before {
  content: "\\f7a2";
}
.fa-globe-snow:before {
  content: "\\f7a3";
}
.fa-globe-stand:before {
  content: "\\f5f6";
}
.fa-gofore:before {
  content: "\\f3a7";
}
.fa-golf-ball:before {
  content: "\\f450";
}
.fa-golf-club:before {
  content: "\\f451";
}
.fa-goodreads:before {
  content: "\\f3a8";
}
.fa-goodreads-g:before {
  content: "\\f3a9";
}
.fa-google:before {
  content: "\\f1a0";
}
.fa-google-drive:before {
  content: "\\f3aa";
}
.fa-google-play:before {
  content: "\\f3ab";
}
.fa-google-plus:before {
  content: "\\f2b3";
}
.fa-google-plus-g:before {
  content: "\\f0d5";
}
.fa-google-plus-square:before {
  content: "\\f0d4";
}
.fa-google-wallet:before {
  content: "\\f1ee";
}
.fa-gopuram:before {
  content: "\\f664";
}
.fa-graduation-cap:before {
  content: "\\f19d";
}
.fa-gramophone:before {
  content: "\\f8bd";
}
.fa-gratipay:before {
  content: "\\f184";
}
.fa-grav:before {
  content: "\\f2d6";
}
.fa-greater-than:before {
  content: "\\f531";
}
.fa-greater-than-equal:before {
  content: "\\f532";
}
.fa-grimace:before {
  content: "\\f57f";
}
.fa-grin:before {
  content: "\\f580";
}
.fa-grin-alt:before {
  content: "\\f581";
}
.fa-grin-beam:before {
  content: "\\f582";
}
.fa-grin-beam-sweat:before {
  content: "\\f583";
}
.fa-grin-hearts:before {
  content: "\\f584";
}
.fa-grin-squint:before {
  content: "\\f585";
}
.fa-grin-squint-tears:before {
  content: "\\f586";
}
.fa-grin-stars:before {
  content: "\\f587";
}
.fa-grin-tears:before {
  content: "\\f588";
}
.fa-grin-tongue:before {
  content: "\\f589";
}
.fa-grin-tongue-squint:before {
  content: "\\f58a";
}
.fa-grin-tongue-wink:before {
  content: "\\f58b";
}
.fa-grin-wink:before {
  content: "\\f58c";
}
.fa-grip-horizontal:before {
  content: "\\f58d";
}
.fa-grip-lines:before {
  content: "\\f7a4";
}
.fa-grip-lines-vertical:before {
  content: "\\f7a5";
}
.fa-grip-vertical:before {
  content: "\\f58e";
}
.fa-gripfire:before {
  content: "\\f3ac";
}
.fa-grunt:before {
  content: "\\f3ad";
}
.fa-guitar:before {
  content: "\\f7a6";
}
.fa-guitar-electric:before {
  content: "\\f8be";
}
.fa-guitars:before {
  content: "\\f8bf";
}
.fa-gulp:before {
  content: "\\f3ae";
}
.fa-h-square:before {
  content: "\\f0fd";
}
.fa-h1:before {
  content: "\\f313";
}
.fa-h2:before {
  content: "\\f314";
}
.fa-h3:before {
  content: "\\f315";
}
.fa-h4:before {
  content: "\\f86a";
}
.fa-hacker-news:before {
  content: "\\f1d4";
}
.fa-hacker-news-square:before {
  content: "\\f3af";
}
.fa-hackerrank:before {
  content: "\\f5f7";
}
.fa-hamburger:before {
  content: "\\f805";
}
.fa-hammer:before {
  content: "\\f6e3";
}
.fa-hammer-war:before {
  content: "\\f6e4";
}
.fa-hamsa:before {
  content: "\\f665";
}
.fa-hand-heart:before {
  content: "\\f4bc";
}
.fa-hand-holding:before {
  content: "\\f4bd";
}
.fa-hand-holding-box:before {
  content: "\\f47b";
}
.fa-hand-holding-heart:before {
  content: "\\f4be";
}
.fa-hand-holding-magic:before {
  content: "\\f6e5";
}
.fa-hand-holding-medical:before {
  content: "\uF95C";
}
.fa-hand-holding-seedling:before {
  content: "\\f4bf";
}
.fa-hand-holding-usd:before {
  content: "\\f4c0";
}
.fa-hand-holding-water:before {
  content: "\\f4c1";
}
.fa-hand-lizard:before {
  content: "\\f258";
}
.fa-hand-middle-finger:before {
  content: "\\f806";
}
.fa-hand-paper:before {
  content: "\\f256";
}
.fa-hand-peace:before {
  content: "\\f25b";
}
.fa-hand-point-down:before {
  content: "\\f0a7";
}
.fa-hand-point-left:before {
  content: "\\f0a5";
}
.fa-hand-point-right:before {
  content: "\\f0a4";
}
.fa-hand-point-up:before {
  content: "\\f0a6";
}
.fa-hand-pointer:before {
  content: "\\f25a";
}
.fa-hand-receiving:before {
  content: "\\f47c";
}
.fa-hand-rock:before {
  content: "\\f255";
}
.fa-hand-scissors:before {
  content: "\\f257";
}
.fa-hand-sparkles:before {
  content: "\uF95D";
}
.fa-hand-spock:before {
  content: "\\f259";
}
.fa-hands:before {
  content: "\\f4c2";
}
.fa-hands-heart:before {
  content: "\\f4c3";
}
.fa-hands-helping:before {
  content: "\\f4c4";
}
.fa-hands-usd:before {
  content: "\\f4c5";
}
.fa-hands-wash:before {
  content: "\uF95E";
}
.fa-handshake:before {
  content: "\\f2b5";
}
.fa-handshake-alt:before {
  content: "\\f4c6";
}
.fa-handshake-alt-slash:before {
  content: "\uF95F";
}
.fa-handshake-slash:before {
  content: "\uF960";
}
.fa-hanukiah:before {
  content: "\\f6e6";
}
.fa-hard-hat:before {
  content: "\\f807";
}
.fa-hashtag:before {
  content: "\\f292";
}
.fa-hat-chef:before {
  content: "\\f86b";
}
.fa-hat-cowboy:before {
  content: "\\f8c0";
}
.fa-hat-cowboy-side:before {
  content: "\\f8c1";
}
.fa-hat-santa:before {
  content: "\\f7a7";
}
.fa-hat-winter:before {
  content: "\\f7a8";
}
.fa-hat-witch:before {
  content: "\\f6e7";
}
.fa-hat-wizard:before {
  content: "\\f6e8";
}
.fa-hdd:before {
  content: "\\f0a0";
}
.fa-head-side:before {
  content: "\\f6e9";
}
.fa-head-side-brain:before {
  content: "\\f808";
}
.fa-head-side-cough:before {
  content: "\uF961";
}
.fa-head-side-cough-slash:before {
  content: "\uF962";
}
.fa-head-side-headphones:before {
  content: "\\f8c2";
}
.fa-head-side-mask:before {
  content: "\uF963";
}
.fa-head-side-medical:before {
  content: "\\f809";
}
.fa-head-side-virus:before {
  content: "\uF964";
}
.fa-head-vr:before {
  content: "\\f6ea";
}
.fa-heading:before {
  content: "\\f1dc";
}
.fa-headphones:before {
  content: "\\f025";
}
.fa-headphones-alt:before {
  content: "\\f58f";
}
.fa-headset:before {
  content: "\\f590";
}
.fa-heart:before {
  content: "\\f004";
}
.fa-heart-broken:before {
  content: "\\f7a9";
}
.fa-heart-circle:before {
  content: "\\f4c7";
}
.fa-heart-rate:before {
  content: "\\f5f8";
}
.fa-heart-square:before {
  content: "\\f4c8";
}
.fa-heartbeat:before {
  content: "\\f21e";
}
.fa-heat:before {
  content: "\uF90C";
}
.fa-helicopter:before {
  content: "\\f533";
}
.fa-helmet-battle:before {
  content: "\\f6eb";
}
.fa-hexagon:before {
  content: "\\f312";
}
.fa-highlighter:before {
  content: "\\f591";
}
.fa-hiking:before {
  content: "\\f6ec";
}
.fa-hippo:before {
  content: "\\f6ed";
}
.fa-hips:before {
  content: "\\f452";
}
.fa-hire-a-helper:before {
  content: "\\f3b0";
}
.fa-history:before {
  content: "\\f1da";
}
.fa-hockey-mask:before {
  content: "\\f6ee";
}
.fa-hockey-puck:before {
  content: "\\f453";
}
.fa-hockey-sticks:before {
  content: "\\f454";
}
.fa-holly-berry:before {
  content: "\\f7aa";
}
.fa-home:before {
  content: "\\f015";
}
.fa-home-alt:before {
  content: "\\f80a";
}
.fa-home-heart:before {
  content: "\\f4c9";
}
.fa-home-lg:before {
  content: "\\f80b";
}
.fa-home-lg-alt:before {
  content: "\\f80c";
}
.fa-hood-cloak:before {
  content: "\\f6ef";
}
.fa-hooli:before {
  content: "\\f427";
}
.fa-horizontal-rule:before {
  content: "\\f86c";
}
.fa-hornbill:before {
  content: "\\f592";
}
.fa-horse:before {
  content: "\\f6f0";
}
.fa-horse-head:before {
  content: "\\f7ab";
}
.fa-horse-saddle:before {
  content: "\\f8c3";
}
.fa-hospital:before {
  content: "\\f0f8";
}
.fa-hospital-alt:before {
  content: "\\f47d";
}
.fa-hospital-symbol:before {
  content: "\\f47e";
}
.fa-hospital-user:before {
  content: "\\f80d";
}
.fa-hospitals:before {
  content: "\\f80e";
}
.fa-hot-tub:before {
  content: "\\f593";
}
.fa-hotdog:before {
  content: "\\f80f";
}
.fa-hotel:before {
  content: "\\f594";
}
.fa-hotjar:before {
  content: "\\f3b1";
}
.fa-hourglass:before {
  content: "\\f254";
}
.fa-hourglass-end:before {
  content: "\\f253";
}
.fa-hourglass-half:before {
  content: "\\f252";
}
.fa-hourglass-start:before {
  content: "\\f251";
}
.fa-house:before {
  content: "\uF90D";
}
.fa-house-damage:before {
  content: "\\f6f1";
}
.fa-house-day:before {
  content: "\uF90E";
}
.fa-house-flood:before {
  content: "\\f74f";
}
.fa-house-leave:before {
  content: "\uF90F";
}
.fa-house-night:before {
  content: "\uF910";
}
.fa-house-return:before {
  content: "\uF911";
}
.fa-house-signal:before {
  content: "\uF912";
}
.fa-house-user:before {
  content: "\uF965";
}
.fa-houzz:before {
  content: "\\f27c";
}
.fa-hryvnia:before {
  content: "\\f6f2";
}
.fa-html5:before {
  content: "\\f13b";
}
.fa-hubspot:before {
  content: "\\f3b2";
}
.fa-humidity:before {
  content: "\\f750";
}
.fa-hurricane:before {
  content: "\\f751";
}
.fa-i-cursor:before {
  content: "\\f246";
}
.fa-ice-cream:before {
  content: "\\f810";
}
.fa-ice-skate:before {
  content: "\\f7ac";
}
.fa-icicles:before {
  content: "\\f7ad";
}
.fa-icons:before {
  content: "\\f86d";
}
.fa-icons-alt:before {
  content: "\\f86e";
}
.fa-id-badge:before {
  content: "\\f2c1";
}
.fa-id-card:before {
  content: "\\f2c2";
}
.fa-id-card-alt:before {
  content: "\\f47f";
}
.fa-ideal:before {
  content: "\uF913";
}
.fa-igloo:before {
  content: "\\f7ae";
}
.fa-image:before {
  content: "\\f03e";
}
.fa-image-polaroid:before {
  content: "\\f8c4";
}
.fa-images:before {
  content: "\\f302";
}
.fa-imdb:before {
  content: "\\f2d8";
}
.fa-inbox:before {
  content: "\\f01c";
}
.fa-inbox-in:before {
  content: "\\f310";
}
.fa-inbox-out:before {
  content: "\\f311";
}
.fa-indent:before {
  content: "\\f03c";
}
.fa-industry:before {
  content: "\\f275";
}
.fa-industry-alt:before {
  content: "\\f3b3";
}
.fa-infinity:before {
  content: "\\f534";
}
.fa-info:before {
  content: "\\f129";
}
.fa-info-circle:before {
  content: "\\f05a";
}
.fa-info-square:before {
  content: "\\f30f";
}
.fa-inhaler:before {
  content: "\\f5f9";
}
.fa-instagram:before {
  content: "\\f16d";
}
.fa-instagram-square:before {
  content: "\uF955";
}
.fa-integral:before {
  content: "\\f667";
}
.fa-intercom:before {
  content: "\\f7af";
}
.fa-internet-explorer:before {
  content: "\\f26b";
}
.fa-intersection:before {
  content: "\\f668";
}
.fa-inventory:before {
  content: "\\f480";
}
.fa-invision:before {
  content: "\\f7b0";
}
.fa-ioxhost:before {
  content: "\\f208";
}
.fa-island-tropical:before {
  content: "\\f811";
}
.fa-italic:before {
  content: "\\f033";
}
.fa-itch-io:before {
  content: "\\f83a";
}
.fa-itunes:before {
  content: "\\f3b4";
}
.fa-itunes-note:before {
  content: "\\f3b5";
}
.fa-jack-o-lantern:before {
  content: "\\f30e";
}
.fa-java:before {
  content: "\\f4e4";
}
.fa-jedi:before {
  content: "\\f669";
}
.fa-jedi-order:before {
  content: "\\f50e";
}
.fa-jenkins:before {
  content: "\\f3b6";
}
.fa-jira:before {
  content: "\\f7b1";
}
.fa-joget:before {
  content: "\\f3b7";
}
.fa-joint:before {
  content: "\\f595";
}
.fa-joomla:before {
  content: "\\f1aa";
}
.fa-journal-whills:before {
  content: "\\f66a";
}
.fa-joystick:before {
  content: "\\f8c5";
}
.fa-js:before {
  content: "\\f3b8";
}
.fa-js-square:before {
  content: "\\f3b9";
}
.fa-jsfiddle:before {
  content: "\\f1cc";
}
.fa-jug:before {
  content: "\\f8c6";
}
.fa-kaaba:before {
  content: "\\f66b";
}
.fa-kaggle:before {
  content: "\\f5fa";
}
.fa-kazoo:before {
  content: "\\f8c7";
}
.fa-kerning:before {
  content: "\\f86f";
}
.fa-key:before {
  content: "\\f084";
}
.fa-key-skeleton:before {
  content: "\\f6f3";
}
.fa-keybase:before {
  content: "\\f4f5";
}
.fa-keyboard:before {
  content: "\\f11c";
}
.fa-keycdn:before {
  content: "\\f3ba";
}
.fa-keynote:before {
  content: "\\f66c";
}
.fa-khanda:before {
  content: "\\f66d";
}
.fa-kickstarter:before {
  content: "\\f3bb";
}
.fa-kickstarter-k:before {
  content: "\\f3bc";
}
.fa-kidneys:before {
  content: "\\f5fb";
}
.fa-kiss:before {
  content: "\\f596";
}
.fa-kiss-beam:before {
  content: "\\f597";
}
.fa-kiss-wink-heart:before {
  content: "\\f598";
}
.fa-kite:before {
  content: "\\f6f4";
}
.fa-kiwi-bird:before {
  content: "\\f535";
}
.fa-knife-kitchen:before {
  content: "\\f6f5";
}
.fa-korvue:before {
  content: "\\f42f";
}
.fa-lambda:before {
  content: "\\f66e";
}
.fa-lamp:before {
  content: "\\f4ca";
}
.fa-lamp-desk:before {
  content: "\uF914";
}
.fa-lamp-floor:before {
  content: "\uF915";
}
.fa-landmark:before {
  content: "\\f66f";
}
.fa-landmark-alt:before {
  content: "\\f752";
}
.fa-language:before {
  content: "\\f1ab";
}
.fa-laptop:before {
  content: "\\f109";
}
.fa-laptop-code:before {
  content: "\\f5fc";
}
.fa-laptop-house:before {
  content: "\uF966";
}
.fa-laptop-medical:before {
  content: "\\f812";
}
.fa-laravel:before {
  content: "\\f3bd";
}
.fa-lasso:before {
  content: "\\f8c8";
}
.fa-lastfm:before {
  content: "\\f202";
}
.fa-lastfm-square:before {
  content: "\\f203";
}
.fa-laugh:before {
  content: "\\f599";
}
.fa-laugh-beam:before {
  content: "\\f59a";
}
.fa-laugh-squint:before {
  content: "\\f59b";
}
.fa-laugh-wink:before {
  content: "\\f59c";
}
.fa-layer-group:before {
  content: "\\f5fd";
}
.fa-layer-minus:before {
  content: "\\f5fe";
}
.fa-layer-plus:before {
  content: "\\f5ff";
}
.fa-leaf:before {
  content: "\\f06c";
}
.fa-leaf-heart:before {
  content: "\\f4cb";
}
.fa-leaf-maple:before {
  content: "\\f6f6";
}
.fa-leaf-oak:before {
  content: "\\f6f7";
}
.fa-leanpub:before {
  content: "\\f212";
}
.fa-lemon:before {
  content: "\\f094";
}
.fa-less:before {
  content: "\\f41d";
}
.fa-less-than:before {
  content: "\\f536";
}
.fa-less-than-equal:before {
  content: "\\f537";
}
.fa-level-down:before {
  content: "\\f149";
}
.fa-level-down-alt:before {
  content: "\\f3be";
}
.fa-level-up:before {
  content: "\\f148";
}
.fa-level-up-alt:before {
  content: "\\f3bf";
}
.fa-life-ring:before {
  content: "\\f1cd";
}
.fa-light-ceiling:before {
  content: "\uF916";
}
.fa-light-switch:before {
  content: "\uF917";
}
.fa-light-switch-off:before {
  content: "\uF918";
}
.fa-light-switch-on:before {
  content: "\uF919";
}
.fa-lightbulb:before {
  content: "\\f0eb";
}
.fa-lightbulb-dollar:before {
  content: "\\f670";
}
.fa-lightbulb-exclamation:before {
  content: "\\f671";
}
.fa-lightbulb-on:before {
  content: "\\f672";
}
.fa-lightbulb-slash:before {
  content: "\\f673";
}
.fa-lights-holiday:before {
  content: "\\f7b2";
}
.fa-line:before {
  content: "\\f3c0";
}
.fa-line-columns:before {
  content: "\\f870";
}
.fa-line-height:before {
  content: "\\f871";
}
.fa-link:before {
  content: "\\f0c1";
}
.fa-linkedin:before {
  content: "\\f08c";
}
.fa-linkedin-in:before {
  content: "\\f0e1";
}
.fa-linode:before {
  content: "\\f2b8";
}
.fa-linux:before {
  content: "\\f17c";
}
.fa-lips:before {
  content: "\\f600";
}
.fa-lira-sign:before {
  content: "\\f195";
}
.fa-list:before {
  content: "\\f03a";
}
.fa-list-alt:before {
  content: "\\f022";
}
.fa-list-music:before {
  content: "\\f8c9";
}
.fa-list-ol:before {
  content: "\\f0cb";
}
.fa-list-ul:before {
  content: "\\f0ca";
}
.fa-location:before {
  content: "\\f601";
}
.fa-location-arrow:before {
  content: "\\f124";
}
.fa-location-circle:before {
  content: "\\f602";
}
.fa-location-slash:before {
  content: "\\f603";
}
.fa-lock:before {
  content: "\\f023";
}
.fa-lock-alt:before {
  content: "\\f30d";
}
.fa-lock-open:before {
  content: "\\f3c1";
}
.fa-lock-open-alt:before {
  content: "\\f3c2";
}
.fa-long-arrow-alt-down:before {
  content: "\\f309";
}
.fa-long-arrow-alt-left:before {
  content: "\\f30a";
}
.fa-long-arrow-alt-right:before {
  content: "\\f30b";
}
.fa-long-arrow-alt-up:before {
  content: "\\f30c";
}
.fa-long-arrow-down:before {
  content: "\\f175";
}
.fa-long-arrow-left:before {
  content: "\\f177";
}
.fa-long-arrow-right:before {
  content: "\\f178";
}
.fa-long-arrow-up:before {
  content: "\\f176";
}
.fa-loveseat:before {
  content: "\\f4cc";
}
.fa-low-vision:before {
  content: "\\f2a8";
}
.fa-luchador:before {
  content: "\\f455";
}
.fa-luggage-cart:before {
  content: "\\f59d";
}
.fa-lungs:before {
  content: "\\f604";
}
.fa-lungs-virus:before {
  content: "\uF967";
}
.fa-lyft:before {
  content: "\\f3c3";
}
.fa-mace:before {
  content: "\\f6f8";
}
.fa-magento:before {
  content: "\\f3c4";
}
.fa-magic:before {
  content: "\\f0d0";
}
.fa-magnet:before {
  content: "\\f076";
}
.fa-mail-bulk:before {
  content: "\\f674";
}
.fa-mailbox:before {
  content: "\\f813";
}
.fa-mailchimp:before {
  content: "\\f59e";
}
.fa-male:before {
  content: "\\f183";
}
.fa-mandalorian:before {
  content: "\\f50f";
}
.fa-mandolin:before {
  content: "\\f6f9";
}
.fa-map:before {
  content: "\\f279";
}
.fa-map-marked:before {
  content: "\\f59f";
}
.fa-map-marked-alt:before {
  content: "\\f5a0";
}
.fa-map-marker:before {
  content: "\\f041";
}
.fa-map-marker-alt:before {
  content: "\\f3c5";
}
.fa-map-marker-alt-slash:before {
  content: "\\f605";
}
.fa-map-marker-check:before {
  content: "\\f606";
}
.fa-map-marker-edit:before {
  content: "\\f607";
}
.fa-map-marker-exclamation:before {
  content: "\\f608";
}
.fa-map-marker-minus:before {
  content: "\\f609";
}
.fa-map-marker-plus:before {
  content: "\\f60a";
}
.fa-map-marker-question:before {
  content: "\\f60b";
}
.fa-map-marker-slash:before {
  content: "\\f60c";
}
.fa-map-marker-smile:before {
  content: "\\f60d";
}
.fa-map-marker-times:before {
  content: "\\f60e";
}
.fa-map-pin:before {
  content: "\\f276";
}
.fa-map-signs:before {
  content: "\\f277";
}
.fa-markdown:before {
  content: "\\f60f";
}
.fa-marker:before {
  content: "\\f5a1";
}
.fa-mars:before {
  content: "\\f222";
}
.fa-mars-double:before {
  content: "\\f227";
}
.fa-mars-stroke:before {
  content: "\\f229";
}
.fa-mars-stroke-h:before {
  content: "\\f22b";
}
.fa-mars-stroke-v:before {
  content: "\\f22a";
}
.fa-mask:before {
  content: "\\f6fa";
}
.fa-mastodon:before {
  content: "\\f4f6";
}
.fa-maxcdn:before {
  content: "\\f136";
}
.fa-mdb:before {
  content: "\\f8ca";
}
.fa-meat:before {
  content: "\\f814";
}
.fa-medal:before {
  content: "\\f5a2";
}
.fa-medapps:before {
  content: "\\f3c6";
}
.fa-medium:before {
  content: "\\f23a";
}
.fa-medium-m:before {
  content: "\\f3c7";
}
.fa-medkit:before {
  content: "\\f0fa";
}
.fa-medrt:before {
  content: "\\f3c8";
}
.fa-meetup:before {
  content: "\\f2e0";
}
.fa-megaphone:before {
  content: "\\f675";
}
.fa-megaport:before {
  content: "\\f5a3";
}
.fa-meh:before {
  content: "\\f11a";
}
.fa-meh-blank:before {
  content: "\\f5a4";
}
.fa-meh-rolling-eyes:before {
  content: "\\f5a5";
}
.fa-memory:before {
  content: "\\f538";
}
.fa-mendeley:before {
  content: "\\f7b3";
}
.fa-menorah:before {
  content: "\\f676";
}
.fa-mercury:before {
  content: "\\f223";
}
.fa-meteor:before {
  content: "\\f753";
}
.fa-microblog:before {
  content: "\uF91A";
}
.fa-microchip:before {
  content: "\\f2db";
}
.fa-microphone:before {
  content: "\\f130";
}
.fa-microphone-alt:before {
  content: "\\f3c9";
}
.fa-microphone-alt-slash:before {
  content: "\\f539";
}
.fa-microphone-slash:before {
  content: "\\f131";
}
.fa-microphone-stand:before {
  content: "\\f8cb";
}
.fa-microscope:before {
  content: "\\f610";
}
.fa-microsoft:before {
  content: "\\f3ca";
}
.fa-microwave:before {
  content: "\uF91B";
}
.fa-mind-share:before {
  content: "\\f677";
}
.fa-minus:before {
  content: "\\f068";
}
.fa-minus-circle:before {
  content: "\\f056";
}
.fa-minus-hexagon:before {
  content: "\\f307";
}
.fa-minus-octagon:before {
  content: "\\f308";
}
.fa-minus-square:before {
  content: "\\f146";
}
.fa-mistletoe:before {
  content: "\\f7b4";
}
.fa-mitten:before {
  content: "\\f7b5";
}
.fa-mix:before {
  content: "\\f3cb";
}
.fa-mixcloud:before {
  content: "\\f289";
}
.fa-mixer:before {
  content: "\uF956";
}
.fa-mizuni:before {
  content: "\\f3cc";
}
.fa-mobile:before {
  content: "\\f10b";
}
.fa-mobile-alt:before {
  content: "\\f3cd";
}
.fa-mobile-android:before {
  content: "\\f3ce";
}
.fa-mobile-android-alt:before {
  content: "\\f3cf";
}
.fa-modx:before {
  content: "\\f285";
}
.fa-monero:before {
  content: "\\f3d0";
}
.fa-money-bill:before {
  content: "\\f0d6";
}
.fa-money-bill-alt:before {
  content: "\\f3d1";
}
.fa-money-bill-wave:before {
  content: "\\f53a";
}
.fa-money-bill-wave-alt:before {
  content: "\\f53b";
}
.fa-money-check:before {
  content: "\\f53c";
}
.fa-money-check-alt:before {
  content: "\\f53d";
}
.fa-money-check-edit:before {
  content: "\\f872";
}
.fa-money-check-edit-alt:before {
  content: "\\f873";
}
.fa-monitor-heart-rate:before {
  content: "\\f611";
}
.fa-monkey:before {
  content: "\\f6fb";
}
.fa-monument:before {
  content: "\\f5a6";
}
.fa-moon:before {
  content: "\\f186";
}
.fa-moon-cloud:before {
  content: "\\f754";
}
.fa-moon-stars:before {
  content: "\\f755";
}
.fa-mortar-pestle:before {
  content: "\\f5a7";
}
.fa-mosque:before {
  content: "\\f678";
}
.fa-motorcycle:before {
  content: "\\f21c";
}
.fa-mountain:before {
  content: "\\f6fc";
}
.fa-mountains:before {
  content: "\\f6fd";
}
.fa-mouse:before {
  content: "\\f8cc";
}
.fa-mouse-alt:before {
  content: "\\f8cd";
}
.fa-mouse-pointer:before {
  content: "\\f245";
}
.fa-mp3-player:before {
  content: "\\f8ce";
}
.fa-mug:before {
  content: "\\f874";
}
.fa-mug-hot:before {
  content: "\\f7b6";
}
.fa-mug-marshmallows:before {
  content: "\\f7b7";
}
.fa-mug-tea:before {
  content: "\\f875";
}
.fa-music:before {
  content: "\\f001";
}
.fa-music-alt:before {
  content: "\\f8cf";
}
.fa-music-alt-slash:before {
  content: "\\f8d0";
}
.fa-music-slash:before {
  content: "\\f8d1";
}
.fa-napster:before {
  content: "\\f3d2";
}
.fa-narwhal:before {
  content: "\\f6fe";
}
.fa-neos:before {
  content: "\\f612";
}
.fa-network-wired:before {
  content: "\\f6ff";
}
.fa-neuter:before {
  content: "\\f22c";
}
.fa-newspaper:before {
  content: "\\f1ea";
}
.fa-nimblr:before {
  content: "\\f5a8";
}
.fa-node:before {
  content: "\\f419";
}
.fa-node-js:before {
  content: "\\f3d3";
}
.fa-not-equal:before {
  content: "\\f53e";
}
.fa-notes-medical:before {
  content: "\\f481";
}
.fa-npm:before {
  content: "\\f3d4";
}
.fa-ns8:before {
  content: "\\f3d5";
}
.fa-nutritionix:before {
  content: "\\f3d6";
}
.fa-object-group:before {
  content: "\\f247";
}
.fa-object-ungroup:before {
  content: "\\f248";
}
.fa-octagon:before {
  content: "\\f306";
}
.fa-odnoklassniki:before {
  content: "\\f263";
}
.fa-odnoklassniki-square:before {
  content: "\\f264";
}
.fa-oil-can:before {
  content: "\\f613";
}
.fa-oil-temp:before {
  content: "\\f614";
}
.fa-old-republic:before {
  content: "\\f510";
}
.fa-om:before {
  content: "\\f679";
}
.fa-omega:before {
  content: "\\f67a";
}
.fa-opencart:before {
  content: "\\f23d";
}
.fa-openid:before {
  content: "\\f19b";
}
.fa-opera:before {
  content: "\\f26a";
}
.fa-optin-monster:before {
  content: "\\f23c";
}
.fa-orcid:before {
  content: "\\f8d2";
}
.fa-ornament:before {
  content: "\\f7b8";
}
.fa-osi:before {
  content: "\\f41a";
}
.fa-otter:before {
  content: "\\f700";
}
.fa-outdent:before {
  content: "\\f03b";
}
.fa-outlet:before {
  content: "\uF91C";
}
.fa-oven:before {
  content: "\uF91D";
}
.fa-overline:before {
  content: "\\f876";
}
.fa-page-break:before {
  content: "\\f877";
}
.fa-page4:before {
  content: "\\f3d7";
}
.fa-pagelines:before {
  content: "\\f18c";
}
.fa-pager:before {
  content: "\\f815";
}
.fa-paint-brush:before {
  content: "\\f1fc";
}
.fa-paint-brush-alt:before {
  content: "\\f5a9";
}
.fa-paint-roller:before {
  content: "\\f5aa";
}
.fa-palette:before {
  content: "\\f53f";
}
.fa-palfed:before {
  content: "\\f3d8";
}
.fa-pallet:before {
  content: "\\f482";
}
.fa-pallet-alt:before {
  content: "\\f483";
}
.fa-paper-plane:before {
  content: "\\f1d8";
}
.fa-paperclip:before {
  content: "\\f0c6";
}
.fa-parachute-box:before {
  content: "\\f4cd";
}
.fa-paragraph:before {
  content: "\\f1dd";
}
.fa-paragraph-rtl:before {
  content: "\\f878";
}
.fa-parking:before {
  content: "\\f540";
}
.fa-parking-circle:before {
  content: "\\f615";
}
.fa-parking-circle-slash:before {
  content: "\\f616";
}
.fa-parking-slash:before {
  content: "\\f617";
}
.fa-passport:before {
  content: "\\f5ab";
}
.fa-pastafarianism:before {
  content: "\\f67b";
}
.fa-paste:before {
  content: "\\f0ea";
}
.fa-patreon:before {
  content: "\\f3d9";
}
.fa-pause:before {
  content: "\\f04c";
}
.fa-pause-circle:before {
  content: "\\f28b";
}
.fa-paw:before {
  content: "\\f1b0";
}
.fa-paw-alt:before {
  content: "\\f701";
}
.fa-paw-claws:before {
  content: "\\f702";
}
.fa-paypal:before {
  content: "\\f1ed";
}
.fa-peace:before {
  content: "\\f67c";
}
.fa-pegasus:before {
  content: "\\f703";
}
.fa-pen:before {
  content: "\\f304";
}
.fa-pen-alt:before {
  content: "\\f305";
}
.fa-pen-fancy:before {
  content: "\\f5ac";
}
.fa-pen-nib:before {
  content: "\\f5ad";
}
.fa-pen-square:before {
  content: "\\f14b";
}
.fa-pencil:before {
  content: "\\f040";
}
.fa-pencil-alt:before {
  content: "\\f303";
}
.fa-pencil-paintbrush:before {
  content: "\\f618";
}
.fa-pencil-ruler:before {
  content: "\\f5ae";
}
.fa-pennant:before {
  content: "\\f456";
}
.fa-penny-arcade:before {
  content: "\\f704";
}
.fa-people-arrows:before {
  content: "\uF968";
}
.fa-people-carry:before {
  content: "\\f4ce";
}
.fa-pepper-hot:before {
  content: "\\f816";
}
.fa-percent:before {
  content: "\\f295";
}
.fa-percentage:before {
  content: "\\f541";
}
.fa-periscope:before {
  content: "\\f3da";
}
.fa-person-booth:before {
  content: "\\f756";
}
.fa-person-carry:before {
  content: "\\f4cf";
}
.fa-person-dolly:before {
  content: "\\f4d0";
}
.fa-person-dolly-empty:before {
  content: "\\f4d1";
}
.fa-person-sign:before {
  content: "\\f757";
}
.fa-phabricator:before {
  content: "\\f3db";
}
.fa-phoenix-framework:before {
  content: "\\f3dc";
}
.fa-phoenix-squadron:before {
  content: "\\f511";
}
.fa-phone:before {
  content: "\\f095";
}
.fa-phone-alt:before {
  content: "\\f879";
}
.fa-phone-laptop:before {
  content: "\\f87a";
}
.fa-phone-office:before {
  content: "\\f67d";
}
.fa-phone-plus:before {
  content: "\\f4d2";
}
.fa-phone-rotary:before {
  content: "\\f8d3";
}
.fa-phone-slash:before {
  content: "\\f3dd";
}
.fa-phone-square:before {
  content: "\\f098";
}
.fa-phone-square-alt:before {
  content: "\\f87b";
}
.fa-phone-volume:before {
  content: "\\f2a0";
}
.fa-photo-video:before {
  content: "\\f87c";
}
.fa-php:before {
  content: "\\f457";
}
.fa-pi:before {
  content: "\\f67e";
}
.fa-piano:before {
  content: "\\f8d4";
}
.fa-piano-keyboard:before {
  content: "\\f8d5";
}
.fa-pie:before {
  content: "\\f705";
}
.fa-pied-piper:before {
  content: "\\f2ae";
}
.fa-pied-piper-alt:before {
  content: "\\f1a8";
}
.fa-pied-piper-hat:before {
  content: "\\f4e5";
}
.fa-pied-piper-pp:before {
  content: "\\f1a7";
}
.fa-pied-piper-square:before {
  content: "\uF91E";
}
.fa-pig:before {
  content: "\\f706";
}
.fa-piggy-bank:before {
  content: "\\f4d3";
}
.fa-pills:before {
  content: "\\f484";
}
.fa-pinterest:before {
  content: "\\f0d2";
}
.fa-pinterest-p:before {
  content: "\\f231";
}
.fa-pinterest-square:before {
  content: "\\f0d3";
}
.fa-pizza:before {
  content: "\\f817";
}
.fa-pizza-slice:before {
  content: "\\f818";
}
.fa-place-of-worship:before {
  content: "\\f67f";
}
.fa-plane:before {
  content: "\\f072";
}
.fa-plane-alt:before {
  content: "\\f3de";
}
.fa-plane-arrival:before {
  content: "\\f5af";
}
.fa-plane-departure:before {
  content: "\\f5b0";
}
.fa-plane-slash:before {
  content: "\uF969";
}
.fa-planet-moon:before {
  content: "\uF91F";
}
.fa-planet-ringed:before {
  content: "\uF920";
}
.fa-play:before {
  content: "\\f04b";
}
.fa-play-circle:before {
  content: "\\f144";
}
.fa-playstation:before {
  content: "\\f3df";
}
.fa-plug:before {
  content: "\\f1e6";
}
.fa-plus:before {
  content: "\\f067";
}
.fa-plus-circle:before {
  content: "\\f055";
}
.fa-plus-hexagon:before {
  content: "\\f300";
}
.fa-plus-octagon:before {
  content: "\\f301";
}
.fa-plus-square:before {
  content: "\\f0fe";
}
.fa-podcast:before {
  content: "\\f2ce";
}
.fa-podium:before {
  content: "\\f680";
}
.fa-podium-star:before {
  content: "\\f758";
}
.fa-police-box:before {
  content: "\uF921";
}
.fa-poll:before {
  content: "\\f681";
}
.fa-poll-h:before {
  content: "\\f682";
}
.fa-poll-people:before {
  content: "\\f759";
}
.fa-poo:before {
  content: "\\f2fe";
}
.fa-poo-storm:before {
  content: "\\f75a";
}
.fa-poop:before {
  content: "\\f619";
}
.fa-popcorn:before {
  content: "\\f819";
}
.fa-portal-enter:before {
  content: "\uF922";
}
.fa-portal-exit:before {
  content: "\uF923";
}
.fa-portrait:before {
  content: "\\f3e0";
}
.fa-pound-sign:before {
  content: "\\f154";
}
.fa-power-off:before {
  content: "\\f011";
}
.fa-pray:before {
  content: "\\f683";
}
.fa-praying-hands:before {
  content: "\\f684";
}
.fa-prescription:before {
  content: "\\f5b1";
}
.fa-prescription-bottle:before {
  content: "\\f485";
}
.fa-prescription-bottle-alt:before {
  content: "\\f486";
}
.fa-presentation:before {
  content: "\\f685";
}
.fa-print:before {
  content: "\\f02f";
}
.fa-print-search:before {
  content: "\\f81a";
}
.fa-print-slash:before {
  content: "\\f686";
}
.fa-procedures:before {
  content: "\\f487";
}
.fa-product-hunt:before {
  content: "\\f288";
}
.fa-project-diagram:before {
  content: "\\f542";
}
.fa-projector:before {
  content: "\\f8d6";
}
.fa-pump-medical:before {
  content: "\uF96A";
}
.fa-pump-soap:before {
  content: "\uF96B";
}
.fa-pumpkin:before {
  content: "\\f707";
}
.fa-pushed:before {
  content: "\\f3e1";
}
.fa-puzzle-piece:before {
  content: "\\f12e";
}
.fa-python:before {
  content: "\\f3e2";
}
.fa-qq:before {
  content: "\\f1d6";
}
.fa-qrcode:before {
  content: "\\f029";
}
.fa-question:before {
  content: "\\f128";
}
.fa-question-circle:before {
  content: "\\f059";
}
.fa-question-square:before {
  content: "\\f2fd";
}
.fa-quidditch:before {
  content: "\\f458";
}
.fa-quinscape:before {
  content: "\\f459";
}
.fa-quora:before {
  content: "\\f2c4";
}
.fa-quote-left:before {
  content: "\\f10d";
}
.fa-quote-right:before {
  content: "\\f10e";
}
.fa-quran:before {
  content: "\\f687";
}
.fa-r-project:before {
  content: "\\f4f7";
}
.fa-rabbit:before {
  content: "\\f708";
}
.fa-rabbit-fast:before {
  content: "\\f709";
}
.fa-racquet:before {
  content: "\\f45a";
}
.fa-radar:before {
  content: "\uF924";
}
.fa-radiation:before {
  content: "\\f7b9";
}
.fa-radiation-alt:before {
  content: "\\f7ba";
}
.fa-radio:before {
  content: "\\f8d7";
}
.fa-radio-alt:before {
  content: "\\f8d8";
}
.fa-rainbow:before {
  content: "\\f75b";
}
.fa-raindrops:before {
  content: "\\f75c";
}
.fa-ram:before {
  content: "\\f70a";
}
.fa-ramp-loading:before {
  content: "\\f4d4";
}
.fa-random:before {
  content: "\\f074";
}
.fa-raspberry-pi:before {
  content: "\\f7bb";
}
.fa-ravelry:before {
  content: "\\f2d9";
}
.fa-raygun:before {
  content: "\uF925";
}
.fa-react:before {
  content: "\\f41b";
}
.fa-reacteurope:before {
  content: "\\f75d";
}
.fa-readme:before {
  content: "\\f4d5";
}
.fa-rebel:before {
  content: "\\f1d0";
}
.fa-receipt:before {
  content: "\\f543";
}
.fa-record-vinyl:before {
  content: "\\f8d9";
}
.fa-rectangle-landscape:before {
  content: "\\f2fa";
}
.fa-rectangle-portrait:before {
  content: "\\f2fb";
}
.fa-rectangle-wide:before {
  content: "\\f2fc";
}
.fa-recycle:before {
  content: "\\f1b8";
}
.fa-red-river:before {
  content: "\\f3e3";
}
.fa-reddit:before {
  content: "\\f1a1";
}
.fa-reddit-alien:before {
  content: "\\f281";
}
.fa-reddit-square:before {
  content: "\\f1a2";
}
.fa-redhat:before {
  content: "\\f7bc";
}
.fa-redo:before {
  content: "\\f01e";
}
.fa-redo-alt:before {
  content: "\\f2f9";
}
.fa-refrigerator:before {
  content: "\uF926";
}
.fa-registered:before {
  content: "\\f25d";
}
.fa-remove-format:before {
  content: "\\f87d";
}
.fa-renren:before {
  content: "\\f18b";
}
.fa-repeat:before {
  content: "\\f363";
}
.fa-repeat-1:before {
  content: "\\f365";
}
.fa-repeat-1-alt:before {
  content: "\\f366";
}
.fa-repeat-alt:before {
  content: "\\f364";
}
.fa-reply:before {
  content: "\\f3e5";
}
.fa-reply-all:before {
  content: "\\f122";
}
.fa-replyd:before {
  content: "\\f3e6";
}
.fa-republican:before {
  content: "\\f75e";
}
.fa-researchgate:before {
  content: "\\f4f8";
}
.fa-resolving:before {
  content: "\\f3e7";
}
.fa-restroom:before {
  content: "\\f7bd";
}
.fa-retweet:before {
  content: "\\f079";
}
.fa-retweet-alt:before {
  content: "\\f361";
}
.fa-rev:before {
  content: "\\f5b2";
}
.fa-ribbon:before {
  content: "\\f4d6";
}
.fa-ring:before {
  content: "\\f70b";
}
.fa-rings-wedding:before {
  content: "\\f81b";
}
.fa-road:before {
  content: "\\f018";
}
.fa-robot:before {
  content: "\\f544";
}
.fa-rocket:before {
  content: "\\f135";
}
.fa-rocket-launch:before {
  content: "\uF927";
}
.fa-rocketchat:before {
  content: "\\f3e8";
}
.fa-rockrms:before {
  content: "\\f3e9";
}
.fa-route:before {
  content: "\\f4d7";
}
.fa-route-highway:before {
  content: "\\f61a";
}
.fa-route-interstate:before {
  content: "\\f61b";
}
.fa-router:before {
  content: "\\f8da";
}
.fa-rss:before {
  content: "\\f09e";
}
.fa-rss-square:before {
  content: "\\f143";
}
.fa-ruble-sign:before {
  content: "\\f158";
}
.fa-ruler:before {
  content: "\\f545";
}
.fa-ruler-combined:before {
  content: "\\f546";
}
.fa-ruler-horizontal:before {
  content: "\\f547";
}
.fa-ruler-triangle:before {
  content: "\\f61c";
}
.fa-ruler-vertical:before {
  content: "\\f548";
}
.fa-running:before {
  content: "\\f70c";
}
.fa-rupee-sign:before {
  content: "\\f156";
}
.fa-rv:before {
  content: "\\f7be";
}
.fa-sack:before {
  content: "\\f81c";
}
.fa-sack-dollar:before {
  content: "\\f81d";
}
.fa-sad-cry:before {
  content: "\\f5b3";
}
.fa-sad-tear:before {
  content: "\\f5b4";
}
.fa-safari:before {
  content: "\\f267";
}
.fa-salad:before {
  content: "\\f81e";
}
.fa-salesforce:before {
  content: "\\f83b";
}
.fa-sandwich:before {
  content: "\\f81f";
}
.fa-sass:before {
  content: "\\f41e";
}
.fa-satellite:before {
  content: "\\f7bf";
}
.fa-satellite-dish:before {
  content: "\\f7c0";
}
.fa-sausage:before {
  content: "\\f820";
}
.fa-save:before {
  content: "\\f0c7";
}
.fa-sax-hot:before {
  content: "\\f8db";
}
.fa-saxophone:before {
  content: "\\f8dc";
}
.fa-scalpel:before {
  content: "\\f61d";
}
.fa-scalpel-path:before {
  content: "\\f61e";
}
.fa-scanner:before {
  content: "\\f488";
}
.fa-scanner-image:before {
  content: "\\f8f3";
}
.fa-scanner-keyboard:before {
  content: "\\f489";
}
.fa-scanner-touchscreen:before {
  content: "\\f48a";
}
.fa-scarecrow:before {
  content: "\\f70d";
}
.fa-scarf:before {
  content: "\\f7c1";
}
.fa-schlix:before {
  content: "\\f3ea";
}
.fa-school:before {
  content: "\\f549";
}
.fa-screwdriver:before {
  content: "\\f54a";
}
.fa-scribd:before {
  content: "\\f28a";
}
.fa-scroll:before {
  content: "\\f70e";
}
.fa-scroll-old:before {
  content: "\\f70f";
}
.fa-scrubber:before {
  content: "\\f2f8";
}
.fa-scythe:before {
  content: "\\f710";
}
.fa-sd-card:before {
  content: "\\f7c2";
}
.fa-search:before {
  content: "\\f002";
}
.fa-search-dollar:before {
  content: "\\f688";
}
.fa-search-location:before {
  content: "\\f689";
}
.fa-search-minus:before {
  content: "\\f010";
}
.fa-search-plus:before {
  content: "\\f00e";
}
.fa-searchengin:before {
  content: "\\f3eb";
}
.fa-seedling:before {
  content: "\\f4d8";
}
.fa-sellcast:before {
  content: "\\f2da";
}
.fa-sellsy:before {
  content: "\\f213";
}
.fa-send-back:before {
  content: "\\f87e";
}
.fa-send-backward:before {
  content: "\\f87f";
}
.fa-sensor:before {
  content: "\uF928";
}
.fa-sensor-alert:before {
  content: "\uF929";
}
.fa-sensor-fire:before {
  content: "\uF92A";
}
.fa-sensor-on:before {
  content: "\uF92B";
}
.fa-sensor-smoke:before {
  content: "\uF92C";
}
.fa-server:before {
  content: "\\f233";
}
.fa-servicestack:before {
  content: "\\f3ec";
}
.fa-shapes:before {
  content: "\\f61f";
}
.fa-share:before {
  content: "\\f064";
}
.fa-share-all:before {
  content: "\\f367";
}
.fa-share-alt:before {
  content: "\\f1e0";
}
.fa-share-alt-square:before {
  content: "\\f1e1";
}
.fa-share-square:before {
  content: "\\f14d";
}
.fa-sheep:before {
  content: "\\f711";
}
.fa-shekel-sign:before {
  content: "\\f20b";
}
.fa-shield:before {
  content: "\\f132";
}
.fa-shield-alt:before {
  content: "\\f3ed";
}
.fa-shield-check:before {
  content: "\\f2f7";
}
.fa-shield-cross:before {
  content: "\\f712";
}
.fa-shield-virus:before {
  content: "\uF96C";
}
.fa-ship:before {
  content: "\\f21a";
}
.fa-shipping-fast:before {
  content: "\\f48b";
}
.fa-shipping-timed:before {
  content: "\\f48c";
}
.fa-shirtsinbulk:before {
  content: "\\f214";
}
.fa-shish-kebab:before {
  content: "\\f821";
}
.fa-shoe-prints:before {
  content: "\\f54b";
}
.fa-shopify:before {
  content: "\uF957";
}
.fa-shopping-bag:before {
  content: "\\f290";
}
.fa-shopping-basket:before {
  content: "\\f291";
}
.fa-shopping-cart:before {
  content: "\\f07a";
}
.fa-shopware:before {
  content: "\\f5b5";
}
.fa-shovel:before {
  content: "\\f713";
}
.fa-shovel-snow:before {
  content: "\\f7c3";
}
.fa-shower:before {
  content: "\\f2cc";
}
.fa-shredder:before {
  content: "\\f68a";
}
.fa-shuttle-van:before {
  content: "\\f5b6";
}
.fa-shuttlecock:before {
  content: "\\f45b";
}
.fa-sickle:before {
  content: "\\f822";
}
.fa-sigma:before {
  content: "\\f68b";
}
.fa-sign:before {
  content: "\\f4d9";
}
.fa-sign-in:before {
  content: "\\f090";
}
.fa-sign-in-alt:before {
  content: "\\f2f6";
}
.fa-sign-language:before {
  content: "\\f2a7";
}
.fa-sign-out:before {
  content: "\\f08b";
}
.fa-sign-out-alt:before {
  content: "\\f2f5";
}
.fa-signal:before {
  content: "\\f012";
}
.fa-signal-1:before {
  content: "\\f68c";
}
.fa-signal-2:before {
  content: "\\f68d";
}
.fa-signal-3:before {
  content: "\\f68e";
}
.fa-signal-4:before {
  content: "\\f68f";
}
.fa-signal-alt:before {
  content: "\\f690";
}
.fa-signal-alt-1:before {
  content: "\\f691";
}
.fa-signal-alt-2:before {
  content: "\\f692";
}
.fa-signal-alt-3:before {
  content: "\\f693";
}
.fa-signal-alt-slash:before {
  content: "\\f694";
}
.fa-signal-slash:before {
  content: "\\f695";
}
.fa-signal-stream:before {
  content: "\\f8dd";
}
.fa-signature:before {
  content: "\\f5b7";
}
.fa-sim-card:before {
  content: "\\f7c4";
}
.fa-simplybuilt:before {
  content: "\\f215";
}
.fa-sink:before {
  content: "\uF96D";
}
.fa-siren:before {
  content: "\uF92D";
}
.fa-siren-on:before {
  content: "\uF92E";
}
.fa-sistrix:before {
  content: "\\f3ee";
}
.fa-sitemap:before {
  content: "\\f0e8";
}
.fa-sith:before {
  content: "\\f512";
}
.fa-skating:before {
  content: "\\f7c5";
}
.fa-skeleton:before {
  content: "\\f620";
}
.fa-sketch:before {
  content: "\\f7c6";
}
.fa-ski-jump:before {
  content: "\\f7c7";
}
.fa-ski-lift:before {
  content: "\\f7c8";
}
.fa-skiing:before {
  content: "\\f7c9";
}
.fa-skiing-nordic:before {
  content: "\\f7ca";
}
.fa-skull:before {
  content: "\\f54c";
}
.fa-skull-cow:before {
  content: "\\f8de";
}
.fa-skull-crossbones:before {
  content: "\\f714";
}
.fa-skyatlas:before {
  content: "\\f216";
}
.fa-skype:before {
  content: "\\f17e";
}
.fa-slack:before {
  content: "\\f198";
}
.fa-slack-hash:before {
  content: "\\f3ef";
}
.fa-slash:before {
  content: "\\f715";
}
.fa-sledding:before {
  content: "\\f7cb";
}
.fa-sleigh:before {
  content: "\\f7cc";
}
.fa-sliders-h:before {
  content: "\\f1de";
}
.fa-sliders-h-square:before {
  content: "\\f3f0";
}
.fa-sliders-v:before {
  content: "\\f3f1";
}
.fa-sliders-v-square:before {
  content: "\\f3f2";
}
.fa-slideshare:before {
  content: "\\f1e7";
}
.fa-smile:before {
  content: "\\f118";
}
.fa-smile-beam:before {
  content: "\\f5b8";
}
.fa-smile-plus:before {
  content: "\\f5b9";
}
.fa-smile-wink:before {
  content: "\\f4da";
}
.fa-smog:before {
  content: "\\f75f";
}
.fa-smoke:before {
  content: "\\f760";
}
.fa-smoking:before {
  content: "\\f48d";
}
.fa-smoking-ban:before {
  content: "\\f54d";
}
.fa-sms:before {
  content: "\\f7cd";
}
.fa-snake:before {
  content: "\\f716";
}
.fa-snapchat:before {
  content: "\\f2ab";
}
.fa-snapchat-ghost:before {
  content: "\\f2ac";
}
.fa-snapchat-square:before {
  content: "\\f2ad";
}
.fa-snooze:before {
  content: "\\f880";
}
.fa-snow-blowing:before {
  content: "\\f761";
}
.fa-snowboarding:before {
  content: "\\f7ce";
}
.fa-snowflake:before {
  content: "\\f2dc";
}
.fa-snowflakes:before {
  content: "\\f7cf";
}
.fa-snowman:before {
  content: "\\f7d0";
}
.fa-snowmobile:before {
  content: "\\f7d1";
}
.fa-snowplow:before {
  content: "\\f7d2";
}
.fa-soap:before {
  content: "\uF96E";
}
.fa-socks:before {
  content: "\\f696";
}
.fa-solar-panel:before {
  content: "\\f5ba";
}
.fa-solar-system:before {
  content: "\uF92F";
}
.fa-sort:before {
  content: "\\f0dc";
}
.fa-sort-alpha-down:before {
  content: "\\f15d";
}
.fa-sort-alpha-down-alt:before {
  content: "\\f881";
}
.fa-sort-alpha-up:before {
  content: "\\f15e";
}
.fa-sort-alpha-up-alt:before {
  content: "\\f882";
}
.fa-sort-alt:before {
  content: "\\f883";
}
.fa-sort-amount-down:before {
  content: "\\f160";
}
.fa-sort-amount-down-alt:before {
  content: "\\f884";
}
.fa-sort-amount-up:before {
  content: "\\f161";
}
.fa-sort-amount-up-alt:before {
  content: "\\f885";
}
.fa-sort-circle:before {
  content: "\uF930";
}
.fa-sort-circle-down:before {
  content: "\uF931";
}
.fa-sort-circle-up:before {
  content: "\uF932";
}
.fa-sort-down:before {
  content: "\\f0dd";
}
.fa-sort-numeric-down:before {
  content: "\\f162";
}
.fa-sort-numeric-down-alt:before {
  content: "\\f886";
}
.fa-sort-numeric-up:before {
  content: "\\f163";
}
.fa-sort-numeric-up-alt:before {
  content: "\\f887";
}
.fa-sort-shapes-down:before {
  content: "\\f888";
}
.fa-sort-shapes-down-alt:before {
  content: "\\f889";
}
.fa-sort-shapes-up:before {
  content: "\\f88a";
}
.fa-sort-shapes-up-alt:before {
  content: "\\f88b";
}
.fa-sort-size-down:before {
  content: "\\f88c";
}
.fa-sort-size-down-alt:before {
  content: "\\f88d";
}
.fa-sort-size-up:before {
  content: "\\f88e";
}
.fa-sort-size-up-alt:before {
  content: "\\f88f";
}
.fa-sort-up:before {
  content: "\\f0de";
}
.fa-soundcloud:before {
  content: "\\f1be";
}
.fa-soup:before {
  content: "\\f823";
}
.fa-sourcetree:before {
  content: "\\f7d3";
}
.fa-spa:before {
  content: "\\f5bb";
}
.fa-space-shuttle:before {
  content: "\\f197";
}
.fa-space-station-moon:before {
  content: "\uF933";
}
.fa-space-station-moon-alt:before {
  content: "\uF934";
}
.fa-spade:before {
  content: "\\f2f4";
}
.fa-sparkles:before {
  content: "\\f890";
}
.fa-speakap:before {
  content: "\\f3f3";
}
.fa-speaker:before {
  content: "\\f8df";
}
.fa-speaker-deck:before {
  content: "\\f83c";
}
.fa-speakers:before {
  content: "\\f8e0";
}
.fa-spell-check:before {
  content: "\\f891";
}
.fa-spider:before {
  content: "\\f717";
}
.fa-spider-black-widow:before {
  content: "\\f718";
}
.fa-spider-web:before {
  content: "\\f719";
}
.fa-spinner:before {
  content: "\\f110";
}
.fa-spinner-third:before {
  content: "\\f3f4";
}
.fa-splotch:before {
  content: "\\f5bc";
}
.fa-spotify:before {
  content: "\\f1bc";
}
.fa-spray-can:before {
  content: "\\f5bd";
}
.fa-sprinkler:before {
  content: "\uF935";
}
.fa-square:before {
  content: "\\f0c8";
}
.fa-square-full:before {
  content: "\\f45c";
}
.fa-square-root:before {
  content: "\\f697";
}
.fa-square-root-alt:before {
  content: "\\f698";
}
.fa-squarespace:before {
  content: "\\f5be";
}
.fa-squirrel:before {
  content: "\\f71a";
}
.fa-stack-exchange:before {
  content: "\\f18d";
}
.fa-stack-overflow:before {
  content: "\\f16c";
}
.fa-stackpath:before {
  content: "\\f842";
}
.fa-staff:before {
  content: "\\f71b";
}
.fa-stamp:before {
  content: "\\f5bf";
}
.fa-star:before {
  content: "\\f005";
}
.fa-star-and-crescent:before {
  content: "\\f699";
}
.fa-star-christmas:before {
  content: "\\f7d4";
}
.fa-star-exclamation:before {
  content: "\\f2f3";
}
.fa-star-half:before {
  content: "\\f089";
}
.fa-star-half-alt:before {
  content: "\\f5c0";
}
.fa-star-of-david:before {
  content: "\\f69a";
}
.fa-star-of-life:before {
  content: "\\f621";
}
.fa-star-shooting:before {
  content: "\uF936";
}
.fa-starfighter:before {
  content: "\uF937";
}
.fa-starfighter-alt:before {
  content: "\uF938";
}
.fa-stars:before {
  content: "\\f762";
}
.fa-starship:before {
  content: "\uF939";
}
.fa-starship-freighter:before {
  content: "\uF93A";
}
.fa-staylinked:before {
  content: "\\f3f5";
}
.fa-steak:before {
  content: "\\f824";
}
.fa-steam:before {
  content: "\\f1b6";
}
.fa-steam-square:before {
  content: "\\f1b7";
}
.fa-steam-symbol:before {
  content: "\\f3f6";
}
.fa-steering-wheel:before {
  content: "\\f622";
}
.fa-step-backward:before {
  content: "\\f048";
}
.fa-step-forward:before {
  content: "\\f051";
}
.fa-stethoscope:before {
  content: "\\f0f1";
}
.fa-sticker-mule:before {
  content: "\\f3f7";
}
.fa-sticky-note:before {
  content: "\\f249";
}
.fa-stocking:before {
  content: "\\f7d5";
}
.fa-stomach:before {
  content: "\\f623";
}
.fa-stop:before {
  content: "\\f04d";
}
.fa-stop-circle:before {
  content: "\\f28d";
}
.fa-stopwatch:before {
  content: "\\f2f2";
}
.fa-stopwatch-20:before {
  content: "\uF96F";
}
.fa-store:before {
  content: "\\f54e";
}
.fa-store-alt:before {
  content: "\\f54f";
}
.fa-store-alt-slash:before {
  content: "\uF970";
}
.fa-store-slash:before {
  content: "\uF971";
}
.fa-strava:before {
  content: "\\f428";
}
.fa-stream:before {
  content: "\\f550";
}
.fa-street-view:before {
  content: "\\f21d";
}
.fa-stretcher:before {
  content: "\\f825";
}
.fa-strikethrough:before {
  content: "\\f0cc";
}
.fa-stripe:before {
  content: "\\f429";
}
.fa-stripe-s:before {
  content: "\\f42a";
}
.fa-stroopwafel:before {
  content: "\\f551";
}
.fa-studiovinari:before {
  content: "\\f3f8";
}
.fa-stumbleupon:before {
  content: "\\f1a4";
}
.fa-stumbleupon-circle:before {
  content: "\\f1a3";
}
.fa-subscript:before {
  content: "\\f12c";
}
.fa-subway:before {
  content: "\\f239";
}
.fa-suitcase:before {
  content: "\\f0f2";
}
.fa-suitcase-rolling:before {
  content: "\\f5c1";
}
.fa-sun:before {
  content: "\\f185";
}
.fa-sun-cloud:before {
  content: "\\f763";
}
.fa-sun-dust:before {
  content: "\\f764";
}
.fa-sun-haze:before {
  content: "\\f765";
}
.fa-sunglasses:before {
  content: "\\f892";
}
.fa-sunrise:before {
  content: "\\f766";
}
.fa-sunset:before {
  content: "\\f767";
}
.fa-superpowers:before {
  content: "\\f2dd";
}
.fa-superscript:before {
  content: "\\f12b";
}
.fa-supple:before {
  content: "\\f3f9";
}
.fa-surprise:before {
  content: "\\f5c2";
}
.fa-suse:before {
  content: "\\f7d6";
}
.fa-swatchbook:before {
  content: "\\f5c3";
}
.fa-swift:before {
  content: "\\f8e1";
}
.fa-swimmer:before {
  content: "\\f5c4";
}
.fa-swimming-pool:before {
  content: "\\f5c5";
}
.fa-sword:before {
  content: "\\f71c";
}
.fa-sword-laser:before {
  content: "\uF93B";
}
.fa-sword-laser-alt:before {
  content: "\uF93C";
}
.fa-swords:before {
  content: "\\f71d";
}
.fa-swords-laser:before {
  content: "\uF93D";
}
.fa-symfony:before {
  content: "\\f83d";
}
.fa-synagogue:before {
  content: "\\f69b";
}
.fa-sync:before {
  content: "\\f021";
}
.fa-sync-alt:before {
  content: "\\f2f1";
}
.fa-syringe:before {
  content: "\\f48e";
}
.fa-table:before {
  content: "\\f0ce";
}
.fa-table-tennis:before {
  content: "\\f45d";
}
.fa-tablet:before {
  content: "\\f10a";
}
.fa-tablet-alt:before {
  content: "\\f3fa";
}
.fa-tablet-android:before {
  content: "\\f3fb";
}
.fa-tablet-android-alt:before {
  content: "\\f3fc";
}
.fa-tablet-rugged:before {
  content: "\\f48f";
}
.fa-tablets:before {
  content: "\\f490";
}
.fa-tachometer:before {
  content: "\\f0e4";
}
.fa-tachometer-alt:before {
  content: "\\f3fd";
}
.fa-tachometer-alt-average:before {
  content: "\\f624";
}
.fa-tachometer-alt-fast:before {
  content: "\\f625";
}
.fa-tachometer-alt-fastest:before {
  content: "\\f626";
}
.fa-tachometer-alt-slow:before {
  content: "\\f627";
}
.fa-tachometer-alt-slowest:before {
  content: "\\f628";
}
.fa-tachometer-average:before {
  content: "\\f629";
}
.fa-tachometer-fast:before {
  content: "\\f62a";
}
.fa-tachometer-fastest:before {
  content: "\\f62b";
}
.fa-tachometer-slow:before {
  content: "\\f62c";
}
.fa-tachometer-slowest:before {
  content: "\\f62d";
}
.fa-taco:before {
  content: "\\f826";
}
.fa-tag:before {
  content: "\\f02b";
}
.fa-tags:before {
  content: "\\f02c";
}
.fa-tally:before {
  content: "\\f69c";
}
.fa-tanakh:before {
  content: "\\f827";
}
.fa-tape:before {
  content: "\\f4db";
}
.fa-tasks:before {
  content: "\\f0ae";
}
.fa-tasks-alt:before {
  content: "\\f828";
}
.fa-taxi:before {
  content: "\\f1ba";
}
.fa-teamspeak:before {
  content: "\\f4f9";
}
.fa-teeth:before {
  content: "\\f62e";
}
.fa-teeth-open:before {
  content: "\\f62f";
}
.fa-telegram:before {
  content: "\\f2c6";
}
.fa-telegram-plane:before {
  content: "\\f3fe";
}
.fa-telescope:before {
  content: "\uF93E";
}
.fa-temperature-down:before {
  content: "\uF93F";
}
.fa-temperature-frigid:before {
  content: "\\f768";
}
.fa-temperature-high:before {
  content: "\\f769";
}
.fa-temperature-hot:before {
  content: "\\f76a";
}
.fa-temperature-low:before {
  content: "\\f76b";
}
.fa-temperature-up:before {
  content: "\uF940";
}
.fa-tencent-weibo:before {
  content: "\\f1d5";
}
.fa-tenge:before {
  content: "\\f7d7";
}
.fa-tennis-ball:before {
  content: "\\f45e";
}
.fa-terminal:before {
  content: "\\f120";
}
.fa-text:before {
  content: "\\f893";
}
.fa-text-height:before {
  content: "\\f034";
}
.fa-text-size:before {
  content: "\\f894";
}
.fa-text-width:before {
  content: "\\f035";
}
.fa-th:before {
  content: "\\f00a";
}
.fa-th-large:before {
  content: "\\f009";
}
.fa-th-list:before {
  content: "\\f00b";
}
.fa-the-red-yeti:before {
  content: "\\f69d";
}
.fa-theater-masks:before {
  content: "\\f630";
}
.fa-themeco:before {
  content: "\\f5c6";
}
.fa-themeisle:before {
  content: "\\f2b2";
}
.fa-thermometer:before {
  content: "\\f491";
}
.fa-thermometer-empty:before {
  content: "\\f2cb";
}
.fa-thermometer-full:before {
  content: "\\f2c7";
}
.fa-thermometer-half:before {
  content: "\\f2c9";
}
.fa-thermometer-quarter:before {
  content: "\\f2ca";
}
.fa-thermometer-three-quarters:before {
  content: "\\f2c8";
}
.fa-theta:before {
  content: "\\f69e";
}
.fa-think-peaks:before {
  content: "\\f731";
}
.fa-thumbs-down:before {
  content: "\\f165";
}
.fa-thumbs-up:before {
  content: "\\f164";
}
.fa-thumbtack:before {
  content: "\\f08d";
}
.fa-thunderstorm:before {
  content: "\\f76c";
}
.fa-thunderstorm-moon:before {
  content: "\\f76d";
}
.fa-thunderstorm-sun:before {
  content: "\\f76e";
}
.fa-ticket:before {
  content: "\\f145";
}
.fa-ticket-alt:before {
  content: "\\f3ff";
}
.fa-tilde:before {
  content: "\\f69f";
}
.fa-times:before {
  content: "\\f00d";
}
.fa-times-circle:before {
  content: "\\f057";
}
.fa-times-hexagon:before {
  content: "\\f2ee";
}
.fa-times-octagon:before {
  content: "\\f2f0";
}
.fa-times-square:before {
  content: "\\f2d3";
}
.fa-tint:before {
  content: "\\f043";
}
.fa-tint-slash:before {
  content: "\\f5c7";
}
.fa-tire:before {
  content: "\\f631";
}
.fa-tire-flat:before {
  content: "\\f632";
}
.fa-tire-pressure-warning:before {
  content: "\\f633";
}
.fa-tire-rugged:before {
  content: "\\f634";
}
.fa-tired:before {
  content: "\\f5c8";
}
.fa-toggle-off:before {
  content: "\\f204";
}
.fa-toggle-on:before {
  content: "\\f205";
}
.fa-toilet:before {
  content: "\\f7d8";
}
.fa-toilet-paper:before {
  content: "\\f71e";
}
.fa-toilet-paper-alt:before {
  content: "\\f71f";
}
.fa-toilet-paper-slash:before {
  content: "\uF972";
}
.fa-tombstone:before {
  content: "\\f720";
}
.fa-tombstone-alt:before {
  content: "\\f721";
}
.fa-toolbox:before {
  content: "\\f552";
}
.fa-tools:before {
  content: "\\f7d9";
}
.fa-tooth:before {
  content: "\\f5c9";
}
.fa-toothbrush:before {
  content: "\\f635";
}
.fa-torah:before {
  content: "\\f6a0";
}
.fa-torii-gate:before {
  content: "\\f6a1";
}
.fa-tornado:before {
  content: "\\f76f";
}
.fa-tractor:before {
  content: "\\f722";
}
.fa-trade-federation:before {
  content: "\\f513";
}
.fa-trademark:before {
  content: "\\f25c";
}
.fa-traffic-cone:before {
  content: "\\f636";
}
.fa-traffic-light:before {
  content: "\\f637";
}
.fa-traffic-light-go:before {
  content: "\\f638";
}
.fa-traffic-light-slow:before {
  content: "\\f639";
}
.fa-traffic-light-stop:before {
  content: "\\f63a";
}
.fa-trailer:before {
  content: "\uF941";
}
.fa-train:before {
  content: "\\f238";
}
.fa-tram:before {
  content: "\\f7da";
}
.fa-transgender:before {
  content: "\\f224";
}
.fa-transgender-alt:before {
  content: "\\f225";
}
.fa-transporter:before {
  content: "\uF942";
}
.fa-transporter-1:before {
  content: "\uF943";
}
.fa-transporter-2:before {
  content: "\uF944";
}
.fa-transporter-3:before {
  content: "\uF945";
}
.fa-transporter-empty:before {
  content: "\uF946";
}
.fa-trash:before {
  content: "\\f1f8";
}
.fa-trash-alt:before {
  content: "\\f2ed";
}
.fa-trash-restore:before {
  content: "\\f829";
}
.fa-trash-restore-alt:before {
  content: "\\f82a";
}
.fa-trash-undo:before {
  content: "\\f895";
}
.fa-trash-undo-alt:before {
  content: "\\f896";
}
.fa-treasure-chest:before {
  content: "\\f723";
}
.fa-tree:before {
  content: "\\f1bb";
}
.fa-tree-alt:before {
  content: "\\f400";
}
.fa-tree-christmas:before {
  content: "\\f7db";
}
.fa-tree-decorated:before {
  content: "\\f7dc";
}
.fa-tree-large:before {
  content: "\\f7dd";
}
.fa-tree-palm:before {
  content: "\\f82b";
}
.fa-trees:before {
  content: "\\f724";
}
.fa-trello:before {
  content: "\\f181";
}
.fa-triangle:before {
  content: "\\f2ec";
}
.fa-triangle-music:before {
  content: "\\f8e2";
}
.fa-tripadvisor:before {
  content: "\\f262";
}
.fa-trophy:before {
  content: "\\f091";
}
.fa-trophy-alt:before {
  content: "\\f2eb";
}
.fa-truck:before {
  content: "\\f0d1";
}
.fa-truck-container:before {
  content: "\\f4dc";
}
.fa-truck-couch:before {
  content: "\\f4dd";
}
.fa-truck-loading:before {
  content: "\\f4de";
}
.fa-truck-monster:before {
  content: "\\f63b";
}
.fa-truck-moving:before {
  content: "\\f4df";
}
.fa-truck-pickup:before {
  content: "\\f63c";
}
.fa-truck-plow:before {
  content: "\\f7de";
}
.fa-truck-ramp:before {
  content: "\\f4e0";
}
.fa-trumpet:before {
  content: "\\f8e3";
}
.fa-tshirt:before {
  content: "\\f553";
}
.fa-tty:before {
  content: "\\f1e4";
}
.fa-tumblr:before {
  content: "\\f173";
}
.fa-tumblr-square:before {
  content: "\\f174";
}
.fa-turkey:before {
  content: "\\f725";
}
.fa-turntable:before {
  content: "\\f8e4";
}
.fa-turtle:before {
  content: "\\f726";
}
.fa-tv:before {
  content: "\\f26c";
}
.fa-tv-alt:before {
  content: "\\f8e5";
}
.fa-tv-music:before {
  content: "\\f8e6";
}
.fa-tv-retro:before {
  content: "\\f401";
}
.fa-twitch:before {
  content: "\\f1e8";
}
.fa-twitter:before {
  content: "\\f099";
}
.fa-twitter-square:before {
  content: "\\f081";
}
.fa-typewriter:before {
  content: "\\f8e7";
}
.fa-typo3:before {
  content: "\\f42b";
}
.fa-uber:before {
  content: "\\f402";
}
.fa-ubuntu:before {
  content: "\\f7df";
}
.fa-ufo:before {
  content: "\uF947";
}
.fa-ufo-beam:before {
  content: "\uF948";
}
.fa-uikit:before {
  content: "\\f403";
}
.fa-umbraco:before {
  content: "\\f8e8";
}
.fa-umbrella:before {
  content: "\\f0e9";
}
.fa-umbrella-beach:before {
  content: "\\f5ca";
}
.fa-underline:before {
  content: "\\f0cd";
}
.fa-undo:before {
  content: "\\f0e2";
}
.fa-undo-alt:before {
  content: "\\f2ea";
}
.fa-unicorn:before {
  content: "\\f727";
}
.fa-union:before {
  content: "\\f6a2";
}
.fa-uniregistry:before {
  content: "\\f404";
}
.fa-unity:before {
  content: "\uF949";
}
.fa-universal-access:before {
  content: "\\f29a";
}
.fa-university:before {
  content: "\\f19c";
}
.fa-unlink:before {
  content: "\\f127";
}
.fa-unlock:before {
  content: "\\f09c";
}
.fa-unlock-alt:before {
  content: "\\f13e";
}
.fa-untappd:before {
  content: "\\f405";
}
.fa-upload:before {
  content: "\\f093";
}
.fa-ups:before {
  content: "\\f7e0";
}
.fa-usb:before {
  content: "\\f287";
}
.fa-usb-drive:before {
  content: "\\f8e9";
}
.fa-usd-circle:before {
  content: "\\f2e8";
}
.fa-usd-square:before {
  content: "\\f2e9";
}
.fa-user:before {
  content: "\\f007";
}
.fa-user-alien:before {
  content: "\uF94A";
}
.fa-user-alt:before {
  content: "\\f406";
}
.fa-user-alt-slash:before {
  content: "\\f4fa";
}
.fa-user-astronaut:before {
  content: "\\f4fb";
}
.fa-user-chart:before {
  content: "\\f6a3";
}
.fa-user-check:before {
  content: "\\f4fc";
}
.fa-user-circle:before {
  content: "\\f2bd";
}
.fa-user-clock:before {
  content: "\\f4fd";
}
.fa-user-cog:before {
  content: "\\f4fe";
}
.fa-user-cowboy:before {
  content: "\\f8ea";
}
.fa-user-crown:before {
  content: "\\f6a4";
}
.fa-user-edit:before {
  content: "\\f4ff";
}
.fa-user-friends:before {
  content: "\\f500";
}
.fa-user-graduate:before {
  content: "\\f501";
}
.fa-user-hard-hat:before {
  content: "\\f82c";
}
.fa-user-headset:before {
  content: "\\f82d";
}
.fa-user-injured:before {
  content: "\\f728";
}
.fa-user-lock:before {
  content: "\\f502";
}
.fa-user-md:before {
  content: "\\f0f0";
}
.fa-user-md-chat:before {
  content: "\\f82e";
}
.fa-user-minus:before {
  content: "\\f503";
}
.fa-user-music:before {
  content: "\\f8eb";
}
.fa-user-ninja:before {
  content: "\\f504";
}
.fa-user-nurse:before {
  content: "\\f82f";
}
.fa-user-plus:before {
  content: "\\f234";
}
.fa-user-robot:before {
  content: "\uF94B";
}
.fa-user-secret:before {
  content: "\\f21b";
}
.fa-user-shield:before {
  content: "\\f505";
}
.fa-user-slash:before {
  content: "\\f506";
}
.fa-user-tag:before {
  content: "\\f507";
}
.fa-user-tie:before {
  content: "\\f508";
}
.fa-user-times:before {
  content: "\\f235";
}
.fa-user-unlock:before {
  content: "\uF958";
}
.fa-user-visor:before {
  content: "\uF94C";
}
.fa-users:before {
  content: "\\f0c0";
}
.fa-users-class:before {
  content: "\\f63d";
}
.fa-users-cog:before {
  content: "\\f509";
}
.fa-users-crown:before {
  content: "\\f6a5";
}
.fa-users-medical:before {
  content: "\\f830";
}
.fa-users-slash:before {
  content: "\uF973";
}
.fa-usps:before {
  content: "\\f7e1";
}
.fa-ussunnah:before {
  content: "\\f407";
}
.fa-utensil-fork:before {
  content: "\\f2e3";
}
.fa-utensil-knife:before {
  content: "\\f2e4";
}
.fa-utensil-spoon:before {
  content: "\\f2e5";
}
.fa-utensils:before {
  content: "\\f2e7";
}
.fa-utensils-alt:before {
  content: "\\f2e6";
}
.fa-vaadin:before {
  content: "\\f408";
}
.fa-vacuum:before {
  content: "\uF94D";
}
.fa-vacuum-robot:before {
  content: "\uF94E";
}
.fa-value-absolute:before {
  content: "\\f6a6";
}
.fa-vector-square:before {
  content: "\\f5cb";
}
.fa-venus:before {
  content: "\\f221";
}
.fa-venus-double:before {
  content: "\\f226";
}
.fa-venus-mars:before {
  content: "\\f228";
}
.fa-vhs:before {
  content: "\\f8ec";
}
.fa-viacoin:before {
  content: "\\f237";
}
.fa-viadeo:before {
  content: "\\f2a9";
}
.fa-viadeo-square:before {
  content: "\\f2aa";
}
.fa-vial:before {
  content: "\\f492";
}
.fa-vials:before {
  content: "\\f493";
}
.fa-viber:before {
  content: "\\f409";
}
.fa-video:before {
  content: "\\f03d";
}
.fa-video-plus:before {
  content: "\\f4e1";
}
.fa-video-slash:before {
  content: "\\f4e2";
}
.fa-vihara:before {
  content: "\\f6a7";
}
.fa-vimeo:before {
  content: "\\f40a";
}
.fa-vimeo-square:before {
  content: "\\f194";
}
.fa-vimeo-v:before {
  content: "\\f27d";
}
.fa-vine:before {
  content: "\\f1ca";
}
.fa-violin:before {
  content: "\\f8ed";
}
.fa-virus:before {
  content: "\uF974";
}
.fa-virus-slash:before {
  content: "\uF975";
}
.fa-viruses:before {
  content: "\uF976";
}
.fa-vk:before {
  content: "\\f189";
}
.fa-vnv:before {
  content: "\\f40b";
}
.fa-voicemail:before {
  content: "\\f897";
}
.fa-volcano:before {
  content: "\\f770";
}
.fa-volleyball-ball:before {
  content: "\\f45f";
}
.fa-volume:before {
  content: "\\f6a8";
}
.fa-volume-down:before {
  content: "\\f027";
}
.fa-volume-mute:before {
  content: "\\f6a9";
}
.fa-volume-off:before {
  content: "\\f026";
}
.fa-volume-slash:before {
  content: "\\f2e2";
}
.fa-volume-up:before {
  content: "\\f028";
}
.fa-vote-nay:before {
  content: "\\f771";
}
.fa-vote-yea:before {
  content: "\\f772";
}
.fa-vr-cardboard:before {
  content: "\\f729";
}
.fa-vuejs:before {
  content: "\\f41f";
}
.fa-wagon-covered:before {
  content: "\\f8ee";
}
.fa-walker:before {
  content: "\\f831";
}
.fa-walkie-talkie:before {
  content: "\\f8ef";
}
.fa-walking:before {
  content: "\\f554";
}
.fa-wallet:before {
  content: "\\f555";
}
.fa-wand:before {
  content: "\\f72a";
}
.fa-wand-magic:before {
  content: "\\f72b";
}
.fa-warehouse:before {
  content: "\\f494";
}
.fa-warehouse-alt:before {
  content: "\\f495";
}
.fa-washer:before {
  content: "\\f898";
}
.fa-watch:before {
  content: "\\f2e1";
}
.fa-watch-calculator:before {
  content: "\\f8f0";
}
.fa-watch-fitness:before {
  content: "\\f63e";
}
.fa-water:before {
  content: "\\f773";
}
.fa-water-lower:before {
  content: "\\f774";
}
.fa-water-rise:before {
  content: "\\f775";
}
.fa-wave-sine:before {
  content: "\\f899";
}
.fa-wave-square:before {
  content: "\\f83e";
}
.fa-wave-triangle:before {
  content: "\\f89a";
}
.fa-waveform:before {
  content: "\\f8f1";
}
.fa-waveform-path:before {
  content: "\\f8f2";
}
.fa-waze:before {
  content: "\\f83f";
}
.fa-webcam:before {
  content: "\\f832";
}
.fa-webcam-slash:before {
  content: "\\f833";
}
.fa-weebly:before {
  content: "\\f5cc";
}
.fa-weibo:before {
  content: "\\f18a";
}
.fa-weight:before {
  content: "\\f496";
}
.fa-weight-hanging:before {
  content: "\\f5cd";
}
.fa-weixin:before {
  content: "\\f1d7";
}
.fa-whale:before {
  content: "\\f72c";
}
.fa-whatsapp:before {
  content: "\\f232";
}
.fa-whatsapp-square:before {
  content: "\\f40c";
}
.fa-wheat:before {
  content: "\\f72d";
}
.fa-wheelchair:before {
  content: "\\f193";
}
.fa-whistle:before {
  content: "\\f460";
}
.fa-whmcs:before {
  content: "\\f40d";
}
.fa-wifi:before {
  content: "\\f1eb";
}
.fa-wifi-1:before {
  content: "\\f6aa";
}
.fa-wifi-2:before {
  content: "\\f6ab";
}
.fa-wifi-slash:before {
  content: "\\f6ac";
}
.fa-wikipedia-w:before {
  content: "\\f266";
}
.fa-wind:before {
  content: "\\f72e";
}
.fa-wind-turbine:before {
  content: "\\f89b";
}
.fa-wind-warning:before {
  content: "\\f776";
}
.fa-window:before {
  content: "\\f40e";
}
.fa-window-alt:before {
  content: "\\f40f";
}
.fa-window-close:before {
  content: "\\f410";
}
.fa-window-frame:before {
  content: "\uF94F";
}
.fa-window-frame-open:before {
  content: "\uF950";
}
.fa-window-maximize:before {
  content: "\\f2d0";
}
.fa-window-minimize:before {
  content: "\\f2d1";
}
.fa-window-restore:before {
  content: "\\f2d2";
}
.fa-windows:before {
  content: "\\f17a";
}
.fa-windsock:before {
  content: "\\f777";
}
.fa-wine-bottle:before {
  content: "\\f72f";
}
.fa-wine-glass:before {
  content: "\\f4e3";
}
.fa-wine-glass-alt:before {
  content: "\\f5ce";
}
.fa-wix:before {
  content: "\\f5cf";
}
.fa-wizards-of-the-coast:before {
  content: "\\f730";
}
.fa-wolf-pack-battalion:before {
  content: "\\f514";
}
.fa-won-sign:before {
  content: "\\f159";
}
.fa-wordpress:before {
  content: "\\f19a";
}
.fa-wordpress-simple:before {
  content: "\\f411";
}
.fa-wpbeginner:before {
  content: "\\f297";
}
.fa-wpexplorer:before {
  content: "\\f2de";
}
.fa-wpforms:before {
  content: "\\f298";
}
.fa-wpressr:before {
  content: "\\f3e4";
}
.fa-wreath:before {
  content: "\\f7e2";
}
.fa-wrench:before {
  content: "\\f0ad";
}
.fa-x-ray:before {
  content: "\\f497";
}
.fa-xbox:before {
  content: "\\f412";
}
.fa-xing:before {
  content: "\\f168";
}
.fa-xing-square:before {
  content: "\\f169";
}
.fa-y-combinator:before {
  content: "\\f23b";
}
.fa-yahoo:before {
  content: "\\f19e";
}
.fa-yammer:before {
  content: "\\f840";
}
.fa-yandex:before {
  content: "\\f413";
}
.fa-yandex-international:before {
  content: "\\f414";
}
.fa-yarn:before {
  content: "\\f7e3";
}
.fa-yelp:before {
  content: "\\f1e9";
}
.fa-yen-sign:before {
  content: "\\f157";
}
.fa-yin-yang:before {
  content: "\\f6ad";
}
.fa-yoast:before {
  content: "\\f2b1";
}
.fa-youtube:before {
  content: "\\f167";
}
.fa-youtube-square:before {
  content: "\\f431";
}
.fa-zhihu:before {
  content: "\\f63f";
}
.sr-only {
  border: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}
.sr-only-focusable:active, .sr-only-focusable:focus {
  clip: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  position: static;
  width: auto;
}
.fab {
  font-family: "Font Awesome 5 Brands";
  font-weight: 400;
}
.fad {
  position: relative;
  font-family: "Font Awesome 5 Duotone";
  font-weight: 900;
}
.fad:before {
  position: absolute;
  color: var(--fa-primary-color, inherit);
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}
.fad:after {
  color: var(--fa-secondary-color, inherit);
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}
.fa-swap-opacity .fad:before,
.fad.fa-swap-opacity:before {
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}
.fa-swap-opacity .fad:after,
.fad.fa-swap-opacity:after {
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}
.fad.fa-inverse {
  color: #fff;
}
.fad.fa-stack-1x, .fad.fa-stack-2x {
  position: absolute;
}
.fad.fa-stack-1x:before,
.fad.fa-stack-2x:before,
.fad.fa-fw:before {
  left: 50%;
  transform: translateX(-50%);
}
.fad.fa-abacus:after {
  content: "\\10f640";
}
.fad.fa-acorn:after {
  content: "\\10f6ae";
}
.fad.fa-ad:after {
  content: "\\10f641";
}
.fad.fa-address-book:after {
  content: "\\10f2b9";
}
.fad.fa-address-card:after {
  content: "\\10f2bb";
}
.fad.fa-adjust:after {
  content: "\\10f042";
}
.fad.fa-air-conditioner:after {
  content: "\\10f8f4";
}
.fad.fa-air-freshener:after {
  content: "\\10f5d0";
}
.fad.fa-alarm-clock:after {
  content: "\\10f34e";
}
.fad.fa-alarm-exclamation:after {
  content: "\\10f843";
}
.fad.fa-alarm-plus:after {
  content: "\\10f844";
}
.fad.fa-alarm-snooze:after {
  content: "\\10f845";
}
.fad.fa-album:after {
  content: "\\10f89f";
}
.fad.fa-album-collection:after {
  content: "\\10f8a0";
}
.fad.fa-alicorn:after {
  content: "\\10f6b0";
}
.fad.fa-alien:after {
  content: "\\10f8f5";
}
.fad.fa-alien-monster:after {
  content: "\\10f8f6";
}
.fad.fa-align-center:after {
  content: "\\10f037";
}
.fad.fa-align-justify:after {
  content: "\\10f039";
}
.fad.fa-align-left:after {
  content: "\\10f036";
}
.fad.fa-align-right:after {
  content: "\\10f038";
}
.fad.fa-align-slash:after {
  content: "\\10f846";
}
.fad.fa-allergies:after {
  content: "\\10f461";
}
.fad.fa-ambulance:after {
  content: "\\10f0f9";
}
.fad.fa-american-sign-language-interpreting:after {
  content: "\\10f2a3";
}
.fad.fa-amp-guitar:after {
  content: "\\10f8a1";
}
.fad.fa-analytics:after {
  content: "\\10f643";
}
.fad.fa-anchor:after {
  content: "\\10f13d";
}
.fad.fa-angel:after {
  content: "\\10f779";
}
.fad.fa-angle-double-down:after {
  content: "\\10f103";
}
.fad.fa-angle-double-left:after {
  content: "\\10f100";
}
.fad.fa-angle-double-right:after {
  content: "\\10f101";
}
.fad.fa-angle-double-up:after {
  content: "\\10f102";
}
.fad.fa-angle-down:after {
  content: "\\10f107";
}
.fad.fa-angle-left:after {
  content: "\\10f104";
}
.fad.fa-angle-right:after {
  content: "\\10f105";
}
.fad.fa-angle-up:after {
  content: "\\10f106";
}
.fad.fa-angry:after {
  content: "\\10f556";
}
.fad.fa-ankh:after {
  content: "\\10f644";
}
.fad.fa-apple-alt:after {
  content: "\\10f5d1";
}
.fad.fa-apple-crate:after {
  content: "\\10f6b1";
}
.fad.fa-archive:after {
  content: "\\10f187";
}
.fad.fa-archway:after {
  content: "\\10f557";
}
.fad.fa-arrow-alt-circle-down:after {
  content: "\\10f358";
}
.fad.fa-arrow-alt-circle-left:after {
  content: "\\10f359";
}
.fad.fa-arrow-alt-circle-right:after {
  content: "\\10f35a";
}
.fad.fa-arrow-alt-circle-up:after {
  content: "\\10f35b";
}
.fad.fa-arrow-alt-down:after {
  content: "\\10f354";
}
.fad.fa-arrow-alt-from-bottom:after {
  content: "\\10f346";
}
.fad.fa-arrow-alt-from-left:after {
  content: "\\10f347";
}
.fad.fa-arrow-alt-from-right:after {
  content: "\\10f348";
}
.fad.fa-arrow-alt-from-top:after {
  content: "\\10f349";
}
.fad.fa-arrow-alt-left:after {
  content: "\\10f355";
}
.fad.fa-arrow-alt-right:after {
  content: "\\10f356";
}
.fad.fa-arrow-alt-square-down:after {
  content: "\\10f350";
}
.fad.fa-arrow-alt-square-left:after {
  content: "\\10f351";
}
.fad.fa-arrow-alt-square-right:after {
  content: "\\10f352";
}
.fad.fa-arrow-alt-square-up:after {
  content: "\\10f353";
}
.fad.fa-arrow-alt-to-bottom:after {
  content: "\\10f34a";
}
.fad.fa-arrow-alt-to-left:after {
  content: "\\10f34b";
}
.fad.fa-arrow-alt-to-right:after {
  content: "\\10f34c";
}
.fad.fa-arrow-alt-to-top:after {
  content: "\\10f34d";
}
.fad.fa-arrow-alt-up:after {
  content: "\\10f357";
}
.fad.fa-arrow-circle-down:after {
  content: "\\10f0ab";
}
.fad.fa-arrow-circle-left:after {
  content: "\\10f0a8";
}
.fad.fa-arrow-circle-right:after {
  content: "\\10f0a9";
}
.fad.fa-arrow-circle-up:after {
  content: "\\10f0aa";
}
.fad.fa-arrow-down:after {
  content: "\\10f063";
}
.fad.fa-arrow-from-bottom:after {
  content: "\\10f342";
}
.fad.fa-arrow-from-left:after {
  content: "\\10f343";
}
.fad.fa-arrow-from-right:after {
  content: "\\10f344";
}
.fad.fa-arrow-from-top:after {
  content: "\\10f345";
}
.fad.fa-arrow-left:after {
  content: "\\10f060";
}
.fad.fa-arrow-right:after {
  content: "\\10f061";
}
.fad.fa-arrow-square-down:after {
  content: "\\10f339";
}
.fad.fa-arrow-square-left:after {
  content: "\\10f33a";
}
.fad.fa-arrow-square-right:after {
  content: "\\10f33b";
}
.fad.fa-arrow-square-up:after {
  content: "\\10f33c";
}
.fad.fa-arrow-to-bottom:after {
  content: "\\10f33d";
}
.fad.fa-arrow-to-left:after {
  content: "\\10f33e";
}
.fad.fa-arrow-to-right:after {
  content: "\\10f340";
}
.fad.fa-arrow-to-top:after {
  content: "\\10f341";
}
.fad.fa-arrow-up:after {
  content: "\\10f062";
}
.fad.fa-arrows:after {
  content: "\\10f047";
}
.fad.fa-arrows-alt:after {
  content: "\\10f0b2";
}
.fad.fa-arrows-alt-h:after {
  content: "\\10f337";
}
.fad.fa-arrows-alt-v:after {
  content: "\\10f338";
}
.fad.fa-arrows-h:after {
  content: "\\10f07e";
}
.fad.fa-arrows-v:after {
  content: "\\10f07d";
}
.fad.fa-assistive-listening-systems:after {
  content: "\\10f2a2";
}
.fad.fa-asterisk:after {
  content: "\\10f069";
}
.fad.fa-at:after {
  content: "\\10f1fa";
}
.fad.fa-atlas:after {
  content: "\\10f558";
}
.fad.fa-atom:after {
  content: "\\10f5d2";
}
.fad.fa-atom-alt:after {
  content: "\\10f5d3";
}
.fad.fa-audio-description:after {
  content: "\\10f29e";
}
.fad.fa-award:after {
  content: "\\10f559";
}
.fad.fa-axe:after {
  content: "\\10f6b2";
}
.fad.fa-axe-battle:after {
  content: "\\10f6b3";
}
.fad.fa-baby:after {
  content: "\\10f77c";
}
.fad.fa-baby-carriage:after {
  content: "\\10f77d";
}
.fad.fa-backpack:after {
  content: "\\10f5d4";
}
.fad.fa-backspace:after {
  content: "\\10f55a";
}
.fad.fa-backward:after {
  content: "\\10f04a";
}
.fad.fa-bacon:after {
  content: "\\10f7e5";
}
.fad.fa-bacteria:after {
  content: "\\10f959";
}
.fad.fa-bacterium:after {
  content: "\\10f95a";
}
.fad.fa-badge:after {
  content: "\\10f335";
}
.fad.fa-badge-check:after {
  content: "\\10f336";
}
.fad.fa-badge-dollar:after {
  content: "\\10f645";
}
.fad.fa-badge-percent:after {
  content: "\\10f646";
}
.fad.fa-badge-sheriff:after {
  content: "\\10f8a2";
}
.fad.fa-badger-honey:after {
  content: "\\10f6b4";
}
.fad.fa-bags-shopping:after {
  content: "\\10f847";
}
.fad.fa-bahai:after {
  content: "\\10f666";
}
.fad.fa-balance-scale:after {
  content: "\\10f24e";
}
.fad.fa-balance-scale-left:after {
  content: "\\10f515";
}
.fad.fa-balance-scale-right:after {
  content: "\\10f516";
}
.fad.fa-ball-pile:after {
  content: "\\10f77e";
}
.fad.fa-ballot:after {
  content: "\\10f732";
}
.fad.fa-ballot-check:after {
  content: "\\10f733";
}
.fad.fa-ban:after {
  content: "\\10f05e";
}
.fad.fa-band-aid:after {
  content: "\\10f462";
}
.fad.fa-banjo:after {
  content: "\\10f8a3";
}
.fad.fa-barcode:after {
  content: "\\10f02a";
}
.fad.fa-barcode-alt:after {
  content: "\\10f463";
}
.fad.fa-barcode-read:after {
  content: "\\10f464";
}
.fad.fa-barcode-scan:after {
  content: "\\10f465";
}
.fad.fa-bars:after {
  content: "\\10f0c9";
}
.fad.fa-baseball:after {
  content: "\\10f432";
}
.fad.fa-baseball-ball:after {
  content: "\\10f433";
}
.fad.fa-basketball-ball:after {
  content: "\\10f434";
}
.fad.fa-basketball-hoop:after {
  content: "\\10f435";
}
.fad.fa-bat:after {
  content: "\\10f6b5";
}
.fad.fa-bath:after {
  content: "\\10f2cd";
}
.fad.fa-battery-bolt:after {
  content: "\\10f376";
}
.fad.fa-battery-empty:after {
  content: "\\10f244";
}
.fad.fa-battery-full:after {
  content: "\\10f240";
}
.fad.fa-battery-half:after {
  content: "\\10f242";
}
.fad.fa-battery-quarter:after {
  content: "\\10f243";
}
.fad.fa-battery-slash:after {
  content: "\\10f377";
}
.fad.fa-battery-three-quarters:after {
  content: "\\10f241";
}
.fad.fa-bed:after {
  content: "\\10f236";
}
.fad.fa-bed-alt:after {
  content: "\\10f8f7";
}
.fad.fa-bed-bunk:after {
  content: "\\10f8f8";
}
.fad.fa-bed-empty:after {
  content: "\\10f8f9";
}
.fad.fa-beer:after {
  content: "\\10f0fc";
}
.fad.fa-bell:after {
  content: "\\10f0f3";
}
.fad.fa-bell-exclamation:after {
  content: "\\10f848";
}
.fad.fa-bell-on:after {
  content: "\\10f8fa";
}
.fad.fa-bell-plus:after {
  content: "\\10f849";
}
.fad.fa-bell-school:after {
  content: "\\10f5d5";
}
.fad.fa-bell-school-slash:after {
  content: "\\10f5d6";
}
.fad.fa-bell-slash:after {
  content: "\\10f1f6";
}
.fad.fa-bells:after {
  content: "\\10f77f";
}
.fad.fa-betamax:after {
  content: "\\10f8a4";
}
.fad.fa-bezier-curve:after {
  content: "\\10f55b";
}
.fad.fa-bible:after {
  content: "\\10f647";
}
.fad.fa-bicycle:after {
  content: "\\10f206";
}
.fad.fa-biking:after {
  content: "\\10f84a";
}
.fad.fa-biking-mountain:after {
  content: "\\10f84b";
}
.fad.fa-binoculars:after {
  content: "\\10f1e5";
}
.fad.fa-biohazard:after {
  content: "\\10f780";
}
.fad.fa-birthday-cake:after {
  content: "\\10f1fd";
}
.fad.fa-blanket:after {
  content: "\\10f498";
}
.fad.fa-blender:after {
  content: "\\10f517";
}
.fad.fa-blender-phone:after {
  content: "\\10f6b6";
}
.fad.fa-blind:after {
  content: "\\10f29d";
}
.fad.fa-blinds:after {
  content: "\\10f8fb";
}
.fad.fa-blinds-open:after {
  content: "\\10f8fc";
}
.fad.fa-blinds-raised:after {
  content: "\\10f8fd";
}
.fad.fa-blog:after {
  content: "\\10f781";
}
.fad.fa-bold:after {
  content: "\\10f032";
}
.fad.fa-bolt:after {
  content: "\\10f0e7";
}
.fad.fa-bomb:after {
  content: "\\10f1e2";
}
.fad.fa-bone:after {
  content: "\\10f5d7";
}
.fad.fa-bone-break:after {
  content: "\\10f5d8";
}
.fad.fa-bong:after {
  content: "\\10f55c";
}
.fad.fa-book:after {
  content: "\\10f02d";
}
.fad.fa-book-alt:after {
  content: "\\10f5d9";
}
.fad.fa-book-dead:after {
  content: "\\10f6b7";
}
.fad.fa-book-heart:after {
  content: "\\10f499";
}
.fad.fa-book-medical:after {
  content: "\\10f7e6";
}
.fad.fa-book-open:after {
  content: "\\10f518";
}
.fad.fa-book-reader:after {
  content: "\\10f5da";
}
.fad.fa-book-spells:after {
  content: "\\10f6b8";
}
.fad.fa-book-user:after {
  content: "\\10f7e7";
}
.fad.fa-bookmark:after {
  content: "\\10f02e";
}
.fad.fa-books:after {
  content: "\\10f5db";
}
.fad.fa-books-medical:after {
  content: "\\10f7e8";
}
.fad.fa-boombox:after {
  content: "\\10f8a5";
}
.fad.fa-boot:after {
  content: "\\10f782";
}
.fad.fa-booth-curtain:after {
  content: "\\10f734";
}
.fad.fa-border-all:after {
  content: "\\10f84c";
}
.fad.fa-border-bottom:after {
  content: "\\10f84d";
}
.fad.fa-border-center-h:after {
  content: "\\10f89c";
}
.fad.fa-border-center-v:after {
  content: "\\10f89d";
}
.fad.fa-border-inner:after {
  content: "\\10f84e";
}
.fad.fa-border-left:after {
  content: "\\10f84f";
}
.fad.fa-border-none:after {
  content: "\\10f850";
}
.fad.fa-border-outer:after {
  content: "\\10f851";
}
.fad.fa-border-right:after {
  content: "\\10f852";
}
.fad.fa-border-style:after {
  content: "\\10f853";
}
.fad.fa-border-style-alt:after {
  content: "\\10f854";
}
.fad.fa-border-top:after {
  content: "\\10f855";
}
.fad.fa-bow-arrow:after {
  content: "\\10f6b9";
}
.fad.fa-bowling-ball:after {
  content: "\\10f436";
}
.fad.fa-bowling-pins:after {
  content: "\\10f437";
}
.fad.fa-box:after {
  content: "\\10f466";
}
.fad.fa-box-alt:after {
  content: "\\10f49a";
}
.fad.fa-box-ballot:after {
  content: "\\10f735";
}
.fad.fa-box-check:after {
  content: "\\10f467";
}
.fad.fa-box-fragile:after {
  content: "\\10f49b";
}
.fad.fa-box-full:after {
  content: "\\10f49c";
}
.fad.fa-box-heart:after {
  content: "\\10f49d";
}
.fad.fa-box-open:after {
  content: "\\10f49e";
}
.fad.fa-box-tissue:after {
  content: "\\10f95b";
}
.fad.fa-box-up:after {
  content: "\\10f49f";
}
.fad.fa-box-usd:after {
  content: "\\10f4a0";
}
.fad.fa-boxes:after {
  content: "\\10f468";
}
.fad.fa-boxes-alt:after {
  content: "\\10f4a1";
}
.fad.fa-boxing-glove:after {
  content: "\\10f438";
}
.fad.fa-brackets:after {
  content: "\\10f7e9";
}
.fad.fa-brackets-curly:after {
  content: "\\10f7ea";
}
.fad.fa-braille:after {
  content: "\\10f2a1";
}
.fad.fa-brain:after {
  content: "\\10f5dc";
}
.fad.fa-bread-loaf:after {
  content: "\\10f7eb";
}
.fad.fa-bread-slice:after {
  content: "\\10f7ec";
}
.fad.fa-briefcase:after {
  content: "\\10f0b1";
}
.fad.fa-briefcase-medical:after {
  content: "\\10f469";
}
.fad.fa-bring-forward:after {
  content: "\\10f856";
}
.fad.fa-bring-front:after {
  content: "\\10f857";
}
.fad.fa-broadcast-tower:after {
  content: "\\10f519";
}
.fad.fa-broom:after {
  content: "\\10f51a";
}
.fad.fa-browser:after {
  content: "\\10f37e";
}
.fad.fa-brush:after {
  content: "\\10f55d";
}
.fad.fa-bug:after {
  content: "\\10f188";
}
.fad.fa-building:after {
  content: "\\10f1ad";
}
.fad.fa-bullhorn:after {
  content: "\\10f0a1";
}
.fad.fa-bullseye:after {
  content: "\\10f140";
}
.fad.fa-bullseye-arrow:after {
  content: "\\10f648";
}
.fad.fa-bullseye-pointer:after {
  content: "\\10f649";
}
.fad.fa-burger-soda:after {
  content: "\\10f858";
}
.fad.fa-burn:after {
  content: "\\10f46a";
}
.fad.fa-burrito:after {
  content: "\\10f7ed";
}
.fad.fa-bus:after {
  content: "\\10f207";
}
.fad.fa-bus-alt:after {
  content: "\\10f55e";
}
.fad.fa-bus-school:after {
  content: "\\10f5dd";
}
.fad.fa-business-time:after {
  content: "\\10f64a";
}
.fad.fa-cabinet-filing:after {
  content: "\\10f64b";
}
.fad.fa-cactus:after {
  content: "\\10f8a7";
}
.fad.fa-calculator:after {
  content: "\\10f1ec";
}
.fad.fa-calculator-alt:after {
  content: "\\10f64c";
}
.fad.fa-calendar:after {
  content: "\\10f133";
}
.fad.fa-calendar-alt:after {
  content: "\\10f073";
}
.fad.fa-calendar-check:after {
  content: "\\10f274";
}
.fad.fa-calendar-day:after {
  content: "\\10f783";
}
.fad.fa-calendar-edit:after {
  content: "\\10f333";
}
.fad.fa-calendar-exclamation:after {
  content: "\\10f334";
}
.fad.fa-calendar-minus:after {
  content: "\\10f272";
}
.fad.fa-calendar-plus:after {
  content: "\\10f271";
}
.fad.fa-calendar-star:after {
  content: "\\10f736";
}
.fad.fa-calendar-times:after {
  content: "\\10f273";
}
.fad.fa-calendar-week:after {
  content: "\\10f784";
}
.fad.fa-camcorder:after {
  content: "\\10f8a8";
}
.fad.fa-camera:after {
  content: "\\10f030";
}
.fad.fa-camera-alt:after {
  content: "\\10f332";
}
.fad.fa-camera-home:after {
  content: "\\10f8fe";
}
.fad.fa-camera-movie:after {
  content: "\\10f8a9";
}
.fad.fa-camera-polaroid:after {
  content: "\\10f8aa";
}
.fad.fa-camera-retro:after {
  content: "\\10f083";
}
.fad.fa-campfire:after {
  content: "\\10f6ba";
}
.fad.fa-campground:after {
  content: "\\10f6bb";
}
.fad.fa-candle-holder:after {
  content: "\\10f6bc";
}
.fad.fa-candy-cane:after {
  content: "\\10f786";
}
.fad.fa-candy-corn:after {
  content: "\\10f6bd";
}
.fad.fa-cannabis:after {
  content: "\\10f55f";
}
.fad.fa-capsules:after {
  content: "\\10f46b";
}
.fad.fa-car:after {
  content: "\\10f1b9";
}
.fad.fa-car-alt:after {
  content: "\\10f5de";
}
.fad.fa-car-battery:after {
  content: "\\10f5df";
}
.fad.fa-car-building:after {
  content: "\\10f859";
}
.fad.fa-car-bump:after {
  content: "\\10f5e0";
}
.fad.fa-car-bus:after {
  content: "\\10f85a";
}
.fad.fa-car-crash:after {
  content: "\\10f5e1";
}
.fad.fa-car-garage:after {
  content: "\\10f5e2";
}
.fad.fa-car-mechanic:after {
  content: "\\10f5e3";
}
.fad.fa-car-side:after {
  content: "\\10f5e4";
}
.fad.fa-car-tilt:after {
  content: "\\10f5e5";
}
.fad.fa-car-wash:after {
  content: "\\10f5e6";
}
.fad.fa-caravan:after {
  content: "\\10f8ff";
}
.fad.fa-caravan-alt:after {
  content: "\\10f900";
}
.fad.fa-caret-circle-down:after {
  content: "\\10f32d";
}
.fad.fa-caret-circle-left:after {
  content: "\\10f32e";
}
.fad.fa-caret-circle-right:after {
  content: "\\10f330";
}
.fad.fa-caret-circle-up:after {
  content: "\\10f331";
}
.fad.fa-caret-down:after {
  content: "\\10f0d7";
}
.fad.fa-caret-left:after {
  content: "\\10f0d9";
}
.fad.fa-caret-right:after {
  content: "\\10f0da";
}
.fad.fa-caret-square-down:after {
  content: "\\10f150";
}
.fad.fa-caret-square-left:after {
  content: "\\10f191";
}
.fad.fa-caret-square-right:after {
  content: "\\10f152";
}
.fad.fa-caret-square-up:after {
  content: "\\10f151";
}
.fad.fa-caret-up:after {
  content: "\\10f0d8";
}
.fad.fa-carrot:after {
  content: "\\10f787";
}
.fad.fa-cars:after {
  content: "\\10f85b";
}
.fad.fa-cart-arrow-down:after {
  content: "\\10f218";
}
.fad.fa-cart-plus:after {
  content: "\\10f217";
}
.fad.fa-cash-register:after {
  content: "\\10f788";
}
.fad.fa-cassette-tape:after {
  content: "\\10f8ab";
}
.fad.fa-cat:after {
  content: "\\10f6be";
}
.fad.fa-cat-space:after {
  content: "\\10f901";
}
.fad.fa-cauldron:after {
  content: "\\10f6bf";
}
.fad.fa-cctv:after {
  content: "\\10f8ac";
}
.fad.fa-certificate:after {
  content: "\\10f0a3";
}
.fad.fa-chair:after {
  content: "\\10f6c0";
}
.fad.fa-chair-office:after {
  content: "\\10f6c1";
}
.fad.fa-chalkboard:after {
  content: "\\10f51b";
}
.fad.fa-chalkboard-teacher:after {
  content: "\\10f51c";
}
.fad.fa-charging-station:after {
  content: "\\10f5e7";
}
.fad.fa-chart-area:after {
  content: "\\10f1fe";
}
.fad.fa-chart-bar:after {
  content: "\\10f080";
}
.fad.fa-chart-line:after {
  content: "\\10f201";
}
.fad.fa-chart-line-down:after {
  content: "\\10f64d";
}
.fad.fa-chart-network:after {
  content: "\\10f78a";
}
.fad.fa-chart-pie:after {
  content: "\\10f200";
}
.fad.fa-chart-pie-alt:after {
  content: "\\10f64e";
}
.fad.fa-chart-scatter:after {
  content: "\\10f7ee";
}
.fad.fa-check:after {
  content: "\\10f00c";
}
.fad.fa-check-circle:after {
  content: "\\10f058";
}
.fad.fa-check-double:after {
  content: "\\10f560";
}
.fad.fa-check-square:after {
  content: "\\10f14a";
}
.fad.fa-cheese:after {
  content: "\\10f7ef";
}
.fad.fa-cheese-swiss:after {
  content: "\\10f7f0";
}
.fad.fa-cheeseburger:after {
  content: "\\10f7f1";
}
.fad.fa-chess:after {
  content: "\\10f439";
}
.fad.fa-chess-bishop:after {
  content: "\\10f43a";
}
.fad.fa-chess-bishop-alt:after {
  content: "\\10f43b";
}
.fad.fa-chess-board:after {
  content: "\\10f43c";
}
.fad.fa-chess-clock:after {
  content: "\\10f43d";
}
.fad.fa-chess-clock-alt:after {
  content: "\\10f43e";
}
.fad.fa-chess-king:after {
  content: "\\10f43f";
}
.fad.fa-chess-king-alt:after {
  content: "\\10f440";
}
.fad.fa-chess-knight:after {
  content: "\\10f441";
}
.fad.fa-chess-knight-alt:after {
  content: "\\10f442";
}
.fad.fa-chess-pawn:after {
  content: "\\10f443";
}
.fad.fa-chess-pawn-alt:after {
  content: "\\10f444";
}
.fad.fa-chess-queen:after {
  content: "\\10f445";
}
.fad.fa-chess-queen-alt:after {
  content: "\\10f446";
}
.fad.fa-chess-rook:after {
  content: "\\10f447";
}
.fad.fa-chess-rook-alt:after {
  content: "\\10f448";
}
.fad.fa-chevron-circle-down:after {
  content: "\\10f13a";
}
.fad.fa-chevron-circle-left:after {
  content: "\\10f137";
}
.fad.fa-chevron-circle-right:after {
  content: "\\10f138";
}
.fad.fa-chevron-circle-up:after {
  content: "\\10f139";
}
.fad.fa-chevron-double-down:after {
  content: "\\10f322";
}
.fad.fa-chevron-double-left:after {
  content: "\\10f323";
}
.fad.fa-chevron-double-right:after {
  content: "\\10f324";
}
.fad.fa-chevron-double-up:after {
  content: "\\10f325";
}
.fad.fa-chevron-down:after {
  content: "\\10f078";
}
.fad.fa-chevron-left:after {
  content: "\\10f053";
}
.fad.fa-chevron-right:after {
  content: "\\10f054";
}
.fad.fa-chevron-square-down:after {
  content: "\\10f329";
}
.fad.fa-chevron-square-left:after {
  content: "\\10f32a";
}
.fad.fa-chevron-square-right:after {
  content: "\\10f32b";
}
.fad.fa-chevron-square-up:after {
  content: "\\10f32c";
}
.fad.fa-chevron-up:after {
  content: "\\10f077";
}
.fad.fa-child:after {
  content: "\\10f1ae";
}
.fad.fa-chimney:after {
  content: "\\10f78b";
}
.fad.fa-church:after {
  content: "\\10f51d";
}
.fad.fa-circle:after {
  content: "\\10f111";
}
.fad.fa-circle-notch:after {
  content: "\\10f1ce";
}
.fad.fa-city:after {
  content: "\\10f64f";
}
.fad.fa-clarinet:after {
  content: "\\10f8ad";
}
.fad.fa-claw-marks:after {
  content: "\\10f6c2";
}
.fad.fa-clinic-medical:after {
  content: "\\10f7f2";
}
.fad.fa-clipboard:after {
  content: "\\10f328";
}
.fad.fa-clipboard-check:after {
  content: "\\10f46c";
}
.fad.fa-clipboard-list:after {
  content: "\\10f46d";
}
.fad.fa-clipboard-list-check:after {
  content: "\\10f737";
}
.fad.fa-clipboard-prescription:after {
  content: "\\10f5e8";
}
.fad.fa-clipboard-user:after {
  content: "\\10f7f3";
}
.fad.fa-clock:after {
  content: "\\10f017";
}
.fad.fa-clone:after {
  content: "\\10f24d";
}
.fad.fa-closed-captioning:after {
  content: "\\10f20a";
}
.fad.fa-cloud:after {
  content: "\\10f0c2";
}
.fad.fa-cloud-download:after {
  content: "\\10f0ed";
}
.fad.fa-cloud-download-alt:after {
  content: "\\10f381";
}
.fad.fa-cloud-drizzle:after {
  content: "\\10f738";
}
.fad.fa-cloud-hail:after {
  content: "\\10f739";
}
.fad.fa-cloud-hail-mixed:after {
  content: "\\10f73a";
}
.fad.fa-cloud-meatball:after {
  content: "\\10f73b";
}
.fad.fa-cloud-moon:after {
  content: "\\10f6c3";
}
.fad.fa-cloud-moon-rain:after {
  content: "\\10f73c";
}
.fad.fa-cloud-music:after {
  content: "\\10f8ae";
}
.fad.fa-cloud-rain:after {
  content: "\\10f73d";
}
.fad.fa-cloud-rainbow:after {
  content: "\\10f73e";
}
.fad.fa-cloud-showers:after {
  content: "\\10f73f";
}
.fad.fa-cloud-showers-heavy:after {
  content: "\\10f740";
}
.fad.fa-cloud-sleet:after {
  content: "\\10f741";
}
.fad.fa-cloud-snow:after {
  content: "\\10f742";
}
.fad.fa-cloud-sun:after {
  content: "\\10f6c4";
}
.fad.fa-cloud-sun-rain:after {
  content: "\\10f743";
}
.fad.fa-cloud-upload:after {
  content: "\\10f0ee";
}
.fad.fa-cloud-upload-alt:after {
  content: "\\10f382";
}
.fad.fa-clouds:after {
  content: "\\10f744";
}
.fad.fa-clouds-moon:after {
  content: "\\10f745";
}
.fad.fa-clouds-sun:after {
  content: "\\10f746";
}
.fad.fa-club:after {
  content: "\\10f327";
}
.fad.fa-cocktail:after {
  content: "\\10f561";
}
.fad.fa-code:after {
  content: "\\10f121";
}
.fad.fa-code-branch:after {
  content: "\\10f126";
}
.fad.fa-code-commit:after {
  content: "\\10f386";
}
.fad.fa-code-merge:after {
  content: "\\10f387";
}
.fad.fa-coffee:after {
  content: "\\10f0f4";
}
.fad.fa-coffee-pot:after {
  content: "\\10f902";
}
.fad.fa-coffee-togo:after {
  content: "\\10f6c5";
}
.fad.fa-coffin:after {
  content: "\\10f6c6";
}
.fad.fa-coffin-cross:after {
  content: "\\10f951";
}
.fad.fa-cog:after {
  content: "\\10f013";
}
.fad.fa-cogs:after {
  content: "\\10f085";
}
.fad.fa-coin:after {
  content: "\\10f85c";
}
.fad.fa-coins:after {
  content: "\\10f51e";
}
.fad.fa-columns:after {
  content: "\\10f0db";
}
.fad.fa-comet:after {
  content: "\\10f903";
}
.fad.fa-comment:after {
  content: "\\10f075";
}
.fad.fa-comment-alt:after {
  content: "\\10f27a";
}
.fad.fa-comment-alt-check:after {
  content: "\\10f4a2";
}
.fad.fa-comment-alt-dollar:after {
  content: "\\10f650";
}
.fad.fa-comment-alt-dots:after {
  content: "\\10f4a3";
}
.fad.fa-comment-alt-edit:after {
  content: "\\10f4a4";
}
.fad.fa-comment-alt-exclamation:after {
  content: "\\10f4a5";
}
.fad.fa-comment-alt-lines:after {
  content: "\\10f4a6";
}
.fad.fa-comment-alt-medical:after {
  content: "\\10f7f4";
}
.fad.fa-comment-alt-minus:after {
  content: "\\10f4a7";
}
.fad.fa-comment-alt-music:after {
  content: "\\10f8af";
}
.fad.fa-comment-alt-plus:after {
  content: "\\10f4a8";
}
.fad.fa-comment-alt-slash:after {
  content: "\\10f4a9";
}
.fad.fa-comment-alt-smile:after {
  content: "\\10f4aa";
}
.fad.fa-comment-alt-times:after {
  content: "\\10f4ab";
}
.fad.fa-comment-check:after {
  content: "\\10f4ac";
}
.fad.fa-comment-dollar:after {
  content: "\\10f651";
}
.fad.fa-comment-dots:after {
  content: "\\10f4ad";
}
.fad.fa-comment-edit:after {
  content: "\\10f4ae";
}
.fad.fa-comment-exclamation:after {
  content: "\\10f4af";
}
.fad.fa-comment-lines:after {
  content: "\\10f4b0";
}
.fad.fa-comment-medical:after {
  content: "\\10f7f5";
}
.fad.fa-comment-minus:after {
  content: "\\10f4b1";
}
.fad.fa-comment-music:after {
  content: "\\10f8b0";
}
.fad.fa-comment-plus:after {
  content: "\\10f4b2";
}
.fad.fa-comment-slash:after {
  content: "\\10f4b3";
}
.fad.fa-comment-smile:after {
  content: "\\10f4b4";
}
.fad.fa-comment-times:after {
  content: "\\10f4b5";
}
.fad.fa-comments:after {
  content: "\\10f086";
}
.fad.fa-comments-alt:after {
  content: "\\10f4b6";
}
.fad.fa-comments-alt-dollar:after {
  content: "\\10f652";
}
.fad.fa-comments-dollar:after {
  content: "\\10f653";
}
.fad.fa-compact-disc:after {
  content: "\\10f51f";
}
.fad.fa-compass:after {
  content: "\\10f14e";
}
.fad.fa-compass-slash:after {
  content: "\\10f5e9";
}
.fad.fa-compress:after {
  content: "\\10f066";
}
.fad.fa-compress-alt:after {
  content: "\\10f422";
}
.fad.fa-compress-arrows-alt:after {
  content: "\\10f78c";
}
.fad.fa-compress-wide:after {
  content: "\\10f326";
}
.fad.fa-computer-classic:after {
  content: "\\10f8b1";
}
.fad.fa-computer-speaker:after {
  content: "\\10f8b2";
}
.fad.fa-concierge-bell:after {
  content: "\\10f562";
}
.fad.fa-construction:after {
  content: "\\10f85d";
}
.fad.fa-container-storage:after {
  content: "\\10f4b7";
}
.fad.fa-conveyor-belt:after {
  content: "\\10f46e";
}
.fad.fa-conveyor-belt-alt:after {
  content: "\\10f46f";
}
.fad.fa-cookie:after {
  content: "\\10f563";
}
.fad.fa-cookie-bite:after {
  content: "\\10f564";
}
.fad.fa-copy:after {
  content: "\\10f0c5";
}
.fad.fa-copyright:after {
  content: "\\10f1f9";
}
.fad.fa-corn:after {
  content: "\\10f6c7";
}
.fad.fa-couch:after {
  content: "\\10f4b8";
}
.fad.fa-cow:after {
  content: "\\10f6c8";
}
.fad.fa-cowbell:after {
  content: "\\10f8b3";
}
.fad.fa-cowbell-more:after {
  content: "\\10f8b4";
}
.fad.fa-credit-card:after {
  content: "\\10f09d";
}
.fad.fa-credit-card-blank:after {
  content: "\\10f389";
}
.fad.fa-credit-card-front:after {
  content: "\\10f38a";
}
.fad.fa-cricket:after {
  content: "\\10f449";
}
.fad.fa-croissant:after {
  content: "\\10f7f6";
}
.fad.fa-crop:after {
  content: "\\10f125";
}
.fad.fa-crop-alt:after {
  content: "\\10f565";
}
.fad.fa-cross:after {
  content: "\\10f654";
}
.fad.fa-crosshairs:after {
  content: "\\10f05b";
}
.fad.fa-crow:after {
  content: "\\10f520";
}
.fad.fa-crown:after {
  content: "\\10f521";
}
.fad.fa-crutch:after {
  content: "\\10f7f7";
}
.fad.fa-crutches:after {
  content: "\\10f7f8";
}
.fad.fa-cube:after {
  content: "\\10f1b2";
}
.fad.fa-cubes:after {
  content: "\\10f1b3";
}
.fad.fa-curling:after {
  content: "\\10f44a";
}
.fad.fa-cut:after {
  content: "\\10f0c4";
}
.fad.fa-dagger:after {
  content: "\\10f6cb";
}
.fad.fa-database:after {
  content: "\\10f1c0";
}
.fad.fa-deaf:after {
  content: "\\10f2a4";
}
.fad.fa-debug:after {
  content: "\\10f7f9";
}
.fad.fa-deer:after {
  content: "\\10f78e";
}
.fad.fa-deer-rudolph:after {
  content: "\\10f78f";
}
.fad.fa-democrat:after {
  content: "\\10f747";
}
.fad.fa-desktop:after {
  content: "\\10f108";
}
.fad.fa-desktop-alt:after {
  content: "\\10f390";
}
.fad.fa-dewpoint:after {
  content: "\\10f748";
}
.fad.fa-dharmachakra:after {
  content: "\\10f655";
}
.fad.fa-diagnoses:after {
  content: "\\10f470";
}
.fad.fa-diamond:after {
  content: "\\10f219";
}
.fad.fa-dice:after {
  content: "\\10f522";
}
.fad.fa-dice-d10:after {
  content: "\\10f6cd";
}
.fad.fa-dice-d12:after {
  content: "\\10f6ce";
}
.fad.fa-dice-d20:after {
  content: "\\10f6cf";
}
.fad.fa-dice-d4:after {
  content: "\\10f6d0";
}
.fad.fa-dice-d6:after {
  content: "\\10f6d1";
}
.fad.fa-dice-d8:after {
  content: "\\10f6d2";
}
.fad.fa-dice-five:after {
  content: "\\10f523";
}
.fad.fa-dice-four:after {
  content: "\\10f524";
}
.fad.fa-dice-one:after {
  content: "\\10f525";
}
.fad.fa-dice-six:after {
  content: "\\10f526";
}
.fad.fa-dice-three:after {
  content: "\\10f527";
}
.fad.fa-dice-two:after {
  content: "\\10f528";
}
.fad.fa-digging:after {
  content: "\\10f85e";
}
.fad.fa-digital-tachograph:after {
  content: "\\10f566";
}
.fad.fa-diploma:after {
  content: "\\10f5ea";
}
.fad.fa-directions:after {
  content: "\\10f5eb";
}
.fad.fa-disc-drive:after {
  content: "\\10f8b5";
}
.fad.fa-disease:after {
  content: "\\10f7fa";
}
.fad.fa-divide:after {
  content: "\\10f529";
}
.fad.fa-dizzy:after {
  content: "\\10f567";
}
.fad.fa-dna:after {
  content: "\\10f471";
}
.fad.fa-do-not-enter:after {
  content: "\\10f5ec";
}
.fad.fa-dog:after {
  content: "\\10f6d3";
}
.fad.fa-dog-leashed:after {
  content: "\\10f6d4";
}
.fad.fa-dollar-sign:after {
  content: "\\10f155";
}
.fad.fa-dolly:after {
  content: "\\10f472";
}
.fad.fa-dolly-empty:after {
  content: "\\10f473";
}
.fad.fa-dolly-flatbed:after {
  content: "\\10f474";
}
.fad.fa-dolly-flatbed-alt:after {
  content: "\\10f475";
}
.fad.fa-dolly-flatbed-empty:after {
  content: "\\10f476";
}
.fad.fa-donate:after {
  content: "\\10f4b9";
}
.fad.fa-door-closed:after {
  content: "\\10f52a";
}
.fad.fa-door-open:after {
  content: "\\10f52b";
}
.fad.fa-dot-circle:after {
  content: "\\10f192";
}
.fad.fa-dove:after {
  content: "\\10f4ba";
}
.fad.fa-download:after {
  content: "\\10f019";
}
.fad.fa-drafting-compass:after {
  content: "\\10f568";
}
.fad.fa-dragon:after {
  content: "\\10f6d5";
}
.fad.fa-draw-circle:after {
  content: "\\10f5ed";
}
.fad.fa-draw-polygon:after {
  content: "\\10f5ee";
}
.fad.fa-draw-square:after {
  content: "\\10f5ef";
}
.fad.fa-dreidel:after {
  content: "\\10f792";
}
.fad.fa-drone:after {
  content: "\\10f85f";
}
.fad.fa-drone-alt:after {
  content: "\\10f860";
}
.fad.fa-drum:after {
  content: "\\10f569";
}
.fad.fa-drum-steelpan:after {
  content: "\\10f56a";
}
.fad.fa-drumstick:after {
  content: "\\10f6d6";
}
.fad.fa-drumstick-bite:after {
  content: "\\10f6d7";
}
.fad.fa-dryer:after {
  content: "\\10f861";
}
.fad.fa-dryer-alt:after {
  content: "\\10f862";
}
.fad.fa-duck:after {
  content: "\\10f6d8";
}
.fad.fa-dumbbell:after {
  content: "\\10f44b";
}
.fad.fa-dumpster:after {
  content: "\\10f793";
}
.fad.fa-dumpster-fire:after {
  content: "\\10f794";
}
.fad.fa-dungeon:after {
  content: "\\10f6d9";
}
.fad.fa-ear:after {
  content: "\\10f5f0";
}
.fad.fa-ear-muffs:after {
  content: "\\10f795";
}
.fad.fa-eclipse:after {
  content: "\\10f749";
}
.fad.fa-eclipse-alt:after {
  content: "\\10f74a";
}
.fad.fa-edit:after {
  content: "\\10f044";
}
.fad.fa-egg:after {
  content: "\\10f7fb";
}
.fad.fa-egg-fried:after {
  content: "\\10f7fc";
}
.fad.fa-eject:after {
  content: "\\10f052";
}
.fad.fa-elephant:after {
  content: "\\10f6da";
}
.fad.fa-ellipsis-h:after {
  content: "\\10f141";
}
.fad.fa-ellipsis-h-alt:after {
  content: "\\10f39b";
}
.fad.fa-ellipsis-v:after {
  content: "\\10f142";
}
.fad.fa-ellipsis-v-alt:after {
  content: "\\10f39c";
}
.fad.fa-empty-set:after {
  content: "\\10f656";
}
.fad.fa-engine-warning:after {
  content: "\\10f5f2";
}
.fad.fa-envelope:after {
  content: "\\10f0e0";
}
.fad.fa-envelope-open:after {
  content: "\\10f2b6";
}
.fad.fa-envelope-open-dollar:after {
  content: "\\10f657";
}
.fad.fa-envelope-open-text:after {
  content: "\\10f658";
}
.fad.fa-envelope-square:after {
  content: "\\10f199";
}
.fad.fa-equals:after {
  content: "\\10f52c";
}
.fad.fa-eraser:after {
  content: "\\10f12d";
}
.fad.fa-ethernet:after {
  content: "\\10f796";
}
.fad.fa-euro-sign:after {
  content: "\\10f153";
}
.fad.fa-exchange:after {
  content: "\\10f0ec";
}
.fad.fa-exchange-alt:after {
  content: "\\10f362";
}
.fad.fa-exclamation:after {
  content: "\\10f12a";
}
.fad.fa-exclamation-circle:after {
  content: "\\10f06a";
}
.fad.fa-exclamation-square:after {
  content: "\\10f321";
}
.fad.fa-exclamation-triangle:after {
  content: "\\10f071";
}
.fad.fa-expand:after {
  content: "\\10f065";
}
.fad.fa-expand-alt:after {
  content: "\\10f424";
}
.fad.fa-expand-arrows:after {
  content: "\\10f31d";
}
.fad.fa-expand-arrows-alt:after {
  content: "\\10f31e";
}
.fad.fa-expand-wide:after {
  content: "\\10f320";
}
.fad.fa-external-link:after {
  content: "\\10f08e";
}
.fad.fa-external-link-alt:after {
  content: "\\10f35d";
}
.fad.fa-external-link-square:after {
  content: "\\10f14c";
}
.fad.fa-external-link-square-alt:after {
  content: "\\10f360";
}
.fad.fa-eye:after {
  content: "\\10f06e";
}
.fad.fa-eye-dropper:after {
  content: "\\10f1fb";
}
.fad.fa-eye-evil:after {
  content: "\\10f6db";
}
.fad.fa-eye-slash:after {
  content: "\\10f070";
}
.fad.fa-fan:after {
  content: "\\10f863";
}
.fad.fa-fan-table:after {
  content: "\\10f904";
}
.fad.fa-farm:after {
  content: "\\10f864";
}
.fad.fa-fast-backward:after {
  content: "\\10f049";
}
.fad.fa-fast-forward:after {
  content: "\\10f050";
}
.fad.fa-faucet:after {
  content: "\\10f905";
}
.fad.fa-faucet-drip:after {
  content: "\\10f906";
}
.fad.fa-fax:after {
  content: "\\10f1ac";
}
.fad.fa-feather:after {
  content: "\\10f52d";
}
.fad.fa-feather-alt:after {
  content: "\\10f56b";
}
.fad.fa-female:after {
  content: "\\10f182";
}
.fad.fa-field-hockey:after {
  content: "\\10f44c";
}
.fad.fa-fighter-jet:after {
  content: "\\10f0fb";
}
.fad.fa-file:after {
  content: "\\10f15b";
}
.fad.fa-file-alt:after {
  content: "\\10f15c";
}
.fad.fa-file-archive:after {
  content: "\\10f1c6";
}
.fad.fa-file-audio:after {
  content: "\\10f1c7";
}
.fad.fa-file-certificate:after {
  content: "\\10f5f3";
}
.fad.fa-file-chart-line:after {
  content: "\\10f659";
}
.fad.fa-file-chart-pie:after {
  content: "\\10f65a";
}
.fad.fa-file-check:after {
  content: "\\10f316";
}
.fad.fa-file-code:after {
  content: "\\10f1c9";
}
.fad.fa-file-contract:after {
  content: "\\10f56c";
}
.fad.fa-file-csv:after {
  content: "\\10f6dd";
}
.fad.fa-file-download:after {
  content: "\\10f56d";
}
.fad.fa-file-edit:after {
  content: "\\10f31c";
}
.fad.fa-file-excel:after {
  content: "\\10f1c3";
}
.fad.fa-file-exclamation:after {
  content: "\\10f31a";
}
.fad.fa-file-export:after {
  content: "\\10f56e";
}
.fad.fa-file-image:after {
  content: "\\10f1c5";
}
.fad.fa-file-import:after {
  content: "\\10f56f";
}
.fad.fa-file-invoice:after {
  content: "\\10f570";
}
.fad.fa-file-invoice-dollar:after {
  content: "\\10f571";
}
.fad.fa-file-medical:after {
  content: "\\10f477";
}
.fad.fa-file-medical-alt:after {
  content: "\\10f478";
}
.fad.fa-file-minus:after {
  content: "\\10f318";
}
.fad.fa-file-music:after {
  content: "\\10f8b6";
}
.fad.fa-file-pdf:after {
  content: "\\10f1c1";
}
.fad.fa-file-plus:after {
  content: "\\10f319";
}
.fad.fa-file-powerpoint:after {
  content: "\\10f1c4";
}
.fad.fa-file-prescription:after {
  content: "\\10f572";
}
.fad.fa-file-search:after {
  content: "\\10f865";
}
.fad.fa-file-signature:after {
  content: "\\10f573";
}
.fad.fa-file-spreadsheet:after {
  content: "\\10f65b";
}
.fad.fa-file-times:after {
  content: "\\10f317";
}
.fad.fa-file-upload:after {
  content: "\\10f574";
}
.fad.fa-file-user:after {
  content: "\\10f65c";
}
.fad.fa-file-video:after {
  content: "\\10f1c8";
}
.fad.fa-file-word:after {
  content: "\\10f1c2";
}
.fad.fa-files-medical:after {
  content: "\\10f7fd";
}
.fad.fa-fill:after {
  content: "\\10f575";
}
.fad.fa-fill-drip:after {
  content: "\\10f576";
}
.fad.fa-film:after {
  content: "\\10f008";
}
.fad.fa-film-alt:after {
  content: "\\10f3a0";
}
.fad.fa-film-canister:after {
  content: "\\10f8b7";
}
.fad.fa-filter:after {
  content: "\\10f0b0";
}
.fad.fa-fingerprint:after {
  content: "\\10f577";
}
.fad.fa-fire:after {
  content: "\\10f06d";
}
.fad.fa-fire-alt:after {
  content: "\\10f7e4";
}
.fad.fa-fire-extinguisher:after {
  content: "\\10f134";
}
.fad.fa-fire-smoke:after {
  content: "\\10f74b";
}
.fad.fa-fireplace:after {
  content: "\\10f79a";
}
.fad.fa-first-aid:after {
  content: "\\10f479";
}
.fad.fa-fish:after {
  content: "\\10f578";
}
.fad.fa-fish-cooked:after {
  content: "\\10f7fe";
}
.fad.fa-fist-raised:after {
  content: "\\10f6de";
}
.fad.fa-flag:after {
  content: "\\10f024";
}
.fad.fa-flag-alt:after {
  content: "\\10f74c";
}
.fad.fa-flag-checkered:after {
  content: "\\10f11e";
}
.fad.fa-flag-usa:after {
  content: "\\10f74d";
}
.fad.fa-flame:after {
  content: "\\10f6df";
}
.fad.fa-flashlight:after {
  content: "\\10f8b8";
}
.fad.fa-flask:after {
  content: "\\10f0c3";
}
.fad.fa-flask-poison:after {
  content: "\\10f6e0";
}
.fad.fa-flask-potion:after {
  content: "\\10f6e1";
}
.fad.fa-flower:after {
  content: "\\10f7ff";
}
.fad.fa-flower-daffodil:after {
  content: "\\10f800";
}
.fad.fa-flower-tulip:after {
  content: "\\10f801";
}
.fad.fa-flushed:after {
  content: "\\10f579";
}
.fad.fa-flute:after {
  content: "\\10f8b9";
}
.fad.fa-flux-capacitor:after {
  content: "\\10f8ba";
}
.fad.fa-fog:after {
  content: "\\10f74e";
}
.fad.fa-folder:after {
  content: "\\10f07b";
}
.fad.fa-folder-download:after {
  content: "\\10f953";
}
.fad.fa-folder-minus:after {
  content: "\\10f65d";
}
.fad.fa-folder-open:after {
  content: "\\10f07c";
}
.fad.fa-folder-plus:after {
  content: "\\10f65e";
}
.fad.fa-folder-times:after {
  content: "\\10f65f";
}
.fad.fa-folder-tree:after {
  content: "\\10f802";
}
.fad.fa-folder-upload:after {
  content: "\\10f954";
}
.fad.fa-folders:after {
  content: "\\10f660";
}
.fad.fa-font:after {
  content: "\\10f031";
}
.fad.fa-font-awesome-logo-full:after {
  content: "\\10f4e6";
}
.fad.fa-font-case:after {
  content: "\\10f866";
}
.fad.fa-football-ball:after {
  content: "\\10f44e";
}
.fad.fa-football-helmet:after {
  content: "\\10f44f";
}
.fad.fa-forklift:after {
  content: "\\10f47a";
}
.fad.fa-forward:after {
  content: "\\10f04e";
}
.fad.fa-fragile:after {
  content: "\\10f4bb";
}
.fad.fa-french-fries:after {
  content: "\\10f803";
}
.fad.fa-frog:after {
  content: "\\10f52e";
}
.fad.fa-frosty-head:after {
  content: "\\10f79b";
}
.fad.fa-frown:after {
  content: "\\10f119";
}
.fad.fa-frown-open:after {
  content: "\\10f57a";
}
.fad.fa-function:after {
  content: "\\10f661";
}
.fad.fa-funnel-dollar:after {
  content: "\\10f662";
}
.fad.fa-futbol:after {
  content: "\\10f1e3";
}
.fad.fa-galaxy:after {
  content: "\\10f908";
}
.fad.fa-game-board:after {
  content: "\\10f867";
}
.fad.fa-game-board-alt:after {
  content: "\\10f868";
}
.fad.fa-game-console-handheld:after {
  content: "\\10f8bb";
}
.fad.fa-gamepad:after {
  content: "\\10f11b";
}
.fad.fa-gamepad-alt:after {
  content: "\\10f8bc";
}
.fad.fa-garage:after {
  content: "\\10f909";
}
.fad.fa-garage-car:after {
  content: "\\10f90a";
}
.fad.fa-garage-open:after {
  content: "\\10f90b";
}
.fad.fa-gas-pump:after {
  content: "\\10f52f";
}
.fad.fa-gas-pump-slash:after {
  content: "\\10f5f4";
}
.fad.fa-gavel:after {
  content: "\\10f0e3";
}
.fad.fa-gem:after {
  content: "\\10f3a5";
}
.fad.fa-genderless:after {
  content: "\\10f22d";
}
.fad.fa-ghost:after {
  content: "\\10f6e2";
}
.fad.fa-gift:after {
  content: "\\10f06b";
}
.fad.fa-gift-card:after {
  content: "\\10f663";
}
.fad.fa-gifts:after {
  content: "\\10f79c";
}
.fad.fa-gingerbread-man:after {
  content: "\\10f79d";
}
.fad.fa-glass:after {
  content: "\\10f804";
}
.fad.fa-glass-champagne:after {
  content: "\\10f79e";
}
.fad.fa-glass-cheers:after {
  content: "\\10f79f";
}
.fad.fa-glass-citrus:after {
  content: "\\10f869";
}
.fad.fa-glass-martini:after {
  content: "\\10f000";
}
.fad.fa-glass-martini-alt:after {
  content: "\\10f57b";
}
.fad.fa-glass-whiskey:after {
  content: "\\10f7a0";
}
.fad.fa-glass-whiskey-rocks:after {
  content: "\\10f7a1";
}
.fad.fa-glasses:after {
  content: "\\10f530";
}
.fad.fa-glasses-alt:after {
  content: "\\10f5f5";
}
.fad.fa-globe:after {
  content: "\\10f0ac";
}
.fad.fa-globe-africa:after {
  content: "\\10f57c";
}
.fad.fa-globe-americas:after {
  content: "\\10f57d";
}
.fad.fa-globe-asia:after {
  content: "\\10f57e";
}
.fad.fa-globe-europe:after {
  content: "\\10f7a2";
}
.fad.fa-globe-snow:after {
  content: "\\10f7a3";
}
.fad.fa-globe-stand:after {
  content: "\\10f5f6";
}
.fad.fa-golf-ball:after {
  content: "\\10f450";
}
.fad.fa-golf-club:after {
  content: "\\10f451";
}
.fad.fa-gopuram:after {
  content: "\\10f664";
}
.fad.fa-graduation-cap:after {
  content: "\\10f19d";
}
.fad.fa-gramophone:after {
  content: "\\10f8bd";
}
.fad.fa-greater-than:after {
  content: "\\10f531";
}
.fad.fa-greater-than-equal:after {
  content: "\\10f532";
}
.fad.fa-grimace:after {
  content: "\\10f57f";
}
.fad.fa-grin:after {
  content: "\\10f580";
}
.fad.fa-grin-alt:after {
  content: "\\10f581";
}
.fad.fa-grin-beam:after {
  content: "\\10f582";
}
.fad.fa-grin-beam-sweat:after {
  content: "\\10f583";
}
.fad.fa-grin-hearts:after {
  content: "\\10f584";
}
.fad.fa-grin-squint:after {
  content: "\\10f585";
}
.fad.fa-grin-squint-tears:after {
  content: "\\10f586";
}
.fad.fa-grin-stars:after {
  content: "\\10f587";
}
.fad.fa-grin-tears:after {
  content: "\\10f588";
}
.fad.fa-grin-tongue:after {
  content: "\\10f589";
}
.fad.fa-grin-tongue-squint:after {
  content: "\\10f58a";
}
.fad.fa-grin-tongue-wink:after {
  content: "\\10f58b";
}
.fad.fa-grin-wink:after {
  content: "\\10f58c";
}
.fad.fa-grip-horizontal:after {
  content: "\\10f58d";
}
.fad.fa-grip-lines:after {
  content: "\\10f7a4";
}
.fad.fa-grip-lines-vertical:after {
  content: "\\10f7a5";
}
.fad.fa-grip-vertical:after {
  content: "\\10f58e";
}
.fad.fa-guitar:after {
  content: "\\10f7a6";
}
.fad.fa-guitar-electric:after {
  content: "\\10f8be";
}
.fad.fa-guitars:after {
  content: "\\10f8bf";
}
.fad.fa-h-square:after {
  content: "\\10f0fd";
}
.fad.fa-h1:after {
  content: "\\10f313";
}
.fad.fa-h2:after {
  content: "\\10f314";
}
.fad.fa-h3:after {
  content: "\\10f315";
}
.fad.fa-h4:after {
  content: "\\10f86a";
}
.fad.fa-hamburger:after {
  content: "\\10f805";
}
.fad.fa-hammer:after {
  content: "\\10f6e3";
}
.fad.fa-hammer-war:after {
  content: "\\10f6e4";
}
.fad.fa-hamsa:after {
  content: "\\10f665";
}
.fad.fa-hand-heart:after {
  content: "\\10f4bc";
}
.fad.fa-hand-holding:after {
  content: "\\10f4bd";
}
.fad.fa-hand-holding-box:after {
  content: "\\10f47b";
}
.fad.fa-hand-holding-heart:after {
  content: "\\10f4be";
}
.fad.fa-hand-holding-magic:after {
  content: "\\10f6e5";
}
.fad.fa-hand-holding-medical:after {
  content: "\\10f95c";
}
.fad.fa-hand-holding-seedling:after {
  content: "\\10f4bf";
}
.fad.fa-hand-holding-usd:after {
  content: "\\10f4c0";
}
.fad.fa-hand-holding-water:after {
  content: "\\10f4c1";
}
.fad.fa-hand-lizard:after {
  content: "\\10f258";
}
.fad.fa-hand-middle-finger:after {
  content: "\\10f806";
}
.fad.fa-hand-paper:after {
  content: "\\10f256";
}
.fad.fa-hand-peace:after {
  content: "\\10f25b";
}
.fad.fa-hand-point-down:after {
  content: "\\10f0a7";
}
.fad.fa-hand-point-left:after {
  content: "\\10f0a5";
}
.fad.fa-hand-point-right:after {
  content: "\\10f0a4";
}
.fad.fa-hand-point-up:after {
  content: "\\10f0a6";
}
.fad.fa-hand-pointer:after {
  content: "\\10f25a";
}
.fad.fa-hand-receiving:after {
  content: "\\10f47c";
}
.fad.fa-hand-rock:after {
  content: "\\10f255";
}
.fad.fa-hand-scissors:after {
  content: "\\10f257";
}
.fad.fa-hand-sparkles:after {
  content: "\\10f95d";
}
.fad.fa-hand-spock:after {
  content: "\\10f259";
}
.fad.fa-hands:after {
  content: "\\10f4c2";
}
.fad.fa-hands-heart:after {
  content: "\\10f4c3";
}
.fad.fa-hands-helping:after {
  content: "\\10f4c4";
}
.fad.fa-hands-usd:after {
  content: "\\10f4c5";
}
.fad.fa-hands-wash:after {
  content: "\\10f95e";
}
.fad.fa-handshake:after {
  content: "\\10f2b5";
}
.fad.fa-handshake-alt:after {
  content: "\\10f4c6";
}
.fad.fa-handshake-alt-slash:after {
  content: "\\10f95f";
}
.fad.fa-handshake-slash:after {
  content: "\\10f960";
}
.fad.fa-hanukiah:after {
  content: "\\10f6e6";
}
.fad.fa-hard-hat:after {
  content: "\\10f807";
}
.fad.fa-hashtag:after {
  content: "\\10f292";
}
.fad.fa-hat-chef:after {
  content: "\\10f86b";
}
.fad.fa-hat-cowboy:after {
  content: "\\10f8c0";
}
.fad.fa-hat-cowboy-side:after {
  content: "\\10f8c1";
}
.fad.fa-hat-santa:after {
  content: "\\10f7a7";
}
.fad.fa-hat-winter:after {
  content: "\\10f7a8";
}
.fad.fa-hat-witch:after {
  content: "\\10f6e7";
}
.fad.fa-hat-wizard:after {
  content: "\\10f6e8";
}
.fad.fa-hdd:after {
  content: "\\10f0a0";
}
.fad.fa-head-side:after {
  content: "\\10f6e9";
}
.fad.fa-head-side-brain:after {
  content: "\\10f808";
}
.fad.fa-head-side-cough:after {
  content: "\\10f961";
}
.fad.fa-head-side-cough-slash:after {
  content: "\\10f962";
}
.fad.fa-head-side-headphones:after {
  content: "\\10f8c2";
}
.fad.fa-head-side-mask:after {
  content: "\\10f963";
}
.fad.fa-head-side-medical:after {
  content: "\\10f809";
}
.fad.fa-head-side-virus:after {
  content: "\\10f964";
}
.fad.fa-head-vr:after {
  content: "\\10f6ea";
}
.fad.fa-heading:after {
  content: "\\10f1dc";
}
.fad.fa-headphones:after {
  content: "\\10f025";
}
.fad.fa-headphones-alt:after {
  content: "\\10f58f";
}
.fad.fa-headset:after {
  content: "\\10f590";
}
.fad.fa-heart:after {
  content: "\\10f004";
}
.fad.fa-heart-broken:after {
  content: "\\10f7a9";
}
.fad.fa-heart-circle:after {
  content: "\\10f4c7";
}
.fad.fa-heart-rate:after {
  content: "\\10f5f8";
}
.fad.fa-heart-square:after {
  content: "\\10f4c8";
}
.fad.fa-heartbeat:after {
  content: "\\10f21e";
}
.fad.fa-heat:after {
  content: "\\10f90c";
}
.fad.fa-helicopter:after {
  content: "\\10f533";
}
.fad.fa-helmet-battle:after {
  content: "\\10f6eb";
}
.fad.fa-hexagon:after {
  content: "\\10f312";
}
.fad.fa-highlighter:after {
  content: "\\10f591";
}
.fad.fa-hiking:after {
  content: "\\10f6ec";
}
.fad.fa-hippo:after {
  content: "\\10f6ed";
}
.fad.fa-history:after {
  content: "\\10f1da";
}
.fad.fa-hockey-mask:after {
  content: "\\10f6ee";
}
.fad.fa-hockey-puck:after {
  content: "\\10f453";
}
.fad.fa-hockey-sticks:after {
  content: "\\10f454";
}
.fad.fa-holly-berry:after {
  content: "\\10f7aa";
}
.fad.fa-home:after {
  content: "\\10f015";
}
.fad.fa-home-alt:after {
  content: "\\10f80a";
}
.fad.fa-home-heart:after {
  content: "\\10f4c9";
}
.fad.fa-home-lg:after {
  content: "\\10f80b";
}
.fad.fa-home-lg-alt:after {
  content: "\\10f80c";
}
.fad.fa-hood-cloak:after {
  content: "\\10f6ef";
}
.fad.fa-horizontal-rule:after {
  content: "\\10f86c";
}
.fad.fa-horse:after {
  content: "\\10f6f0";
}
.fad.fa-horse-head:after {
  content: "\\10f7ab";
}
.fad.fa-horse-saddle:after {
  content: "\\10f8c3";
}
.fad.fa-hospital:after {
  content: "\\10f0f8";
}
.fad.fa-hospital-alt:after {
  content: "\\10f47d";
}
.fad.fa-hospital-symbol:after {
  content: "\\10f47e";
}
.fad.fa-hospital-user:after {
  content: "\\10f80d";
}
.fad.fa-hospitals:after {
  content: "\\10f80e";
}
.fad.fa-hot-tub:after {
  content: "\\10f593";
}
.fad.fa-hotdog:after {
  content: "\\10f80f";
}
.fad.fa-hotel:after {
  content: "\\10f594";
}
.fad.fa-hourglass:after {
  content: "\\10f254";
}
.fad.fa-hourglass-end:after {
  content: "\\10f253";
}
.fad.fa-hourglass-half:after {
  content: "\\10f252";
}
.fad.fa-hourglass-start:after {
  content: "\\10f251";
}
.fad.fa-house:after {
  content: "\\10f90d";
}
.fad.fa-house-damage:after {
  content: "\\10f6f1";
}
.fad.fa-house-day:after {
  content: "\\10f90e";
}
.fad.fa-house-flood:after {
  content: "\\10f74f";
}
.fad.fa-house-leave:after {
  content: "\\10f90f";
}
.fad.fa-house-night:after {
  content: "\\10f910";
}
.fad.fa-house-return:after {
  content: "\\10f911";
}
.fad.fa-house-signal:after {
  content: "\\10f912";
}
.fad.fa-house-user:after {
  content: "\\10f965";
}
.fad.fa-hryvnia:after {
  content: "\\10f6f2";
}
.fad.fa-humidity:after {
  content: "\\10f750";
}
.fad.fa-hurricane:after {
  content: "\\10f751";
}
.fad.fa-i-cursor:after {
  content: "\\10f246";
}
.fad.fa-ice-cream:after {
  content: "\\10f810";
}
.fad.fa-ice-skate:after {
  content: "\\10f7ac";
}
.fad.fa-icicles:after {
  content: "\\10f7ad";
}
.fad.fa-icons:after {
  content: "\\10f86d";
}
.fad.fa-icons-alt:after {
  content: "\\10f86e";
}
.fad.fa-id-badge:after {
  content: "\\10f2c1";
}
.fad.fa-id-card:after {
  content: "\\10f2c2";
}
.fad.fa-id-card-alt:after {
  content: "\\10f47f";
}
.fad.fa-igloo:after {
  content: "\\10f7ae";
}
.fad.fa-image:after {
  content: "\\10f03e";
}
.fad.fa-image-polaroid:after {
  content: "\\10f8c4";
}
.fad.fa-images:after {
  content: "\\10f302";
}
.fad.fa-inbox:after {
  content: "\\10f01c";
}
.fad.fa-inbox-in:after {
  content: "\\10f310";
}
.fad.fa-inbox-out:after {
  content: "\\10f311";
}
.fad.fa-indent:after {
  content: "\\10f03c";
}
.fad.fa-industry:after {
  content: "\\10f275";
}
.fad.fa-industry-alt:after {
  content: "\\10f3b3";
}
.fad.fa-infinity:after {
  content: "\\10f534";
}
.fad.fa-info:after {
  content: "\\10f129";
}
.fad.fa-info-circle:after {
  content: "\\10f05a";
}
.fad.fa-info-square:after {
  content: "\\10f30f";
}
.fad.fa-inhaler:after {
  content: "\\10f5f9";
}
.fad.fa-integral:after {
  content: "\\10f667";
}
.fad.fa-intersection:after {
  content: "\\10f668";
}
.fad.fa-inventory:after {
  content: "\\10f480";
}
.fad.fa-island-tropical:after {
  content: "\\10f811";
}
.fad.fa-italic:after {
  content: "\\10f033";
}
.fad.fa-jack-o-lantern:after {
  content: "\\10f30e";
}
.fad.fa-jedi:after {
  content: "\\10f669";
}
.fad.fa-joint:after {
  content: "\\10f595";
}
.fad.fa-journal-whills:after {
  content: "\\10f66a";
}
.fad.fa-joystick:after {
  content: "\\10f8c5";
}
.fad.fa-jug:after {
  content: "\\10f8c6";
}
.fad.fa-kaaba:after {
  content: "\\10f66b";
}
.fad.fa-kazoo:after {
  content: "\\10f8c7";
}
.fad.fa-kerning:after {
  content: "\\10f86f";
}
.fad.fa-key:after {
  content: "\\10f084";
}
.fad.fa-key-skeleton:after {
  content: "\\10f6f3";
}
.fad.fa-keyboard:after {
  content: "\\10f11c";
}
.fad.fa-keynote:after {
  content: "\\10f66c";
}
.fad.fa-khanda:after {
  content: "\\10f66d";
}
.fad.fa-kidneys:after {
  content: "\\10f5fb";
}
.fad.fa-kiss:after {
  content: "\\10f596";
}
.fad.fa-kiss-beam:after {
  content: "\\10f597";
}
.fad.fa-kiss-wink-heart:after {
  content: "\\10f598";
}
.fad.fa-kite:after {
  content: "\\10f6f4";
}
.fad.fa-kiwi-bird:after {
  content: "\\10f535";
}
.fad.fa-knife-kitchen:after {
  content: "\\10f6f5";
}
.fad.fa-lambda:after {
  content: "\\10f66e";
}
.fad.fa-lamp:after {
  content: "\\10f4ca";
}
.fad.fa-lamp-desk:after {
  content: "\\10f914";
}
.fad.fa-lamp-floor:after {
  content: "\\10f915";
}
.fad.fa-landmark:after {
  content: "\\10f66f";
}
.fad.fa-landmark-alt:after {
  content: "\\10f752";
}
.fad.fa-language:after {
  content: "\\10f1ab";
}
.fad.fa-laptop:after {
  content: "\\10f109";
}
.fad.fa-laptop-code:after {
  content: "\\10f5fc";
}
.fad.fa-laptop-house:after {
  content: "\\10f966";
}
.fad.fa-laptop-medical:after {
  content: "\\10f812";
}
.fad.fa-lasso:after {
  content: "\\10f8c8";
}
.fad.fa-laugh:after {
  content: "\\10f599";
}
.fad.fa-laugh-beam:after {
  content: "\\10f59a";
}
.fad.fa-laugh-squint:after {
  content: "\\10f59b";
}
.fad.fa-laugh-wink:after {
  content: "\\10f59c";
}
.fad.fa-layer-group:after {
  content: "\\10f5fd";
}
.fad.fa-layer-minus:after {
  content: "\\10f5fe";
}
.fad.fa-layer-plus:after {
  content: "\\10f5ff";
}
.fad.fa-leaf:after {
  content: "\\10f06c";
}
.fad.fa-leaf-heart:after {
  content: "\\10f4cb";
}
.fad.fa-leaf-maple:after {
  content: "\\10f6f6";
}
.fad.fa-leaf-oak:after {
  content: "\\10f6f7";
}
.fad.fa-lemon:after {
  content: "\\10f094";
}
.fad.fa-less-than:after {
  content: "\\10f536";
}
.fad.fa-less-than-equal:after {
  content: "\\10f537";
}
.fad.fa-level-down:after {
  content: "\\10f149";
}
.fad.fa-level-down-alt:after {
  content: "\\10f3be";
}
.fad.fa-level-up:after {
  content: "\\10f148";
}
.fad.fa-level-up-alt:after {
  content: "\\10f3bf";
}
.fad.fa-life-ring:after {
  content: "\\10f1cd";
}
.fad.fa-light-ceiling:after {
  content: "\\10f916";
}
.fad.fa-light-switch:after {
  content: "\\10f917";
}
.fad.fa-light-switch-off:after {
  content: "\\10f918";
}
.fad.fa-light-switch-on:after {
  content: "\\10f919";
}
.fad.fa-lightbulb:after {
  content: "\\10f0eb";
}
.fad.fa-lightbulb-dollar:after {
  content: "\\10f670";
}
.fad.fa-lightbulb-exclamation:after {
  content: "\\10f671";
}
.fad.fa-lightbulb-on:after {
  content: "\\10f672";
}
.fad.fa-lightbulb-slash:after {
  content: "\\10f673";
}
.fad.fa-lights-holiday:after {
  content: "\\10f7b2";
}
.fad.fa-line-columns:after {
  content: "\\10f870";
}
.fad.fa-line-height:after {
  content: "\\10f871";
}
.fad.fa-link:after {
  content: "\\10f0c1";
}
.fad.fa-lips:after {
  content: "\\10f600";
}
.fad.fa-lira-sign:after {
  content: "\\10f195";
}
.fad.fa-list:after {
  content: "\\10f03a";
}
.fad.fa-list-alt:after {
  content: "\\10f022";
}
.fad.fa-list-music:after {
  content: "\\10f8c9";
}
.fad.fa-list-ol:after {
  content: "\\10f0cb";
}
.fad.fa-list-ul:after {
  content: "\\10f0ca";
}
.fad.fa-location:after {
  content: "\\10f601";
}
.fad.fa-location-arrow:after {
  content: "\\10f124";
}
.fad.fa-location-circle:after {
  content: "\\10f602";
}
.fad.fa-location-slash:after {
  content: "\\10f603";
}
.fad.fa-lock:after {
  content: "\\10f023";
}
.fad.fa-lock-alt:after {
  content: "\\10f30d";
}
.fad.fa-lock-open:after {
  content: "\\10f3c1";
}
.fad.fa-lock-open-alt:after {
  content: "\\10f3c2";
}
.fad.fa-long-arrow-alt-down:after {
  content: "\\10f309";
}
.fad.fa-long-arrow-alt-left:after {
  content: "\\10f30a";
}
.fad.fa-long-arrow-alt-right:after {
  content: "\\10f30b";
}
.fad.fa-long-arrow-alt-up:after {
  content: "\\10f30c";
}
.fad.fa-long-arrow-down:after {
  content: "\\10f175";
}
.fad.fa-long-arrow-left:after {
  content: "\\10f177";
}
.fad.fa-long-arrow-right:after {
  content: "\\10f178";
}
.fad.fa-long-arrow-up:after {
  content: "\\10f176";
}
.fad.fa-loveseat:after {
  content: "\\10f4cc";
}
.fad.fa-low-vision:after {
  content: "\\10f2a8";
}
.fad.fa-luchador:after {
  content: "\\10f455";
}
.fad.fa-luggage-cart:after {
  content: "\\10f59d";
}
.fad.fa-lungs:after {
  content: "\\10f604";
}
.fad.fa-lungs-virus:after {
  content: "\\10f967";
}
.fad.fa-mace:after {
  content: "\\10f6f8";
}
.fad.fa-magic:after {
  content: "\\10f0d0";
}
.fad.fa-magnet:after {
  content: "\\10f076";
}
.fad.fa-mail-bulk:after {
  content: "\\10f674";
}
.fad.fa-mailbox:after {
  content: "\\10f813";
}
.fad.fa-male:after {
  content: "\\10f183";
}
.fad.fa-mandolin:after {
  content: "\\10f6f9";
}
.fad.fa-map:after {
  content: "\\10f279";
}
.fad.fa-map-marked:after {
  content: "\\10f59f";
}
.fad.fa-map-marked-alt:after {
  content: "\\10f5a0";
}
.fad.fa-map-marker:after {
  content: "\\10f041";
}
.fad.fa-map-marker-alt:after {
  content: "\\10f3c5";
}
.fad.fa-map-marker-alt-slash:after {
  content: "\\10f605";
}
.fad.fa-map-marker-check:after {
  content: "\\10f606";
}
.fad.fa-map-marker-edit:after {
  content: "\\10f607";
}
.fad.fa-map-marker-exclamation:after {
  content: "\\10f608";
}
.fad.fa-map-marker-minus:after {
  content: "\\10f609";
}
.fad.fa-map-marker-plus:after {
  content: "\\10f60a";
}
.fad.fa-map-marker-question:after {
  content: "\\10f60b";
}
.fad.fa-map-marker-slash:after {
  content: "\\10f60c";
}
.fad.fa-map-marker-smile:after {
  content: "\\10f60d";
}
.fad.fa-map-marker-times:after {
  content: "\\10f60e";
}
.fad.fa-map-pin:after {
  content: "\\10f276";
}
.fad.fa-map-signs:after {
  content: "\\10f277";
}
.fad.fa-marker:after {
  content: "\\10f5a1";
}
.fad.fa-mars:after {
  content: "\\10f222";
}
.fad.fa-mars-double:after {
  content: "\\10f227";
}
.fad.fa-mars-stroke:after {
  content: "\\10f229";
}
.fad.fa-mars-stroke-h:after {
  content: "\\10f22b";
}
.fad.fa-mars-stroke-v:after {
  content: "\\10f22a";
}
.fad.fa-mask:after {
  content: "\\10f6fa";
}
.fad.fa-meat:after {
  content: "\\10f814";
}
.fad.fa-medal:after {
  content: "\\10f5a2";
}
.fad.fa-medkit:after {
  content: "\\10f0fa";
}
.fad.fa-megaphone:after {
  content: "\\10f675";
}
.fad.fa-meh:after {
  content: "\\10f11a";
}
.fad.fa-meh-blank:after {
  content: "\\10f5a4";
}
.fad.fa-meh-rolling-eyes:after {
  content: "\\10f5a5";
}
.fad.fa-memory:after {
  content: "\\10f538";
}
.fad.fa-menorah:after {
  content: "\\10f676";
}
.fad.fa-mercury:after {
  content: "\\10f223";
}
.fad.fa-meteor:after {
  content: "\\10f753";
}
.fad.fa-microchip:after {
  content: "\\10f2db";
}
.fad.fa-microphone:after {
  content: "\\10f130";
}
.fad.fa-microphone-alt:after {
  content: "\\10f3c9";
}
.fad.fa-microphone-alt-slash:after {
  content: "\\10f539";
}
.fad.fa-microphone-slash:after {
  content: "\\10f131";
}
.fad.fa-microphone-stand:after {
  content: "\\10f8cb";
}
.fad.fa-microscope:after {
  content: "\\10f610";
}
.fad.fa-microwave:after {
  content: "\\10f91b";
}
.fad.fa-mind-share:after {
  content: "\\10f677";
}
.fad.fa-minus:after {
  content: "\\10f068";
}
.fad.fa-minus-circle:after {
  content: "\\10f056";
}
.fad.fa-minus-hexagon:after {
  content: "\\10f307";
}
.fad.fa-minus-octagon:after {
  content: "\\10f308";
}
.fad.fa-minus-square:after {
  content: "\\10f146";
}
.fad.fa-mistletoe:after {
  content: "\\10f7b4";
}
.fad.fa-mitten:after {
  content: "\\10f7b5";
}
.fad.fa-mobile:after {
  content: "\\10f10b";
}
.fad.fa-mobile-alt:after {
  content: "\\10f3cd";
}
.fad.fa-mobile-android:after {
  content: "\\10f3ce";
}
.fad.fa-mobile-android-alt:after {
  content: "\\10f3cf";
}
.fad.fa-money-bill:after {
  content: "\\10f0d6";
}
.fad.fa-money-bill-alt:after {
  content: "\\10f3d1";
}
.fad.fa-money-bill-wave:after {
  content: "\\10f53a";
}
.fad.fa-money-bill-wave-alt:after {
  content: "\\10f53b";
}
.fad.fa-money-check:after {
  content: "\\10f53c";
}
.fad.fa-money-check-alt:after {
  content: "\\10f53d";
}
.fad.fa-money-check-edit:after {
  content: "\\10f872";
}
.fad.fa-money-check-edit-alt:after {
  content: "\\10f873";
}
.fad.fa-monitor-heart-rate:after {
  content: "\\10f611";
}
.fad.fa-monkey:after {
  content: "\\10f6fb";
}
.fad.fa-monument:after {
  content: "\\10f5a6";
}
.fad.fa-moon:after {
  content: "\\10f186";
}
.fad.fa-moon-cloud:after {
  content: "\\10f754";
}
.fad.fa-moon-stars:after {
  content: "\\10f755";
}
.fad.fa-mortar-pestle:after {
  content: "\\10f5a7";
}
.fad.fa-mosque:after {
  content: "\\10f678";
}
.fad.fa-motorcycle:after {
  content: "\\10f21c";
}
.fad.fa-mountain:after {
  content: "\\10f6fc";
}
.fad.fa-mountains:after {
  content: "\\10f6fd";
}
.fad.fa-mouse:after {
  content: "\\10f8cc";
}
.fad.fa-mouse-alt:after {
  content: "\\10f8cd";
}
.fad.fa-mouse-pointer:after {
  content: "\\10f245";
}
.fad.fa-mp3-player:after {
  content: "\\10f8ce";
}
.fad.fa-mug:after {
  content: "\\10f874";
}
.fad.fa-mug-hot:after {
  content: "\\10f7b6";
}
.fad.fa-mug-marshmallows:after {
  content: "\\10f7b7";
}
.fad.fa-mug-tea:after {
  content: "\\10f875";
}
.fad.fa-music:after {
  content: "\\10f001";
}
.fad.fa-music-alt:after {
  content: "\\10f8cf";
}
.fad.fa-music-alt-slash:after {
  content: "\\10f8d0";
}
.fad.fa-music-slash:after {
  content: "\\10f8d1";
}
.fad.fa-narwhal:after {
  content: "\\10f6fe";
}
.fad.fa-network-wired:after {
  content: "\\10f6ff";
}
.fad.fa-neuter:after {
  content: "\\10f22c";
}
.fad.fa-newspaper:after {
  content: "\\10f1ea";
}
.fad.fa-not-equal:after {
  content: "\\10f53e";
}
.fad.fa-notes-medical:after {
  content: "\\10f481";
}
.fad.fa-object-group:after {
  content: "\\10f247";
}
.fad.fa-object-ungroup:after {
  content: "\\10f248";
}
.fad.fa-octagon:after {
  content: "\\10f306";
}
.fad.fa-oil-can:after {
  content: "\\10f613";
}
.fad.fa-oil-temp:after {
  content: "\\10f614";
}
.fad.fa-om:after {
  content: "\\10f679";
}
.fad.fa-omega:after {
  content: "\\10f67a";
}
.fad.fa-ornament:after {
  content: "\\10f7b8";
}
.fad.fa-otter:after {
  content: "\\10f700";
}
.fad.fa-outdent:after {
  content: "\\10f03b";
}
.fad.fa-outlet:after {
  content: "\\10f91c";
}
.fad.fa-oven:after {
  content: "\\10f91d";
}
.fad.fa-overline:after {
  content: "\\10f876";
}
.fad.fa-page-break:after {
  content: "\\10f877";
}
.fad.fa-pager:after {
  content: "\\10f815";
}
.fad.fa-paint-brush:after {
  content: "\\10f1fc";
}
.fad.fa-paint-brush-alt:after {
  content: "\\10f5a9";
}
.fad.fa-paint-roller:after {
  content: "\\10f5aa";
}
.fad.fa-palette:after {
  content: "\\10f53f";
}
.fad.fa-pallet:after {
  content: "\\10f482";
}
.fad.fa-pallet-alt:after {
  content: "\\10f483";
}
.fad.fa-paper-plane:after {
  content: "\\10f1d8";
}
.fad.fa-paperclip:after {
  content: "\\10f0c6";
}
.fad.fa-parachute-box:after {
  content: "\\10f4cd";
}
.fad.fa-paragraph:after {
  content: "\\10f1dd";
}
.fad.fa-paragraph-rtl:after {
  content: "\\10f878";
}
.fad.fa-parking:after {
  content: "\\10f540";
}
.fad.fa-parking-circle:after {
  content: "\\10f615";
}
.fad.fa-parking-circle-slash:after {
  content: "\\10f616";
}
.fad.fa-parking-slash:after {
  content: "\\10f617";
}
.fad.fa-passport:after {
  content: "\\10f5ab";
}
.fad.fa-pastafarianism:after {
  content: "\\10f67b";
}
.fad.fa-paste:after {
  content: "\\10f0ea";
}
.fad.fa-pause:after {
  content: "\\10f04c";
}
.fad.fa-pause-circle:after {
  content: "\\10f28b";
}
.fad.fa-paw:after {
  content: "\\10f1b0";
}
.fad.fa-paw-alt:after {
  content: "\\10f701";
}
.fad.fa-paw-claws:after {
  content: "\\10f702";
}
.fad.fa-peace:after {
  content: "\\10f67c";
}
.fad.fa-pegasus:after {
  content: "\\10f703";
}
.fad.fa-pen:after {
  content: "\\10f304";
}
.fad.fa-pen-alt:after {
  content: "\\10f305";
}
.fad.fa-pen-fancy:after {
  content: "\\10f5ac";
}
.fad.fa-pen-nib:after {
  content: "\\10f5ad";
}
.fad.fa-pen-square:after {
  content: "\\10f14b";
}
.fad.fa-pencil:after {
  content: "\\10f040";
}
.fad.fa-pencil-alt:after {
  content: "\\10f303";
}
.fad.fa-pencil-paintbrush:after {
  content: "\\10f618";
}
.fad.fa-pencil-ruler:after {
  content: "\\10f5ae";
}
.fad.fa-pennant:after {
  content: "\\10f456";
}
.fad.fa-people-arrows:after {
  content: "\\10f968";
}
.fad.fa-people-carry:after {
  content: "\\10f4ce";
}
.fad.fa-pepper-hot:after {
  content: "\\10f816";
}
.fad.fa-percent:after {
  content: "\\10f295";
}
.fad.fa-percentage:after {
  content: "\\10f541";
}
.fad.fa-person-booth:after {
  content: "\\10f756";
}
.fad.fa-person-carry:after {
  content: "\\10f4cf";
}
.fad.fa-person-dolly:after {
  content: "\\10f4d0";
}
.fad.fa-person-dolly-empty:after {
  content: "\\10f4d1";
}
.fad.fa-person-sign:after {
  content: "\\10f757";
}
.fad.fa-phone:after {
  content: "\\10f095";
}
.fad.fa-phone-alt:after {
  content: "\\10f879";
}
.fad.fa-phone-laptop:after {
  content: "\\10f87a";
}
.fad.fa-phone-office:after {
  content: "\\10f67d";
}
.fad.fa-phone-plus:after {
  content: "\\10f4d2";
}
.fad.fa-phone-rotary:after {
  content: "\\10f8d3";
}
.fad.fa-phone-slash:after {
  content: "\\10f3dd";
}
.fad.fa-phone-square:after {
  content: "\\10f098";
}
.fad.fa-phone-square-alt:after {
  content: "\\10f87b";
}
.fad.fa-phone-volume:after {
  content: "\\10f2a0";
}
.fad.fa-photo-video:after {
  content: "\\10f87c";
}
.fad.fa-pi:after {
  content: "\\10f67e";
}
.fad.fa-piano:after {
  content: "\\10f8d4";
}
.fad.fa-piano-keyboard:after {
  content: "\\10f8d5";
}
.fad.fa-pie:after {
  content: "\\10f705";
}
.fad.fa-pig:after {
  content: "\\10f706";
}
.fad.fa-piggy-bank:after {
  content: "\\10f4d3";
}
.fad.fa-pills:after {
  content: "\\10f484";
}
.fad.fa-pizza:after {
  content: "\\10f817";
}
.fad.fa-pizza-slice:after {
  content: "\\10f818";
}
.fad.fa-place-of-worship:after {
  content: "\\10f67f";
}
.fad.fa-plane:after {
  content: "\\10f072";
}
.fad.fa-plane-alt:after {
  content: "\\10f3de";
}
.fad.fa-plane-arrival:after {
  content: "\\10f5af";
}
.fad.fa-plane-departure:after {
  content: "\\10f5b0";
}
.fad.fa-plane-slash:after {
  content: "\\10f969";
}
.fad.fa-planet-moon:after {
  content: "\\10f91f";
}
.fad.fa-planet-ringed:after {
  content: "\\10f920";
}
.fad.fa-play:after {
  content: "\\10f04b";
}
.fad.fa-play-circle:after {
  content: "\\10f144";
}
.fad.fa-plug:after {
  content: "\\10f1e6";
}
.fad.fa-plus:after {
  content: "\\10f067";
}
.fad.fa-plus-circle:after {
  content: "\\10f055";
}
.fad.fa-plus-hexagon:after {
  content: "\\10f300";
}
.fad.fa-plus-octagon:after {
  content: "\\10f301";
}
.fad.fa-plus-square:after {
  content: "\\10f0fe";
}
.fad.fa-podcast:after {
  content: "\\10f2ce";
}
.fad.fa-podium:after {
  content: "\\10f680";
}
.fad.fa-podium-star:after {
  content: "\\10f758";
}
.fad.fa-police-box:after {
  content: "\\10f921";
}
.fad.fa-poll:after {
  content: "\\10f681";
}
.fad.fa-poll-h:after {
  content: "\\10f682";
}
.fad.fa-poll-people:after {
  content: "\\10f759";
}
.fad.fa-poo:after {
  content: "\\10f2fe";
}
.fad.fa-poo-storm:after {
  content: "\\10f75a";
}
.fad.fa-poop:after {
  content: "\\10f619";
}
.fad.fa-popcorn:after {
  content: "\\10f819";
}
.fad.fa-portal-enter:after {
  content: "\\10f922";
}
.fad.fa-portal-exit:after {
  content: "\\10f923";
}
.fad.fa-portrait:after {
  content: "\\10f3e0";
}
.fad.fa-pound-sign:after {
  content: "\\10f154";
}
.fad.fa-power-off:after {
  content: "\\10f011";
}
.fad.fa-pray:after {
  content: "\\10f683";
}
.fad.fa-praying-hands:after {
  content: "\\10f684";
}
.fad.fa-prescription:after {
  content: "\\10f5b1";
}
.fad.fa-prescription-bottle:after {
  content: "\\10f485";
}
.fad.fa-prescription-bottle-alt:after {
  content: "\\10f486";
}
.fad.fa-presentation:after {
  content: "\\10f685";
}
.fad.fa-print:after {
  content: "\\10f02f";
}
.fad.fa-print-search:after {
  content: "\\10f81a";
}
.fad.fa-print-slash:after {
  content: "\\10f686";
}
.fad.fa-procedures:after {
  content: "\\10f487";
}
.fad.fa-project-diagram:after {
  content: "\\10f542";
}
.fad.fa-projector:after {
  content: "\\10f8d6";
}
.fad.fa-pump-medical:after {
  content: "\\10f96a";
}
.fad.fa-pump-soap:after {
  content: "\\10f96b";
}
.fad.fa-pumpkin:after {
  content: "\\10f707";
}
.fad.fa-puzzle-piece:after {
  content: "\\10f12e";
}
.fad.fa-qrcode:after {
  content: "\\10f029";
}
.fad.fa-question:after {
  content: "\\10f128";
}
.fad.fa-question-circle:after {
  content: "\\10f059";
}
.fad.fa-question-square:after {
  content: "\\10f2fd";
}
.fad.fa-quidditch:after {
  content: "\\10f458";
}
.fad.fa-quote-left:after {
  content: "\\10f10d";
}
.fad.fa-quote-right:after {
  content: "\\10f10e";
}
.fad.fa-quran:after {
  content: "\\10f687";
}
.fad.fa-rabbit:after {
  content: "\\10f708";
}
.fad.fa-rabbit-fast:after {
  content: "\\10f709";
}
.fad.fa-racquet:after {
  content: "\\10f45a";
}
.fad.fa-radar:after {
  content: "\\10f924";
}
.fad.fa-radiation:after {
  content: "\\10f7b9";
}
.fad.fa-radiation-alt:after {
  content: "\\10f7ba";
}
.fad.fa-radio:after {
  content: "\\10f8d7";
}
.fad.fa-radio-alt:after {
  content: "\\10f8d8";
}
.fad.fa-rainbow:after {
  content: "\\10f75b";
}
.fad.fa-raindrops:after {
  content: "\\10f75c";
}
.fad.fa-ram:after {
  content: "\\10f70a";
}
.fad.fa-ramp-loading:after {
  content: "\\10f4d4";
}
.fad.fa-random:after {
  content: "\\10f074";
}
.fad.fa-raygun:after {
  content: "\\10f925";
}
.fad.fa-receipt:after {
  content: "\\10f543";
}
.fad.fa-record-vinyl:after {
  content: "\\10f8d9";
}
.fad.fa-rectangle-landscape:after {
  content: "\\10f2fa";
}
.fad.fa-rectangle-portrait:after {
  content: "\\10f2fb";
}
.fad.fa-rectangle-wide:after {
  content: "\\10f2fc";
}
.fad.fa-recycle:after {
  content: "\\10f1b8";
}
.fad.fa-redo:after {
  content: "\\10f01e";
}
.fad.fa-redo-alt:after {
  content: "\\10f2f9";
}
.fad.fa-refrigerator:after {
  content: "\\10f926";
}
.fad.fa-registered:after {
  content: "\\10f25d";
}
.fad.fa-remove-format:after {
  content: "\\10f87d";
}
.fad.fa-repeat:after {
  content: "\\10f363";
}
.fad.fa-repeat-1:after {
  content: "\\10f365";
}
.fad.fa-repeat-1-alt:after {
  content: "\\10f366";
}
.fad.fa-repeat-alt:after {
  content: "\\10f364";
}
.fad.fa-reply:after {
  content: "\\10f3e5";
}
.fad.fa-reply-all:after {
  content: "\\10f122";
}
.fad.fa-republican:after {
  content: "\\10f75e";
}
.fad.fa-restroom:after {
  content: "\\10f7bd";
}
.fad.fa-retweet:after {
  content: "\\10f079";
}
.fad.fa-retweet-alt:after {
  content: "\\10f361";
}
.fad.fa-ribbon:after {
  content: "\\10f4d6";
}
.fad.fa-ring:after {
  content: "\\10f70b";
}
.fad.fa-rings-wedding:after {
  content: "\\10f81b";
}
.fad.fa-road:after {
  content: "\\10f018";
}
.fad.fa-robot:after {
  content: "\\10f544";
}
.fad.fa-rocket:after {
  content: "\\10f135";
}
.fad.fa-rocket-launch:after {
  content: "\\10f927";
}
.fad.fa-route:after {
  content: "\\10f4d7";
}
.fad.fa-route-highway:after {
  content: "\\10f61a";
}
.fad.fa-route-interstate:after {
  content: "\\10f61b";
}
.fad.fa-router:after {
  content: "\\10f8da";
}
.fad.fa-rss:after {
  content: "\\10f09e";
}
.fad.fa-rss-square:after {
  content: "\\10f143";
}
.fad.fa-ruble-sign:after {
  content: "\\10f158";
}
.fad.fa-ruler:after {
  content: "\\10f545";
}
.fad.fa-ruler-combined:after {
  content: "\\10f546";
}
.fad.fa-ruler-horizontal:after {
  content: "\\10f547";
}
.fad.fa-ruler-triangle:after {
  content: "\\10f61c";
}
.fad.fa-ruler-vertical:after {
  content: "\\10f548";
}
.fad.fa-running:after {
  content: "\\10f70c";
}
.fad.fa-rupee-sign:after {
  content: "\\10f156";
}
.fad.fa-rv:after {
  content: "\\10f7be";
}
.fad.fa-sack:after {
  content: "\\10f81c";
}
.fad.fa-sack-dollar:after {
  content: "\\10f81d";
}
.fad.fa-sad-cry:after {
  content: "\\10f5b3";
}
.fad.fa-sad-tear:after {
  content: "\\10f5b4";
}
.fad.fa-salad:after {
  content: "\\10f81e";
}
.fad.fa-sandwich:after {
  content: "\\10f81f";
}
.fad.fa-satellite:after {
  content: "\\10f7bf";
}
.fad.fa-satellite-dish:after {
  content: "\\10f7c0";
}
.fad.fa-sausage:after {
  content: "\\10f820";
}
.fad.fa-save:after {
  content: "\\10f0c7";
}
.fad.fa-sax-hot:after {
  content: "\\10f8db";
}
.fad.fa-saxophone:after {
  content: "\\10f8dc";
}
.fad.fa-scalpel:after {
  content: "\\10f61d";
}
.fad.fa-scalpel-path:after {
  content: "\\10f61e";
}
.fad.fa-scanner:after {
  content: "\\10f488";
}
.fad.fa-scanner-image:after {
  content: "\\10f8f3";
}
.fad.fa-scanner-keyboard:after {
  content: "\\10f489";
}
.fad.fa-scanner-touchscreen:after {
  content: "\\10f48a";
}
.fad.fa-scarecrow:after {
  content: "\\10f70d";
}
.fad.fa-scarf:after {
  content: "\\10f7c1";
}
.fad.fa-school:after {
  content: "\\10f549";
}
.fad.fa-screwdriver:after {
  content: "\\10f54a";
}
.fad.fa-scroll:after {
  content: "\\10f70e";
}
.fad.fa-scroll-old:after {
  content: "\\10f70f";
}
.fad.fa-scrubber:after {
  content: "\\10f2f8";
}
.fad.fa-scythe:after {
  content: "\\10f710";
}
.fad.fa-sd-card:after {
  content: "\\10f7c2";
}
.fad.fa-search:after {
  content: "\\10f002";
}
.fad.fa-search-dollar:after {
  content: "\\10f688";
}
.fad.fa-search-location:after {
  content: "\\10f689";
}
.fad.fa-search-minus:after {
  content: "\\10f010";
}
.fad.fa-search-plus:after {
  content: "\\10f00e";
}
.fad.fa-seedling:after {
  content: "\\10f4d8";
}
.fad.fa-send-back:after {
  content: "\\10f87e";
}
.fad.fa-send-backward:after {
  content: "\\10f87f";
}
.fad.fa-sensor:after {
  content: "\\10f928";
}
.fad.fa-sensor-alert:after {
  content: "\\10f929";
}
.fad.fa-sensor-fire:after {
  content: "\\10f92a";
}
.fad.fa-sensor-on:after {
  content: "\\10f92b";
}
.fad.fa-sensor-smoke:after {
  content: "\\10f92c";
}
.fad.fa-server:after {
  content: "\\10f233";
}
.fad.fa-shapes:after {
  content: "\\10f61f";
}
.fad.fa-share:after {
  content: "\\10f064";
}
.fad.fa-share-all:after {
  content: "\\10f367";
}
.fad.fa-share-alt:after {
  content: "\\10f1e0";
}
.fad.fa-share-alt-square:after {
  content: "\\10f1e1";
}
.fad.fa-share-square:after {
  content: "\\10f14d";
}
.fad.fa-sheep:after {
  content: "\\10f711";
}
.fad.fa-shekel-sign:after {
  content: "\\10f20b";
}
.fad.fa-shield:after {
  content: "\\10f132";
}
.fad.fa-shield-alt:after {
  content: "\\10f3ed";
}
.fad.fa-shield-check:after {
  content: "\\10f2f7";
}
.fad.fa-shield-cross:after {
  content: "\\10f712";
}
.fad.fa-shield-virus:after {
  content: "\\10f96c";
}
.fad.fa-ship:after {
  content: "\\10f21a";
}
.fad.fa-shipping-fast:after {
  content: "\\10f48b";
}
.fad.fa-shipping-timed:after {
  content: "\\10f48c";
}
.fad.fa-shish-kebab:after {
  content: "\\10f821";
}
.fad.fa-shoe-prints:after {
  content: "\\10f54b";
}
.fad.fa-shopping-bag:after {
  content: "\\10f290";
}
.fad.fa-shopping-basket:after {
  content: "\\10f291";
}
.fad.fa-shopping-cart:after {
  content: "\\10f07a";
}
.fad.fa-shovel:after {
  content: "\\10f713";
}
.fad.fa-shovel-snow:after {
  content: "\\10f7c3";
}
.fad.fa-shower:after {
  content: "\\10f2cc";
}
.fad.fa-shredder:after {
  content: "\\10f68a";
}
.fad.fa-shuttle-van:after {
  content: "\\10f5b6";
}
.fad.fa-shuttlecock:after {
  content: "\\10f45b";
}
.fad.fa-sickle:after {
  content: "\\10f822";
}
.fad.fa-sigma:after {
  content: "\\10f68b";
}
.fad.fa-sign:after {
  content: "\\10f4d9";
}
.fad.fa-sign-in:after {
  content: "\\10f090";
}
.fad.fa-sign-in-alt:after {
  content: "\\10f2f6";
}
.fad.fa-sign-language:after {
  content: "\\10f2a7";
}
.fad.fa-sign-out:after {
  content: "\\10f08b";
}
.fad.fa-sign-out-alt:after {
  content: "\\10f2f5";
}
.fad.fa-signal:after {
  content: "\\10f012";
}
.fad.fa-signal-1:after {
  content: "\\10f68c";
}
.fad.fa-signal-2:after {
  content: "\\10f68d";
}
.fad.fa-signal-3:after {
  content: "\\10f68e";
}
.fad.fa-signal-4:after {
  content: "\\10f68f";
}
.fad.fa-signal-alt:after {
  content: "\\10f690";
}
.fad.fa-signal-alt-1:after {
  content: "\\10f691";
}
.fad.fa-signal-alt-2:after {
  content: "\\10f692";
}
.fad.fa-signal-alt-3:after {
  content: "\\10f693";
}
.fad.fa-signal-alt-slash:after {
  content: "\\10f694";
}
.fad.fa-signal-slash:after {
  content: "\\10f695";
}
.fad.fa-signal-stream:after {
  content: "\\10f8dd";
}
.fad.fa-signature:after {
  content: "\\10f5b7";
}
.fad.fa-sim-card:after {
  content: "\\10f7c4";
}
.fad.fa-sink:after {
  content: "\\10f96d";
}
.fad.fa-siren:after {
  content: "\\10f92d";
}
.fad.fa-siren-on:after {
  content: "\\10f92e";
}
.fad.fa-sitemap:after {
  content: "\\10f0e8";
}
.fad.fa-skating:after {
  content: "\\10f7c5";
}
.fad.fa-skeleton:after {
  content: "\\10f620";
}
.fad.fa-ski-jump:after {
  content: "\\10f7c7";
}
.fad.fa-ski-lift:after {
  content: "\\10f7c8";
}
.fad.fa-skiing:after {
  content: "\\10f7c9";
}
.fad.fa-skiing-nordic:after {
  content: "\\10f7ca";
}
.fad.fa-skull:after {
  content: "\\10f54c";
}
.fad.fa-skull-cow:after {
  content: "\\10f8de";
}
.fad.fa-skull-crossbones:after {
  content: "\\10f714";
}
.fad.fa-slash:after {
  content: "\\10f715";
}
.fad.fa-sledding:after {
  content: "\\10f7cb";
}
.fad.fa-sleigh:after {
  content: "\\10f7cc";
}
.fad.fa-sliders-h:after {
  content: "\\10f1de";
}
.fad.fa-sliders-h-square:after {
  content: "\\10f3f0";
}
.fad.fa-sliders-v:after {
  content: "\\10f3f1";
}
.fad.fa-sliders-v-square:after {
  content: "\\10f3f2";
}
.fad.fa-smile:after {
  content: "\\10f118";
}
.fad.fa-smile-beam:after {
  content: "\\10f5b8";
}
.fad.fa-smile-plus:after {
  content: "\\10f5b9";
}
.fad.fa-smile-wink:after {
  content: "\\10f4da";
}
.fad.fa-smog:after {
  content: "\\10f75f";
}
.fad.fa-smoke:after {
  content: "\\10f760";
}
.fad.fa-smoking:after {
  content: "\\10f48d";
}
.fad.fa-smoking-ban:after {
  content: "\\10f54d";
}
.fad.fa-sms:after {
  content: "\\10f7cd";
}
.fad.fa-snake:after {
  content: "\\10f716";
}
.fad.fa-snooze:after {
  content: "\\10f880";
}
.fad.fa-snow-blowing:after {
  content: "\\10f761";
}
.fad.fa-snowboarding:after {
  content: "\\10f7ce";
}
.fad.fa-snowflake:after {
  content: "\\10f2dc";
}
.fad.fa-snowflakes:after {
  content: "\\10f7cf";
}
.fad.fa-snowman:after {
  content: "\\10f7d0";
}
.fad.fa-snowmobile:after {
  content: "\\10f7d1";
}
.fad.fa-snowplow:after {
  content: "\\10f7d2";
}
.fad.fa-soap:after {
  content: "\\10f96e";
}
.fad.fa-socks:after {
  content: "\\10f696";
}
.fad.fa-solar-panel:after {
  content: "\\10f5ba";
}
.fad.fa-solar-system:after {
  content: "\\10f92f";
}
.fad.fa-sort:after {
  content: "\\10f0dc";
}
.fad.fa-sort-alpha-down:after {
  content: "\\10f15d";
}
.fad.fa-sort-alpha-down-alt:after {
  content: "\\10f881";
}
.fad.fa-sort-alpha-up:after {
  content: "\\10f15e";
}
.fad.fa-sort-alpha-up-alt:after {
  content: "\\10f882";
}
.fad.fa-sort-alt:after {
  content: "\\10f883";
}
.fad.fa-sort-amount-down:after {
  content: "\\10f160";
}
.fad.fa-sort-amount-down-alt:after {
  content: "\\10f884";
}
.fad.fa-sort-amount-up:after {
  content: "\\10f161";
}
.fad.fa-sort-amount-up-alt:after {
  content: "\\10f885";
}
.fad.fa-sort-circle:after {
  content: "\\10f930";
}
.fad.fa-sort-circle-down:after {
  content: "\\10f931";
}
.fad.fa-sort-circle-up:after {
  content: "\\10f932";
}
.fad.fa-sort-down:after {
  content: "\\10f0dd";
}
.fad.fa-sort-numeric-down:after {
  content: "\\10f162";
}
.fad.fa-sort-numeric-down-alt:after {
  content: "\\10f886";
}
.fad.fa-sort-numeric-up:after {
  content: "\\10f163";
}
.fad.fa-sort-numeric-up-alt:after {
  content: "\\10f887";
}
.fad.fa-sort-shapes-down:after {
  content: "\\10f888";
}
.fad.fa-sort-shapes-down-alt:after {
  content: "\\10f889";
}
.fad.fa-sort-shapes-up:after {
  content: "\\10f88a";
}
.fad.fa-sort-shapes-up-alt:after {
  content: "\\10f88b";
}
.fad.fa-sort-size-down:after {
  content: "\\10f88c";
}
.fad.fa-sort-size-down-alt:after {
  content: "\\10f88d";
}
.fad.fa-sort-size-up:after {
  content: "\\10f88e";
}
.fad.fa-sort-size-up-alt:after {
  content: "\\10f88f";
}
.fad.fa-sort-up:after {
  content: "\\10f0de";
}
.fad.fa-soup:after {
  content: "\\10f823";
}
.fad.fa-spa:after {
  content: "\\10f5bb";
}
.fad.fa-space-shuttle:after {
  content: "\\10f197";
}
.fad.fa-space-station-moon:after {
  content: "\\10f933";
}
.fad.fa-space-station-moon-alt:after {
  content: "\\10f934";
}
.fad.fa-spade:after {
  content: "\\10f2f4";
}
.fad.fa-sparkles:after {
  content: "\\10f890";
}
.fad.fa-speaker:after {
  content: "\\10f8df";
}
.fad.fa-speakers:after {
  content: "\\10f8e0";
}
.fad.fa-spell-check:after {
  content: "\\10f891";
}
.fad.fa-spider:after {
  content: "\\10f717";
}
.fad.fa-spider-black-widow:after {
  content: "\\10f718";
}
.fad.fa-spider-web:after {
  content: "\\10f719";
}
.fad.fa-spinner:after {
  content: "\\10f110";
}
.fad.fa-spinner-third:after {
  content: "\\10f3f4";
}
.fad.fa-splotch:after {
  content: "\\10f5bc";
}
.fad.fa-spray-can:after {
  content: "\\10f5bd";
}
.fad.fa-sprinkler:after {
  content: "\\10f935";
}
.fad.fa-square:after {
  content: "\\10f0c8";
}
.fad.fa-square-full:after {
  content: "\\10f45c";
}
.fad.fa-square-root:after {
  content: "\\10f697";
}
.fad.fa-square-root-alt:after {
  content: "\\10f698";
}
.fad.fa-squirrel:after {
  content: "\\10f71a";
}
.fad.fa-staff:after {
  content: "\\10f71b";
}
.fad.fa-stamp:after {
  content: "\\10f5bf";
}
.fad.fa-star:after {
  content: "\\10f005";
}
.fad.fa-star-and-crescent:after {
  content: "\\10f699";
}
.fad.fa-star-christmas:after {
  content: "\\10f7d4";
}
.fad.fa-star-exclamation:after {
  content: "\\10f2f3";
}
.fad.fa-star-half:after {
  content: "\\10f089";
}
.fad.fa-star-half-alt:after {
  content: "\\10f5c0";
}
.fad.fa-star-of-david:after {
  content: "\\10f69a";
}
.fad.fa-star-of-life:after {
  content: "\\10f621";
}
.fad.fa-star-shooting:after {
  content: "\\10f936";
}
.fad.fa-starfighter:after {
  content: "\\10f937";
}
.fad.fa-starfighter-alt:after {
  content: "\\10f938";
}
.fad.fa-stars:after {
  content: "\\10f762";
}
.fad.fa-starship:after {
  content: "\\10f939";
}
.fad.fa-starship-freighter:after {
  content: "\\10f93a";
}
.fad.fa-steak:after {
  content: "\\10f824";
}
.fad.fa-steering-wheel:after {
  content: "\\10f622";
}
.fad.fa-step-backward:after {
  content: "\\10f048";
}
.fad.fa-step-forward:after {
  content: "\\10f051";
}
.fad.fa-stethoscope:after {
  content: "\\10f0f1";
}
.fad.fa-sticky-note:after {
  content: "\\10f249";
}
.fad.fa-stocking:after {
  content: "\\10f7d5";
}
.fad.fa-stomach:after {
  content: "\\10f623";
}
.fad.fa-stop:after {
  content: "\\10f04d";
}
.fad.fa-stop-circle:after {
  content: "\\10f28d";
}
.fad.fa-stopwatch:after {
  content: "\\10f2f2";
}
.fad.fa-stopwatch-20:after {
  content: "\\10f96f";
}
.fad.fa-store:after {
  content: "\\10f54e";
}
.fad.fa-store-alt:after {
  content: "\\10f54f";
}
.fad.fa-store-alt-slash:after {
  content: "\\10f970";
}
.fad.fa-store-slash:after {
  content: "\\10f971";
}
.fad.fa-stream:after {
  content: "\\10f550";
}
.fad.fa-street-view:after {
  content: "\\10f21d";
}
.fad.fa-stretcher:after {
  content: "\\10f825";
}
.fad.fa-strikethrough:after {
  content: "\\10f0cc";
}
.fad.fa-stroopwafel:after {
  content: "\\10f551";
}
.fad.fa-subscript:after {
  content: "\\10f12c";
}
.fad.fa-subway:after {
  content: "\\10f239";
}
.fad.fa-suitcase:after {
  content: "\\10f0f2";
}
.fad.fa-suitcase-rolling:after {
  content: "\\10f5c1";
}
.fad.fa-sun:after {
  content: "\\10f185";
}
.fad.fa-sun-cloud:after {
  content: "\\10f763";
}
.fad.fa-sun-dust:after {
  content: "\\10f764";
}
.fad.fa-sun-haze:after {
  content: "\\10f765";
}
.fad.fa-sunglasses:after {
  content: "\\10f892";
}
.fad.fa-sunrise:after {
  content: "\\10f766";
}
.fad.fa-sunset:after {
  content: "\\10f767";
}
.fad.fa-superscript:after {
  content: "\\10f12b";
}
.fad.fa-surprise:after {
  content: "\\10f5c2";
}
.fad.fa-swatchbook:after {
  content: "\\10f5c3";
}
.fad.fa-swimmer:after {
  content: "\\10f5c4";
}
.fad.fa-swimming-pool:after {
  content: "\\10f5c5";
}
.fad.fa-sword:after {
  content: "\\10f71c";
}
.fad.fa-sword-laser:after {
  content: "\\10f93b";
}
.fad.fa-sword-laser-alt:after {
  content: "\\10f93c";
}
.fad.fa-swords:after {
  content: "\\10f71d";
}
.fad.fa-swords-laser:after {
  content: "\\10f93d";
}
.fad.fa-synagogue:after {
  content: "\\10f69b";
}
.fad.fa-sync:after {
  content: "\\10f021";
}
.fad.fa-sync-alt:after {
  content: "\\10f2f1";
}
.fad.fa-syringe:after {
  content: "\\10f48e";
}
.fad.fa-table:after {
  content: "\\10f0ce";
}
.fad.fa-table-tennis:after {
  content: "\\10f45d";
}
.fad.fa-tablet:after {
  content: "\\10f10a";
}
.fad.fa-tablet-alt:after {
  content: "\\10f3fa";
}
.fad.fa-tablet-android:after {
  content: "\\10f3fb";
}
.fad.fa-tablet-android-alt:after {
  content: "\\10f3fc";
}
.fad.fa-tablet-rugged:after {
  content: "\\10f48f";
}
.fad.fa-tablets:after {
  content: "\\10f490";
}
.fad.fa-tachometer:after {
  content: "\\10f0e4";
}
.fad.fa-tachometer-alt:after {
  content: "\\10f3fd";
}
.fad.fa-tachometer-alt-average:after {
  content: "\\10f624";
}
.fad.fa-tachometer-alt-fast:after {
  content: "\\10f625";
}
.fad.fa-tachometer-alt-fastest:after {
  content: "\\10f626";
}
.fad.fa-tachometer-alt-slow:after {
  content: "\\10f627";
}
.fad.fa-tachometer-alt-slowest:after {
  content: "\\10f628";
}
.fad.fa-tachometer-average:after {
  content: "\\10f629";
}
.fad.fa-tachometer-fast:after {
  content: "\\10f62a";
}
.fad.fa-tachometer-fastest:after {
  content: "\\10f62b";
}
.fad.fa-tachometer-slow:after {
  content: "\\10f62c";
}
.fad.fa-tachometer-slowest:after {
  content: "\\10f62d";
}
.fad.fa-taco:after {
  content: "\\10f826";
}
.fad.fa-tag:after {
  content: "\\10f02b";
}
.fad.fa-tags:after {
  content: "\\10f02c";
}
.fad.fa-tally:after {
  content: "\\10f69c";
}
.fad.fa-tanakh:after {
  content: "\\10f827";
}
.fad.fa-tape:after {
  content: "\\10f4db";
}
.fad.fa-tasks:after {
  content: "\\10f0ae";
}
.fad.fa-tasks-alt:after {
  content: "\\10f828";
}
.fad.fa-taxi:after {
  content: "\\10f1ba";
}
.fad.fa-teeth:after {
  content: "\\10f62e";
}
.fad.fa-teeth-open:after {
  content: "\\10f62f";
}
.fad.fa-telescope:after {
  content: "\\10f93e";
}
.fad.fa-temperature-down:after {
  content: "\\10f93f";
}
.fad.fa-temperature-frigid:after {
  content: "\\10f768";
}
.fad.fa-temperature-high:after {
  content: "\\10f769";
}
.fad.fa-temperature-hot:after {
  content: "\\10f76a";
}
.fad.fa-temperature-low:after {
  content: "\\10f76b";
}
.fad.fa-temperature-up:after {
  content: "\\10f940";
}
.fad.fa-tenge:after {
  content: "\\10f7d7";
}
.fad.fa-tennis-ball:after {
  content: "\\10f45e";
}
.fad.fa-terminal:after {
  content: "\\10f120";
}
.fad.fa-text:after {
  content: "\\10f893";
}
.fad.fa-text-height:after {
  content: "\\10f034";
}
.fad.fa-text-size:after {
  content: "\\10f894";
}
.fad.fa-text-width:after {
  content: "\\10f035";
}
.fad.fa-th:after {
  content: "\\10f00a";
}
.fad.fa-th-large:after {
  content: "\\10f009";
}
.fad.fa-th-list:after {
  content: "\\10f00b";
}
.fad.fa-theater-masks:after {
  content: "\\10f630";
}
.fad.fa-thermometer:after {
  content: "\\10f491";
}
.fad.fa-thermometer-empty:after {
  content: "\\10f2cb";
}
.fad.fa-thermometer-full:after {
  content: "\\10f2c7";
}
.fad.fa-thermometer-half:after {
  content: "\\10f2c9";
}
.fad.fa-thermometer-quarter:after {
  content: "\\10f2ca";
}
.fad.fa-thermometer-three-quarters:after {
  content: "\\10f2c8";
}
.fad.fa-theta:after {
  content: "\\10f69e";
}
.fad.fa-thumbs-down:after {
  content: "\\10f165";
}
.fad.fa-thumbs-up:after {
  content: "\\10f164";
}
.fad.fa-thumbtack:after {
  content: "\\10f08d";
}
.fad.fa-thunderstorm:after {
  content: "\\10f76c";
}
.fad.fa-thunderstorm-moon:after {
  content: "\\10f76d";
}
.fad.fa-thunderstorm-sun:after {
  content: "\\10f76e";
}
.fad.fa-ticket:after {
  content: "\\10f145";
}
.fad.fa-ticket-alt:after {
  content: "\\10f3ff";
}
.fad.fa-tilde:after {
  content: "\\10f69f";
}
.fad.fa-times:after {
  content: "\\10f00d";
}
.fad.fa-times-circle:after {
  content: "\\10f057";
}
.fad.fa-times-hexagon:after {
  content: "\\10f2ee";
}
.fad.fa-times-octagon:after {
  content: "\\10f2f0";
}
.fad.fa-times-square:after {
  content: "\\10f2d3";
}
.fad.fa-tint:after {
  content: "\\10f043";
}
.fad.fa-tint-slash:after {
  content: "\\10f5c7";
}
.fad.fa-tire:after {
  content: "\\10f631";
}
.fad.fa-tire-flat:after {
  content: "\\10f632";
}
.fad.fa-tire-pressure-warning:after {
  content: "\\10f633";
}
.fad.fa-tire-rugged:after {
  content: "\\10f634";
}
.fad.fa-tired:after {
  content: "\\10f5c8";
}
.fad.fa-toggle-off:after {
  content: "\\10f204";
}
.fad.fa-toggle-on:after {
  content: "\\10f205";
}
.fad.fa-toilet:after {
  content: "\\10f7d8";
}
.fad.fa-toilet-paper:after {
  content: "\\10f71e";
}
.fad.fa-toilet-paper-alt:after {
  content: "\\10f71f";
}
.fad.fa-toilet-paper-slash:after {
  content: "\\10f972";
}
.fad.fa-tombstone:after {
  content: "\\10f720";
}
.fad.fa-tombstone-alt:after {
  content: "\\10f721";
}
.fad.fa-toolbox:after {
  content: "\\10f552";
}
.fad.fa-tools:after {
  content: "\\10f7d9";
}
.fad.fa-tooth:after {
  content: "\\10f5c9";
}
.fad.fa-toothbrush:after {
  content: "\\10f635";
}
.fad.fa-torah:after {
  content: "\\10f6a0";
}
.fad.fa-torii-gate:after {
  content: "\\10f6a1";
}
.fad.fa-tornado:after {
  content: "\\10f76f";
}
.fad.fa-tractor:after {
  content: "\\10f722";
}
.fad.fa-trademark:after {
  content: "\\10f25c";
}
.fad.fa-traffic-cone:after {
  content: "\\10f636";
}
.fad.fa-traffic-light:after {
  content: "\\10f637";
}
.fad.fa-traffic-light-go:after {
  content: "\\10f638";
}
.fad.fa-traffic-light-slow:after {
  content: "\\10f639";
}
.fad.fa-traffic-light-stop:after {
  content: "\\10f63a";
}
.fad.fa-trailer:after {
  content: "\\10f941";
}
.fad.fa-train:after {
  content: "\\10f238";
}
.fad.fa-tram:after {
  content: "\\10f7da";
}
.fad.fa-transgender:after {
  content: "\\10f224";
}
.fad.fa-transgender-alt:after {
  content: "\\10f225";
}
.fad.fa-transporter:after {
  content: "\\10f942";
}
.fad.fa-transporter-1:after {
  content: "\\10f943";
}
.fad.fa-transporter-2:after {
  content: "\\10f944";
}
.fad.fa-transporter-3:after {
  content: "\\10f945";
}
.fad.fa-transporter-empty:after {
  content: "\\10f946";
}
.fad.fa-trash:after {
  content: "\\10f1f8";
}
.fad.fa-trash-alt:after {
  content: "\\10f2ed";
}
.fad.fa-trash-restore:after {
  content: "\\10f829";
}
.fad.fa-trash-restore-alt:after {
  content: "\\10f82a";
}
.fad.fa-trash-undo:after {
  content: "\\10f895";
}
.fad.fa-trash-undo-alt:after {
  content: "\\10f896";
}
.fad.fa-treasure-chest:after {
  content: "\\10f723";
}
.fad.fa-tree:after {
  content: "\\10f1bb";
}
.fad.fa-tree-alt:after {
  content: "\\10f400";
}
.fad.fa-tree-christmas:after {
  content: "\\10f7db";
}
.fad.fa-tree-decorated:after {
  content: "\\10f7dc";
}
.fad.fa-tree-large:after {
  content: "\\10f7dd";
}
.fad.fa-tree-palm:after {
  content: "\\10f82b";
}
.fad.fa-trees:after {
  content: "\\10f724";
}
.fad.fa-triangle:after {
  content: "\\10f2ec";
}
.fad.fa-triangle-music:after {
  content: "\\10f8e2";
}
.fad.fa-trophy:after {
  content: "\\10f091";
}
.fad.fa-trophy-alt:after {
  content: "\\10f2eb";
}
.fad.fa-truck:after {
  content: "\\10f0d1";
}
.fad.fa-truck-container:after {
  content: "\\10f4dc";
}
.fad.fa-truck-couch:after {
  content: "\\10f4dd";
}
.fad.fa-truck-loading:after {
  content: "\\10f4de";
}
.fad.fa-truck-monster:after {
  content: "\\10f63b";
}
.fad.fa-truck-moving:after {
  content: "\\10f4df";
}
.fad.fa-truck-pickup:after {
  content: "\\10f63c";
}
.fad.fa-truck-plow:after {
  content: "\\10f7de";
}
.fad.fa-truck-ramp:after {
  content: "\\10f4e0";
}
.fad.fa-trumpet:after {
  content: "\\10f8e3";
}
.fad.fa-tshirt:after {
  content: "\\10f553";
}
.fad.fa-tty:after {
  content: "\\10f1e4";
}
.fad.fa-turkey:after {
  content: "\\10f725";
}
.fad.fa-turntable:after {
  content: "\\10f8e4";
}
.fad.fa-turtle:after {
  content: "\\10f726";
}
.fad.fa-tv:after {
  content: "\\10f26c";
}
.fad.fa-tv-alt:after {
  content: "\\10f8e5";
}
.fad.fa-tv-music:after {
  content: "\\10f8e6";
}
.fad.fa-tv-retro:after {
  content: "\\10f401";
}
.fad.fa-typewriter:after {
  content: "\\10f8e7";
}
.fad.fa-ufo:after {
  content: "\\10f947";
}
.fad.fa-ufo-beam:after {
  content: "\\10f948";
}
.fad.fa-umbrella:after {
  content: "\\10f0e9";
}
.fad.fa-umbrella-beach:after {
  content: "\\10f5ca";
}
.fad.fa-underline:after {
  content: "\\10f0cd";
}
.fad.fa-undo:after {
  content: "\\10f0e2";
}
.fad.fa-undo-alt:after {
  content: "\\10f2ea";
}
.fad.fa-unicorn:after {
  content: "\\10f727";
}
.fad.fa-union:after {
  content: "\\10f6a2";
}
.fad.fa-universal-access:after {
  content: "\\10f29a";
}
.fad.fa-university:after {
  content: "\\10f19c";
}
.fad.fa-unlink:after {
  content: "\\10f127";
}
.fad.fa-unlock:after {
  content: "\\10f09c";
}
.fad.fa-unlock-alt:after {
  content: "\\10f13e";
}
.fad.fa-upload:after {
  content: "\\10f093";
}
.fad.fa-usb-drive:after {
  content: "\\10f8e9";
}
.fad.fa-usd-circle:after {
  content: "\\10f2e8";
}
.fad.fa-usd-square:after {
  content: "\\10f2e9";
}
.fad.fa-user:after {
  content: "\\10f007";
}
.fad.fa-user-alien:after {
  content: "\\10f94a";
}
.fad.fa-user-alt:after {
  content: "\\10f406";
}
.fad.fa-user-alt-slash:after {
  content: "\\10f4fa";
}
.fad.fa-user-astronaut:after {
  content: "\\10f4fb";
}
.fad.fa-user-chart:after {
  content: "\\10f6a3";
}
.fad.fa-user-check:after {
  content: "\\10f4fc";
}
.fad.fa-user-circle:after {
  content: "\\10f2bd";
}
.fad.fa-user-clock:after {
  content: "\\10f4fd";
}
.fad.fa-user-cog:after {
  content: "\\10f4fe";
}
.fad.fa-user-cowboy:after {
  content: "\\10f8ea";
}
.fad.fa-user-crown:after {
  content: "\\10f6a4";
}
.fad.fa-user-edit:after {
  content: "\\10f4ff";
}
.fad.fa-user-friends:after {
  content: "\\10f500";
}
.fad.fa-user-graduate:after {
  content: "\\10f501";
}
.fad.fa-user-hard-hat:after {
  content: "\\10f82c";
}
.fad.fa-user-headset:after {
  content: "\\10f82d";
}
.fad.fa-user-injured:after {
  content: "\\10f728";
}
.fad.fa-user-lock:after {
  content: "\\10f502";
}
.fad.fa-user-md:after {
  content: "\\10f0f0";
}
.fad.fa-user-md-chat:after {
  content: "\\10f82e";
}
.fad.fa-user-minus:after {
  content: "\\10f503";
}
.fad.fa-user-music:after {
  content: "\\10f8eb";
}
.fad.fa-user-ninja:after {
  content: "\\10f504";
}
.fad.fa-user-nurse:after {
  content: "\\10f82f";
}
.fad.fa-user-plus:after {
  content: "\\10f234";
}
.fad.fa-user-robot:after {
  content: "\\10f94b";
}
.fad.fa-user-secret:after {
  content: "\\10f21b";
}
.fad.fa-user-shield:after {
  content: "\\10f505";
}
.fad.fa-user-slash:after {
  content: "\\10f506";
}
.fad.fa-user-tag:after {
  content: "\\10f507";
}
.fad.fa-user-tie:after {
  content: "\\10f508";
}
.fad.fa-user-times:after {
  content: "\\10f235";
}
.fad.fa-user-unlock:after {
  content: "\\10f958";
}
.fad.fa-user-visor:after {
  content: "\\10f94c";
}
.fad.fa-users:after {
  content: "\\10f0c0";
}
.fad.fa-users-class:after {
  content: "\\10f63d";
}
.fad.fa-users-cog:after {
  content: "\\10f509";
}
.fad.fa-users-crown:after {
  content: "\\10f6a5";
}
.fad.fa-users-medical:after {
  content: "\\10f830";
}
.fad.fa-users-slash:after {
  content: "\\10f973";
}
.fad.fa-utensil-fork:after {
  content: "\\10f2e3";
}
.fad.fa-utensil-knife:after {
  content: "\\10f2e4";
}
.fad.fa-utensil-spoon:after {
  content: "\\10f2e5";
}
.fad.fa-utensils:after {
  content: "\\10f2e7";
}
.fad.fa-utensils-alt:after {
  content: "\\10f2e6";
}
.fad.fa-vacuum:after {
  content: "\\10f94d";
}
.fad.fa-vacuum-robot:after {
  content: "\\10f94e";
}
.fad.fa-value-absolute:after {
  content: "\\10f6a6";
}
.fad.fa-vector-square:after {
  content: "\\10f5cb";
}
.fad.fa-venus:after {
  content: "\\10f221";
}
.fad.fa-venus-double:after {
  content: "\\10f226";
}
.fad.fa-venus-mars:after {
  content: "\\10f228";
}
.fad.fa-vhs:after {
  content: "\\10f8ec";
}
.fad.fa-vial:after {
  content: "\\10f492";
}
.fad.fa-vials:after {
  content: "\\10f493";
}
.fad.fa-video:after {
  content: "\\10f03d";
}
.fad.fa-video-plus:after {
  content: "\\10f4e1";
}
.fad.fa-video-slash:after {
  content: "\\10f4e2";
}
.fad.fa-vihara:after {
  content: "\\10f6a7";
}
.fad.fa-violin:after {
  content: "\\10f8ed";
}
.fad.fa-virus:after {
  content: "\\10f974";
}
.fad.fa-virus-slash:after {
  content: "\\10f975";
}
.fad.fa-viruses:after {
  content: "\\10f976";
}
.fad.fa-voicemail:after {
  content: "\\10f897";
}
.fad.fa-volcano:after {
  content: "\\10f770";
}
.fad.fa-volleyball-ball:after {
  content: "\\10f45f";
}
.fad.fa-volume:after {
  content: "\\10f6a8";
}
.fad.fa-volume-down:after {
  content: "\\10f027";
}
.fad.fa-volume-mute:after {
  content: "\\10f6a9";
}
.fad.fa-volume-off:after {
  content: "\\10f026";
}
.fad.fa-volume-slash:after {
  content: "\\10f2e2";
}
.fad.fa-volume-up:after {
  content: "\\10f028";
}
.fad.fa-vote-nay:after {
  content: "\\10f771";
}
.fad.fa-vote-yea:after {
  content: "\\10f772";
}
.fad.fa-vr-cardboard:after {
  content: "\\10f729";
}
.fad.fa-wagon-covered:after {
  content: "\\10f8ee";
}
.fad.fa-walker:after {
  content: "\\10f831";
}
.fad.fa-walkie-talkie:after {
  content: "\\10f8ef";
}
.fad.fa-walking:after {
  content: "\\10f554";
}
.fad.fa-wallet:after {
  content: "\\10f555";
}
.fad.fa-wand:after {
  content: "\\10f72a";
}
.fad.fa-wand-magic:after {
  content: "\\10f72b";
}
.fad.fa-warehouse:after {
  content: "\\10f494";
}
.fad.fa-warehouse-alt:after {
  content: "\\10f495";
}
.fad.fa-washer:after {
  content: "\\10f898";
}
.fad.fa-watch:after {
  content: "\\10f2e1";
}
.fad.fa-watch-calculator:after {
  content: "\\10f8f0";
}
.fad.fa-watch-fitness:after {
  content: "\\10f63e";
}
.fad.fa-water:after {
  content: "\\10f773";
}
.fad.fa-water-lower:after {
  content: "\\10f774";
}
.fad.fa-water-rise:after {
  content: "\\10f775";
}
.fad.fa-wave-sine:after {
  content: "\\10f899";
}
.fad.fa-wave-square:after {
  content: "\\10f83e";
}
.fad.fa-wave-triangle:after {
  content: "\\10f89a";
}
.fad.fa-waveform:after {
  content: "\\10f8f1";
}
.fad.fa-waveform-path:after {
  content: "\\10f8f2";
}
.fad.fa-webcam:after {
  content: "\\10f832";
}
.fad.fa-webcam-slash:after {
  content: "\\10f833";
}
.fad.fa-weight:after {
  content: "\\10f496";
}
.fad.fa-weight-hanging:after {
  content: "\\10f5cd";
}
.fad.fa-whale:after {
  content: "\\10f72c";
}
.fad.fa-wheat:after {
  content: "\\10f72d";
}
.fad.fa-wheelchair:after {
  content: "\\10f193";
}
.fad.fa-whistle:after {
  content: "\\10f460";
}
.fad.fa-wifi:after {
  content: "\\10f1eb";
}
.fad.fa-wifi-1:after {
  content: "\\10f6aa";
}
.fad.fa-wifi-2:after {
  content: "\\10f6ab";
}
.fad.fa-wifi-slash:after {
  content: "\\10f6ac";
}
.fad.fa-wind:after {
  content: "\\10f72e";
}
.fad.fa-wind-turbine:after {
  content: "\\10f89b";
}
.fad.fa-wind-warning:after {
  content: "\\10f776";
}
.fad.fa-window:after {
  content: "\\10f40e";
}
.fad.fa-window-alt:after {
  content: "\\10f40f";
}
.fad.fa-window-close:after {
  content: "\\10f410";
}
.fad.fa-window-frame:after {
  content: "\\10f94f";
}
.fad.fa-window-frame-open:after {
  content: "\\10f950";
}
.fad.fa-window-maximize:after {
  content: "\\10f2d0";
}
.fad.fa-window-minimize:after {
  content: "\\10f2d1";
}
.fad.fa-window-restore:after {
  content: "\\10f2d2";
}
.fad.fa-windsock:after {
  content: "\\10f777";
}
.fad.fa-wine-bottle:after {
  content: "\\10f72f";
}
.fad.fa-wine-glass:after {
  content: "\\10f4e3";
}
.fad.fa-wine-glass-alt:after {
  content: "\\10f5ce";
}
.fad.fa-won-sign:after {
  content: "\\10f159";
}
.fad.fa-wreath:after {
  content: "\\10f7e2";
}
.fad.fa-wrench:after {
  content: "\\10f0ad";
}
.fad.fa-x-ray:after {
  content: "\\10f497";
}
.fad.fa-yen-sign:after {
  content: "\\10f157";
}
.fad.fa-yin-yang:after {
  content: "\\10f6ad";
}
.fal {
  font-family: "Font Awesome 5 Pro";
  font-weight: 300;
}
@font-face {
  font-family: "Font Awesome 5 Pro";
  font-style: normal;
  font-weight: 400;
  font-display: block;
  src: url("/dist/assets/fa-regular-400.86cbcb46.eot");
  src: url("/dist/assets/fa-regular-400.86cbcb46.eot?#iefix") format("embedded-opentype"), url("/dist/assets/fa-regular-400.a771731f.woff2") format("woff2"), url("/dist/assets/fa-regular-400.bb9e1c89.woff") format("woff"), url("/dist/assets/fa-regular-400.b81833e9.ttf") format("truetype"), url("/dist/assets/fa-regular-400.09f741e9.svg#fontawesome") format("svg");
}
.far {
  font-family: "Font Awesome 5 Pro";
  font-weight: 400;
}
@font-face {
  font-family: "Font Awesome 5 Pro";
  font-style: normal;
  font-weight: 900;
  font-display: block;
  src: url("/dist/assets/fa-solid-900.15a70ae0.eot");
  src: url("/dist/assets/fa-solid-900.15a70ae0.eot?#iefix") format("embedded-opentype"), url("/dist/assets/fa-solid-900.e77c7e1c.woff2") format("woff2"), url("/dist/assets/fa-solid-900.974d7c91.woff") format("woff"), url("/dist/assets/fa-solid-900.8050bcbf.ttf") format("truetype"), url("/dist/assets/fa-solid-900.02c2aa62.svg#fontawesome") format("svg");
}
.fa,
.fas {
  font-family: "Font Awesome 5 Pro";
  font-weight: 900;
}
@-webkit-keyframes loading {
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
}
@keyframes loading {
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fui-loading {
  position: relative;
  pointer-events: none;
  color: transparent !important;
  min-height: 1rem;
}
.fui-loading::after {
  position: absolute;
  display: block;
  height: 1rem;
  width: 1rem;
  margin-top: -0.5rem;
  margin-left: -0.5rem;
  border-width: 2px;
  border-style: solid;
  border-radius: 9999px;
  border-color: #E5422B;
  -webkit-animation: loading 0.5s infinite linear;
          animation: loading 0.5s infinite linear;
  border-right-color: transparent;
  border-top-color: transparent;
  content: "";
  left: 50%;
  top: 50%;
  z-index: 1;
}
.fui-loading.fui-loading-lg {
  min-height: 2rem;
}
.fui-loading.fui-loading-lg::after {
  height: 2rem;
  width: 2rem;
  margin-top: -1rem;
  margin-left: -1rem;
}
.fui-loading.fui-loading-sm {
  min-height: 1rem;
}
.fui-loading.fui-loading-sm::after {
  height: 1rem;
  width: 1rem;
  margin-top: -0.5rem;
  margin-left: -0.375rem;
}
.fui-loading.fui-loading-tiny {
  min-height: 0.75rem;
}
.fui-loading.fui-loading-tiny::after {
  height: 0.75rem;
  width: 0.75rem;
  margin-top: -6px;
  margin-left: -6px;
}
.btn.submit.fui-loading {
  color: transparent !important;
}
.btn.submit.fui-loading::after {
  border-bottom-color: #fff;
  border-left-color: #fff;
}
.btn.fui-loading {
  color: transparent !important;
}
.field-wrapper {
  margin: 0 !important;
}
[data-invalid=true] .text {
  border-color: #EF4E4E;
}
.field .field-label {
  display: flex;
  align-items: center;
}
.field .field-label span[data-icon] {
  display: inline-flex;
  margin-left: 5px;
}
.field .field-label span[data-icon]:hover {
  color: #0B69A3;
}
.tippy-box[data-theme~=fui-field-instructions-tooltip] .tippy-content {
  font-size: 14px;
  line-height: 20px;
  color: #3f4d5a;
  padding: 24px;
}
.field[data-type=number] {
  -moz-appearance: textfield;
}
.field[data-type=number] input::-webkit-inner-spin-button,
.field[data-type=number] input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.field[data-type=number] input[size="1"] {
  width: 1rem;
}
.field[data-type=number] input[size="2"] {
  width: 2rem;
}
.field[data-type=number] input[size="3"] {
  width: 3rem;
}
.field[data-type=number] input[size="4"] {
  width: 4rem;
}
.field[data-type=number] input[size="5"] {
  width: 5rem;
}
.field[data-type=number] input[size="6"] {
  width: 6rem;
}
.field[data-type=number] input[size="7"] {
  width: 7rem;
}
.field[data-type=number] input[size="8"] {
  width: 8rem;
}
.field[data-type=number] input[size="9"] {
  width: 9rem;
}
.field[data-type=collapse] .input {
  height: 100%;
}
.fui-prefix-text {
  color: #7b8793;
  padding-right: 5px;
}
.fui-suffix-text {
  color: #7b8793;
  padding-left: 5px;
}
.field[data-type=checkbox] [data-disabled],
.field[data-type=radio] [data-disabled] {
  opacity: 30%;
}
.field[data-type=checkbox] .field-label,
.field[data-type=radio] .field-label {
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  padding: 0;
  margin: 0;
}
.field[data-type=checkbox] .field-wrapper,
.field[data-type=radio] .field-wrapper {
  display: inline-flex;
  align-items: center;
}
.field[data-type=checkbox] input,
.field[data-type=radio] input {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  position: absolute;
  width: 0;
  height: 0;
  overflow: hidden;
  opacity: 0;
  left: -999em;
}
.field[data-type=checkbox] input ~ .formkit-decorator,
.field[data-type=radio] input ~ .formkit-decorator {
  background: #fbfcfe;
  display: block;
  box-sizing: content-box;
  width: 14px;
  height: 14px;
  flex: 0 0 14px;
  border: none;
  box-shadow: 0 0 0 1px rgba(96, 125, 159, 0.4);
  border-radius: 2px;
  position: relative;
  cursor: pointer;
  margin-right: 7px;
}
.field[data-type=checkbox] input ~ .formkit-decorator::before,
.field[data-type=radio] input ~ .formkit-decorator::before {
  background: transparent;
  content: "";
  display: block;
  width: 84%;
  height: 50%;
  pointer-events: none;
  border-bottom: 0.26em solid transparent;
  border-left: 0.26em solid transparent;
  transform: rotate(-45deg);
  transform-origin: bottom left;
  position: absolute;
  bottom: 5%;
  left: 45%;
}
.field[data-type=checkbox] input:checked ~ .formkit-decorator,
.field[data-type=radio] input:checked ~ .formkit-decorator {
  box-shadow: 0 0 0 1px rgba(96, 125, 159, 0.4);
}
.field[data-type=checkbox] input:checked ~ .formkit-decorator::before,
.field[data-type=radio] input:checked ~ .formkit-decorator::before {
  border-color: #4c545c;
}
.field[data-type=checkbox] input:focus ~ .formkit-decorator,
.field[data-type=radio] input:focus ~ .formkit-decorator {
  box-shadow: 0 0 0 1px rgba(96, 125, 159, 0.4);
}
.field[data-type=checkbox] input:focus-visible ~ .formkit-decorator,
.field[data-type=radio] input:focus-visible ~ .formkit-decorator {
  box-shadow: 0 0 0 1px rgba(96, 125, 159, 0.4);
}
.field[data-type=checkbox] .formkit-options,
.field[data-type=radio] .formkit-options {
  padding: 0;
}
.field[data-type=checkbox] .formkit-option,
.field[data-type=radio] .formkit-option {
  list-style-type: none;
}
.field[data-type=checkbox] .formkit-option:last-child,
.field[data-type=radio] .formkit-option:last-child {
  margin-bottom: 0;
}
.field[data-type=checkbox] fieldset.formkit-fieldset,
.field[data-type=radio] fieldset.formkit-fieldset {
  border: var(--fk-border);
  border-radius: 2px;
}
.sr-only {
  border: 0;
  clip: rect(1px, 1px, 1px, 1px);
  -webkit-clip-path: inset(50%);
          clip-path: inset(50%);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute !important;
  width: 1px;
  word-wrap: normal !important;
}
[v-cloak] {
  display: none;
}
.fui-body-start #content-container {
  display: flex;
}
.fui-start {
  min-width: 550px;
  margin: auto;
  padding: 40px;
}
.fui-start .intro {
  text-align: center;
  margin-bottom: 3rem;
}
.fui-start h1 {
  color: #fb6853;
  font-size: 28px;
  margin: 0;
  font-weight: 300;
}
.fui-start .intro p {
  color: #7b8793;
  margin: 10px;
}
.fui-start .buttons {
  display: flex;
  justify-content: space-between;
}
.fui-field-pill {
  border-radius: 3px;
  border: 1px solid #cbd6e2;
  font-size: 16px;
  color: #33475b;
  padding: 10px;
  font-size: 13px;
  font-weight: 400;
  background-color: #fff;
  position: relative;
  cursor: move;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  z-index: 11;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.fui-field-pill svg {
  width: 100%;
  height: 100%;
}
.fui-field-pill-icon {
  width: 16px;
  height: 16px;
  margin-right: 6px;
}
.fui-field-pill-drag {
  width: 13px;
  height: 15px;
  margin-left: auto;
  margin-right: -5px;
  opacity: 0;
  transition: all 0.15s ease-out;
  background-image: url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ctitle%3Edrag%3C/title%3E%3Cpath fill='%2396adc4' d='M11 8c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3zM21 8c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3zM11 19c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3zM21 19c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3zM11 30c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3zM21 30c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3z'%3E%3C/path%3E%3C/svg%3E");
  background-size: 13px 15px;
  background-repeat: no-repeat;
}
.fui-field-pill:hover .fui-field-pill-drag {
  opacity: 1;
}
.fui-form-field {
  display: flex;
}
.fui-form-field * {
  pointer-events: none;
}
.fui-field-block {
  width: 100%;
  position: relative;
  padding: 10px 15px !important;
  cursor: move;
  border-radius: 4px;
  transition: all 0.2s ease;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  z-index: 2;
}
.fui-field-block:hover {
  background: #f1f5f8;
}
.fui-field-block.is-active {
  opacity: 0.3;
}
.fui-field-block.has-errors {
  box-shadow: 0 0 1px 1px #ef9898;
  background: #fff6f6;
}
.fui-field-block.fui-submit-block {
  cursor: pointer;
  padding: 1.5rem 15px !important;
}
.fui-field-block svg {
  width: 100%;
  height: 100%;
}
.fui-field-block .warning {
  margin: 8px 0 0;
}
.fui-edit-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
}
.fui-field-info {
  display: flex;
  flex: 1;
  align-items: center;
  flex-wrap: wrap;
  margin: -5px 0 5px;
}
.fui-field-label {
  font-size: 14px;
  color: #33475b;
  font-weight: 500;
}
.fui-field-handle {
  color: #8f98a3;
  font-size: 10px !important;
  display: inline-flex;
  margin-left: 8px;
  background-color: #EBEDEF;
  padding: 0;
  height: 16px;
  line-height: 16px;
  padding: 0 6px;
  border-radius: 10px;
  display: none;
}
.fui-field-synced {
  display: flex;
  align-items: center;
  font-size: 10px !important;
  margin-left: 8px;
  font-weight: 500;
  padding: 0 6px;
  border-radius: 10px;
  color: #c05621;
  background: #fffaf0;
  border: 1px solid #f6ad55;
}
.fui-field-synced svg {
  width: 9px;
  height: 9px;
  margin-right: 5px;
}
.fui-field-conditions {
  display: flex;
  align-items: center;
  font-size: 10px !important;
  margin-left: 8px;
  font-weight: 500;
  padding: 0 6px;
  border-radius: 10px;
  color: #1992D4;
  background: #f0faff;
  border: 1px solid #81c3e7;
}
.fui-field-conditions svg {
  width: 13px;
  height: 13px;
  margin-right: 5px;
}
.fui-field-actions {
  opacity: 0;
  position: absolute;
  top: 5px;
  right: 5px;
  margin-left: auto;
  transition: all 0.2s ease;
}
.fui-field-block:hover > .fui-field-info > .fui-field-actions {
  opacity: 1;
}
.fui-field-settings {
  cursor: pointer;
  transition: all 0.2s ease;
  width: 30px;
  height: 28px !important;
  background-color: transparent;
  border-radius: 4px;
  border: none;
  outline: none;
  display: block !important;
}
.fui-field-settings svg {
  pointer-events: none;
  width: 16px;
  height: 16px;
  fill: #9da5af;
  margin: auto;
}
.fui-field-settings:after {
  display: none;
}
.fui-field-settings:hover svg {
  fill: #33475b;
}
.fui-field-settings:hover {
  background-color: rgba(0, 0, 0, 0.08);
}
.fui-flex-break {
  flex-basis: 100%;
  height: 0;
}
.fui-field-instructions {
  color: #7b8793;
  font-size: 12px;
  line-height: 1.4;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin: 3px 0 0;
}
.fui-field-preview {
  position: relative;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  pointer-events: none;
}
.fui-field-preview .fui-field-icon {
  position: absolute;
  top: 50%;
  right: 10px;
  width: 15px;
  height: 15px;
  display: block;
  opacity: 0.4;
  transform: translateY(-50%);
}
.fui-field-preview .fui-field-input[disabled] {
  background-color: #ebeff3;
}
.fui-field-preview .fui-field-label {
  font-size: 11px;
  color: #8ba1ba;
  font-weight: 500;
  margin-bottom: 2px;
  display: block;
}
.fui-field-preview .fui-row {
  margin-bottom: 8px;
}
.fui-field-preview .fui-row:last-child {
  margin-bottom: 0;
}
.fui-field-preview .fui-field-input,
.fui-field-preview .fui-field-select {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  outline: 0;
  display: block;
  width: 100%;
  font-size: 14px;
  line-height: 1.5;
  transition: all 0.15s ease;
  background-clip: padding-box;
  padding: 0.5rem 1.75rem 0.5rem 0.75rem;
  border: 1px solid #cbd5e0;
  border-radius: 0.25rem;
  color: #a9a9a9;
  background-color: #fff;
}
.fui-field-preview .fui-field-input[type=number] {
  -moz-appearance: textfield;
}
.fui-field-preview .fui-field-input[type=number]::-webkit-inner-spin-button, .fui-field-preview .fui-field-input[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.fui-field-preview .fui-field-textarea {
  height: auto;
}
.fui-field-preview .fui-field-checkbox,
.fui-field-preview .fui-field-radio {
  box-sizing: border-box;
  padding: 0;
}
.fui-field-preview .fui-field-checkbox input,
.fui-field-preview .fui-field-radio input {
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  position: absolute;
  width: 1px;
}
.fui-field-preview .fui-field-checkbox label,
.fui-field-preview .fui-field-radio label {
  padding-left: 1.4rem;
  line-height: 1.5rem;
  position: relative;
  display: inline-block;
  margin-bottom: 0;
  transition: all 0.3s ease;
}
.fui-field-preview .fui-field-checkbox label::before,
.fui-field-preview .fui-field-radio label::before {
  position: absolute;
  top: 4px;
  left: 0;
  display: block;
  width: 1rem;
  height: 1rem;
  content: "";
  cursor: pointer;
  border: 1px solid #caced7;
  background-color: #fff;
  background-repeat: no-repeat;
  background-position: center center;
  background-size: 50% 50%;
  transition: all 0.3s ease;
}
.fui-field-preview .fui-field-radio label::before {
  border-radius: 50%;
}
.fui-field-preview .fui-field-checkbox input:checked + label::before,
.fui-field-preview .fui-field-radio input:checked + label::before {
  background-color: #0D99F2;
  border-color: #0D99F2;
}
.fui-field-preview .fui-field-radio input:checked + label::before {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3E%3Ccircle r='3' fill='%23fff'/%3E%3C/svg%3E");
  background-size: 8px auto;
}
.fui-field-preview .fui-field-checkbox label::before {
  border-radius: 2px;
}
.fui-field-preview .fui-field-checkbox input:checked + label::before {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26 2.974 7.25 8 2.193z'/%3E%3C/svg%3E");
  background-size: 8px auto;
}
.fui-field-preview .fui-field-select:not([multiple]):not([size]) {
  background: #fff url("data:image/svg+xml;charset=utf8,%3Csvg%20xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 4'%3E%3Cpath fill='%23333F48' fill-rule='evenodd' d='M7.484.643a.23.23 0 0 1-.067.154l-3.12 3.12a.23.23 0 0 1-.154.067.23.23 0 0 1-.154-.067L.869.797A.23.23 0 0 1 .8.643.23.23 0 0 1 .868.489l.335-.335a.218.218 0 0 1 .154-.067.23.23 0 0 1 .154.067l2.632 2.632L6.775.154a.23.23 0 0 1 .154-.067.23.23 0 0 1 .154.067l.334.335c.04.04.067.1.067.154z'/%3E%3C/svg%3E") no-repeat;
  background-position: right 0.75rem center;
  background-size: 0.7rem;
  padding-right: 1.4rem;
}
.fui-field-preview .fui-field-layout-horizontal {
  display: flex;
}
.fui-field-preview .fui-field-layout-horizontal .fui-field-checkbox,
.fui-field-preview .fui-field-layout-horizontal .fui-field-radio {
  margin-right: 0.5rem;
}
.fui-field-preview .fui-field-layout-vertical {
  display: block;
}
.fui-field-preview .fui-field-html {
  min-height: 6rem;
  max-height: 16rem;
  overflow: hidden;
}
.fui-field-preview .fui-field-hr {
  padding: 1rem;
}
.fui-field-preview .fui-field-hr hr {
  border-color: #cbd5e0;
  padding: 0;
  margin: 0;
}
.fui-field-preview .fui-field-file {
  line-height: 1;
  padding: 1rem;
}
.fui-field-preview .fui-phone-flag-wrap {
  position: absolute;
  top: 1px;
  left: 1px;
}
.fui-field-preview .fui-phone-flag-icon {
  width: 20px;
  height: 10px;
  background: rgb(204, 204, 204);
  display: block;
  position: absolute;
  top: 50%;
  left: 10px;
  transform: translateY(-50%);
}
.fui-field-preview .fui-phone-flag-select {
  padding-left: 30px;
  border: none;
  background-position: right 5px center !important;
  background-size: 8px !important;
}
.fui-field-preview .iti__flag {
  height: 15px;
  box-shadow: 0px 0px 1px 0px #888;
  background-image: url("https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/img/flags.png");
  background-repeat: no-repeat;
  background-color: #DBDBDB;
  background-position: 20px 0;
}
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .fui-field-preview .iti__flag {
    background-image: url("https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/img/flags@2x.png");
  }
}
.fui-field-preview .iti__flag.iti__ac {
  height: 10px;
  background-position: 0px 0px;
}
.fui-field-preview .iti__flag.iti__ad {
  height: 14px;
  background-position: -22px 0px;
}
.fui-field-preview .iti__flag.iti__ae {
  height: 10px;
  background-position: -44px 0px;
}
.fui-field-preview .iti__flag.iti__af {
  height: 14px;
  background-position: -66px 0px;
}
.fui-field-preview .iti__flag.iti__ag {
  height: 14px;
  background-position: -88px 0px;
}
.fui-field-preview .iti__flag.iti__ai {
  height: 10px;
  background-position: -110px 0px;
}
.fui-field-preview .iti__flag.iti__al {
  height: 15px;
  background-position: -132px 0px;
}
.fui-field-preview .iti__flag.iti__am {
  height: 10px;
  background-position: -154px 0px;
}
.fui-field-preview .iti__flag.iti__ao {
  height: 14px;
  background-position: -176px 0px;
}
.fui-field-preview .iti__flag.iti__aq {
  height: 14px;
  background-position: -198px 0px;
}
.fui-field-preview .iti__flag.iti__ar {
  height: 13px;
  background-position: -220px 0px;
}
.fui-field-preview .iti__flag.iti__as {
  height: 10px;
  background-position: -242px 0px;
}
.fui-field-preview .iti__flag.iti__at {
  height: 14px;
  background-position: -264px 0px;
}
.fui-field-preview .iti__flag.iti__au {
  height: 10px;
  background-position: -286px 0px;
}
.fui-field-preview .iti__flag.iti__aw {
  height: 14px;
  background-position: -308px 0px;
}
.fui-field-preview .iti__flag.iti__ax {
  height: 13px;
  background-position: -330px 0px;
}
.fui-field-preview .iti__flag.iti__az {
  height: 10px;
  background-position: -352px 0px;
}
.fui-field-preview .iti__flag.iti__ba {
  height: 10px;
  background-position: -374px 0px;
}
.fui-field-preview .iti__flag.iti__bb {
  height: 14px;
  background-position: -396px 0px;
}
.fui-field-preview .iti__flag.iti__bd {
  height: 12px;
  background-position: -418px 0px;
}
.fui-field-preview .iti__flag.iti__be {
  height: 15px;
  background-position: -440px 0px;
}
.fui-field-preview .iti__flag.iti__bf {
  height: 14px;
  background-position: -460px 0px;
}
.fui-field-preview .iti__flag.iti__bg {
  height: 12px;
  background-position: -482px 0px;
}
.fui-field-preview .iti__flag.iti__bh {
  height: 12px;
  background-position: -504px 0px;
}
.fui-field-preview .iti__flag.iti__bi {
  height: 12px;
  background-position: -526px 0px;
}
.fui-field-preview .iti__flag.iti__bj {
  height: 14px;
  background-position: -548px 0px;
}
.fui-field-preview .iti__flag.iti__bl {
  height: 14px;
  background-position: -570px 0px;
}
.fui-field-preview .iti__flag.iti__bm {
  height: 10px;
  background-position: -592px 0px;
}
.fui-field-preview .iti__flag.iti__bn {
  height: 10px;
  background-position: -614px 0px;
}
.fui-field-preview .iti__flag.iti__bo {
  height: 14px;
  background-position: -636px 0px;
}
.fui-field-preview .iti__flag.iti__bq {
  height: 14px;
  background-position: -658px 0px;
}
.fui-field-preview .iti__flag.iti__br {
  height: 14px;
  background-position: -680px 0px;
}
.fui-field-preview .iti__flag.iti__bs {
  height: 10px;
  background-position: -702px 0px;
}
.fui-field-preview .iti__flag.iti__bt {
  height: 14px;
  background-position: -724px 0px;
}
.fui-field-preview .iti__flag.iti__bv {
  height: 15px;
  background-position: -746px 0px;
}
.fui-field-preview .iti__flag.iti__bw {
  height: 14px;
  background-position: -768px 0px;
}
.fui-field-preview .iti__flag.iti__by {
  height: 10px;
  background-position: -790px 0px;
}
.fui-field-preview .iti__flag.iti__bz {
  height: 14px;
  background-position: -812px 0px;
}
.fui-field-preview .iti__flag.iti__ca {
  height: 10px;
  background-position: -834px 0px;
}
.fui-field-preview .iti__flag.iti__cc {
  height: 10px;
  background-position: -856px 0px;
}
.fui-field-preview .iti__flag.iti__cd {
  height: 15px;
  background-position: -878px 0px;
}
.fui-field-preview .iti__flag.iti__cf {
  height: 14px;
  background-position: -900px 0px;
}
.fui-field-preview .iti__flag.iti__cg {
  height: 14px;
  background-position: -922px 0px;
}
.fui-field-preview .iti__flag.iti__ch {
  height: 15px;
  background-position: -944px 0px;
}
.fui-field-preview .iti__flag.iti__ci {
  height: 14px;
  background-position: -961px 0px;
}
.fui-field-preview .iti__flag.iti__ck {
  height: 10px;
  background-position: -983px 0px;
}
.fui-field-preview .iti__flag.iti__cl {
  height: 14px;
  background-position: -1005px 0px;
}
.fui-field-preview .iti__flag.iti__cm {
  height: 14px;
  background-position: -1027px 0px;
}
.fui-field-preview .iti__flag.iti__cn {
  height: 14px;
  background-position: -1049px 0px;
}
.fui-field-preview .iti__flag.iti__co {
  height: 14px;
  background-position: -1071px 0px;
}
.fui-field-preview .iti__flag.iti__cp {
  height: 14px;
  background-position: -1093px 0px;
}
.fui-field-preview .iti__flag.iti__cr {
  height: 12px;
  background-position: -1115px 0px;
}
.fui-field-preview .iti__flag.iti__cu {
  height: 10px;
  background-position: -1137px 0px;
}
.fui-field-preview .iti__flag.iti__cv {
  height: 12px;
  background-position: -1159px 0px;
}
.fui-field-preview .iti__flag.iti__cw {
  height: 14px;
  background-position: -1181px 0px;
}
.fui-field-preview .iti__flag.iti__cx {
  height: 10px;
  background-position: -1203px 0px;
}
.fui-field-preview .iti__flag.iti__cy {
  height: 14px;
  background-position: -1225px 0px;
}
.fui-field-preview .iti__flag.iti__cz {
  height: 14px;
  background-position: -1247px 0px;
}
.fui-field-preview .iti__flag.iti__de {
  height: 12px;
  background-position: -1269px 0px;
}
.fui-field-preview .iti__flag.iti__dg {
  height: 10px;
  background-position: -1291px 0px;
}
.fui-field-preview .iti__flag.iti__dj {
  height: 14px;
  background-position: -1313px 0px;
}
.fui-field-preview .iti__flag.iti__dk {
  height: 15px;
  background-position: -1335px 0px;
}
.fui-field-preview .iti__flag.iti__dm {
  height: 10px;
  background-position: -1357px 0px;
}
.fui-field-preview .iti__flag.iti__do {
  height: 14px;
  background-position: -1379px 0px;
}
.fui-field-preview .iti__flag.iti__dz {
  height: 14px;
  background-position: -1401px 0px;
}
.fui-field-preview .iti__flag.iti__ea {
  height: 14px;
  background-position: -1423px 0px;
}
.fui-field-preview .iti__flag.iti__ec {
  height: 14px;
  background-position: -1445px 0px;
}
.fui-field-preview .iti__flag.iti__ee {
  height: 13px;
  background-position: -1467px 0px;
}
.fui-field-preview .iti__flag.iti__eg {
  height: 14px;
  background-position: -1489px 0px;
}
.fui-field-preview .iti__flag.iti__eh {
  height: 10px;
  background-position: -1511px 0px;
}
.fui-field-preview .iti__flag.iti__er {
  height: 10px;
  background-position: -1533px 0px;
}
.fui-field-preview .iti__flag.iti__es {
  height: 14px;
  background-position: -1555px 0px;
}
.fui-field-preview .iti__flag.iti__et {
  height: 10px;
  background-position: -1577px 0px;
}
.fui-field-preview .iti__flag.iti__eu {
  height: 14px;
  background-position: -1599px 0px;
}
.fui-field-preview .iti__flag.iti__fi {
  height: 12px;
  background-position: -1621px 0px;
}
.fui-field-preview .iti__flag.iti__fj {
  height: 10px;
  background-position: -1643px 0px;
}
.fui-field-preview .iti__flag.iti__fk {
  height: 10px;
  background-position: -1665px 0px;
}
.fui-field-preview .iti__flag.iti__fm {
  height: 11px;
  background-position: -1687px 0px;
}
.fui-field-preview .iti__flag.iti__fo {
  height: 15px;
  background-position: -1709px 0px;
}
.fui-field-preview .iti__flag.iti__fr {
  height: 14px;
  background-position: -1731px 0px;
}
.fui-field-preview .iti__flag.iti__ga {
  height: 15px;
  background-position: -1753px 0px;
}
.fui-field-preview .iti__flag.iti__gb {
  height: 10px;
  background-position: -1775px 0px;
}
.fui-field-preview .iti__flag.iti__gd {
  height: 12px;
  background-position: -1797px 0px;
}
.fui-field-preview .iti__flag.iti__ge {
  height: 14px;
  background-position: -1819px 0px;
}
.fui-field-preview .iti__flag.iti__gf {
  height: 14px;
  background-position: -1841px 0px;
}
.fui-field-preview .iti__flag.iti__gg {
  height: 14px;
  background-position: -1863px 0px;
}
.fui-field-preview .iti__flag.iti__gh {
  height: 14px;
  background-position: -1885px 0px;
}
.fui-field-preview .iti__flag.iti__gi {
  height: 10px;
  background-position: -1907px 0px;
}
.fui-field-preview .iti__flag.iti__gl {
  height: 14px;
  background-position: -1929px 0px;
}
.fui-field-preview .iti__flag.iti__gm {
  height: 14px;
  background-position: -1951px 0px;
}
.fui-field-preview .iti__flag.iti__gn {
  height: 14px;
  background-position: -1973px 0px;
}
.fui-field-preview .iti__flag.iti__gp {
  height: 14px;
  background-position: -1995px 0px;
}
.fui-field-preview .iti__flag.iti__gq {
  height: 14px;
  background-position: -2017px 0px;
}
.fui-field-preview .iti__flag.iti__gr {
  height: 14px;
  background-position: -2039px 0px;
}
.fui-field-preview .iti__flag.iti__gs {
  height: 10px;
  background-position: -2061px 0px;
}
.fui-field-preview .iti__flag.iti__gt {
  height: 13px;
  background-position: -2083px 0px;
}
.fui-field-preview .iti__flag.iti__gu {
  height: 11px;
  background-position: -2105px 0px;
}
.fui-field-preview .iti__flag.iti__gw {
  height: 10px;
  background-position: -2127px 0px;
}
.fui-field-preview .iti__flag.iti__gy {
  height: 12px;
  background-position: -2149px 0px;
}
.fui-field-preview .iti__flag.iti__hk {
  height: 14px;
  background-position: -2171px 0px;
}
.fui-field-preview .iti__flag.iti__hm {
  height: 10px;
  background-position: -2193px 0px;
}
.fui-field-preview .iti__flag.iti__hn {
  height: 10px;
  background-position: -2215px 0px;
}
.fui-field-preview .iti__flag.iti__hr {
  height: 10px;
  background-position: -2237px 0px;
}
.fui-field-preview .iti__flag.iti__ht {
  height: 12px;
  background-position: -2259px 0px;
}
.fui-field-preview .iti__flag.iti__hu {
  height: 10px;
  background-position: -2281px 0px;
}
.fui-field-preview .iti__flag.iti__ic {
  height: 14px;
  background-position: -2303px 0px;
}
.fui-field-preview .iti__flag.iti__id {
  height: 14px;
  background-position: -2325px 0px;
}
.fui-field-preview .iti__flag.iti__ie {
  height: 10px;
  background-position: -2347px 0px;
}
.fui-field-preview .iti__flag.iti__il {
  height: 15px;
  background-position: -2369px 0px;
}
.fui-field-preview .iti__flag.iti__im {
  height: 10px;
  background-position: -2391px 0px;
}
.fui-field-preview .iti__flag.iti__in {
  height: 14px;
  background-position: -2413px 0px;
}
.fui-field-preview .iti__flag.iti__io {
  height: 10px;
  background-position: -2435px 0px;
}
.fui-field-preview .iti__flag.iti__iq {
  height: 14px;
  background-position: -2457px 0px;
}
.fui-field-preview .iti__flag.iti__ir {
  height: 12px;
  background-position: -2479px 0px;
}
.fui-field-preview .iti__flag.iti__is {
  height: 15px;
  background-position: -2501px 0px;
}
.fui-field-preview .iti__flag.iti__it {
  height: 14px;
  background-position: -2523px 0px;
}
.fui-field-preview .iti__flag.iti__je {
  height: 12px;
  background-position: -2545px 0px;
}
.fui-field-preview .iti__flag.iti__jm {
  height: 10px;
  background-position: -2567px 0px;
}
.fui-field-preview .iti__flag.iti__jo {
  height: 10px;
  background-position: -2589px 0px;
}
.fui-field-preview .iti__flag.iti__jp {
  height: 14px;
  background-position: -2611px 0px;
}
.fui-field-preview .iti__flag.iti__ke {
  height: 14px;
  background-position: -2633px 0px;
}
.fui-field-preview .iti__flag.iti__kg {
  height: 12px;
  background-position: -2655px 0px;
}
.fui-field-preview .iti__flag.iti__kh {
  height: 13px;
  background-position: -2677px 0px;
}
.fui-field-preview .iti__flag.iti__ki {
  height: 10px;
  background-position: -2699px 0px;
}
.fui-field-preview .iti__flag.iti__km {
  height: 12px;
  background-position: -2721px 0px;
}
.fui-field-preview .iti__flag.iti__kn {
  height: 14px;
  background-position: -2743px 0px;
}
.fui-field-preview .iti__flag.iti__kp {
  height: 10px;
  background-position: -2765px 0px;
}
.fui-field-preview .iti__flag.iti__kr {
  height: 14px;
  background-position: -2787px 0px;
}
.fui-field-preview .iti__flag.iti__kw {
  height: 10px;
  background-position: -2809px 0px;
}
.fui-field-preview .iti__flag.iti__ky {
  height: 10px;
  background-position: -2831px 0px;
}
.fui-field-preview .iti__flag.iti__kz {
  height: 10px;
  background-position: -2853px 0px;
}
.fui-field-preview .iti__flag.iti__la {
  height: 14px;
  background-position: -2875px 0px;
}
.fui-field-preview .iti__flag.iti__lb {
  height: 14px;
  background-position: -2897px 0px;
}
.fui-field-preview .iti__flag.iti__lc {
  height: 10px;
  background-position: -2919px 0px;
}
.fui-field-preview .iti__flag.iti__li {
  height: 12px;
  background-position: -2941px 0px;
}
.fui-field-preview .iti__flag.iti__lk {
  height: 10px;
  background-position: -2963px 0px;
}
.fui-field-preview .iti__flag.iti__lr {
  height: 11px;
  background-position: -2985px 0px;
}
.fui-field-preview .iti__flag.iti__ls {
  height: 14px;
  background-position: -3007px 0px;
}
.fui-field-preview .iti__flag.iti__lt {
  height: 12px;
  background-position: -3029px 0px;
}
.fui-field-preview .iti__flag.iti__lu {
  height: 12px;
  background-position: -3051px 0px;
}
.fui-field-preview .iti__flag.iti__lv {
  height: 10px;
  background-position: -3073px 0px;
}
.fui-field-preview .iti__flag.iti__ly {
  height: 10px;
  background-position: -3095px 0px;
}
.fui-field-preview .iti__flag.iti__ma {
  height: 14px;
  background-position: -3117px 0px;
}
.fui-field-preview .iti__flag.iti__mc {
  height: 15px;
  background-position: -3139px 0px;
}
.fui-field-preview .iti__flag.iti__md {
  height: 10px;
  background-position: -3160px 0px;
}
.fui-field-preview .iti__flag.iti__me {
  height: 10px;
  background-position: -3182px 0px;
}
.fui-field-preview .iti__flag.iti__mf {
  height: 14px;
  background-position: -3204px 0px;
}
.fui-field-preview .iti__flag.iti__mg {
  height: 14px;
  background-position: -3226px 0px;
}
.fui-field-preview .iti__flag.iti__mh {
  height: 11px;
  background-position: -3248px 0px;
}
.fui-field-preview .iti__flag.iti__mk {
  height: 10px;
  background-position: -3270px 0px;
}
.fui-field-preview .iti__flag.iti__ml {
  height: 14px;
  background-position: -3292px 0px;
}
.fui-field-preview .iti__flag.iti__mm {
  height: 14px;
  background-position: -3314px 0px;
}
.fui-field-preview .iti__flag.iti__mn {
  height: 10px;
  background-position: -3336px 0px;
}
.fui-field-preview .iti__flag.iti__mo {
  height: 14px;
  background-position: -3358px 0px;
}
.fui-field-preview .iti__flag.iti__mp {
  height: 10px;
  background-position: -3380px 0px;
}
.fui-field-preview .iti__flag.iti__mq {
  height: 14px;
  background-position: -3402px 0px;
}
.fui-field-preview .iti__flag.iti__mr {
  height: 14px;
  background-position: -3424px 0px;
}
.fui-field-preview .iti__flag.iti__ms {
  height: 10px;
  background-position: -3446px 0px;
}
.fui-field-preview .iti__flag.iti__mt {
  height: 14px;
  background-position: -3468px 0px;
}
.fui-field-preview .iti__flag.iti__mu {
  height: 14px;
  background-position: -3490px 0px;
}
.fui-field-preview .iti__flag.iti__mv {
  height: 14px;
  background-position: -3512px 0px;
}
.fui-field-preview .iti__flag.iti__mw {
  height: 14px;
  background-position: -3534px 0px;
}
.fui-field-preview .iti__flag.iti__mx {
  height: 12px;
  background-position: -3556px 0px;
}
.fui-field-preview .iti__flag.iti__my {
  height: 10px;
  background-position: -3578px 0px;
}
.fui-field-preview .iti__flag.iti__mz {
  height: 14px;
  background-position: -3600px 0px;
}
.fui-field-preview .iti__flag.iti__na {
  height: 14px;
  background-position: -3622px 0px;
}
.fui-field-preview .iti__flag.iti__nc {
  height: 10px;
  background-position: -3644px 0px;
}
.fui-field-preview .iti__flag.iti__ne {
  height: 15px;
  background-position: -3666px 0px;
}
.fui-field-preview .iti__flag.iti__nf {
  height: 10px;
  background-position: -3686px 0px;
}
.fui-field-preview .iti__flag.iti__ng {
  height: 10px;
  background-position: -3708px 0px;
}
.fui-field-preview .iti__flag.iti__ni {
  height: 12px;
  background-position: -3730px 0px;
}
.fui-field-preview .iti__flag.iti__nl {
  height: 14px;
  background-position: -3752px 0px;
}
.fui-field-preview .iti__flag.iti__no {
  height: 15px;
  background-position: -3774px 0px;
}
.fui-field-preview .iti__flag.iti__np {
  height: 15px;
  background-position: -3796px 0px;
}
.fui-field-preview .iti__flag.iti__nr {
  height: 10px;
  background-position: -3811px 0px;
}
.fui-field-preview .iti__flag.iti__nu {
  height: 10px;
  background-position: -3833px 0px;
}
.fui-field-preview .iti__flag.iti__nz {
  height: 10px;
  background-position: -3855px 0px;
}
.fui-field-preview .iti__flag.iti__om {
  height: 10px;
  background-position: -3877px 0px;
}
.fui-field-preview .iti__flag.iti__pa {
  height: 14px;
  background-position: -3899px 0px;
}
.fui-field-preview .iti__flag.iti__pe {
  height: 14px;
  background-position: -3921px 0px;
}
.fui-field-preview .iti__flag.iti__pf {
  height: 14px;
  background-position: -3943px 0px;
}
.fui-field-preview .iti__flag.iti__pg {
  height: 15px;
  background-position: -3965px 0px;
}
.fui-field-preview .iti__flag.iti__ph {
  height: 10px;
  background-position: -3987px 0px;
}
.fui-field-preview .iti__flag.iti__pk {
  height: 14px;
  background-position: -4009px 0px;
}
.fui-field-preview .iti__flag.iti__pl {
  height: 13px;
  background-position: -4031px 0px;
}
.fui-field-preview .iti__flag.iti__pm {
  height: 14px;
  background-position: -4053px 0px;
}
.fui-field-preview .iti__flag.iti__pn {
  height: 10px;
  background-position: -4075px 0px;
}
.fui-field-preview .iti__flag.iti__pr {
  height: 14px;
  background-position: -4097px 0px;
}
.fui-field-preview .iti__flag.iti__ps {
  height: 10px;
  background-position: -4119px 0px;
}
.fui-field-preview .iti__flag.iti__pt {
  height: 14px;
  background-position: -4141px 0px;
}
.fui-field-preview .iti__flag.iti__pw {
  height: 13px;
  background-position: -4163px 0px;
}
.fui-field-preview .iti__flag.iti__py {
  height: 11px;
  background-position: -4185px 0px;
}
.fui-field-preview .iti__flag.iti__qa {
  height: 8px;
  background-position: -4207px 0px;
}
.fui-field-preview .iti__flag.iti__re {
  height: 14px;
  background-position: -4229px 0px;
}
.fui-field-preview .iti__flag.iti__ro {
  height: 14px;
  background-position: -4251px 0px;
}
.fui-field-preview .iti__flag.iti__rs {
  height: 14px;
  background-position: -4273px 0px;
}
.fui-field-preview .iti__flag.iti__ru {
  height: 14px;
  background-position: -4295px 0px;
}
.fui-field-preview .iti__flag.iti__rw {
  height: 14px;
  background-position: -4317px 0px;
}
.fui-field-preview .iti__flag.iti__sa {
  height: 14px;
  background-position: -4339px 0px;
}
.fui-field-preview .iti__flag.iti__sb {
  height: 10px;
  background-position: -4361px 0px;
}
.fui-field-preview .iti__flag.iti__sc {
  height: 10px;
  background-position: -4383px 0px;
}
.fui-field-preview .iti__flag.iti__sd {
  height: 10px;
  background-position: -4405px 0px;
}
.fui-field-preview .iti__flag.iti__se {
  height: 13px;
  background-position: -4427px 0px;
}
.fui-field-preview .iti__flag.iti__sg {
  height: 14px;
  background-position: -4449px 0px;
}
.fui-field-preview .iti__flag.iti__sh {
  height: 10px;
  background-position: -4471px 0px;
}
.fui-field-preview .iti__flag.iti__si {
  height: 10px;
  background-position: -4493px 0px;
}
.fui-field-preview .iti__flag.iti__sj {
  height: 15px;
  background-position: -4515px 0px;
}
.fui-field-preview .iti__flag.iti__sk {
  height: 14px;
  background-position: -4537px 0px;
}
.fui-field-preview .iti__flag.iti__sl {
  height: 14px;
  background-position: -4559px 0px;
}
.fui-field-preview .iti__flag.iti__sm {
  height: 15px;
  background-position: -4581px 0px;
}
.fui-field-preview .iti__flag.iti__sn {
  height: 14px;
  background-position: -4603px 0px;
}
.fui-field-preview .iti__flag.iti__so {
  height: 14px;
  background-position: -4625px 0px;
}
.fui-field-preview .iti__flag.iti__sr {
  height: 14px;
  background-position: -4647px 0px;
}
.fui-field-preview .iti__flag.iti__ss {
  height: 10px;
  background-position: -4669px 0px;
}
.fui-field-preview .iti__flag.iti__st {
  height: 10px;
  background-position: -4691px 0px;
}
.fui-field-preview .iti__flag.iti__sv {
  height: 12px;
  background-position: -4713px 0px;
}
.fui-field-preview .iti__flag.iti__sx {
  height: 14px;
  background-position: -4735px 0px;
}
.fui-field-preview .iti__flag.iti__sy {
  height: 14px;
  background-position: -4757px 0px;
}
.fui-field-preview .iti__flag.iti__sz {
  height: 14px;
  background-position: -4779px 0px;
}
.fui-field-preview .iti__flag.iti__ta {
  height: 10px;
  background-position: -4801px 0px;
}
.fui-field-preview .iti__flag.iti__tc {
  height: 10px;
  background-position: -4823px 0px;
}
.fui-field-preview .iti__flag.iti__td {
  height: 14px;
  background-position: -4845px 0px;
}
.fui-field-preview .iti__flag.iti__tf {
  height: 14px;
  background-position: -4867px 0px;
}
.fui-field-preview .iti__flag.iti__tg {
  height: 13px;
  background-position: -4889px 0px;
}
.fui-field-preview .iti__flag.iti__th {
  height: 14px;
  background-position: -4911px 0px;
}
.fui-field-preview .iti__flag.iti__tj {
  height: 10px;
  background-position: -4933px 0px;
}
.fui-field-preview .iti__flag.iti__tk {
  height: 10px;
  background-position: -4955px 0px;
}
.fui-field-preview .iti__flag.iti__tl {
  height: 10px;
  background-position: -4977px 0px;
}
.fui-field-preview .iti__flag.iti__tm {
  height: 14px;
  background-position: -4999px 0px;
}
.fui-field-preview .iti__flag.iti__tn {
  height: 14px;
  background-position: -5021px 0px;
}
.fui-field-preview .iti__flag.iti__to {
  height: 10px;
  background-position: -5043px 0px;
}
.fui-field-preview .iti__flag.iti__tr {
  height: 14px;
  background-position: -5065px 0px;
}
.fui-field-preview .iti__flag.iti__tt {
  height: 12px;
  background-position: -5087px 0px;
}
.fui-field-preview .iti__flag.iti__tv {
  height: 10px;
  background-position: -5109px 0px;
}
.fui-field-preview .iti__flag.iti__tw {
  height: 14px;
  background-position: -5131px 0px;
}
.fui-field-preview .iti__flag.iti__tz {
  height: 14px;
  background-position: -5153px 0px;
}
.fui-field-preview .iti__flag.iti__ua {
  height: 14px;
  background-position: -5175px 0px;
}
.fui-field-preview .iti__flag.iti__ug {
  height: 14px;
  background-position: -5197px 0px;
}
.fui-field-preview .iti__flag.iti__um {
  height: 11px;
  background-position: -5219px 0px;
}
.fui-field-preview .iti__flag.iti__un {
  height: 14px;
  background-position: -5241px 0px;
}
.fui-field-preview .iti__flag.iti__us {
  height: 11px;
  background-position: -5263px 0px;
}
.fui-field-preview .iti__flag.iti__uy {
  height: 14px;
  background-position: -5285px 0px;
}
.fui-field-preview .iti__flag.iti__uz {
  height: 10px;
  background-position: -5307px 0px;
}
.fui-field-preview .iti__flag.iti__va {
  height: 15px;
  background-position: -5329px 0px;
}
.fui-field-preview .iti__flag.iti__vc {
  height: 14px;
  background-position: -5346px 0px;
}
.fui-field-preview .iti__flag.iti__ve {
  height: 14px;
  background-position: -5368px 0px;
}
.fui-field-preview .iti__flag.iti__vg {
  height: 10px;
  background-position: -5390px 0px;
}
.fui-field-preview .iti__flag.iti__vi {
  height: 14px;
  background-position: -5412px 0px;
}
.fui-field-preview .iti__flag.iti__vn {
  height: 14px;
  background-position: -5434px 0px;
}
.fui-field-preview .iti__flag.iti__vu {
  height: 12px;
  background-position: -5456px 0px;
}
.fui-field-preview .iti__flag.iti__wf {
  height: 14px;
  background-position: -5478px 0px;
}
.fui-field-preview .iti__flag.iti__ws {
  height: 10px;
  background-position: -5500px 0px;
}
.fui-field-preview .iti__flag.iti__xk {
  height: 15px;
  background-position: -5522px 0px;
}
.fui-field-preview .iti__flag.iti__ye {
  height: 14px;
  background-position: -5544px 0px;
}
.fui-field-preview .iti__flag.iti__yt {
  height: 14px;
  background-position: -5566px 0px;
}
.fui-field-preview .iti__flag.iti__za {
  height: 14px;
  background-position: -5588px 0px;
}
.fui-field-preview .iti__flag.iti__zm {
  height: 14px;
  background-position: -5610px 0px;
}
.fui-field-preview .iti__flag.iti__zw {
  height: 10px;
  background-position: -5632px 0px;
}
.fui-field-preview .fui-type-payment {
  position: relative;
}
.fui-field-preview .fui-payment-icon {
  position: absolute;
  width: 20px;
  height: 20px;
  top: 50%;
  left: 1rem;
  margin-top: -10px;
}
.fui-field-preview .fui-payment-icon svg * {
  fill: #515e80;
}
.fui-field-preview .fui-payment-number {
  position: absolute;
  top: 50%;
  left: 3rem;
  margin-top: -10px;
  color: #b8c3ce;
}
.fui-field-preview .fui-payment-expiry {
  position: absolute;
  top: 50%;
  margin-top: -10px;
  right: 1rem;
  color: #b8c3ce;
}
.fui-field-preview .fui-paypal-button {
  background: #ffc439;
  color: #2C2E2F;
  border-radius: 4px;
  margin: 10px 0;
}
.fui-field-preview .fui-paypal-button-label-container {
  padding: 14px;
  display: flex;
  align-items: center;
  margin: auto;
  justify-content: center;
}
.fui-field-preview .fui-paypal-button-text {
  font-weight: bold;
}
.fui-field-preview .fui-paypal-button img {
  width: 65px;
  margin-right: 10px;
}
.fui-color-field {
  margin: 0 !important;
  padding: 3px !important;
  height: 34px;
}
.fui-field-input.is-disabled {
  background-color: #ebeff3;
}
.field[data-type=toggleBlock] {
  position: static;
  margin: 0;
}
.field[data-type=toggleBlock] > .field {
  position: static;
}
.fui-toggle-block {
  margin-bottom: 8px;
  border-radius: 5px;
  border: 1px solid rgba(51, 64, 77, 0.1);
  background-color: #f3f7fc;
  outline: none;
  overflow: hidden;
}
.fui-toggle-block.has-errors {
  border-color: #EF4E4E;
}
.fui-tb-header {
  position: relative;
  display: flex;
  align-items: center;
  padding: 10px;
  box-shadow: 0 1px 0 rgba(51, 64, 77, 0.1);
}
.has-errors .fui-tb-header {
  background-color: rgba(207, 17, 36, 0.1);
}
.fui-tb-header .field {
  margin: 0;
}
.fui-tb-header [data-type=collapse] {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
.fui-tb-header [data-type=collapse] .field {
  position: relative;
  width: 100%;
  height: 100%;
}
.fui-tb-header .fui-toggle {
  position: absolute;
  width: 100%;
  height: 100%;
  text-align: right;
  cursor: pointer;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  z-index: 1;
}
.fui-tb-header .fui-toggle:before {
  content: "downangle";
  font-family: "Craft";
  speak: none;
  font-feature-settings: "liga", "dlig";
  text-rendering: optimizeLegibility;
  font-weight: normal;
  font-variant: normal;
  text-transform: none;
  line-height: 1;
  direction: ltr;
  display: inline-block;
  text-align: center;
  font-style: normal;
  vertical-align: middle;
  word-wrap: normal !important;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  opacity: 0.8;
  padding: 13px 15px;
  transition: transform linear 100ms;
  transform: rotate(0deg);
}
.fui-tb-header .fui-toggle.expanded:before {
  transform: rotate(180deg);
}
.fui-tb-header .lightswitch {
  position: relative;
  z-index: 2;
  margin-right: 5px;
}
.fui-tb-header-title {
  font-weight: 600;
  font-size: 14px;
  margin-left: 5px;
  color: #5f6c7b;
}
.has-errors .fui-tb-header-title {
  color: #EF4E4E;
}
.fui-tb-body {
  padding: 14px;
}
.lightswitch.extra-small {
  border-radius: 7px;
  width: 24px;
  height: 14px;
}
.lightswitch.extra-small .lightswitch-container {
  width: 34px;
}
.lightswitch.extra-small .lightswitch-container .handle {
  border-radius: 8px;
  width: 12px;
  height: 12px;
  left: calc(50% - 4px);
}
.lightswitch.extra-small.on .lightswitch-container .handle {
  left: calc(50% - 6px);
}
.fui-submission .fields .field > .heading > label {
  font-weight: 600;
}
.fui-submission .fields .field .field label {
  font-size: 11px;
  color: #8ba1ba;
  font-weight: 500;
  margin-bottom: 0;
  display: block;
}
.fui-submission .fields .fui-row {
  margin-bottom: 15px;
}
.fui-submission .fields .fui-row:last-child {
  margin-bottom: 0;
}
.fui-submission .fields .fui-field-hr {
  padding: 1rem;
}
.fui-submission .fields .fui-field-hr hr {
  border-color: #cbd5e0;
  padding: 0;
  margin: 0;
}
.fui-submission .fields .fui-pre {
  border: 1px solid rgba(96, 125, 159, 0.25);
  background-color: #fbfcfd;
  border-radius: 3px;
  padding: 20px;
  margin: 0;
}
.fui-fields-inner-wrapper {
  overflow: auto;
  position: absolute;
  top: 55px;
  bottom: 0;
  left: 0;
  width: 100%;
}
.fui-fields-inner-wrapper * {
  box-sizing: border-box;
}
.fui-fields-scroll {
  padding: 16px;
}
.fui-fields-pane {
  display: flex;
  margin: -24px;
  position: relative;
  height: calc(100vh - 236px);
}
.fui-fields-wrapper {
  position: relative;
  flex: 1;
  height: 100%;
}
.fui-fields-wrapper > .fui-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.info-hud {
  max-width: 28rem;
}
.fui-field-tabs {
  position: -webkit-sticky;
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  background: #fff;
  z-index: 11;
  box-shadow: 0 1px 5px 0 rgba(205, 216, 228, 0.25);
}
.fui-editor-tabs {
  position: absolute;
}
.fui-field-tabs .fui-pages-menu {
  padding: 0 3px 0 24px;
}
.fui-field-tabs .fui-tab-btn {
  position: relative;
  padding: 4px 9px;
  margin: 10px 7px;
  border-radius: 3px;
  color: #33475b;
  font-size: 15px;
  margin-left: auto;
  border: 1px solid #d7dce2;
  background-image: linear-gradient(#fff, #fafafa);
}
.fui-field-tabs .fui-tab-btn:hover {
  text-decoration: none;
}
.fui-field-tabs .fui-tab-btn:after {
  content: "settings";
  position: relative;
  top: 1px;
  font-family: Craft, sans-serif;
}
.fui-menu {
  padding: 0;
  overflow: hidden;
}
.fui-menu ul li a {
  margin: 0;
  padding: 6px 14px 6px 30px !important;
  font-size: 13px;
}
.fui-menu li a[data-icon]:before,
.fui-menu li a.icon:before,
.fui-menu li a.sel:before {
  margin: 3px 0 0 -20px !important;
}
.form-field-drop-target-container {
  position: relative;
  padding-left: 15px;
  padding-right: 15px;
  width: 100%;
  height: 6px;
}
.form-field-drop-target-container.is-active {
  z-index: 10;
}
.dropzone-holder {
  position: relative;
}
.form-field-dropzone {
  z-index: 1;
  position: absolute;
}
.form-field-dropzone-horizontal {
  height: 65px;
  width: 100%;
  top: -25px;
}
.dashed-dropzone {
  border: 1px dashed #0D99F2;
  border-radius: 1px;
  background-color: #e5f5f8;
  opacity: 0;
  visibility: hidden;
  transition: all 0.2s ease;
}
.is-disabled .dashed-dropzone {
  opacity: 0 !important;
  visibility: hidden !important;
}
.is-active > .dropzone-holder > .dashed-dropzone {
  opacity: 1;
  visibility: visible;
}
.is-hover .dashed-dropzone {
  background-color: #0D99F2;
}
.dashed-dropzone-horizontal {
  height: 11px;
}
.form-field-drop-target {
  width: 0;
  z-index: 1;
  transform: translateY(2.4em) translateX(-5px);
}
.form-field-drop-target.is-active {
  z-index: 10;
}
.form-field-dropzone-vertical {
  z-index: 2;
  top: -20px;
  left: -10px;
  width: 30px;
  height: 80px;
}
.dashed-dropzone-vertical {
  width: 11px;
  height: 40px;
}
.dropzone-new-field {
  position: relative;
  background-color: #fff;
  border: 1px dashed #8aa2bd;
  border-radius: 4px;
  color: #7c98b6;
  text-align: center;
  margin: 15px;
  padding: 30px;
  transition: all 0.2s ease;
  z-index: 10;
}
.dropzone-new-field.is-active {
  opacity: 1;
  visibility: visible;
}
.dropzone-new-field.is-hover {
  border: 1px dashed #0D99F2;
  background-color: #e5f5f8;
}
.dropzone-new-field span {
  pointer-events: none;
}
.fui-sidebar-wrapper {
  position: relative;
  flex: 0 0 350px;
  background-color: #f3f7fc;
  border-radius: 0 6px 6px 0;
  border-left: 1px solid rgba(51, 64, 77, 0.1);
  overflow: auto;
}
.fui-sidebar-scroll {
  padding: 15px;
}
.sidebar-title {
  margin-bottom: 10px;
  color: #33475b;
  font-size: 11px;
  opacity: 0.7;
}
.fui-sidebar-wrapper hr {
  margin: 10px 0 15px 0 !important;
}
.fui-sidebar-wrapper .add.btn {
  margin: 0 0 10px 0;
  transition: all 0.3s ease;
}
.fui-sidebar-wrapper .add.btn:hover {
  background-color: #e3e9f1 !important;
}
.fui-sidebar-wrapper .fui-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.fui-field-preview.fui-type-repeater {
  pointer-events: auto;
}
.fui-field-preview.fui-type-repeater .fui-field-label {
  font-size: 13px;
  color: #33475b;
  margin-bottom: 0;
}
.fui-field-preview .dropzone-new-field {
  margin: 0;
}
.fui-repeater-fields:not(.fui-empty) {
  padding: 10px 15px;
  background-color: #fff;
  border-radius: 4px;
  border: 1px solid #e4ecf6;
}
.fui-repeater-button {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 15px 15px 10px;
  padding: 8px;
  border: 1px dashed #8aa2bd;
  border-radius: 4px;
  opacity: 0.5;
}
.fui-field-preview.fui-type-group {
  pointer-events: auto;
}
.fui-field-preview.fui-type-group .fui-field-label {
  font-size: 13px;
  color: #33475b;
  margin-bottom: 0;
}
.fui-field-preview .dropzone-new-field {
  margin: 0;
}
.fui-group-fields:not(.fui-empty) {
  padding: 10px 15px;
  background-color: #fff;
  border-radius: 4px;
  border: 1px solid #e4ecf6;
}
.fui-field-preview.fui-type-signature {
  position: relative;
}
.fui-field-preview.fui-type-signature .fui-field-input {
  height: 6rem;
}
.fui-field-preview.fui-type-signature img {
  position: absolute;
  height: 4rem;
  top: 1rem;
  left: 1rem;
}
.fui-pages-menu {
  display: flex;
  margin: 0;
  padding: 0 24px;
  border-bottom: 1px solid #e6e6e6;
  list-style: none;
  border-top-width: 0;
}
.fui-pages-menu ul {
  display: flex;
  margin-left: -15px;
  overflow-x: auto;
  overflow-y: hidden;
}
.fui-pages-menu li {
  display: flex;
  flex: 1 0 auto;
}
.fui-tab-item {
  position: relative;
  cursor: pointer;
  padding: 14px 15px 12px;
  color: #7e8fa0;
  font-size: 12px;
  line-height: 22px;
  font-weight: 500;
  text-transform: uppercase;
  text-decoration: none;
  box-shadow: none;
  outline: none;
  font-family: inherit;
  background: #fff;
  border: 0;
  margin: 0;
  cursor: pointer;
}
.fui-tab-item:hover {
  color: #0D99F2;
  text-decoration: none;
}
.fui-tab-item[aria-selected=true]::after, .fui-tab-item.sel::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 15px;
  right: 0;
  width: calc(100% - 30px);
  height: 2px;
  background: #0D99F2;
}
.fui-tab-item.is-hover {
  border-radius: 1px;
  background-color: #e5f5f8;
}
.fui-tab-item span {
  pointer-events: none;
}
.fui-field-tab-list .fui-pages-menu {
  padding: 0 9px;
}
.fui-modal-fieldtype {
  border-radius: 20px;
  background: #d8e2ea;
  padding: 1px 10px;
  font-weight: 400;
  font-size: 10px;
  color: #738496;
  margin-left: 10px;
  margin-top: 2px;
}
.fui-edit-notification-modal .fui-modal-content,
.fui-edit-field-modal .fui-modal-content {
  flex: 1;
}
.fui-existing-item-modal .fui-modal-content,
.fui-existing-item-modal .fui-modal-sidebar {
  overflow: auto;
}
.fui-notice-wrap {
  padding: 12px 24px 0;
}
.fui-notice {
  border: 1px solid transparent;
  padding: 0.5rem 0.75rem;
  position: relative;
  border-radius: 4px;
  font-size: 12px;
}
.fui-notice.warning {
  border-color: #f6ad55;
  color: #c05621;
  background: #fffaf0;
}
.fui-notice.error {
  border-color: #ef9898;
  color: #f05053;
  background: #fff6f6;
}
.fui-notice.success {
  border-color: #7ed321;
  color: #65a91a;
  background: #ecf8de;
}
.fui-modal-content-wrap {
  flex: 1;
  display: flex;
  height: 100%;
}
body.ltr .field .required:after {
  margin: -8px 0 0 5px !important;
}
.fui-existing-item-heading-wrap {
  position: relative;
  margin-bottom: 10px;
}
.fui-existing-item-heading-wrap::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 1px;
  background: #e2e8f0;
  transform: translateY(-50%);
}
.fui-existing-item-heading {
  position: relative;
  display: inline-block;
  text-transform: uppercase;
  font-weight: 600;
  font-size: 11px;
  position: relative;
  background: #fff;
  padding-right: 10px;
  z-index: 1;
  color: #98afc5;
}
.fui-existing-item {
  border-radius: 4px;
  border: 2px solid #cbd6e2;
  color: #33475b;
  padding: 10px 12px;
  font-size: 13px;
  font-weight: 400;
  background-color: #fff;
  position: relative;
  cursor: pointer;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  z-index: 11;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  transition: all 0.2s ease;
}
.fui-existing-item:hover {
  border-color: #aabcd0;
}
.fui-existing-item.sel {
  border-color: #0D99F2;
}
.fui-existing-item.disabled {
  cursor: auto;
  pointer-events: none;
  opacity: 0.3;
}
.fui-existing-item-wrap {
  max-width: 90%;
}
.fui-existing-item-title {
  font-weight: 500;
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.fui-existing-item-handle {
  font-size: 10px !important;
  border-radius: 13px;
  margin-left: 4px;
  line-height: 18px;
  display: inline-block;
  color: #98a6bd;
}
.fui-existing-item-type {
  font-size: 12px;
  color: #8394a5;
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.fui-existing-item-right {
  margin-left: auto;
  display: flex;
  align-items: center;
}
.fui-existing-item-icon {
  width: 16px;
  height: 16px;
  margin-left: 10px;
}
.fui-existing-item-icon svg {
  width: 100%;
  height: 100%;
}
/* General Integrations */
.fui-integrations-pane {
  display: flex;
  margin: -24px;
  position: relative;
}
.fui-integrations-pane .sidebar {
  padding: 0 0 14px;
}
.fui-integrations-pane .sidebar .heading {
  margin: 0;
  width: auto;
  padding: 14px 14px 2px;
}
.fui-integrations-pane .sidebar nav li a {
  padding: 7px 14px !important;
}
.fui-integrations-pane .sidebar .status {
  margin: 0 !important;
}
.fui-integrations-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 14px;
}
.fui-integrations-header h2 {
  margin: 0;
}
.fui-integrations-check-wrap {
  display: flex;
  align-items: center;
}
.fui-integrations-check-wrap .btn {
  margin-left: 10px;
}
#tab-integrations .fui-integrations-pane {
  height: calc(100vh - 236px);
}
.fui-integrations-sidebar-wrapper {
  position: relative;
  background-color: #f3f7fc;
  border-radius: 0 6px 6px 0;
  border-left: 1px solid rgba(51, 64, 77, 0.1);
  overflow: auto;
}
.fui-integrations-tabs li {
  width: 100%;
  max-width: 100% !important;
}
.fui-integrations-tabs .formie-integration-icon {
  width: 20px;
  height: 20px;
  margin-right: 10px;
}
/* Forms Integrations */
.fui-form-integrations-wrapper {
  position: relative;
  flex: 1;
  overflow: auto;
  height: 100%;
}
.fui-form-integrations-inner-wrapper {
  padding: 24px;
  overflow: hidden;
}
/* Settings Integrations */
.fui-settings-block {
  padding: 16px;
  background: #f3f7fc;
  border-radius: 3px;
  border: 1px solid #cbd6e2;
  margin-bottom: 24px;
}
.fui-settings-block ul {
  list-style-type: disc;
}
.fui-settings-block ol, .fui-settings-block ul {
  padding-left: 20px !important;
}
.fui-settings-wrap {
  padding: 16px;
  background: #f3f7fc;
  border-radius: 3px;
  border: 1px solid #cbd6e2;
}
.fui-form-template-spinner {
  margin-top: -18px;
  display: flex;
  align-items: center;
  margin-bottom: 14px;
  font-weight: 600;
  color: #9ba5b1;
}
.fui-form-template-spinner .spinner {
  margin-right: 10px;
}
.fui-btn-transparent {
  background: transparent !important;
}`)();
function makeMap(str, expectsLowerCase) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const list3 = str.split(",");
  for (let i = 0; i < list3.length; i++) {
    map3[list3[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map3[val.toLowerCase()] : (val) => !!map3[val];
}
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range$2 = 2;
function generateCodeFrame(source, start2 = 0, end3 = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
  lines = lines.filter((_2, idx) => idx % 2 === 0);
  let count2 = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count2 += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count2 >= start2) {
      for (let j2 = i - range$2; j2 <= i + range$2 || end3 > count2; j2++) {
        if (j2 < 0 || j2 >= lines.length)
          continue;
        const line = j2 + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j2]}`);
        const lineLength = lines[j2].length;
        const newLineSeqLength = newlineSequences[j2] && newlineSequences[j2].length || 0;
        if (j2 === i) {
          const pad = start2 - (count2 - (lineLength + newLineSeqLength));
          const length3 = Math.max(1, end3 > count2 ? lineLength - pad : end3 - start2);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length3));
        } else if (j2 > i) {
          if (end3 > count2) {
            const length3 = Math.max(Math.min(end3 - count2, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length3));
          }
          count2 += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value)) {
    return value;
  } else if (isObject$5(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$5(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props2) {
  if (!props2)
    return null;
  let { class: klass, style: style2 } = props2;
  if (klass && !isString$1(klass)) {
    props2.class = normalizeClass(klass);
  }
  if (style2) {
    props2.style = normalizeStyle(style2);
  }
  return props2;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$5(a);
  bValidType = isObject$5(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$5(val) && (val.toString === objectToString$1 || !isFunction$3(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$5(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr, el2) => {
  const i = arr.indexOf(el2);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$h = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$h.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction$3 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$5 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$5(val) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction$1 = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE$1 = /-(\w)/g;
const camelize$1 = cacheStringFunction$1((str) => {
  return str.replace(camelizeRE$1, (_2, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction$1((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction$1((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction$1((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber$1 = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function warn$3(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn2) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn$3(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect3, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect3);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  } else {
    warn$3(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect3) => {
  const { deps } = effect3;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect3);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
  constructor(fn2, scheduler = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect3) {
  const { deps } = effect3;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect3);
    }
    deps.length = 0;
  }
}
function effect$3(fn2, options2) {
  if (fn2.effect) {
    fn2 = fn2.effect.fn;
  }
  const _effect = new ReactiveEffect(fn2);
  if (options2) {
    extend$2(_effect, options2);
    if (options2.scope)
      recordEffectScope(_effect, options2.scope);
  }
  if (!options2 || !options2.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target2, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = { effect: activeEffect, target: target2, type, key };
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target2, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target2)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = { target: target2, type, key, newValue, oldValue, oldTarget };
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0], eventInfo);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects), eventInfo);
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$2(dep) ? dep : [...dep];
  for (const effect3 of effects) {
    if (effect3.computed) {
      triggerEffect(effect3, debuggerEventExtraInfo);
    }
  }
  for (const effect3 of effects) {
    if (!effect3.computed) {
      triggerEffect(effect3, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect3, debuggerEventExtraInfo) {
  if (effect3 !== activeEffect || effect3.allowRecurse) {
    if (effect3.onTrigger) {
      effect3.onTrigger(extend$2({ effect: effect3 }, debuggerEventExtraInfo));
    }
    if (effect3.scheduler) {
      effect3.scheduler();
    } else {
      effect3.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1));
const get$3 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get4(target2, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2)) {
      return target2;
    }
    const targetIsArray = isArray$2(target2);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target2, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$5(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set3(target2, key, value, receiver) {
    let oldValue = target2[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow$1(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$2(target2) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$2(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn(target2, key);
    const result = Reflect.set(target2, key, value, receiver);
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target2, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target2, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target2, key) {
  const hadKey = hasOwn(target2, key);
  const oldValue = target2[key];
  const result = Reflect.deleteProperty(target2, key);
  if (result && hadKey) {
    trigger(target2, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$4(target2, key) {
  const result = Reflect.has(target2, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target2, "has", key);
  }
  return result;
}
function ownKeys$2(target2) {
  track(target2, "iterate", isArray$2(target2) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target2);
}
const mutableHandlers = {
  get: get$3,
  set,
  deleteProperty,
  has: has$4,
  ownKeys: ownKeys$2
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target2, key) {
    {
      warn$3(`Set operation on key "${String(key)}" failed: target is readonly.`, target2);
    }
    return true;
  },
  deleteProperty(target2, key) {
    {
      warn$3(`Delete operation on key "${String(key)}" failed: target is readonly.`, target2);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$2({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$2({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1$1(target2, key, isReadonly2 = false, isShallow2 = false) {
  target2 = target2["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target2.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target2.get(rawKey));
  } else if (target2 !== rawTarget) {
    target2.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target2 = this["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
}
function size$1(target2, isReadonly2 = false) {
  target2 = target2["__v_raw"];
  !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
  return Reflect.get(target2, "size", target2);
}
function add$1(value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const proto = getProto(target2);
  const hadKey = proto.has.call(target2, value);
  if (!hadKey) {
    target2.add(value);
    trigger(target2, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const { has: has2, get: get4 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  } else {
    checkIdentityKeys(target2, has2, key);
  }
  const oldValue = get4.call(target2, key);
  target2.set(key, value);
  if (!hadKey) {
    trigger(target2, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target2, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target2 = toRaw(this);
  const { has: has2, get: get4 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  } else {
    checkIdentityKeys(target2, has2, key);
  }
  const oldValue = get4 ? get4.call(target2, key) : void 0;
  const result = target2.delete(key);
  if (hadKey) {
    trigger(target2, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target2 = toRaw(this);
  const hadItems = target2.size !== 0;
  const oldTarget = isMap(target2) ? new Map(target2) : new Set(target2);
  const result = target2.clear();
  if (hadItems) {
    trigger(target2, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target2 = observed["__v_raw"];
    const rawTarget = toRaw(target2);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target2.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target2[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$1(this, key);
    },
    get size() {
      return size$1(this);
    },
    has: has$1$1,
    add: add$1,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, false, true);
    },
    get size() {
      return size$1(this);
    },
    has: has$1$1,
    add: add$1,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target2, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target2;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target2 ? instrumentations : target2, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target2, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target2, rawKey)) {
    const type = toRawType(target2);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target2) {
  if (isReadonly(target2)) {
    return target2;
  }
  return createReactiveObject(target2, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target2) {
  return createReactiveObject(target2, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target2) {
  return createReactiveObject(target2, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target2) {
  return createReactiveObject(target2, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$5(target2)) {
    {
      console.warn(`value cannot be made reactive: ${String(target2)}`);
    }
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(target2, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow$1(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw2 = observed && observed["__v_raw"];
  return raw2 ? toRaw(raw2) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$5(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$5(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, ref2.value);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
  set: (target2, key, value, receiver) => {
    const oldValue = target2[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target2, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get4, set: set3 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get4;
    this._set = set3;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (!isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$3(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      console.warn("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$2(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close2 = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
}
function formatProps(props2) {
  const res = [];
  const keys2 = Object.keys(props2);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props2[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw2) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw2 ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw2 ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw2 ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$3(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw2 ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn2, instance, type, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
  if (isFunction$3(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn2.length; i++) {
    values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type];
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$2(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id) {
  let start2 = flushIndex + 1;
  let end3 = queue.length;
  while (start2 < end3) {
    const middle = start2 + end3 >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start2 = middle + 1 : end3 = middle;
  }
  return start2;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$2(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen2, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if (checkRecursiveUpdates(seen2, activePreFlushCbs[preFlushIndex])) {
        continue;
      }
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen2, parentJob);
  }
}
function flushPostFlushCbs(seen2) {
  flushPreFlushCbs();
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen2, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen2 = seen2 || /* @__PURE__ */ new Map();
  }
  flushPreFlushCbs(seen2);
  queue.sort((a, b) => getId(a) - getId(b));
  const check2 = (job) => checkRecursiveUpdates(seen2, job);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (check2(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen2);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen2);
    }
  }
}
function checkRecursiveUpdates(seen2, fn2) {
  if (!seen2.has(fn2)) {
    seen2.set(fn2, 1);
  } else {
    const count2 = seen2.get(fn2);
    if (count2 > RECURSION_LIMIT) {
      const instance = fn2.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn$2(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen2.set(fn2, count2 + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
{
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map$3 = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map$3.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map$3.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map$3.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map$3.has(id)) {
    return false;
  }
  map$3.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map$3.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map$3.get(id);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
      if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
        instance.parent.ceReload(newComp.styles);
      }
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend$2(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn2) {
  return (id, arg) => {
    try {
      return fn2(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$2(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook, target2) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target2);
    });
    setTimeout(() => {
      if (!devtools) {
        target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$2("app:init", app, version2, {
    Fragment: Fragment$1,
    Text: Text$2,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$2("app:unmount", app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
const devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$2(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time2) => {
    emit$2(hook, component.appContext.app, component.uid, component, type, time2);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$2("component:emit", component.appContext.app, component, event, params);
}
function emit$1$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props2 = instance.vnode.props || EMPTY_OBJ;
  {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn$2(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator6 = emitsOptions[event];
        if (isFunction$3(validator6)) {
          const isValid = validator6(...rawArgs);
          if (!isValid) {
            warn$2(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props2) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number3, trim } = props2[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => a.trim());
    }
    if (number3) {
      args = rawArgs.map(toNumber$1);
    }
  }
  {
    devtoolsComponentEmit(instance, event, args);
  }
  {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props2[toHandlerKey(lowerCaseEvent)]) {
      warn$2(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props2[handlerName = toHandlerKey(event)] || props2[handlerName = toHandlerKey(camelize$1(event))];
  if (!handler && isModelListener2) {
    handler = props2[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props2[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp2, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp2);
  if (cached !== void 0) {
    return cached;
  }
  const raw2 = comp2.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp2)) {
    const extendEmits = (raw3) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw3, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp2.extends) {
      extendEmits(comp2.extends);
    }
    if (comp2.mixins) {
      comp2.mixins.forEach(extendEmits);
    }
  }
  if (!raw2 && !hasExtends) {
    cache.set(comp2, null);
    return null;
  }
  if (isArray$2(raw2)) {
    raw2.forEach((key) => normalized[key] = null);
  } else {
    extend$2(normalized, raw2);
  }
  cache.set(comp2, normalized);
  return normalized;
}
function isEmitListener(options2, key) {
  if (!options2 || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options2, key[0].toLowerCase() + key.slice(1)) || hasOwn(options2, hyphenate(key)) || hasOwn(options2, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn2(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props: props2, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render3, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render3.call(proxyToUse, proxyToUse, renderCache, props2, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render4 = Component;
      if (attrs === props2) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render4.length > 1 ? render4(props2, true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render4(props2, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  let setRoot = void 0;
  if (result.patchFlag > 0 && result.patchFlag & 2048) {
    [root2, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      } else if (!accessedAttrs && root2.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$2(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn$2(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (!isElementRoot(root2)) {
      warn$2(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (!isElementRoot(root2)) {
      warn$2(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root2.transition = vnode.transition;
  }
  if (setRoot) {
    setRoot(root2);
  } else {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index2 = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index2] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props2) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props2)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if ((prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$3(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch, o: { createElement: createElement2 } } = rendererInternals;
  const hiddenContainer = createElement2("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement2("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (!hasWarned) {
    hasWarned = true;
    console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
  }
  const { p: patch, m: move, um: unmount, n: next, o: { parentNode: parentNode2, remove: remove2 } } = rendererInternals;
  const timeout = toNumber$1(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(`suspense.resolve() is called without a pending branch.`);
        }
        if (suspense.isUnmounted) {
          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
        }
      }
      const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent2 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent2) {
        if (parent2.pendingBranch) {
          parent2.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent2 = parent2.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null, true);
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode2, parentNode2(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block3;
  if (isFunction$3(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block3 = currentBlock;
      closeBlock();
    }
  }
  if (isArray$2(s)) {
    const singleChild = filterSingleRoot(s);
    if (!singleChild) {
      warn$2(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block3 && !s.dynamicChildren) {
    s.dynamicChildren = block3.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el2 = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el2;
    updateHOCHostEl(parentComponent, el2);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    {
      warn$2(`provide() can only be used inside setup().`);
    }
  } else {
    let provides7 = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides7) {
      provides7 = currentInstance.provides = Object.create(parentProvides);
    }
    provides7[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides7 = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides7 && key in provides7) {
      return provides7[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else {
      warn$2(`injection "${String(key)}" not found.`);
    }
  } else {
    warn$2(`inject() can only be used inside setup() or functional components.`);
  }
}
function watchEffect(effect3, options2) {
  return doWatch(effect3, null, options2);
}
function watchPostEffect(effect3, options2) {
  return doWatch(effect3, null, Object.assign(Object.assign({}, options2), { flush: "post" }));
}
function watchSyncEffect(effect3, options2) {
  return doWatch(effect3, null, Object.assign(Object.assign({}, options2), { flush: "sync" }));
}
const INITIAL_WATCHER_VALUE = {};
function watch$1(source, cb, options2) {
  if (!isFunction$3(cb)) {
    warn$2(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options2);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger: onTrigger2 } = EMPTY_OBJ) {
  if (!cb) {
    if (immediate !== void 0) {
      warn$2(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn$2(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn$2(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow$1(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow$1(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$3(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
        warnInvalidSource(s);
      }
    });
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect3.onStop = () => {
      callWithErrorHandling(fn2, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect3.active) {
      return;
    }
    if (cb) {
      const newValue = effect3.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect3.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => queuePreFlushCb(job);
  }
  const effect3 = new ReactiveEffect(getter, scheduler);
  {
    effect3.onTrack = onTrack;
    effect3.onTrigger = onTrigger2;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect3.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect3.run.bind(effect3), instance && instance.suspense);
  } else {
    effect3.run();
  }
  return () => {
    effect3.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect3);
    }
  };
}
function instanceWatch(source, value, options2) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options2 = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options2);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$5(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (hasFound) {
              warn$2("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
              break;
            }
            child = c;
            hasFound = true;
          }
        }
      }
      const rawProps = toRaw(props2);
      const { mode } = rawProps;
      if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn$2(`invalid <transition> mode: ${mode}`);
      }
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state2, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state2, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state2, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el2._leaveCb = () => {
              earlyRemove();
              el2._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props2, state2, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props2;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks8 = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2._leaveCb) {
        el2._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el2]);
        } else {
          callHook2(afterHook, [el2]);
        }
        if (hooks8.delayedLeave) {
          hooks8.delayedLeave();
        }
        el2._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el2, done]);
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2._enterCb) {
        el2._enterCb(true);
      }
      if (state2.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el2]);
      let called = false;
      const done = el2._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el2]);
        } else {
          callHook2(onAfterLeave, [el2]);
        }
        el2._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el2, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props2, state2, instance);
    }
  };
  return hooks8;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks8) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks8);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks8.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks8.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks8;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment$1) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options2) {
  return isFunction$3(options2) ? { setup: options2, name: options2.name } : options2;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction$3(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp2) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (!comp2) {
        warn$2(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
      }
      if (comp2 && (comp2.__esModule || comp2[Symbol.toStringTag] === "Module")) {
        comp2 = comp2.default;
      }
      if (comp2 && !isObject$5(comp2) && !isFunction$3(comp2)) {
        throw new Error(`Invalid async component load result: ${comp2}`);
      }
      resolvedComp = comp2;
      return comp2;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp2) => {
          return () => createInnerComp(comp2, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded2 = ref(false);
      const error2 = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded2.value && !error2.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error2.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded2.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error2.value = err;
      });
      return () => {
        if (loaded2.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error2.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error2.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp2, { vnode: { ref: ref2, props: props2, children, shapeFlag }, parent }) {
  const vnode = createVNode(comp2, props2, children);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement: createElement2 } } } = sharedContext;
    const storageContainer = createElement2("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter2) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter2 || !filter2(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys2.delete(key);
    }
    watch$1(() => [props2.include, props2.exclude], ([include, exclude]) => {
      include && pruneCache((name) => matches$3(include, name));
      exclude && pruneCache((name) => !matches$3(exclude, name));
    }, { flush: "post", deep: true });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        {
          warn$2(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp2 = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp2);
      const { include, exclude, max: max3 } = props2;
      if (include && (!name || !matches$3(include, name)) || exclude && name && matches$3(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp2 : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key);
        keys2.add(key);
      } else {
        keys2.add(key);
        if (max3 && keys2.size > parseInt(max3, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches$3(pattern, name) {
  if (isArray$2(pattern)) {
    return pattern.some((p2) => matches$3(p2, name));
  } else if (isString$1(pattern)) {
    return pattern.split(",").includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target2;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target2);
  if (target2) {
    let current = target2.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target2, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target2);
}
function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target2 = currentInstance, prepend2 = false) {
  if (target2) {
    const hooks8 = target2[type] || (target2[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target2.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend2) {
      hooks8.unshift(wrappedHook);
    } else {
      hooks8.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn$2(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target2);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$2("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives2) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    warn$2(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives2.length; i++) {
    let [dir, value, arg, modifiers2 = EMPTY_OBJ] = directives2[i];
    if (isFunction$3(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers: modifiers2
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize(camelize$1(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$2(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else {
    warn$2(`resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`);
  }
}
function resolve(registry2, name) {
  return registry2 && (registry2[name] || registry2[camelize$1(name)] || registry2[capitalize(camelize$1(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$2(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn$2(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$5(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i = 0, l = keys2.length; i < l; i++) {
        const key = keys2[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$2(slot)) {
      for (let j2 = 0; j2 < slot.length; j2++) {
        slots[slot[j2].name] = slot[j2].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props2 = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot.length > 1) {
    warn$2(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props2));
  const rendered = createBlock(Fragment$1, { key: props2.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment$1 && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj) {
  const ret = {};
  if (!isObject$5(obj)) {
    warn$2(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => shallowReadonly(i.props),
  $attrs: (i) => shallowReadonly(i.attrs),
  $slots: (i) => shallowReadonly(i.slots),
  $refs: (i) => shallowReadonly(i.refs),
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: (i) => instanceWatch.bind(i)
});
const isReservedPrefix = (key) => key === "_" || key === "$";
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props: props2, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn(setupState, key)) {
      return setupState[key];
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props2[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props2[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
        markAttrsAccessed();
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString$1(key) || key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn$2(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn$2(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      warn$2(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$2(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target2, key, descriptor) {
    if (descriptor.get != null) {
      target2._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target2, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target2, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target2) => {
    warn$2(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target2);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$2({}, PublicInstanceProxyHandlers, {
  get(target2, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target2, key, target2);
  },
  has(_2, key) {
    const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
    if (!has2 && PublicInstanceProxyHandlers.has(_2, key)) {
      warn$2(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
    }
    return has2;
  }
});
function createDevRenderContext(instance) {
  const target2 = {};
  Object.defineProperty(target2, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target2, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      set: NOOP
    });
  });
  return target2;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$2(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$2(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options2 = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options2.beforeCreate) {
    callHook$1(options2.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods: methods2,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render3,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives: directives2,
    filters
  } = options2;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods2) {
    for (const key in methods2) {
      const methodHandler = methods2[key];
      if (isFunction$3(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn$2(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (!isFunction$3(dataOptions)) {
      warn$2(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (isPromise$1(data)) {
      warn$2(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject$5(data)) {
      warn$2(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get4 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get4 === NOOP) {
        warn$2(`Computed property "${key}" has no getter.`);
      }
      const set3 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : () => {
        warn$2(`Write operation failed: computed property "${key}" is readonly.`);
      };
      const c = computed({
        get: get4,
        set: set3
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides7 = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides7).forEach((key) => {
      provide(key, provides7[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register3, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register3(_hook.bind(publicThis)));
    } else if (hook) {
      register3(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render3 && instance.render === NOOP) {
    instance.render = render3;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives2)
    instance.directives = directives2;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$5(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        {
          warn$2(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw2, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw2)) {
    const handler = ctx[raw2];
    if (isFunction$3(handler)) {
      watch$1(getter, handler);
    } else {
      warn$2(`Invalid watch handler specified by key "${raw2}"`, handler);
    }
  } else if (isFunction$3(raw2)) {
    watch$1(getter, raw2.bind(publicThis));
  } else if (isObject$5(raw2)) {
    if (isArray$2(raw2)) {
      raw2.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$3(raw2.handler) ? raw2.handler.bind(publicThis) : ctx[raw2.handler];
      if (isFunction$3(handler)) {
        watch$1(getter, handler, raw2);
      } else {
        warn$2(`Invalid watch handler specified by key "${raw2.handler}"`, handler);
      }
    }
  } else {
    warn$2(`Invalid watch option: "${key}"`, raw2);
  }
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  cache.set(base2, resolved);
  return resolved;
}
function mergeOptions(to, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from2) {
    if (asMixin && key === "expose") {
      warn$2(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from2[key]) : from2[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from2) {
  if (!from2) {
    return to;
  }
  if (!to) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$2(isFunction$3(to) ? to.call(this, this) : to, isFunction$3(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to, from2) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
}
function normalizeInject(raw2) {
  if (isArray$2(raw2)) {
    const res = {};
    for (let i = 0; i < raw2.length; i++) {
      res[raw2[i]] = raw2[i];
    }
    return res;
  }
  return raw2;
}
function mergeAsArray$1(to, from2) {
  return to ? [...new Set([].concat(to, from2))] : from2;
}
function mergeObjectOptions(to, from2) {
  return to ? extend$2(extend$2(/* @__PURE__ */ Object.create(null), to), from2) : from2;
}
function mergeWatchOptions(to, from2) {
  if (!to)
    return from2;
  if (!from2)
    return to;
  const merged = extend$2(/* @__PURE__ */ Object.create(null), to);
  for (const key in from2) {
    merged[key] = mergeAsArray$1(to[key], from2[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props2 = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props2, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props2)) {
      props2[key] = void 0;
    }
  }
  {
    validateProps$1(rawProps || {}, props2, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props2 : shallowReactive(props2);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props2;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props: props2, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props2);
  const [options2] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options2) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props2[camelizedKey] = resolvePropValue(options2, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props2, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options2) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props2[key] = resolvePropValue(options2, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props2[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  {
    validateProps$1(rawProps || {}, props2, instance);
  }
}
function setFullProps(instance, rawProps, props2, attrs) {
  const [options2, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options2 && hasOwn(options2, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props2[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props2);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props2[key] = resolvePropValue(options2, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options2, props2, key, value, instance, isAbsent) {
  const opt = options2[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props2);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp2, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp2);
  if (cached) {
    return cached;
  }
  const raw2 = comp2.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp2)) {
    const extendProps = (raw3) => {
      hasExtends = true;
      const [props2, keys2] = normalizePropsOptions(raw3, appContext, true);
      extend$2(normalized, props2);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp2.extends) {
      extendProps(comp2.extends);
    }
    if (comp2.mixins) {
      comp2.mixins.forEach(extendProps);
    }
  }
  if (!raw2 && !hasExtends) {
    cache.set(comp2, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$2(raw2)) {
    for (let i = 0; i < raw2.length; i++) {
      if (!isString$1(raw2[i])) {
        warn$2(`props must be strings when using array syntax.`, raw2[i]);
      }
      const normalizedKey = camelize$1(raw2[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw2) {
    if (!isObject$5(raw2)) {
      warn$2(`invalid props options`, raw2);
    }
    for (const key in raw2) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw2[key];
        const prop2 = normalized[normalizedKey] = isArray$2(opt) || isFunction$3(opt) ? { type: opt } : opt;
        if (prop2) {
          const booleanIndex = getTypeIndex(Boolean, prop2.type);
          const stringIndex = getTypeIndex(String, prop2.type);
          prop2[0] = booleanIndex > -1;
          prop2[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop2, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp2, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else {
    warn$2(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType$1(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match2 ? match2[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType$1(a) === getType$1(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$3(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps$1(rawProps, props2, instance) {
  const resolvedValues = toRaw(props2);
  const options2 = instance.propsOptions[0];
  for (const key in options2) {
    let opt = options2[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop2, isAbsent) {
  const { type, required: required3, validator: validator6 } = prop2;
  if (required3 && isAbsent) {
    warn$2('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop2.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray$2(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$2(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator6 && !validator6(value)) {
    warn$2('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType$1(type);
  if (isSimpleType(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$5(value);
  } else if (expectedType === "Array") {
    valid = isArray$2(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message2 = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message2 += ` with value ${expectedValue}`;
  }
  message2 += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message2 += `with value ${receivedValue}.`;
  }
  return message2;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (currentInstance) {
      warn$2(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$3(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      {
        warn$2(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (!isKeepAlive(instance.vnode) && true) {
    warn$2(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (isHmrUpdating) {
        extend$2(slots, children);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$2(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render3, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$5(rootProps)) {
      warn$2(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
        {
          warn$2(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin2, ...options2) {
        if (installedPlugins.has(plugin2)) {
          warn$2(`Plugin has already been applied to target app.`);
        } else if (plugin2 && isFunction$3(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options2);
        } else if (isFunction$3(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options2);
        } else {
          warn$2(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else {
            warn$2("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app;
      },
      component(name, component) {
        {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (context.components[name]) {
          warn$2(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (context.directives[name]) {
          warn$2(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (rootContainer.__vue_app__) {
            warn$2(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          {
            context.reload = () => {
              render3(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render3(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          {
            app._instance = vnode.component;
            devtoolsInitApp(app, version$1);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else {
          warn$2(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render3(null, app._container);
          {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else {
          warn$2(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$2(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (!owner) {
    warn$2(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else {
          warn$2("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else {
      warn$2("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, createText, nextSibling, parentNode: parentNode2, remove: remove2, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      warn$2(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    const domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text$2:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode2(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            warn$2(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (domType !== 1 && domType !== 3) {
          nextNode = onMismatch();
        } else {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment$1:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode2(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment$1);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode2(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else {
          warn$2("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props: props2, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props2) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props2) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(el2, key, null, props2[key], false, void 0, parentComponent);
            }
          }
        } else if (props2.onClick) {
          patchProp2(el2, "onClick", null, props2.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props2 && props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props2 && props2.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props2 && (props2.innerHTML || props2.textContent))) {
        let next = hydrateChildren(el2.firstChild, vnode, el2, parentComponent, parentSuspense, slotScopeIds, optimized);
        let hasWarned2 = false;
        while (next) {
          hasMismatch = true;
          if (!hasWarned2) {
            warn$2(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
            hasWarned2 = true;
          }
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el2.textContent !== vnode.children) {
          hasMismatch = true;
          warn$2(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el2.textContent}
- Server: ${vnode.children}`);
          el2.textContent = vnode.children;
        }
      }
    }
    return el2.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned2 = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text$2 && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        if (!hasWarned2) {
          warn$2(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
          hasWarned2 = true;
        }
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode2(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment2) => {
    hasMismatch = true;
    warn$2(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
    vnode.el = null;
    if (isFragment2) {
      const end3 = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end3) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode2(node);
    remove2(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match2 = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match2++;
        if (node.data === "]") {
          if (match2 === 0) {
            return nextSibling(node);
          } else {
            match2--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
let supported$1;
let perf$2;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf$2.mark(`vue-${type}-${instance.uid}`);
  }
  {
    devtoolsPerfStart(instance, type, isSupported() ? perf$2.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf$2.mark(endTag);
    perf$2.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf$2.clearMarks(startTag);
    perf$2.clearMarks(endTag);
  }
  {
    devtoolsPerfEnd(instance, type, isSupported() ? perf$2.now() : Date.now());
  }
}
function isSupported() {
  if (supported$1 !== void 0) {
    return supported$1;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported$1 = true;
    perf$2 = window.performance;
  } else {
    supported$1 = false;
  }
  return supported$1;
}
function initFeatureFlags() {
  const needWarn = [];
  if (needWarn.length) {
    const multi2 = needWarn.length > 1;
    console.warn(`Feature flag${multi2 ? `s` : ``} ${needWarn.join(", ")} ${multi2 ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options2) {
  return baseCreateRenderer(options2);
}
function createHydrationRenderer(options2) {
  return baseCreateRenderer(options2, createHydrationFunctions);
}
function baseCreateRenderer(options2, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target2 = getGlobalThis();
  target2.__VUE__ = true;
  {
    setDevtoolsHook(target2.__VUE_DEVTOOLS_GLOBAL_HOOK__, target2);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options2;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text$2:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment$1:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else {
          warn$2("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props: props2, shapeFlag, transition, patchFlag, dirs } = vnode;
    {
      el2 = vnode.el = hostCreateElement(vnode.type, isSVG, props2 && props2.is, props2);
      if (shapeFlag & 8) {
        hostSetElementText(el2, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el2, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props2) {
        for (const key in props2) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el2, key, null, props2[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props2) {
          hostPatchProp(el2, "value", null, props2.value);
        }
        if (vnodeHook = props2.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    {
      Object.defineProperty(el2, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el2, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el2, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el2, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el2, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el2, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el2, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment$1 || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el2, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el2, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (isHmrUpdating || patchFlag & 2048) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (instance.type.__hmrId) {
      registerHMR(instance);
    }
    {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props: props2 } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(el2, instance.subTree, instance, parentSuspense, null);
            {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          {
            startMeasure(instance, `patch`);
          }
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        {
          startMeasure(instance, `patch`);
        }
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        {
          devtoolsComponentUpdated(instance);
        }
        {
          popWarningContext();
        }
      }
    };
    const effect3 = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update3), instance.scope);
    const update3 = instance.update = () => effect3.run();
    update3.id = instance.uid;
    toggleRecurse(instance, true);
    {
      effect3.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect3.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update3.ownerInstance = instance;
    }
    update3();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (keyToNewIndexMap.has(nextChild.key)) {
            warn$2(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex2;
        if (prevChild.key != null) {
          newIndex2 = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex2 = j2;
              break;
            }
          }
        }
        if (newIndex2 === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex2 - s2] = i + 1;
          if (newIndex2 >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex2;
          } else {
            moved2 = true;
          }
          patch(prevChild, c2[newIndex2], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved2) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment$1) {
      hostInsert(el2, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props: props2, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment$1 || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment$1 && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment$1) {
      if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end3) => {
    let next;
    while (cur !== end3) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end3);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, update: update3, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update3) {
      update3.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render3 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options2
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render3,
    hydrate: hydrate2,
    createApp: createAppAPI(render3, hydrate2)
  };
}
function toggleRecurse({ effect: effect3, update: update3 }, allowed) {
  effect3.allowRecurse = update3.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
const resolveTarget = (props2, select2) => {
  const targetSelector = props2 && props2.to;
  if (isString$1(targetSelector)) {
    if (!select2) {
      warn$2(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
      return null;
    } else {
      const target2 = select2(targetSelector);
      if (!target2) {
        warn$2(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
      }
      return target2;
    }
  } else {
    if (!targetSelector && !isTeleportDisabled(props2)) {
      warn$2(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled2 = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el = createComment("teleport start");
      const mainAnchor = n2.anchor = createComment("teleport end");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target2 = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target2) {
        insert(targetAnchor, target2);
        isSVG = isSVG || isTargetSVG(target2);
      } else if (!disabled2) {
        warn$2("Invalid Teleport target on mount:", target2, `(${typeof target2})`);
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled2) {
        mount2(container, mainAnchor);
      } else if (target2) {
        mount2(target2, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target2 = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target2;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target2);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled2) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          } else {
            warn$2("Invalid Teleport target on update:", target2, `(${typeof target2})`);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target2, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target: target2, props: props2 } = vnode;
    if (target2) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props2)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el: el2, anchor, shapeFlag, children, props: props2 } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el2, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props2)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode: parentNode2, querySelector } }, hydrateChildren) {
  const target2 = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target2) {
    const targetNode = target2._lpa || target2.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode2(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target2, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const Fragment$1 = Symbol("Fragment");
const Text$2 = Symbol("Text");
const Comment = Symbol("Comment");
const Static = Symbol("Static");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props2, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props2, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props2, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props2, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$3(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment$1 ? 0 : 1, isBlockNode2 = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props: props2,
    key: props2 && normalizeKey(props2),
    ref: props2 && normalizeRef(props2),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (vnode.key !== vnode.key) {
    warn$2(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode2 = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (!type) {
      warn$2(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props2, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props2) {
    props2 = guardReactiveProps(props2);
    let { class: klass, style: style2 } = props2;
    if (klass && !isString$1(klass)) {
      props2.class = normalizeClass(klass);
    }
    if (isObject$5(style2)) {
      if (isProxy(style2) && !isArray$2(style2)) {
        style2 = extend$2({}, style2);
      }
      props2.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$5(type) ? 4 : isFunction$3(type) ? 2 : 0;
  if (shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn$2(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props2, children, patchFlag, dynamicProps, shapeFlag, isBlockNode2, true);
}
function guardReactiveProps(props2) {
  if (!props2)
    return null;
  return isProxy(props2) || InternalObjectKey in props2 ? extend$2({}, props2) : props2;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props: props2, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: patchFlag === -1 && isArray$2(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray$2(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text3 = " ", flag = 0) {
  return createVNode(Text$2, null, text3, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text3 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text3)) : createVNode(Comment, null, text3);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(Fragment$1, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text$2, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config2) {
  const appIsNativeTag = config2.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn$2("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props: props2, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props2, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$2(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup: setup4 } = Component;
  if (setup4) {
    const setupContext = instance.setupContext = setup4.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup4, instance, 0, [shallowReadonly(instance.props), setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (!instance.suspense) {
          const name = (_a = Component.name) !== null && _a !== void 0 ? _a : "Anonymous";
          warn$2(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$5(setupResult)) {
    if (isVNode(setupResult)) {
      warn$2(`setup() should not return VNodes directly - return a render function instead.`);
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$2(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile$3;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$3 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$3;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$3 && !Component.render) {
      const template2 = Component.template;
      if (template2) {
        {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$2(extend$2({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$3(template2, finalCompilerOptions);
        {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (!Component.render && instance.render === NOOP && !isSSR) {
    if (!compile$3 && Component.template) {
      warn$2(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
    } else {
      warn$2(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target2, key) {
      markAttrsAccessed();
      track(instance, "get", "$attrs");
      return target2[key];
    },
    set() {
      warn$2(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$2(`setupContext.attrs is readonly.`);
      return false;
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (instance.exposed) {
      warn$2(`expose() should be called only once per setup().`);
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target2, key) {
        if (key in target2) {
          return target2[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match2) {
      name = match2[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry2) => {
      for (const key in registry2) {
        if (registry2[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$3(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const warnRuntimeUsage = (method) => warn$2(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
  {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
function defineEmits() {
  {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
function defineExpose(exposed) {
  {
    warnRuntimeUsage(`defineExpose`);
  }
}
function withDefaults(props2, defaults2) {
  {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
function useSlots() {
  return getContext$1().slots;
}
function useAttrs() {
  return getContext$1().attrs;
}
function getContext$1() {
  const i = getCurrentInstance();
  if (!i) {
    warn$2(`useContext() called without active instance.`);
  }
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function mergeDefaults(raw2, defaults2) {
  const props2 = isArray$2(raw2) ? raw2.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw2;
  for (const key in defaults2) {
    const opt = props2[key];
    if (opt) {
      if (isArray$2(opt) || isFunction$3(opt)) {
        props2[key] = { type: opt, default: defaults2[key] };
      } else {
        opt.default = defaults2[key];
      }
    } else if (opt === null) {
      props2[key] = { default: defaults2[key] };
    } else {
      warn$2(`props default key "${key}" has no corresponding declaration.`);
    }
  }
  return props2;
}
function createPropsRestProxy(props2, excludedKeys) {
  const ret = {};
  for (const key in props2) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props2[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (!ctx) {
    warn$2(`withAsyncContext called without active current instance. This is likely a bug.`);
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise$1(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$5(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(`ssrContext`);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn$2(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function initCustomFormatter() {
  if (typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#0b1bc9" };
  const stringStyle = { style: "color:#b62e24" };
  const keywordStyle = { style: "color:#9d288c" };
  const formatter = {
    header(obj) {
      if (!isObject$5(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target2) {
    target2 = extend$2({}, target2);
    if (!Object.keys(target2).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target2).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target2[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject$5(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction$3(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray$2(opts) && opts.includes(key) || isObject$5(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
function withMemo(memo2, render3, cache, index2) {
  const cached = cache[index2];
  if (cached && isMemoSame(cached, memo2)) {
    return cached;
  }
  const ret = render3();
  ret.memo = memo2.slice();
  return cache[index2] = ret;
}
function isMemoSame(cached, memo2) {
  const prev = cached.memo;
  if (prev.length != memo2.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo2[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$1 = "3.2.37";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc$2 = typeof document !== "undefined" ? document : null;
const templateContainer = doc$2 && /* @__PURE__ */ doc$2.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is4, props2) => {
    const el2 = isSVG ? doc$2.createElementNS(svgNS, tag) : doc$2.createElement(tag, is4 ? { is: is4 } : void 0);
    if (tag === "select" && props2 && props2.multiple != null) {
      el2.setAttribute("multiple", props2.multiple);
    }
    return el2;
  },
  createText: (text3) => doc$2.createTextNode(text3),
  createComment: (text3) => doc$2.createComment(text3),
  setText: (node, text3) => {
    node.nodeValue = text3;
  },
  setElementText: (el2, text3) => {
    el2.textContent = text3;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc$2.querySelector(selector),
  setScopeId(el2, id) {
    el2.setAttribute(id, "");
  },
  cloneNode(el2) {
    const cloned = el2.cloneNode(true);
    if (`_value` in el2) {
      cloned._value = el2._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start2, end3) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end3 || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end3 || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template2 = templateContainer.content;
      if (isSVG) {
        const wrapper2 = template2.firstChild;
        while (wrapper2.firstChild) {
          template2.appendChild(wrapper2.firstChild);
        }
        template2.removeChild(wrapper2);
      }
      parent.insertBefore(template2, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style2 = el2.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
    if (prev && !isString$1(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style2, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el2.tagName !== "PROGRESS" && !el2.tagName.includes("-")) {
    el2._value = value;
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue || el2.tagName === "OPTION") {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
    {
      warn$2(`Failed setting prop "${key}" on <${el2.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
    }
  }
  needRemove && el2.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = performance.now.bind(performance);
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const reset$1 = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$1.then(reset$1), cachedNow = _getNow());
function addEventListener(el2, event, handler, options2) {
  el2.addEventListener(event, handler, options2);
}
function removeEventListener(el2, event, handler, options2) {
  el2.removeEventListener(event, handler, options2);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options2] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name, invoker, options2);
    } else if (existingInvoker) {
      removeEventListener(el2, name, existingInvoker, options2);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options2;
  if (optionsModifierRE.test(name)) {
    options2 = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options2[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options2];
}
function createInvoker(initialValue2, instance) {
  const invoker = (e) => {
    const timeStamp = e.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    }
  };
  invoker.value = initialValue2;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(el2, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction$3(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$1(value)) {
    return false;
  }
  return key in el2;
}
function defineCustomElement(options2, hydrate2) {
  const Comp = defineComponent(options2);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options2) => {
  return defineCustomElement(options2, hydrate$1);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (this.shadowRoot) {
        warn$2(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
      }
      this.attachShadow({ mode: "open" });
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      this._resolveDef();
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render$4(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    if (this._resolved) {
      return;
    }
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    new MutationObserver((mutations2) => {
      for (const m of mutations2) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2) => {
      const { props: props2, styles: styles2 } = def2;
      const hasOptions = !isArray$2(props2);
      const rawKeys = props2 ? hasOptions ? Object.keys(props2) : props2 : [];
      let numberProps;
      if (hasOptions) {
        for (const key in this._props) {
          const opt = props2[key];
          if (opt === Number || opt && opt.type === Number) {
            this._props[key] = toNumber$1(this._props[key]);
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
          }
        }
      }
      this._numberProps = numberProps;
      for (const key of Object.keys(this)) {
        if (key[0] !== "_") {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of rawKeys.map(camelize$1)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
      this._applyStyles(styles2);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(resolve2);
    } else {
      resolve2(this._def);
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    if (this._numberProps && this._numberProps[key]) {
      value = toNumber$1(value);
    }
    this._setProp(camelize$1(key), value, false);
  }
  _getProp(key) {
    return this._props[key];
  }
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render$4(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$2({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this.shadowRoot.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            if (!this._def.__asyncLoader) {
              this._instance = null;
              this._update();
            }
          };
        }
        instance.emit = (event, ...args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles2) {
    if (styles2) {
      styles2.forEach((css2) => {
        const s = document.createElement("style");
        s.textContent = css2;
        this.shadowRoot.appendChild(s);
        {
          (this._styles || (this._styles = [])).push(s);
        }
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      warn$2(`useCssModule must be called inside setup()`);
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      warn$2(`Current instance does not have CSS modules injected.`);
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      warn$2(`Current instance does not have CSS module named "${name}".`);
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    warn$2(`useCssVars is called without current active component instance.`);
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment$1) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el: el2, anchor } = vnode;
    while (el2) {
      setVarsOnNode(el2, vars);
      if (el2 === anchor)
        break;
      el2 = el2.nextSibling;
    }
  }
}
function setVarsOnNode(el2, vars) {
  if (el2.nodeType === 1) {
    const style2 = el2.style;
    for (const key in vars) {
      style2.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const Transition = (props2, { slots }) => h(BaseTransition, resolveTransitionProps(props2), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$2({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el2, isAppear, done) => {
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    el2._isLeaving = false;
    removeTransitionClass(el2, leaveFromClass);
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook(hook, [el2, resolve2]);
      nextFrame$1(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$2(baseProps, {
    onBeforeEnter(el2) {
      callHook(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      el2._isLeaving = true;
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      forceReflow();
      addTransitionClass(el2, leaveActiveClass);
      nextFrame$1(() => {
        if (!el2._isLeaving) {
          return;
        }
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false);
      callHook(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true);
      callHook(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$5(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  validateDuration(res);
  return res;
}
function validateDuration(val) {
  if (typeof val !== "number") {
    warn$2(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$2(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
  }
}
function addTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.add(c));
  (el2._vtc || (el2._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
  const { _vtc } = el2;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el2._vtc = void 0;
    }
  }
}
function nextFrame$1(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end3 = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el2 && ++ended >= propCount) {
      end3();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end3();
    }
  }, timeout + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles2 = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles2[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION$1 + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION$1 + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(styles2[TRANSITION$1 + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el2 = c.el;
        const style2 = el2.style;
        addTransitionClass(el2, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb = el2._moveCb = (e) => {
          if (e && e.target !== el2) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el2.removeEventListener("transitionend", cb);
            el2._moveCb = null;
            removeTransitionClass(el2, moveClass);
          }
        };
        el2.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props2);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment$1;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state2, instance));
        } else {
          warn$2(`<TransitionGroup> children must be keyed.`);
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state2, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el2 = c.el;
  if (el2._moveCb) {
    el2._moveCb();
  }
  if (el2._enterCb) {
    el2._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el2, root2, moveClass) {
  const clone2 = el2.cloneNode();
  if (el2._vtc) {
    el2._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target2 = e.target;
  if (target2.composing) {
    target2.composing = false;
    target2.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el2, { modifiers: { lazy, trim, number: number3 } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    const castToNumber = number3 || vnode.props && vnode.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el2.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = toNumber$1(domValue);
      }
      el2._assign(domValue);
    });
    if (trim) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  mounted(el2, { value }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, { value, modifiers: { lazy, trim, number: number3 } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (el2.composing)
      return;
    if (document.activeElement === el2 && el2.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el2.value.trim() === value) {
        return;
      }
      if ((number3 || el2.type === "number") && toNumber$1(el2.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el2, _2, vnode) {
    el2._assign = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      const modelValue = el2._modelValue;
      const elementValue = getValue$2(el2);
      const checked = el2.checked;
      const assign2 = el2._assign;
      if (isArray$2(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found2 = index2 !== -1;
        if (checked && !found2) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found2) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el2, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el2, binding, vnode) {
    el2._assign = getModelAssigner(vnode);
    setChecked(el2, binding, vnode);
  }
};
function setChecked(el2, { value, oldValue }, vnode) {
  el2._modelValue = value;
  if (isArray$2(value)) {
    el2.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el2.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el2.checked = looseEqual(value, getCheckboxValue(el2, true));
  }
}
const vModelRadio = {
  created(el2, { value }, vnode) {
    el2.checked = looseEqual(value, vnode.props.value);
    el2._assign = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      el2._assign(getValue$2(el2));
    });
  },
  beforeUpdate(el2, { value, oldValue }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el2.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el2, { value, modifiers: { number: number3 } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el2, "change", () => {
      const selectedVal = Array.prototype.filter.call(el2.options, (o) => o.selected).map((o) => number3 ? toNumber$1(getValue$2(o)) : getValue$2(o));
      el2._assign(el2.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el2._assign = getModelAssigner(vnode);
  },
  mounted(el2, { value }) {
    setSelected(el2, value);
  },
  beforeUpdate(el2, _binding, vnode) {
    el2._assign = getModelAssigner(vnode);
  },
  updated(el2, { value }) {
    setSelected(el2, value);
  }
};
function setSelected(el2, value) {
  const isMultiple = el2.multiple;
  if (isMultiple && !isArray$2(value) && !isSet(value)) {
    warn$2(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
    return;
  }
  for (let i = 0, l = el2.options.length; i < l; i++) {
    const option3 = el2.options[i];
    const optionValue2 = getValue$2(option3);
    if (isMultiple) {
      if (isArray$2(value)) {
        option3.selected = looseIndexOf(value, optionValue2) > -1;
      } else {
        option3.selected = value.has(optionValue2);
      }
    } else {
      if (looseEqual(getValue$2(option3), value)) {
        if (el2.selectedIndex !== i)
          el2.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el2.selectedIndex !== -1) {
    el2.selectedIndex = -1;
  }
}
function getValue$2(el2) {
  return "_value" in el2 ? el2._value : el2.value;
}
function getCheckboxValue(el2, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el2 ? el2[key] : checked;
}
const vModelDynamic = {
  created(el2, binding, vnode) {
    callModelHook(el2, binding, vnode, null, "created");
  },
  mounted(el2, binding, vnode) {
    callModelHook(el2, binding, vnode, null, "mounted");
  },
  beforeUpdate(el2, binding, vnode, prevVNode) {
    callModelHook(el2, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el2, binding, vnode, prevVNode) {
    callModelHook(el2, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el2, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el2.tagName, vnode.props && vnode.props.type);
  const fn2 = modelToUse[hook];
  fn2 && fn2(el2, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$2(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(vnode.type.toUpperCase(), vnode.props && vnode.props.type);
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers2) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers2.includes(m))
};
const withModifiers = (fn2, modifiers2) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers2.length; i++) {
      const guard = modifierGuards[modifiers2[i]];
      if (guard && guard(event, modifiers2))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers2) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers2.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn2(event);
    }
  };
};
const vShow = {
  beforeMount(el2, { value }, { transition }) {
    el2._vod = el2.style.display === "none" ? "" : el2.style.display;
    if (transition && value) {
      transition.beforeEnter(el2);
    } else {
      setDisplay(el2, value);
    }
  },
  mounted(el2, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el2);
    }
  },
  updated(el2, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el2);
        setDisplay(el2, true);
        transition.enter(el2);
      } else {
        transition.leave(el2, () => {
          setDisplay(el2, false);
        });
      }
    } else {
      setDisplay(el2, value);
    }
  },
  beforeUnmount(el2, { value }) {
    setDisplay(el2, value);
  }
};
function setDisplay(el2, value) {
  el2.style.display = value ? el2._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
let renderer$1;
let enabledHydration = false;
function ensureRenderer() {
  return renderer$1 || (renderer$1 = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer$1 = enabledHydration ? renderer$1 : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer$1;
}
const render$4 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate$1 = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount2(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if (isRuntimeOnly()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn$2(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn$2(msg);
        return compilerOptions;
      },
      set() {
        warn$2(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    if (!res) {
      warn$2(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn$2(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
var runtimeDom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Transition,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate: hydrate$1,
  initDirectivesForSSR,
  render: render$4,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers,
  EffectScope,
  ReactiveEffect,
  customRef,
  effect: effect$3,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow: isShallow$1,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  camelize: camelize$1,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString,
  toHandlerKey,
  BaseTransition,
  Comment,
  Fragment: Fragment$1,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text: Text$2,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs,
  useSSRContext,
  useSlots,
  useTransitionState,
  version: version$1,
  warn: warn$2,
  watch: watch$1,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
function defaultOnError(error2) {
  throw error2;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code2, loc, messages2, additionalMessage) {
  const msg = (messages2 || errorMessages)[code2] + (additionalMessage || ``);
  const error2 = new SyntaxError(String(msg));
  error2.code = code2;
  error2.loc = loc;
  return error2;
}
const errorMessages = {
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `Error parsing JavaScript expression: `,
  [45]: `<KeepAlive> expects exactly one child component.`,
  [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [47]: `ES module mode is not supported in this build of compiler.`,
  [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [49]: `"scopeId" option is only supported in module mode.`,
  [50]: ``
};
const FRAGMENT = Symbol(`Fragment`);
const TELEPORT = Symbol(`Teleport`);
const SUSPENSE = Symbol(`Suspense`);
const KEEP_ALIVE = Symbol(`KeepAlive`);
const BASE_TRANSITION = Symbol(`BaseTransition`);
const OPEN_BLOCK = Symbol(`openBlock`);
const CREATE_BLOCK = Symbol(`createBlock`);
const CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock`);
const CREATE_VNODE = Symbol(`createVNode`);
const CREATE_ELEMENT_VNODE = Symbol(`createElementVNode`);
const CREATE_COMMENT = Symbol(`createCommentVNode`);
const CREATE_TEXT = Symbol(`createTextVNode`);
const CREATE_STATIC = Symbol(`createStaticVNode`);
const RESOLVE_COMPONENT = Symbol(`resolveComponent`);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent`);
const RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
const RESOLVE_FILTER = Symbol(`resolveFilter`);
const WITH_DIRECTIVES = Symbol(`withDirectives`);
const RENDER_LIST = Symbol(`renderList`);
const RENDER_SLOT = Symbol(`renderSlot`);
const CREATE_SLOTS = Symbol(`createSlots`);
const TO_DISPLAY_STRING = Symbol(`toDisplayString`);
const MERGE_PROPS = Symbol(`mergeProps`);
const NORMALIZE_CLASS = Symbol(`normalizeClass`);
const NORMALIZE_STYLE = Symbol(`normalizeStyle`);
const NORMALIZE_PROPS = Symbol(`normalizeProps`);
const GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps`);
const TO_HANDLERS = Symbol(`toHandlers`);
const CAMELIZE = Symbol(`camelize`);
const CAPITALIZE = Symbol(`capitalize`);
const TO_HANDLER_KEY = Symbol(`toHandlerKey`);
const SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
const PUSH_SCOPE_ID = Symbol(`pushScopeId`);
const POP_SCOPE_ID = Symbol(`popScopeId`);
const WITH_CTX = Symbol(`withCtx`);
const UNREF = Symbol(`unref`);
const IS_REF = Symbol(`isRef`);
const WITH_MEMO = Symbol(`withMemo`);
const IS_MEMO_SAME = Symbol(`isMemoSame`);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers2) {
  Object.getOwnPropertySymbols(helpers2).forEach((s) => {
    helperNameMap[s] = helpers2[s];
  });
}
const locStub = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props2, children, patchFlag, dynamicProps, directives2, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives2) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props: props2,
    children,
    patchFlag,
    dynamicProps,
    directives: directives2,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString$1(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline3 = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline: newline3,
    isSlot,
    loc
  };
}
function createConditionalExpression(test3, consequent, alternate, newline3 = true) {
  return {
    type: 19,
    test: test3,
    consequent,
    alternate,
    newline: newline3,
    loc: locStub
  };
}
function createCacheExpression(index2, value, isVNode2 = false) {
  return {
    type: 20,
    index: index2,
    value,
    isVNode: isVNode2,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
const isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const isMemberExpressionBrowser = (path) => {
  path = path.trim().replace(whitespaceRE, (s) => s.trim());
  let state2 = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state2) {
      case 0:
        if (char === "[") {
          stateStack.push(state2);
          state2 = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state2);
          state2 = 2;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state2);
          state2 = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state2 = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state2);
          state2 = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state2 = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state2 = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpression = isMemberExpressionBrowser;
function getInnerRange(loc, offset2, length3) {
  const source = loc.source.slice(offset2, offset2 + length3);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset2),
    end: loc.end
  };
  if (length3 != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset2 + length3);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(extend$2({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert$1(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 7 && (allowEmpty || p2.exp) && (isString$1(name) ? p2.name === name : name.test(p2.name))) {
      return p2;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (dynamicOnly)
        continue;
      if (p2.name === name && (p2.value || allowEmpty)) {
        return p2;
      }
    } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
      return p2;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some((p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || p2.arg.type !== 4 || !p2.arg.isStatic));
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p2) {
  return p2.type === 7 && p2.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props2, callPath = []) {
  if (props2 && !isString$1(props2) && props2.type === 14) {
    const callee = props2.callee;
    if (!isString$1(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props2.arguments[0], callPath.concat(props2));
    }
  }
  return [props2, callPath];
}
function injectProp(node, prop2, context) {
  let propsWithInjection;
  let props2 = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props2 && !isString$1(props2) && props2.type === 14) {
    const ret = getUnnormalizedProps(props2);
    props2 = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props2 == null || isString$1(props2)) {
    propsWithInjection = createObjectExpression([prop2]);
  } else if (props2.type === 14) {
    const first2 = props2.arguments[0];
    if (!isString$1(first2) && first2.type === 15) {
      first2.properties.unshift(prop2);
    } else {
      if (props2.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop2]),
          props2
        ]);
      } else {
        props2.arguments.unshift(createObjectExpression([prop2]));
      }
    }
    !propsWithInjection && (propsWithInjection = props2);
  } else if (props2.type === 15) {
    let alreadyExists = false;
    if (prop2.key.type === 4) {
      const propKeyName = prop2.key.content;
      alreadyExists = props2.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
    }
    if (!alreadyExists) {
      props2.properties.unshift(prop2);
    }
    propsWithInjection = props2;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop2]),
      props2
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_PROP"]: {
    message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTER"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, context) {
  const config2 = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config2 && config2[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message: message2, link: link3 } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message2 === "function" ? message2(...args) : message2}${link3 ? `
  Details: ${link3}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
const defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  decodeEntities: (rawText) => rawText.replace(decodeRE, (_2, p1) => decodeMap[p1]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: true
};
function baseParse(content, options2 = {}) {
  const context = createParserContext(content, options2);
  const start2 = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection$1(context, start2));
}
function createParserContext(content, rawOptions) {
  const options2 = extend$2({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options2[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options: options2,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options2.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
            warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray$2(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!context.inPre && node.type === 2) {
        if (!/[^\t\r\n\f ]/.test(node.content)) {
          const prev = nodes[i - 1];
          const next = nodes[i + 1];
          if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first2 = nodes[0];
      if (first2 && first2.type === 2) {
        first2.content = first2.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start2 = getCursor(context);
  let content;
  const match2 = /--(\!)?>/.exec(context.source);
  if (!match2) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match2.index <= 3) {
      emitError(context, 0);
    }
    if (match2[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match2.index);
    const s = context.source.slice(0, match2.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match2.index + match2[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection$1(context, start2)
  };
}
function parseBogusComment(context) {
  const start2 = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection$1(context, start2)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find((p2) => p2.type === 6 && p2.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
      const loc = getSelection$1(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first2 = children[0];
      if (first2 && startsWith(first2.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection$1(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
const isSpecialTemplateDirective = /* @__PURE__ */ makeMap(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
  const start2 = getCursor(context);
  const match2 = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match2[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match2[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props2 = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props2.some((p2) => p2.type === 7 && p2.name === "pre")) {
    context.inVPre = true;
    extend$2(context, cursor);
    context.source = currentSource;
    props2 = parseAttributes(context, type).filter((p2) => p2.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
    let hasIf = false;
    let hasFor = false;
    for (let i = 0; i < props2.length; i++) {
      const p2 = props2[i];
      if (p2.type === 7) {
        if (p2.name === "if") {
          hasIf = true;
        } else if (p2.name === "for") {
          hasFor = true;
        }
      }
      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection$1(context, start2));
        break;
      }
    }
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props2.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
        tagType = 3;
      }
    } else if (isComponent$2(tag, props2, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props: props2,
    isSelfClosing,
    children: [],
    loc: getSelection$1(context, start2),
    codegenNode: void 0
  };
}
function isComponent$2(tag, props2, context) {
  const options2 = context.options;
  if (options2.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options2.isBuiltInComponent && options2.isBuiltInComponent(tag) || options2.isNativeTag && !options2.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props2.length; i++) {
    const p2 = props2[i];
    if (p2.type === 6) {
      if (p2.name === "is" && p2.value) {
        if (p2.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p2.loc)) {
          return true;
        }
      }
    } else {
      if (p2.name === "is") {
        return true;
      } else if (p2.name === "bind" && isStaticArgOf(p2.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p2.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props2 = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props2.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props2;
}
function parseAttribute(context, nameSet) {
  const start2 = getCursor(context);
  const match2 = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match2[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection$1(context, start2);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match3 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
    let isPropShorthand = startsWith(name, ".");
    let dirName = match3[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match3[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match3[2]);
      const loc2 = getSelection$1(context, getNewPosition(context, start2, startOffset), getNewPosition(context, start2, startOffset + match3[2].length + (isSlot && match3[3] || "").length));
      let content = match3[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match3[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers2 = match3[3] ? match3[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers2.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers2.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
        dirName = "model";
        modifiers2.splice(modifiers2.indexOf("sync"), 1);
      }
      if (modifiers2.includes("prop")) {
        checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers: modifiers2,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start2 = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex2 = context.source.indexOf(quote);
    if (endIndex2 === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex2, 4);
      advanceBy(context, 1);
    }
  } else {
    const match2 = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match2) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match2[0])) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(context, match2[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection$1(context, start2) };
}
function parseInterpolation(context, mode) {
  const [open, close2] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close2, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start2 = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close2.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection$1(context, innerStart, innerEnd)
    },
    loc: getSelection$1(context, start2)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex2 = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index2 = context.source.indexOf(endTokens[i], 1);
    if (index2 !== -1 && endIndex2 > index2) {
      endIndex2 = index2;
    }
  }
  const start2 = getCursor(context);
  const content = parseTextData(context, endIndex2, mode);
  return {
    type: 2,
    content,
    loc: getSelection$1(context, start2)
  };
}
function parseTextData(context, length3, mode) {
  const rawText = context.source.slice(0, length3);
  advanceBy(context, length3);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const { column, line, offset: offset2 } = context;
  return { column, line, offset: offset2 };
}
function getSelection$1(context, start2, end3) {
  end3 = end3 || getCursor(context);
  return {
    start: start2,
    end: end3,
    source: context.originalSource.slice(start2.offset, end3.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match2 = /^[\t\r\n\f ]+/.exec(context.source);
  if (match2) {
    advanceBy(context, match2[0].length);
  }
}
function getNewPosition(context, start2, numberOfCharacters) {
  return advancePositionWithClone(start2, context.originalSource.slice(start2.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code2, offset2, loc = getCursor(context)) {
  if (offset2) {
    loc.offset += offset2;
    loc.column += offset2;
  }
  context.options.onError(createCompilerError(code2, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root2, context) {
  walk(root2, context, isSingleElementRoot(root2, root2.children[0]));
}
function isSingleElementRoot(root2, child) {
  const { children } = root2;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + ` /* HOISTED */`;
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props2 = getNodeProps(child);
            if (props2) {
              codegenNode.props = context.hoist(props2);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12 && getConstantType(child.content, context) >= 2) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray$2(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7 && p2.name === "bind" && p2.exp) {
              const expType = getConstantType(p2.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString$1(child) || isSymbol$1(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString$1(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props2 = getNodeProps(node);
  if (props2 && props2.type === 15) {
    const { properties } = props2;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root2, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline: inline3 = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    selfName: nameMatch && capitalize(camelize$1(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline: inline3,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root: root2,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root2,
    childIndex: 0,
    inVOnce: false,
    helper(name) {
      const count2 = context.helpers.get(name) || 0;
      context.helpers.set(name, count2 + 1);
      return name;
    },
    removeHelper(name) {
      const count2 = context.helpers.get(name);
      if (count2) {
        const currentCount = count2 - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list3 = context.parent.children;
      const removalIndex = node ? list3.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString$1(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode2 = false) {
      return createCacheExpression(context.cached++, exp, isVNode2);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root2, options2) {
  const context = createTransformContext(root2, options2);
  traverseNode(root2, context);
  if (options2.hoistStatic) {
    hoistStatic(root2, context);
  }
  if (!options2.ssr) {
    createRootCodegen(root2, context);
  }
  root2.helpers = [...context.helpers.keys()];
  root2.components = [...context.components];
  root2.directives = [...context.directives];
  root2.imports = context.imports;
  root2.hoists = context.hoists;
  root2.temps = context.temps;
  root2.cached = context.cached;
  {
    root2.filters = [...context.filters];
  }
}
function createRootCodegen(root2, context) {
  const { helper } = context;
  const { children } = root2;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root2, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context);
      }
      root2.codegenNode = codegenNode;
    } else {
      root2.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root2.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root2.children, patchFlag + ` /* ${patchFlagText} */`, void 0, void 0, true, void 0, false);
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString$1(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray$2(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn2) {
  const matches3 = isString$1(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props: props2 } = node;
      if (node.tagType === 3 && props2.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props2.length; i++) {
        const prop2 = props2[i];
        if (prop2.type === 7 && matches3(prop2.name)) {
          props2.splice(i, 1);
          i--;
          const onExit = fn2(node, prop2, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast2, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast2.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code2, node) {
      context.code += code2;
    },
    indent() {
      newline3(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline3(--context.indentLevel);
      }
    },
    newline() {
      newline3(context.indentLevel);
    }
  };
  function newline3(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast2, options2 = {}) {
  const context = createCodegenContext(ast2, options2);
  if (options2.onContextCreated)
    options2.onContextCreated(context);
  const { mode, push, prefixIdentifiers, indent, deindent, newline: newline3, scopeId, ssr } = context;
  const hasHelpers = ast2.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast2, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${ast2.helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push(`
`);
      newline3();
    }
  }
  if (ast2.components.length) {
    genAssets(ast2.components, "component", context);
    if (ast2.directives.length || ast2.temps > 0) {
      newline3();
    }
  }
  if (ast2.directives.length) {
    genAssets(ast2.directives, "directive", context);
    if (ast2.temps > 0) {
      newline3();
    }
  }
  if (ast2.filters && ast2.filters.length) {
    newline3();
    genAssets(ast2.filters, "filter", context);
    newline3();
  }
  if (ast2.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast2.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast2.components.length || ast2.directives.length || ast2.temps) {
    push(`
`);
    newline3();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast2.codegenNode) {
    genNode(ast2.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast: ast2,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast2, context) {
  const { ssr, prefixIdentifiers, push, newline: newline3, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
  const VueBinding = runtimeGlobalName;
  if (ast2.helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast2.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => ast2.helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast2.hoists, context);
  newline3();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline: newline3, isTS }) {
  const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline3();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline: newline3, helper, scopeId, mode } = context;
  newline3();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline3();
    }
  }
  context.pure = false;
}
function isText$1(n) {
  return isString$1(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray$2(n) || !isText$1(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma2 = true) {
  const { push, newline: newline3 } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString$1(node)) {
      push(node);
    } else if (isArray$2(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma2 && push(",");
        newline3();
      } else {
        comma2 && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString$1(node)) {
    context.push(node);
    return;
  }
  if (isSymbol$1(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert$1(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default: {
      assert$1(false, `unhandled codegen node type: ${node.type}`);
      const exhaustiveCheck = node;
      return exhaustiveCheck;
    }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString$1(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text3 = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text3, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const { tag, props: props2, children, patchFlag, dynamicProps, directives: directives2, isBlock, disableTracking, isComponent: isComponent2 } = node;
  if (directives2) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props2, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives2) {
    push(`, `);
    genNode(directives2, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString$1(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline: newline3 } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline3();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline: newline3, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray$2(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline3 || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline3) {
      push(`return `);
    }
    if (isArray$2(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline3 || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test: test3, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline: newline3 } = context;
  if (test3.type === 4) {
    const needsParens = !isSimpleIdentifier(test3.content);
    needsParens && push(`(`);
    genExpression(test3, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test3, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline3();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline: newline3 } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline3();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline3();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline3();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
const prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
  } catch (e) {
    let message2 = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message2 = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(createCompilerError(44, node.loc, void 0, message2));
  }
}
const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(node.content, context);
  } else if (node.type === 1) {
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
          dir.exp = processExpression(exp, context, dir.name === "slot");
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
  return processIf(node, dir, context, (ifNode, branch, isRoot) => {
    const siblings = context.parent.children;
    let i = siblings.indexOf(ifNode);
    let key = 0;
    while (i-- >= 0) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 9) {
        key += sibling.branches.length;
      }
    }
    return () => {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        const parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
});
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(createCompilerError(29, branch.userKey.loc));
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
      '"v-if"',
      "true"
    ]));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ` /* ${patchFlagText} */`, void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
const transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
  const { helper, removeHelper } = context;
  return processFor(node, dir, context, (forNode) => {
    const renderExp = createCallExpression(helper(RENDER_LIST), [
      forNode.source
    ]);
    const isTemplate = isTemplateNode(node);
    const memo2 = findDir(node, "memo");
    const keyProp = findProp(node, `key`);
    const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
    const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
    const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
    const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + ` /* ${PatchFlagNames[fragmentFlag]} */`, void 0, void 0, true, !isStableFragment, false, node.loc);
    return () => {
      let childBlock;
      const { children } = forNode;
      if (isTemplate) {
        node.children.some((c) => {
          if (c.type === 1) {
            const key = findProp(c, "key");
            if (key) {
              context.onError(createCompilerError(33, key.loc));
              return true;
            }
          }
        });
      }
      const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
      const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
      if (slotOutlet) {
        childBlock = slotOutlet.codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + ` /* ${PatchFlagNames[64]} */`, void 0, void 0, true, void 0, false);
      } else {
        childBlock = children[0].codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            removeHelper(OPEN_BLOCK);
            removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        childBlock.isBlock = !isStableFragment;
        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
        } else {
          helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
        }
      }
      if (memo2) {
        const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
          createSimpleExpression(`_cached`)
        ]));
        loop.body = createBlockStatement([
          createCompoundExpression([`const _memo = (`, memo2.exp, `)`]),
          createCompoundExpression([
            `if (_cached`,
            ...keyExp ? [` && _cached.key === `, keyExp] : [],
            ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
          ]),
          createCompoundExpression([`const _item = `, childBlock]),
          createSimpleExpression(`_item.memo = _memo`),
          createSimpleExpression(`return _item`)
        ]);
        renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
      } else {
        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
      }
    };
  });
});
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(dir.exp, context);
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index: index2 } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index2,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input2, context) {
  const loc = input2.loc;
  const exp = input2.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  {
    validateBrowserExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      {
        validateBrowserExpression(result.key, context, true);
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    {
      validateBrowserExpression(result.value, context, true);
    }
  }
  return result;
}
function createAliasExpression(range2, content, offset2) {
  return createSimpleExpression(content, false, getInnerRange(range2, offset2, content.length));
}
function createForLoopParams({ value, key, index: index2 }, memoArgs = []) {
  return createParamsList([value, key, index2, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const buildClientSlotFn = (props2, children, loc) => createFunctionExpression(props2, children, false, true, children.length ? children[0].loc : loc);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j2 = i;
      let prev;
      while (j2--) {
        prev = children[j2];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props2, children2) => {
      const fn2 = buildSlotFn(props2, children2, loc);
      if (context.compatConfig) {
        fn2.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn2);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + ` /* ${slotFlagsText[slotFlag]} */`, false))), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn2) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn2)
  ]);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props: props2 } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject$5(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
    if (props2.length > 0) {
      const propsBuildResult = buildProps(node, context, void 0, isComponent2, isDynamicComponent);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives2 = propsBuildResult.directives;
      vnodeDirectives = directives2 && directives2.length ? createArrayExpression(directives2.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if (node.children.length > 1) {
          context.onError(createCompilerError(45, {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ""
          }));
        }
      }
      const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      {
        if (patchFlag < 0) {
          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
        } else {
          const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
        }
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props2 = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props2.length; i++) {
    const prop2 = props2[i];
    if (prop2.type === 6) {
      const { loc, name, value } = prop2;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name, arg, exp, loc } = prop2;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }
          if (isVBind) {
            {
              {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                }
              }
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            mergeArgs.push({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props3, needRuntime } = directiveTransform(prop2, node, context);
        !ssr && props3.forEach(analyzePatchFlag);
        properties.push(...props3);
        if (needRuntime) {
          runtimeDirectives.push(prop2);
          if (isSymbol$1(needRuntime)) {
            directiveImportMap.set(prop2, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop2);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
          createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop2 = properties[i];
    if (prop2.key.type === 8 || !prop2.key.isStatic) {
      deduped.push(prop2);
      continue;
    }
    const name = prop2.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop2);
      }
    } else {
      knownProps.set(name, prop2);
      deduped.push(prop2);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props2) {
  let propsNamesString = `[`;
  for (let i = 0, l = props2.length; i < l; i++) {
    propsNamesString += JSON.stringify(props2[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
Object.freeze({});
Object.freeze([]);
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (p2.value) {
        if (p2.name === "name") {
          slotName = JSON.stringify(p2.value.content);
        } else {
          p2.name = camelize(p2.name);
          nonNameProps.push(p2);
        }
      }
    } else {
      if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
        if (p2.exp)
          slotName = p2.exp;
      } else {
        if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
          p2.arg.content = camelize(p2.arg.content);
        }
        nonNameProps.push(p2);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props: props2, directives: directives2 } = buildProps(node, context, nonNameProps, false, false);
    slotProps = props2;
    if (directives2.length) {
      context.onError(createCompilerError(36, directives2[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers: modifiers2, arg } = dir;
  if (!dir.exp && !modifiers2.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      eventName = createSimpleExpression(toHandlerKey(camelize$1(rawName)), true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    {
      validateBrowserExpression(exp, context, false, hasMultipleStatements);
    }
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p2) => p2.key.isHandlerKey = true);
  return ret;
};
const transformBind = (dir, _node, context) => {
  const { exp, modifiers: modifiers2, loc } = dir;
  const arg = dir.arg;
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers2.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize$1(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers2.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers2.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  if (!exp || exp.type === 4 && !exp.content.trim()) {
    context.onError(createCompilerError(34, loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
    };
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix2) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix2 + arg.content;
    } else {
      arg.content = `\`${prefix2}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix2}' + (`);
    arg.children.push(`)`);
  }
};
const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText(child)) {
          hasText = true;
          for (let j2 = i + 1; j2 < children.length; j2++) {
            const next = children[j2];
            if (isText(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression([child], child.loc);
              }
              currentContainer.children.push(` + `, next);
              children.splice(j2, 1);
              j2--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p2) => p2.type === 7 && !context.directiveTransforms[p2.name]) && !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(1 + ` /* ${PatchFlagNames[1]} */`);
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          };
        }
      }
    };
  }
};
const seen = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen.has(node) || context.inVOnce) {
      return;
    }
    seen.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true);
      }
    };
  }
};
const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(createCompilerError(41, dir.loc));
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  context.bindingMetadata[rawExp];
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context.onError(createCompilerError(42, exp.loc));
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props2 = [
    createObjectProperty(propName, dir.exp),
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers2 = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props2.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers2} }`, false, dir.loc, 2)));
  }
  return createTransformProps(props2);
};
function createTransformProps(props2 = []) {
  return { props: props2 };
}
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTER", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  }
  if (node.type === 1) {
    node.props.forEach((prop2) => {
      if (prop2.type === 7 && prop2.name !== "for" && prop2.exp) {
        rewriteFilter(prop2.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square2 = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square2 && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square2++;
          break;
        case 93:
          square2--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j2 = i - 1;
        let p2;
        for (; j2 >= 0; j2--) {
          p2 = exp.charAt(j2);
          if (p2 !== " ")
            break;
        }
        if (!p2 || !validDivisionCharRE.test(p2)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation("COMPILER_FILTER", context, node.loc);
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter2, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter2.indexOf("(");
  if (i < 0) {
    context.filters.add(filter2);
    return `${toValidAssetId(filter2, "filter")}(${exp})`;
  } else {
    const name = filter2.slice(0, i);
    const args = filter2.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
const seen$1 = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen$1.has(node)) {
      return;
    }
    seen$1.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          makeBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached++)
        ]);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...[transformExpression],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(template2, options2 = {}) {
  const onError = options2.onError || defaultOnError;
  const isModuleMode = options2.mode === "module";
  {
    if (options2.prefixIdentifiers === true) {
      onError(createCompilerError(46));
    } else if (isModuleMode) {
      onError(createCompilerError(47));
    }
  }
  const prefixIdentifiers = false;
  if (options2.cacheHandlers) {
    onError(createCompilerError(48));
  }
  if (options2.scopeId && !isModuleMode) {
    onError(createCompilerError(49));
  }
  const ast2 = isString$1(template2) ? baseParse(template2, options2) : template2;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast2, extend$2({}, options2, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options2.nodeTransforms || []
    ],
    directiveTransforms: extend$2({}, directiveTransforms, options2.directiveTransforms || {})
  }));
  return generate(ast2, extend$2({}, options2, {
    prefixIdentifiers
  }));
}
const noopDirectiveTransform = () => ({ props: [] });
const V_MODEL_RADIO = Symbol(`vModelRadio`);
const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
const V_MODEL_TEXT = Symbol(`vModelText`);
const V_MODEL_SELECT = Symbol(`vModelSelect`);
const V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
const V_SHOW = Symbol(`vShow`);
const TRANSITION = Symbol(`Transition`);
const TRANSITION_GROUP = Symbol(`TransitionGroup`);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw2, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw2.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw2;
    return decoder.textContent;
  }
}
const isRawTextContainer = /* @__PURE__ */ makeMap("style,iframe,script,noscript", true);
const parserOptions = {
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: (tag) => tag === "pre",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: (tag) => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION;
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  },
  getNamespace(tag, parent) {
    let ns = parent ? parent.ns : 0;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  },
  getTextMode({ tag, ns }) {
    if (ns === 0) {
      if (tag === "textarea" || tag === "title") {
        return 1;
      }
      if (isRawTextContainer(tag)) {
        return 2;
      }
    }
    return 0;
  }
};
const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p2, i) => {
      if (p2.type === 6 && p2.name === "style" && p2.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p2.loc),
          exp: parseInlineCSS(p2.value.content, p2.loc),
          modifiers: [],
          loc: p2.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
};
function createDOMCompilerError(code2, loc) {
  return createCompilerError(code2, loc, DOMErrorMessages);
}
const DOMErrorMessages = {
  [50]: `v-html is missing expression.`,
  [51]: `v-html will override element children.`,
  [52]: `v-text is missing expression.`,
  [53]: `v-text will override element children.`,
  [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [55]: `v-model argument is not supported on plain elements.`,
  [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [58]: `v-show is missing expression.`,
  [59]: `<Transition> expects exactly one child element or component.`,
  [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(50, loc));
  }
  if (node.children.length) {
    context.onError(createDOMCompilerError(51, loc));
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
    ]
  };
};
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(52, loc));
  }
  if (node.children.length) {
    context.onError(createDOMCompilerError(53, loc));
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(createSimpleExpression(`textContent`, true), exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
    ]
  };
};
const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(createDOMCompilerError(55, dir.arg.loc));
  }
  function checkDuplicatedValue() {
    const value = findProp(node, "value");
    if (value) {
      context.onError(createDOMCompilerError(57, value.loc));
    }
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(createDOMCompilerError(56, dir.loc));
              break;
            default:
              checkDuplicatedValue();
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
        checkDuplicatedValue();
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
      checkDuplicatedValue();
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(createDOMCompilerError(54, dir.loc));
  }
  baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers2, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers2.length; i++) {
    const modifier = modifiers2[i];
    if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers: modifiers2 } = dir;
    if (!modifiers2.length)
      return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers2, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && (!isStaticExp(key) || isKeyboardEvent(key.content))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(createDOMCompilerError(58, loc));
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
const transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(createDOMCompilerError(59, {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ""
          }));
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p2 of child.props) {
            if (p2.type === 7 && p2.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                value: void 0,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter((c) => c.type !== 3 && !(c.type === 2 && !c.content.trim()));
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.onError(createDOMCompilerError(60, node.loc));
    context.removeNode();
  }
};
const DOMNodeTransforms = [
  transformStyle,
  ...[transformTransition]
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  on: transformOn,
  show: transformShow
};
function compile$2(template2, options2 = {}) {
  return baseCompile(template2, extend$2({}, parserOptions, options2, {
    nodeTransforms: [
      ignoreSideEffectTags,
      ...DOMNodeTransforms,
      ...options2.nodeTransforms || []
    ],
    directiveTransforms: extend$2({}, DOMDirectiveTransforms, options2.directiveTransforms || {}),
    transformHoist: null
  }));
}
function initDev() {
  {
    initCustomFormatter();
  }
}
{
  initDev();
}
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template2, options2) {
  if (!isString$1(template2)) {
    if (template2.nodeType) {
      template2 = template2.innerHTML;
    } else {
      warn$2(`invalid template option: `, template2);
      return NOOP;
    }
  }
  const key = template2;
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template2[0] === "#") {
    const el2 = document.querySelector(template2);
    if (!el2) {
      warn$2(`Template element not found or is empty: ${template2}`);
    }
    template2 = el2 ? el2.innerHTML : ``;
  }
  const { code: code2 } = compile$2(template2, extend$2({
    hoistStatic: true,
    onError,
    onWarn: (e) => onError(e, true)
  }, options2));
  function onError(err, asWarning = false) {
    const message2 = asWarning ? err.message : `Template compilation error: ${err.message}`;
    const codeFrame = err.loc && generateCodeFrame(template2, err.loc.start.offset, err.loc.end.offset);
    warn$2(codeFrame ? `${message2}
${codeFrame}` : message2);
  }
  const render3 = new Function("Vue", code2)(runtimeDom);
  render3._rc = true;
  return compileCache[key] = render3;
}
registerRuntimeCompiler(compileToFunction);
var vue_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile: compileToFunction,
  EffectScope,
  ReactiveEffect,
  customRef,
  effect: effect$3,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow: isShallow$1,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  camelize: camelize$1,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString,
  toHandlerKey,
  BaseTransition,
  Comment,
  Fragment: Fragment$1,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text: Text$2,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs,
  useSSRContext,
  useSlots,
  useTransitionState,
  version: version$1,
  warn: warn$2,
  watch: watch$1,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId,
  Transition,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate: hydrate$1,
  initDirectivesForSSR,
  render: render$4,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers
}, Symbol.toStringTag, { value: "Module" }));
function mitt(all) {
  all = all || /* @__PURE__ */ Object.create(null);
  return {
    on: function on2(type, handler) {
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off2(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit2(type, evt) {
      (all[type] || []).slice().map(function(handler) {
        handler(evt);
      });
      (all["*"] || []).slice().map(function(handler) {
        handler(type, evt);
      });
    }
  };
}
function getBasePlacement$2(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement$1(placement) {
  return ["top", "bottom"].includes(getBasePlacement$2(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref2) {
  let {
    reference: reference3,
    floating,
    placement
  } = _ref2;
  const commonX = reference3.x + reference3.width / 2 - floating.width / 2;
  const commonY = reference3.y + reference3.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement$2(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference3.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference3.y + reference3.height
      };
      break;
    case "right":
      coords = {
        x: reference3.x + reference3.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference3.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference3.x,
        y: reference3.y
      };
  }
  const mainAxis = getMainAxisFromPlacement$1(placement);
  const length3 = getLengthFromAxis(mainAxis);
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference3[length3] / 2 - floating[length3] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference3[length3] / 2 - floating[length3] / 2);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference3, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref2) => {
      let {
        name
      } = _ref2;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference: reference3,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(__spreadProps(__spreadValues({}, rects), {
    placement
  }));
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;
  for (let i = 0; i < middleware.length; i++) {
    {
      _debug_loop_count_++;
      if (_debug_loop_count_ > 100) {
        throw new Error(["Floating UI: The middleware lifecycle appears to be", "running in an infinite loop. This is usually caused by a `reset`", "continually being returned without a break condition."].join(" "));
      }
    }
    const {
      name,
      fn: fn2
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn2({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference3,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: data != null ? data : {}
    });
    if (reset2) {
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference: reference3,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(__spreadProps(__spreadValues({}, rects), {
          placement: statefulPlacement
        })));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect$1(rect2) {
  return __spreadProps(__spreadValues({}, rect2), {
    top: rect2.y,
    left: rect2.x,
    right: rect2.x + rect2.width,
    bottom: rect2.y + rect2.height
  });
}
async function detectOverflow$1(middlewareArguments, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options2;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect$1(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x,
      y
    }) : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$3 = Math.min;
const max$3 = Math.max;
function within$1(min$12, value, max$12) {
  return max$3(min$12, min$3(value, max$12));
}
const arrow$3 = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options2 != null ? options2 : {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const basePlacement = getBasePlacement$2(placement);
    const axis = getMainAxisFromPlacement$1(basePlacement);
    const length3 = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions({
      element
    });
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length3] + rects.reference[axis] - coords[axis] - rects.floating[length3];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await platform2.getOffsetParent({
      element
    });
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length3] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length3] / 2 + centerToReference;
    const offset2 = within$1(min3, center, max3);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1$1[matched]);
}
function getAlignmentSides(placement, rects) {
  const isStart = getAlignment(placement) === "start";
  const mainAxis = getMainAxisFromPlacement$1(placement);
  const length3 = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length3] > rects.floating[length3]) {
    mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement$1(mainAlignmentSide)
  };
}
const hash$2 = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash$2[matched]);
}
const basePlacements$1 = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ basePlacements$1.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement$2(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "autoPlacement",
    options: options2,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
      const {
        x,
        y,
        rects,
        middlewareData,
        placement
      } = middlewareArguments;
      const _a = options2, {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "alignment",
        "allowedPlacements",
        "autoAlignment"
      ]);
      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
        return {};
      }
      const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
      const currentPlacement = placements2[currentIndex];
      const {
        main: main2,
        cross: cross2
      } = getAlignmentSides(currentPlacement, rects);
      if (placement !== currentPlacement) {
        return {
          x,
          y,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow[getBasePlacement$2(currentPlacement)], overflow[main2], overflow[cross2]];
      const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref2) => {
        let {
          overflows
        } = _ref2;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      return {
        data: {
          skip: true
        },
        reset: {
          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
        }
      };
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const _a = options2, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "flipAlignment"
      ]);
      const basePlacement = getBasePlacement$2(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross: cross2
        } = getAlignmentSides(placement, rects);
        overflows.push(overflow[main2], overflow[cross2]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(_ref2) {
  let {
    placement,
    rects,
    value
  } = _ref2;
  const basePlacement = getBasePlacement$2(placement);
  const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
  const rawValue = typeof value === "function" ? value(__spreadProps(__spreadValues({}, rects), {
    placement
  })) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : __spreadValues({
    mainAxis: 0,
    crossAxis: 0
  }, rawValue);
  return getMainAxisFromPlacement$1(basePlacement) === "x" ? {
    x: crossAxis,
    y: mainAxis * multiplier
  } : {
    x: mainAxis * multiplier,
    y: crossAxis
  };
}
const offset$2 = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects
      } = middlewareArguments;
      const diffCoords = convertValueToCoords({
        placement,
        rects,
        value
      });
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift$1 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const _a = options2, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref2) => {
            let {
              x: x2,
              y: y2
            } = _ref2;
            return {
              x: x2,
              y: y2
            };
          }
        }
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement$1(getBasePlacement$2(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within$1(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within$1(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, middlewareArguments), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      });
    }
  };
};
const size = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(middlewareArguments) {
      var _middlewareData$size;
      const {
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const _a = options2, {
        apply: apply2
      } = _a, detectOverflowOptions = __objRest(_a, [
        "apply"
      ]);
      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
        return {};
      }
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const basePlacement = getBasePlacement$2(placement);
      const isEnd2 = getAlignment(placement) === "end";
      let heightSide;
      let widthSide;
      if (basePlacement === "top" || basePlacement === "bottom") {
        heightSide = basePlacement;
        widthSide = isEnd2 ? "left" : "right";
      } else {
        widthSide = basePlacement;
        heightSide = isEnd2 ? "top" : "bottom";
      }
      const xMin = max$3(overflow.left, 0);
      const xMax = max$3(overflow.right, 0);
      const yMin = max$3(overflow.top, 0);
      const yMax = max$3(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$3(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$3(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply2 == null ? void 0 : apply2(__spreadValues(__spreadValues({}, dimensions), rects));
      return {
        data: {
          skip: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeName$1(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement$1(value) {
  return value instanceof getWindow$1(value).HTMLElement;
}
function isElement$2(value) {
  return value instanceof getWindow$1(value).Element;
}
function isNode$1(value) {
  return value instanceof getWindow$1(value).Node;
}
function isShadowRoot$1(node) {
  const OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent$1(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].includes(getNodeName$1(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css2 = getComputedStyle$1$1(element);
  return css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].includes(css2.willChange) || isFirefox && css2.willChange === "filter" || isFirefox && (css2.filter ? css2.filter !== "none" : false);
}
const min$2 = Math.min;
const max$2 = Math.max;
const round$1 = Math.round;
function getBoundingClientRect$1(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect2.width / scaleX,
    height: clientRect2.height / scaleY,
    top: clientRect2.top / scaleY,
    right: clientRect2.right / scaleX,
    bottom: clientRect2.bottom / scaleY,
    left: clientRect2.left / scaleX,
    x: clientRect2.left / scaleX,
    y: clientRect2.top / scaleY
  };
}
function getDocumentElement$1(node) {
  return ((isNode$1(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll$1(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
}
function isScaled(element) {
  const rect2 = getBoundingClientRect$1(element);
  return round$1(rect2.width) !== element.offsetWidth || round$1(rect2.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  const rect2 = getBoundingClientRect$1(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect2.left + scroll.scrollLeft - offsets.x,
    y: rect2.top + scroll.scrollTop - offsets.y,
    width: rect2.width,
    height: rect2.height
  };
}
function getParentNode$1(node) {
  if (getNodeName$1(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot$1(node) ? node.host : null) || getDocumentElement$1(node);
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement$1(currentNode) && !["html", "body"].includes(getNodeName$1(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  const window2 = getWindow$1(element);
  let offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getDimensions(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref2) {
  let {
    rect: rect2,
    offsetParent,
    strategy
  } = _ref2;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  if (offsetParent === documentElement) {
    return rect2;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return __spreadProps(__spreadValues({}, rect2), {
    x: rect2.x - scroll.scrollLeft + offsets.x,
    y: rect2.y - scroll.scrollTop + offsets.y
  });
}
function getViewportRect$1(element) {
  const win = getWindow$1(element);
  const html = getDocumentElement$1(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement$1(element);
  const scroll = getNodeScroll$1(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX$1(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1$1(body || html).direction === "rtl") {
    x += max$2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getScrollParent$1(node) {
  if (["html", "body", "#document"].includes(getNodeName$1(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(node) && isScrollParent$1(node)) {
    return node;
  }
  return getScrollParent$1(getParentNode$1(node));
}
function getScrollParents(node, list3) {
  var _node$ownerDocument;
  if (list3 === void 0) {
    list3 = [];
  }
  const scrollParent = getScrollParent$1(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow$1(scrollParent);
  const target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list3.concat(target2);
  return isBody ? updatedList : updatedList.concat(getScrollParents(getParentNode$1(target2)));
}
function contains$1(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect$1(element) {
  const clientRect2 = getBoundingClientRect$1(element);
  const top2 = clientRect2.top + element.clientTop;
  const left2 = clientRect2.left + element.clientLeft;
  return {
    top: top2,
    left: left2,
    x: left2,
    y: top2,
    right: left2 + element.clientWidth,
    bottom: top2 + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect$1(getViewportRect$1(element));
  }
  if (isElement$2(clippingParent)) {
    return getInnerBoundingClientRect$1(clippingParent);
  }
  return rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents$1(element) {
  const clippingParents2 = getScrollParents(getParentNode$1(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter((clippingParent) => isElement$2(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body");
}
function getClippingClientRect(_ref2) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref2;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element) : [].concat(boundary);
  const clippingParents2 = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents2[0];
  const clippingRect = clippingParents2.reduce((accRect, clippingParent) => {
    const rect2 = getClientRectFromClippingParent(element, clippingParent);
    accRect.top = max$2(rect2.top, accRect.top);
    accRect.right = min$2(rect2.right, accRect.right);
    accRect.bottom = min$2(rect2.bottom, accRect.bottom);
    accRect.left = max$2(rect2.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
const platform = {
  getElementRects: (_ref2) => {
    let {
      reference: reference3,
      floating,
      strategy
    } = _ref2;
    return {
      reference: getRectRelativeToOffsetParent(reference3, getOffsetParent$1(floating), strategy),
      floating: __spreadProps(__spreadValues({}, getDimensions(floating)), {
        x: 0,
        y: 0
      })
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent$1(element);
  },
  isElement: (value) => isElement$2(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement$1(element);
  },
  getClippingClientRect: (args) => getClippingClientRect(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
const computePosition = (reference3, floating, options2) => computePosition$1(reference3, floating, __spreadValues({
  platform
}, options2));
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp2.call(b, prop2))
      __defNormalProp2(a, prop2, b[prop2]);
  if (__getOwnPropSymbols2)
    for (var prop2 of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop2))
        __defNormalProp2(a, prop2, b[prop2]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
function assign$2(to, from2) {
  for (const key in from2) {
    if (Object.prototype.hasOwnProperty.call(from2, key)) {
      if (typeof from2[key] === "object" && to[key]) {
        assign$2(to[key], from2[key]);
      } else {
        to[key] = from2[key];
      }
    }
  }
}
const config$3 = {
  disabled: false,
  distance: 5,
  skidding: 0,
  container: "body",
  boundary: void 0,
  instantMove: false,
  disposeTimeout: 5e3,
  popperTriggers: [],
  strategy: "absolute",
  preventOverflow: true,
  flip: true,
  shift: true,
  overflowPadding: 0,
  arrowPadding: 0,
  arrowOverflow: true,
  themes: {
    tooltip: {
      placement: "top",
      triggers: ["hover", "focus", "touch"],
      hideTriggers: (events2) => [...events2, "click"],
      delay: {
        show: 200,
        hide: 0
      },
      handleResize: false,
      html: false,
      loadingContent: "..."
    },
    dropdown: {
      placement: "bottom",
      triggers: ["click"],
      delay: 0,
      handleResize: true,
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function getDefaultConfig(theme, key) {
  let themeConfig = config$3.themes[theme] || {};
  let value;
  do {
    value = themeConfig[key];
    if (typeof value === "undefined") {
      if (themeConfig.$extend) {
        themeConfig = config$3.themes[themeConfig.$extend] || {};
      } else {
        themeConfig = null;
        value = config$3[key];
      }
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return value;
}
function getThemeClasses(theme) {
  const result = [theme];
  let themeConfig = config$3.themes[theme] || {};
  do {
    if (themeConfig.$extend && !themeConfig.$resetCss) {
      result.push(themeConfig.$extend);
      themeConfig = config$3.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result.map((c) => `v-popper--theme-${c}`);
}
function getAllParentThemes(theme) {
  const result = [theme];
  let themeConfig = config$3.themes[theme] || {};
  do {
    if (themeConfig.$extend) {
      result.push(themeConfig.$extend);
      themeConfig = config$3.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result;
}
let supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
}
let isIOS = false;
if (typeof window !== "undefined" && typeof navigator !== "undefined") {
  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
const placements$1 = ["auto", "top", "bottom", "left", "right"].reduce((acc, base2) => acc.concat([
  base2,
  `${base2}-start`,
  `${base2}-end`
]), []);
const SHOW_EVENT_MAP = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart"
};
const HIDE_EVENT_MAP = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend"
};
function removeFromArray(array, item) {
  const index2 = array.indexOf(item);
  if (index2 !== -1) {
    array.splice(index2, 1);
  }
}
function nextFrame() {
  return new Promise((resolve2) => requestAnimationFrame(() => {
    requestAnimationFrame(resolve2);
  }));
}
const shownPoppers = [];
let hidingPopper = null;
const shownPoppersByTheme = {};
function getShownPoppersByTheme(theme) {
  let list3 = shownPoppersByTheme[theme];
  if (!list3) {
    list3 = shownPoppersByTheme[theme] = [];
  }
  return list3;
}
let Element$2 = function() {
};
if (typeof window !== "undefined") {
  Element$2 = window.Element;
}
function defaultPropFactory(prop2) {
  return function(props2) {
    return getDefaultConfig(props2.theme, prop2);
  };
}
const PROVIDE_KEY = "__floating-vue__popper";
var PrivatePopper = () => defineComponent({
  name: "VPopper",
  provide() {
    return {
      [PROVIDE_KEY]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [PROVIDE_KEY]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      required: true
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: defaultPropFactory("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: defaultPropFactory("positioningDisabled")
    },
    placement: {
      type: String,
      default: defaultPropFactory("placement"),
      validator: (value) => placements$1.includes(value)
    },
    delay: {
      type: [String, Number, Object],
      default: defaultPropFactory("delay")
    },
    distance: {
      type: [Number, String],
      default: defaultPropFactory("distance")
    },
    skidding: {
      type: [Number, String],
      default: defaultPropFactory("skidding")
    },
    triggers: {
      type: Array,
      default: defaultPropFactory("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: defaultPropFactory("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperHideTriggers")
    },
    container: {
      type: [String, Object, Element$2, Boolean],
      default: defaultPropFactory("container")
    },
    boundary: {
      type: [String, Element$2],
      default: defaultPropFactory("boundary")
    },
    strategy: {
      type: String,
      validator: (value) => ["absolute", "fixed"].includes(value),
      default: defaultPropFactory("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: defaultPropFactory("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: defaultPropFactory("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: defaultPropFactory("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: defaultPropFactory("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: defaultPropFactory("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: defaultPropFactory("computeTransformOrigin")
    },
    autoMinSize: {
      type: Boolean,
      default: defaultPropFactory("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: defaultPropFactory("autoSize")
    },
    autoMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: defaultPropFactory("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: defaultPropFactory("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: defaultPropFactory("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: defaultPropFactory("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: defaultPropFactory("flip")
    },
    shift: {
      type: Boolean,
      default: defaultPropFactory("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: defaultPropFactory("shiftCrossAxis")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide === "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: __spreadProps2(__spreadValues2({}, this.classes), {
          popperClass: this.popperClass
        }),
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var _a;
      return (_a = this[PROVIDE_KEY]) == null ? void 0 : _a.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var _a, _b;
      return ((_a = this.popperTriggers) == null ? void 0 : _a.includes("hover")) || ((_b = this.popperShowTriggers) == null ? void 0 : _b.includes("hover"));
    }
  },
  watch: __spreadValues2(__spreadValues2({
    shown: "$_autoShowHide",
    disabled(value) {
      if (value) {
        this.dispose();
      } else {
        this.init();
      }
    },
    async container() {
      if (this.isShown) {
        this.$_ensureTeleport();
        await this.$_computePosition();
      }
    }
  }, [
    "triggers",
    "positioningDisabled"
  ].reduce((acc, prop2) => {
    acc[prop2] = "$_refreshListeners";
    return acc;
  }, {})), [
    "placement",
    "distance",
    "skidding",
    "boundary",
    "strategy",
    "overflowPadding",
    "arrowPadding",
    "preventOverflow",
    "shift",
    "shiftCrossAxis",
    "flip"
  ].reduce((acc, prop2) => {
    acc[prop2] = "$_computePosition";
    return acc;
  }, {})),
  created() {
    this.$_isDisposed = true;
    this.randomId = `popper_${[Math.random(), Date.now()].map((n) => n.toString(36).substring(2, 10)).join("_")}`;
    if (this.autoMinSize) {
      console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.');
    }
    if (this.autoMaxSize) {
      console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
    }
  },
  mounted() {
    this.init();
    this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event = null, skipDelay = false, force = false } = {}) {
      var _a, _b;
      if (((_a = this.parentPopper) == null ? void 0 : _a.lockedChild) && this.parentPopper.lockedChild !== this)
        return;
      this.$_pendingHide = false;
      if (force || !this.disabled) {
        if (((_b = this.parentPopper) == null ? void 0 : _b.lockedChild) === this) {
          this.parentPopper.lockedChild = null;
        }
        this.$_scheduleShow(event, skipDelay);
        this.$emit("show");
        this.$_showFrameLocked = true;
        requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        });
      }
      this.$emit("update:shown", true);
    },
    hide({ event = null, skipDelay = false } = {}) {
      var _a;
      if (this.$_hideInProgress)
        return;
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
        if (this.parentPopper) {
          this.parentPopper.lockedChild = this;
          clearTimeout(this.parentPopper.lockedChildTimer);
          this.parentPopper.lockedChildTimer = setTimeout(() => {
            if (this.parentPopper.lockedChild === this) {
              this.parentPopper.lockedChild.hide({ skipDelay });
              this.parentPopper.lockedChild = null;
            }
          }, 1e3);
        }
        return;
      }
      if (((_a = this.parentPopper) == null ? void 0 : _a.lockedChild) === this) {
        this.parentPopper.lockedChild = null;
      }
      this.$_pendingHide = false;
      this.$_scheduleHide(event, skipDelay);
      this.$emit("hide");
      this.$emit("update:shown", false);
    },
    init() {
      if (!this.$_isDisposed)
        return;
      this.$_isDisposed = false;
      this.isMounted = false;
      this.$_events = [];
      this.$_preventShow = false;
      this.$_referenceNode = this.referenceNode();
      this.$_targetNodes = this.targetNodes().filter((e) => e.nodeType === e.ELEMENT_NODE);
      this.$_popperNode = this.popperNode();
      this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
      this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
      this.$_swapTargetAttrs("title", "data-original-title");
      this.$_detachPopperNode();
      if (this.triggers.length) {
        this.$_addEventListeners();
      }
      if (this.shown) {
        this.show();
      }
    },
    dispose() {
      if (this.$_isDisposed)
        return;
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({ skipDelay: true });
      this.$_detachPopperNode();
      this.isMounted = false;
      this.isShown = false;
      this.$_updateParentShownChildren(false);
      this.$_swapTargetAttrs("data-original-title", "title");
      this.$emit("dispose");
    },
    async onResize() {
      if (this.isShown) {
        await this.$_computePosition();
        this.$emit("resize");
      }
    },
    async $_computePosition() {
      var _a;
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const options2 = {
        strategy: this.strategy,
        middleware: []
      };
      if (this.distance || this.skidding) {
        options2.middleware.push(offset$2({
          mainAxis: this.distance,
          crossAxis: this.skidding
        }));
      }
      const isPlacementAuto = this.placement.startsWith("auto");
      if (isPlacementAuto) {
        options2.middleware.push(autoPlacement({
          alignment: (_a = this.placement.split("-")[1]) != null ? _a : ""
        }));
      } else {
        options2.placement = this.placement;
      }
      if (this.preventOverflow) {
        if (this.shift) {
          options2.middleware.push(shift$1({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          }));
        }
        if (!isPlacementAuto && this.flip) {
          options2.middleware.push(flip$2({
            padding: this.overflowPadding,
            boundary: this.boundary
          }));
        }
      }
      options2.middleware.push(arrow$3({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      }));
      if (this.arrowOverflow) {
        options2.middleware.push({
          name: "arrowOverflow",
          fn: ({ placement, rects, middlewareData }) => {
            let overflow;
            const { centerOffset } = middlewareData.arrow;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              overflow = Math.abs(centerOffset) > rects.reference.width / 2;
            } else {
              overflow = Math.abs(centerOffset) > rects.reference.height / 2;
            }
            return {
              data: {
                overflow
              }
            };
          }
        });
      }
      if (this.autoMinSize || this.autoSize) {
        const autoSize = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        options2.middleware.push({
          name: "autoSize",
          fn: ({ rects, placement, middlewareData }) => {
            var _a2;
            if ((_a2 = middlewareData.autoSize) == null ? void 0 : _a2.skip) {
              return {};
            }
            let width;
            let height;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              width = rects.reference.width;
            } else {
              height = rects.reference.height;
            }
            this.$_innerNode.style[autoSize === "min" ? "minWidth" : autoSize === "max" ? "maxWidth" : "width"] = width != null ? `${width}px` : null;
            this.$_innerNode.style[autoSize === "min" ? "minHeight" : autoSize === "max" ? "maxHeight" : "height"] = height != null ? `${height}px` : null;
            return {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      if (this.autoMaxSize || this.autoBoundaryMaxSize) {
        this.$_innerNode.style.maxWidth = null;
        this.$_innerNode.style.maxHeight = null;
        options2.middleware.push(size({
          boundary: this.boundary,
          padding: this.overflowPadding,
          apply: ({ width, height }) => {
            this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
          }
        }));
      }
      const data = await computePosition(this.$_referenceNode, this.$_popperNode, options2);
      Object.assign(this.result, {
        x: data.x,
        y: data.y,
        placement: data.placement,
        strategy: data.strategy,
        arrow: __spreadValues2(__spreadValues2({}, data.middlewareData.arrow), data.middlewareData.arrowOverflow)
      });
    },
    $_scheduleShow(event = null, skipDelay = false) {
      this.$_updateParentShownChildren(true);
      this.$_hideInProgress = false;
      clearTimeout(this.$_scheduleTimer);
      if (hidingPopper && this.instantMove && hidingPopper.instantMove && hidingPopper !== this.parentPopper) {
        hidingPopper.$_applyHide(true);
        this.$_applyShow(true);
        return;
      }
      if (skipDelay) {
        this.$_applyShow();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      }
    },
    $_scheduleHide(event = null, skipDelay = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false);
      this.$_hideInProgress = true;
      clearTimeout(this.$_scheduleTimer);
      if (this.isShown) {
        hidingPopper = this;
      }
      if (skipDelay) {
        this.$_applyHide();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      }
    },
    $_computeDelay(type) {
      const delay = this.delay;
      return parseInt(delay && delay[type] || delay || 0);
    },
    async $_applyShow(skipTransition = false) {
      clearTimeout(this.$_disposeTimer);
      clearTimeout(this.$_scheduleTimer);
      this.skipTransition = skipTransition;
      if (this.isShown) {
        return;
      }
      this.$_ensureTeleport();
      await nextFrame();
      await this.$_computePosition();
      await this.$_applyShowEffect();
      if (!this.positioningDisabled) {
        this.$_registerEventListeners([
          ...getScrollParents(this.$_referenceNode),
          ...getScrollParents(this.$_popperNode)
        ], "scroll", () => {
          this.$_computePosition();
        });
      }
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const bounds = this.$_referenceNode.getBoundingClientRect();
        const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
        const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
        const x = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
        const y = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
        this.result.transformOrigin = `${x}px ${y}px`;
      }
      this.isShown = true;
      this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const showGroup = this.showGroup;
      if (showGroup) {
        let popover;
        for (let i = 0; i < shownPoppers.length; i++) {
          popover = shownPoppers[i];
          if (popover.showGroup !== showGroup) {
            popover.hide();
            popover.$emit("close-group");
          }
        }
      }
      shownPoppers.push(this);
      document.body.classList.add("v-popper--some-open");
      for (const theme of getAllParentThemes(this.theme)) {
        getShownPoppersByTheme(theme).push(this);
        document.body.classList.add(`v-popper--some-open--${theme}`);
      }
      this.$emit("apply-show");
      this.classes.showFrom = true;
      this.classes.showTo = false;
      this.classes.hideFrom = false;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.showFrom = false;
      this.classes.showTo = true;
      this.$_popperNode.focus();
    },
    async $_applyHide(skipTransition = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        this.$_hideInProgress = false;
        return;
      }
      clearTimeout(this.$_scheduleTimer);
      if (!this.isShown) {
        return;
      }
      this.skipTransition = skipTransition;
      removeFromArray(shownPoppers, this);
      if (shownPoppers.length === 0) {
        document.body.classList.remove("v-popper--some-open");
      }
      for (const theme of getAllParentThemes(this.theme)) {
        const list3 = getShownPoppersByTheme(theme);
        removeFromArray(list3, this);
        if (list3.length === 0) {
          document.body.classList.remove(`v-popper--some-open--${theme}`);
        }
      }
      if (hidingPopper === this) {
        hidingPopper = null;
      }
      this.isShown = false;
      this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      });
      clearTimeout(this.$_disposeTimer);
      const disposeTime = getDefaultConfig(this.theme, "disposeTimeout");
      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(() => {
          if (this.$_popperNode) {
            this.$_detachPopperNode();
            this.isMounted = false;
          }
        }, disposeTime);
      }
      this.$_removeEventListeners("scroll");
      this.$emit("apply-hide");
      this.classes.showFrom = false;
      this.classes.showTo = false;
      this.classes.hideFrom = true;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.hideFrom = false;
      this.classes.hideTo = true;
    },
    $_autoShowHide() {
      if (this.shown) {
        this.show();
      } else {
        this.hide();
      }
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let container = this.container;
      if (typeof container === "string") {
        container = window.document.querySelector(container);
      } else if (container === false) {
        container = this.$_targetNodes[0].parentNode;
      }
      if (!container) {
        throw new Error("No container for popover: " + this.container);
      }
      container.appendChild(this.$_popperNode);
      this.isMounted = true;
    },
    $_addEventListeners() {
      const handleShow = (event) => {
        if (this.isShown && !this.$_hideInProgress) {
          return;
        }
        event.usedByTooltip = true;
        !this.$_preventShow && this.show({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, SHOW_EVENT_MAP, this.triggers, this.showTriggers, handleShow);
      this.$_registerTriggerListeners([this.$_popperNode], SHOW_EVENT_MAP, this.popperTriggers, this.popperShowTriggers, handleShow);
      const handleHide = (event) => {
        if (event.usedByTooltip) {
          return;
        }
        this.hide({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, HIDE_EVENT_MAP, this.triggers, this.hideTriggers, handleHide);
      this.$_registerTriggerListeners([this.$_popperNode], HIDE_EVENT_MAP, this.popperTriggers, this.popperHideTriggers, handleHide);
    },
    $_registerEventListeners(targetNodes, eventType, handler) {
      this.$_events.push({ targetNodes, eventType, handler });
      targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(targetNodes, eventMap, commonTriggers, customTrigger, handler) {
      let triggers = commonTriggers;
      if (customTrigger != null) {
        triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
      }
      triggers.forEach((trigger2) => {
        const eventType = eventMap[trigger2];
        if (eventType) {
          this.$_registerEventListeners(targetNodes, eventType, handler);
        }
      });
    },
    $_removeEventListeners(filterEventType) {
      const newList = [];
      this.$_events.forEach((listener3) => {
        const { targetNodes, eventType, handler } = listener3;
        if (!filterEventType || filterEventType === eventType) {
          targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
        } else {
          newList.push(listener3);
        }
      });
      this.$_events = newList;
    },
    $_refreshListeners() {
      if (!this.$_isDisposed) {
        this.$_removeEventListeners();
        this.$_addEventListeners();
      }
    },
    $_handleGlobalClose(event, touch2 = false) {
      if (this.$_showFrameLocked)
        return;
      this.hide({ event });
      if (event.closePopover) {
        this.$emit("close-directive");
      } else {
        this.$emit("auto-hide");
      }
      if (touch2) {
        this.$_preventShow = true;
        setTimeout(() => {
          this.$_preventShow = false;
        }, 300);
      }
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(attrFrom, attrTo) {
      for (const el2 of this.$_targetNodes) {
        const value = el2.getAttribute(attrFrom);
        if (value) {
          el2.removeAttribute(attrFrom);
          el2.setAttribute(attrTo, value);
        }
      }
    },
    $_applyAttrsToTarget(attrs) {
      for (const el2 of this.$_targetNodes) {
        for (const n in attrs) {
          const value = attrs[n];
          if (value == null) {
            el2.removeAttribute(n);
          } else {
            el2.setAttribute(n, value);
          }
        }
      }
    },
    $_updateParentShownChildren(value) {
      let parent = this.parentPopper;
      while (parent) {
        if (value) {
          parent.shownChildren.add(this.randomId);
        } else {
          parent.shownChildren.delete(this.randomId);
          if (parent.$_pendingHide) {
            parent.hide();
          }
        }
        parent = parent.parentPopper;
      }
    },
    $_isAimingPopper() {
      const referenceBounds = this.$_referenceNode.getBoundingClientRect();
      if (mouseX >= referenceBounds.left && mouseX <= referenceBounds.right && mouseY >= referenceBounds.top && mouseY <= referenceBounds.bottom) {
        const popperBounds = this.$_popperNode.getBoundingClientRect();
        const vectorX = mouseX - mousePreviousX;
        const vectorY = mouseY - mousePreviousY;
        const distance = popperBounds.left + popperBounds.width / 2 - mousePreviousX + (popperBounds.top + popperBounds.height / 2) - mousePreviousY;
        const newVectorLength = distance + popperBounds.width + popperBounds.height;
        const edgeX = mousePreviousX + vectorX * newVectorLength;
        const edgeY = mousePreviousY + vectorY * newVectorLength;
        return lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.left, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.right, popperBounds.top) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.right, popperBounds.top, popperBounds.right, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.bottom, popperBounds.right, popperBounds.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
if (typeof document !== "undefined" && typeof window !== "undefined") {
  if (isIOS) {
    document.addEventListener("touchstart", handleGlobalMousedown, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
    document.addEventListener("touchend", handleGlobalTouchend, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener("mousedown", handleGlobalMousedown, true);
    window.addEventListener("click", handleGlobalClick, true);
  }
  window.addEventListener("resize", computePositionAllShownPoppers);
}
function handleGlobalMousedown(event) {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper2 = shownPoppers[i];
    try {
      const popperContent = popper2.popperNode();
      popper2.$_mouseDownContains = popperContent.contains(event.target);
    } catch (e) {
    }
  }
}
function handleGlobalClick(event) {
  handleGlobalClose(event);
}
function handleGlobalTouchend(event) {
  handleGlobalClose(event, true);
}
function handleGlobalClose(event, touch2 = false) {
  const preventClose = {};
  for (let i = shownPoppers.length - 1; i >= 0; i--) {
    const popper2 = shownPoppers[i];
    try {
      const contains2 = popper2.$_containsGlobalTarget = isContainingEventTarget(popper2, event);
      popper2.$_pendingHide = false;
      requestAnimationFrame(() => {
        popper2.$_pendingHide = false;
        if (preventClose[popper2.randomId])
          return;
        if (shouldAutoHide(popper2, contains2, event)) {
          popper2.$_handleGlobalClose(event, touch2);
          if (!event.closeAllPopover && event.closePopover && contains2) {
            let parent2 = popper2.parentPopper;
            while (parent2) {
              preventClose[parent2.randomId] = true;
              parent2 = parent2.parentPopper;
            }
            return;
          }
          let parent = popper2.parentPopper;
          while (parent) {
            if (shouldAutoHide(parent, parent.$_containsGlobalTarget, event)) {
              parent.$_handleGlobalClose(event, touch2);
            } else {
              break;
            }
            parent = parent.parentPopper;
          }
        }
      });
    } catch (e) {
    }
  }
}
function isContainingEventTarget(popper2, event) {
  const popperContent = popper2.popperNode();
  return popper2.$_mouseDownContains || popperContent.contains(event.target);
}
function shouldAutoHide(popper2, contains2, event) {
  return event.closeAllPopover || event.closePopover && contains2 || getAutoHideResult(popper2, event) && !contains2;
}
function getAutoHideResult(popper2, event) {
  if (typeof popper2.autoHide === "function") {
    const result = popper2.autoHide(event);
    popper2.lastAutoHide = result;
    return result;
  }
  return popper2.autoHide;
}
function computePositionAllShownPoppers(event) {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper2 = shownPoppers[i];
    popper2.$_computePosition(event);
  }
}
let mousePreviousX = 0;
let mousePreviousY = 0;
let mouseX = 0;
let mouseY = 0;
if (typeof window !== "undefined") {
  window.addEventListener("mousemove", (event) => {
    mousePreviousX = mouseX;
    mousePreviousY = mouseY;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }, supportsPassive ? {
    passive: true
  } : void 0);
}
function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
  const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
}
var _export_sfc$1 = (sfc, props2) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$6$1 = {
  extends: PrivatePopper()
};
function _sfc_render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "reference",
    class: "v-popper"
  }, _ctx.$attrs, {
    class: {
      "v-popper--shown": _ctx.slotData.isShown
    }
  }), [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)))
  ], 16);
}
var Popper$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$6$1, [["render", _sfc_render$3$1]]);
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script$1 = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId("data-v-b329ee4c");
pushScopeId("data-v-b329ee4c");
const _hoisted_1$2$1 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render$3 = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$2$1);
});
script$1.render = render$3;
script$1.__scopeId = "data-v-b329ee4c";
script$1.__file = "src/components/ResizeObserver.vue";
var PrivateThemeClass = (prop2 = "theme") => ({
  computed: {
    themeClass() {
      return getThemeClasses(this[prop2]);
    }
  }
});
const _sfc_main$5$1 = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: script$1
  },
  mixins: [
    PrivateThemeClass()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(value) {
      if (value != null && !isNaN(value)) {
        return `${value}px`;
      }
      return null;
    }
  }
});
const _hoisted_1$1$1 = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
const _hoisted_2$1$1 = {
  ref: "inner",
  class: "v-popper__inner"
};
const _hoisted_3$k = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1);
const _hoisted_4$h = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1);
const _hoisted_5$c = [
  _hoisted_3$k,
  _hoisted_4$h
];
function _sfc_render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: _ctx.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      _ctx.themeClass,
      _ctx.classes.popperClass,
      {
        "v-popper__popper--shown": _ctx.shown,
        "v-popper__popper--hidden": !_ctx.shown,
        "v-popper__popper--show-from": _ctx.classes.showFrom,
        "v-popper__popper--show-to": _ctx.classes.showTo,
        "v-popper__popper--hide-from": _ctx.classes.hideFrom,
        "v-popper__popper--hide-to": _ctx.classes.hideTo,
        "v-popper__popper--skip-transition": _ctx.skipTransition,
        "v-popper__popper--arrow-overflow": _ctx.result && _ctx.result.arrow.overflow,
        "v-popper__popper--no-positioning": !_ctx.result
      }
    ]]),
    style: normalizeStyle(_ctx.result ? {
      position: _ctx.result.strategy,
      transform: `translate3d(${Math.round(_ctx.result.x)}px,${Math.round(_ctx.result.y)}px,0)`
    } : void 0),
    "aria-hidden": _ctx.shown ? "false" : "true",
    tabindex: _ctx.autoHide ? 0 : void 0,
    "data-popper-placement": _ctx.result ? _ctx.result.placement : void 0,
    onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.autoHide && _ctx.$emit("hide"), ["esc"]))
  }, [
    createBaseVNode("div", {
      class: "v-popper__backdrop",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.autoHide && _ctx.$emit("hide"))
    }),
    createBaseVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(_ctx.result ? {
        transformOrigin: _ctx.result.transformOrigin
      } : void 0)
    }, [
      createBaseVNode("div", _hoisted_2$1$1, [
        _ctx.mounted ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
          createBaseVNode("div", null, [
            renderSlot(_ctx.$slots, "default")
          ]),
          _ctx.handleResize ? (openBlock(), createBlock(_component_ResizeObserver, {
            key: 0,
            onNotify: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("resize", $event))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createBaseVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(_ctx.result ? {
          left: _ctx.toPx(_ctx.result.arrow.x),
          top: _ctx.toPx(_ctx.result.arrow.y)
        } : void 0)
      }, _hoisted_5$c, 4)
    ], 4)
  ], 46, _hoisted_1$1$1);
}
var PrivatePopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$5$1, [["render", _sfc_render$2$1]]);
var PrivatePopperMethods = {
  methods: {
    show(...args) {
      return this.$refs.popper.show(...args);
    },
    hide(...args) {
      return this.$refs.popper.hide(...args);
    },
    dispose(...args) {
      return this.$refs.popper.dispose(...args);
    },
    onResize(...args) {
      return this.$refs.popper.onResize(...args);
    }
  }
};
const _sfc_main$4$1 = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: Popper$1,
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods,
    PrivateThemeClass("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      var _a;
      return (_a = this.theme) != null ? _a : this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$refs.popper.$el.children).filter((node) => node !== this.$refs.popperContent.$el);
    }
  }
});
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, {
    ref: "popper",
    theme: _ctx.finalTheme,
    "target-nodes": _ctx.getTargetNodes,
    "reference-node": () => _ctx.$refs.popper.$el,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    class: normalizeClass([
      _ctx.themeClass
    ])
  }, {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      show,
      hide: hide2,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      renderSlot(_ctx.$slots, "default", {
        shown: isShown,
        show,
        hide: hide2
      }),
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        "popper-id": popperId,
        theme: _ctx.finalTheme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide2,
        onResize
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "popper", {
            shown: isShown,
            hide: hide2
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 8, ["theme", "target-nodes", "reference-node", "popper-node", "class"]);
}
var PrivatePopperWrapper = /* @__PURE__ */ _export_sfc$1(_sfc_main$4$1, [["render", _sfc_render$1$1]]);
const _sfc_main$3$1 = defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VDropdown",
  vPopperTheme: "dropdown"
}));
const _sfc_main$2$1 = defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VMenu",
  vPopperTheme: "menu"
}));
const _sfc_main$1$1 = defineComponent(__spreadProps2(__spreadValues2({}, PrivatePopperWrapper), {
  name: "VTooltip",
  vPopperTheme: "tooltip"
}));
const _sfc_main$v = defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (props2) => getDefaultConfig(props2.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (props2) => getDefaultConfig(props2.theme, "loadingContent")
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content === "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      if (this.isContentAsync) {
        return this.loading ? this.loadingContent : this.asyncContent;
      }
      return this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick();
      this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(force) {
      if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null;
        this.$_loading = true;
        const fetchId = ++this.$_fetchId;
        const result = this.content(this);
        if (result.then) {
          result.then((res) => this.onResult(fetchId, res));
        } else {
          this.onResult(fetchId, result);
        }
      }
    },
    onResult(fetchId, result) {
      if (fetchId !== this.$_fetchId)
        return;
      this.$_loading = false;
      this.asyncContent = result;
    },
    onShow() {
      this.$_isShown = true;
      this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
});
const _hoisted_1$s = ["innerHTML"];
const _hoisted_2$o = ["textContent"];
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, mergeProps({ ref: "popper" }, _ctx.$attrs, {
    theme: _ctx.theme,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    onApplyShow: _ctx.onShow,
    onApplyHide: _ctx.onHide
  }), {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      hide: hide2,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        class: normalizeClass({
          "v-popper--tooltip-loading": _ctx.loading
        }),
        "popper-id": popperId,
        theme: _ctx.theme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide2,
        onResize
      }, {
        default: withCtx(() => [
          _ctx.html ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: _ctx.finalContent
          }, null, 8, _hoisted_1$s)) : (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(_ctx.finalContent)
          }, null, 8, _hoisted_2$o))
        ]),
        _: 2
      }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 1
  }, 16, ["theme", "popper-node", "onApplyShow", "onApplyHide"]);
}
var PrivateTooltipDirective = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$u]]);
const TARGET_CLASS = "v-popper--has-tooltip";
function getPlacement(options2, modifiers2) {
  let result = options2.placement;
  if (!result && modifiers2) {
    for (const pos of placements$1) {
      if (modifiers2[pos]) {
        result = pos;
      }
    }
  }
  if (!result) {
    result = getDefaultConfig(options2.theme || "tooltip", "placement");
  }
  return result;
}
function getOptions(el2, value, modifiers2) {
  let options2;
  const type = typeof value;
  if (type === "string") {
    options2 = { content: value };
  } else if (value && type === "object") {
    options2 = value;
  } else {
    options2 = { content: false };
  }
  options2.placement = getPlacement(options2, modifiers2);
  options2.targetNodes = () => [el2];
  options2.referenceNode = () => el2;
  return options2;
}
let directiveApp;
let directives;
let uid = 0;
function ensureDirectiveApp() {
  if (directiveApp)
    return;
  directives = ref([]);
  directiveApp = createApp({
    name: "VTooltipDirectiveApp",
    setup() {
      return {
        directives
      };
    },
    render() {
      return this.directives.map((directive) => {
        return h(PrivateTooltipDirective, __spreadProps2(__spreadValues2({}, directive.options), {
          shown: directive.shown || directive.options.shown,
          key: directive.id
        }));
      });
    },
    devtools: {
      hide: true
    }
  });
  const mountTarget = document.createElement("div");
  document.body.appendChild(mountTarget);
  directiveApp.mount(mountTarget);
}
function createTooltip(el2, value, modifiers2) {
  ensureDirectiveApp();
  const options2 = ref(getOptions(el2, value, modifiers2));
  const shown = ref(false);
  const item = {
    id: uid++,
    options: options2,
    shown
  };
  directives.value.push(item);
  if (el2.classList) {
    el2.classList.add(TARGET_CLASS);
  }
  const result = el2.$_popper = {
    options: options2,
    item,
    show() {
      shown.value = true;
    },
    hide() {
      shown.value = false;
    }
  };
  return result;
}
function destroyTooltip(el2) {
  if (el2.$_popper) {
    const index2 = directives.value.indexOf(el2.$_popper.item);
    if (index2 !== -1)
      directives.value.splice(index2, 1);
    delete el2.$_popper;
    delete el2.$_popperOldShown;
    delete el2.$_popperMountTarget;
  }
  if (el2.classList) {
    el2.classList.remove(TARGET_CLASS);
  }
}
function bind$1(el2, { value, modifiers: modifiers2 }) {
  const options2 = getOptions(el2, value, modifiers2);
  if (!options2.content || getDefaultConfig(options2.theme || "tooltip", "disabled")) {
    destroyTooltip(el2);
  } else {
    let directive;
    if (el2.$_popper) {
      directive = el2.$_popper;
      directive.options.value = options2;
    } else {
      directive = createTooltip(el2, value, modifiers2);
    }
    if (typeof value.shown !== "undefined" && value.shown !== el2.$_popperOldShown) {
      el2.$_popperOldShown = value.shown;
      value.shown ? directive.show() : directive.hide();
    }
  }
}
var PrivateVTooltip = {
  beforeMount: bind$1,
  updated: bind$1,
  beforeUnmount(el2) {
    destroyTooltip(el2);
  }
};
function addListeners(el2) {
  el2.addEventListener("click", onClick);
  el2.addEventListener("touchstart", onTouchStart, supportsPassive ? {
    passive: true
  } : false);
}
function removeListeners$1(el2) {
  el2.removeEventListener("click", onClick);
  el2.removeEventListener("touchstart", onTouchStart);
  el2.removeEventListener("touchend", onTouchEnd);
  el2.removeEventListener("touchcancel", onTouchCancel);
}
function onClick(event) {
  const el2 = event.currentTarget;
  event.closePopover = !el2.$_vclosepopover_touch;
  event.closeAllPopover = el2.$_closePopoverModifiers && !!el2.$_closePopoverModifiers.all;
}
function onTouchStart(event) {
  if (event.changedTouches.length === 1) {
    const el2 = event.currentTarget;
    el2.$_vclosepopover_touch = true;
    const touch2 = event.changedTouches[0];
    el2.$_vclosepopover_touchPoint = touch2;
    el2.addEventListener("touchend", onTouchEnd);
    el2.addEventListener("touchcancel", onTouchCancel);
  }
}
function onTouchEnd(event) {
  const el2 = event.currentTarget;
  el2.$_vclosepopover_touch = false;
  if (event.changedTouches.length === 1) {
    const touch2 = event.changedTouches[0];
    const firstTouch = el2.$_vclosepopover_touchPoint;
    event.closePopover = Math.abs(touch2.screenY - firstTouch.screenY) < 20 && Math.abs(touch2.screenX - firstTouch.screenX) < 20;
    event.closeAllPopover = el2.$_closePopoverModifiers && !!el2.$_closePopoverModifiers.all;
  }
}
function onTouchCancel(event) {
  const el2 = event.currentTarget;
  el2.$_vclosepopover_touch = false;
}
var PrivateVClosePopper = {
  beforeMount(el2, { value, modifiers: modifiers2 }) {
    el2.$_closePopoverModifiers = modifiers2;
    if (typeof value === "undefined" || value) {
      addListeners(el2);
    }
  },
  updated(el2, { value, oldValue, modifiers: modifiers2 }) {
    el2.$_closePopoverModifiers = modifiers2;
    if (value !== oldValue) {
      if (typeof value === "undefined" || value) {
        addListeners(el2);
      } else {
        removeListeners$1(el2);
      }
    }
  },
  beforeUnmount(el2) {
    removeListeners$1(el2);
  }
};
function install$1(app, options2 = {}) {
  if (app.$_vTooltipInstalled)
    return;
  app.$_vTooltipInstalled = true;
  assign$2(config$3, options2);
  app.directive("tooltip", PrivateVTooltip);
  app.directive("close-popper", PrivateVClosePopper);
  app.component("v-tooltip", _sfc_main$1$1);
  app.component("VTooltip", _sfc_main$1$1);
  app.component("v-dropdown", _sfc_main$3$1);
  app.component("VDropdown", _sfc_main$3$1);
  app.component("v-menu", _sfc_main$2$1);
  app.component("VMenu", _sfc_main$2$1);
}
const plugin$1 = {
  version: "2.0.0-beta.17",
  install: install$1,
  options: config$3
};
function C(e) {
  return (C = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
    return typeof e2;
  } : function(e2) {
    return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
  })(e);
}
function k(e, t2, n, o, r, i, a) {
  try {
    var l = e[i](a), u = l.value;
  } catch (e2) {
    return void n(e2);
  }
  l.done ? t2(u) : Promise.resolve(u).then(o, r);
}
function A(e, t2) {
  for (var n = 0; n < t2.length; n++) {
    var o = t2[n];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, o.key, o);
  }
}
function L(e, t2, n) {
  return t2 in e ? Object.defineProperty(e, t2, { value: n, enumerable: true, configurable: true, writable: true }) : e[t2] = n, e;
}
function B(e, t2) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t2 && (o = o.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e, t3).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _(e) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n = arguments[t2] != null ? arguments[t2] : {};
    t2 % 2 ? B(Object(n), true).forEach(function(t3) {
      L(e, t3, n[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B(Object(n)).forEach(function(t3) {
      Object.defineProperty(e, t3, Object.getOwnPropertyDescriptor(n, t3));
    });
  }
  return e;
}
function j(e) {
  return function(e2) {
    if (Array.isArray(e2))
      return P(e2);
  }(e) || function(e2) {
    if (typeof Symbol != "undefined" && Symbol.iterator in Object(e2))
      return Array.from(e2);
  }(e) || function(e2, t2) {
    if (!e2)
      return;
    if (typeof e2 == "string")
      return P(e2, t2);
    var n = Object.prototype.toString.call(e2).slice(8, -1);
    n === "Object" && e2.constructor && (n = e2.constructor.name);
    if (n === "Map" || n === "Set")
      return Array.from(e2);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return P(e2, t2);
  }(e) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function P(e, t2) {
  (t2 == null || t2 > e.length) && (t2 = e.length);
  for (var n = 0, o = new Array(t2); n < t2; n++)
    o[n] = e[n];
  return o;
}
var I = function(e) {
  return function(e2, t2) {
    return j(e2.querySelectorAll(t2) || []);
  }(e, 'button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=""]:not([disabled]), [contentEditable="true"]:not([disabled]), [contentEditable="TRUE"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex="-1"])');
}, V = function(e) {
  return e == document.activeElement;
}, D = function() {
  function e() {
    !function(e2, t3) {
      if (!(e2 instanceof t3))
        throw new TypeError("Cannot call a class as a function");
    }(this, e), this.root = null, this.elements = [], this.onKeyDown = this.onKeyDown.bind(this), this.enable = this.enable.bind(this), this.disable = this.disable.bind(this), this.firstElement = this.firstElement.bind(this), this.lastElement = this.lastElement.bind(this);
  }
  var t2, n;
  return t2 = e, (n = [{ key: "lastElement", value: function() {
    return this.elements[this.elements.length - 1] || null;
  } }, { key: "firstElement", value: function() {
    return this.elements[0] || null;
  } }, { key: "onKeyDown", value: function(e2) {
    if (function(e3) {
      return e3.key === "Tab" || e3.keyCode === 9;
    }(e2)) {
      if (!e2.shiftKey)
        return !document.activeElement || V(this.lastElement()) ? (this.firstElement().focus(), void e2.preventDefault()) : void 0;
      V(this.firstElement()) && (this.lastElement().focus(), e2.preventDefault());
    }
  } }, { key: "enabled", value: function() {
    return !!this.root;
  } }, { key: "enable", value: function(e2) {
    e2 && (this.root = e2, this.elements = I(this.root), this.root.addEventListener("keydown", this.onKeyDown));
  } }, { key: "disable", value: function() {
    this.root.removeEventListener("keydown", this.onKeyDown), this.root = null;
  } }]) && A(t2.prototype, n), e;
}(), N = function(e) {
  var t2 = e.targetTouches ? e.targetTouches[0] : e;
  return { x: t2.clientX, y: t2.clientY };
}, R = function(e, t2, n) {
  return typeof e != "number" && (e = Math.min(t2, n) || t2), typeof n != "number" && (n = Math.max(t2, e)), Math.min(Math.max(t2, e), n);
}, $$1 = function(e) {
  return e && Number(e.replace(/px$/, "")) || 0;
}, H = { down: { pc: "mousedown", m: "touchstart" }, move: { pc: "mousemove", m: "touchmove" }, up: { pc: "mouseup", m: "touchend" } }, K = function(e, t2, n) {
  t2 && t2.addEventListener(H[e].pc, n), t2 && t2.addEventListener(H[e].m, n, { passive: false });
}, U = function(e, t2, n) {
  t2 && t2.removeEventListener(H[e].pc, n), t2 && t2.removeEventListener(H[e].m, n);
}, F = false;
if (typeof window != "undefined") {
  var W = { get passive() {
    F = true;
  } };
  window.addEventListener("testPassive", null, W), window.removeEventListener("testPassive", null, W);
}
var Y, q, G = typeof window != "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1), X = [], Z = false, J = 0, Q = -1, ee$1 = function(e, t2) {
  var n = false;
  return function(e2) {
    for (var t3 = []; e2; ) {
      if (t3.push(e2), e2.classList.contains("vfm"))
        return t3;
      e2 = e2.parentElement;
    }
    return t3;
  }(e).forEach(function(e2) {
    (function(e3) {
      if (!e3 || e3.nodeType !== Node.ELEMENT_NODE)
        return false;
      var t3 = window.getComputedStyle(e3);
      return ["auto", "scroll"].includes(t3.overflowY) && e3.scrollHeight > e3.clientHeight;
    })(e2) && function(e3, t3) {
      return !(e3.scrollTop === 0 && t3 < 0 || e3.scrollTop + e3.clientHeight + t3 >= e3.scrollHeight && t3 > 0);
    }(e2, t2) && (n = true);
  }), n;
}, te = function(e) {
  return X.some(function() {
    return ee$1(e, -J);
  });
}, ne$1 = function(e) {
  var t2 = e || window.event;
  return !!te(t2.target) || (t2.touches.length > 1 || (t2.preventDefault && t2.preventDefault(), false));
}, oe = function(e, t2) {
  if (e) {
    if (!X.some(function(t3) {
      return t3.targetElement === e;
    })) {
      var n = { targetElement: e, options: t2 || {} };
      X = [].concat(j(X), [n]), G ? (e.ontouchstart = function(e2) {
        e2.targetTouches.length === 1 && (Q = e2.targetTouches[0].clientY);
      }, e.ontouchmove = function(t3) {
        t3.targetTouches.length === 1 && function(e2, t4) {
          J = e2.targetTouches[0].clientY - Q, !te(e2.target) && (t4 && t4.scrollTop === 0 && J > 0 || function(e3) {
            return !!e3 && e3.scrollHeight - e3.scrollTop <= e3.clientHeight;
          }(t4) && J < 0 ? ne$1(e2) : e2.stopPropagation());
        }(t3, e);
      }, Z || (document.addEventListener("touchmove", ne$1, F ? { passive: false } : void 0), Z = true)) : function(e2) {
        if (q === void 0) {
          var t3 = !!e2 && e2.reserveScrollBarGap === true, n2 = window.innerWidth - document.documentElement.clientWidth;
          if (t3 && n2 > 0) {
            var o = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
            q = document.body.style.paddingRight, document.body.style.paddingRight = "".concat(o + n2, "px");
          }
        }
        Y === void 0 && (Y = document.body.style.overflow, document.body.style.overflow = "hidden");
      }(t2);
    }
  } else
    console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
}, re$1 = function(e) {
  e ? (X = X.filter(function(t2) {
    return t2.targetElement !== e;
  }), G ? (e.ontouchstart = null, e.ontouchmove = null, Z && X.length === 0 && (document.removeEventListener("touchmove", ne$1, F ? { passive: false } : void 0), Z = false)) : X.length || (q !== void 0 && (document.body.style.paddingRight = q, q = void 0), Y !== void 0 && (document.body.style.overflow = Y, Y = void 0))) : console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
}, ie$2 = function() {
}, ae = "enter", le$1 = "entering", ue = "leave", se = "leavng", fe = { t: "ns-resize", tr: "nesw-resize", r: "ew-resize", br: "nwse-resize", b: "ns-resize", bl: "nesw-resize", l: "ew-resize", tl: "nwse-resize" }, de = { props: { name: { type: String, default: null }, modelValue: { type: Boolean, default: false }, ssr: { type: Boolean, default: true }, classes: { type: [String, Object, Array], default: "" }, overlayClass: { type: [String, Object, Array], default: "" }, contentClass: { type: [String, Object, Array], default: "" }, styles: { type: [Object, Array], default: function() {
  return {};
} }, overlayStyle: { type: [Object, Array], default: function() {
  return {};
} }, contentStyle: { type: [Object, Array], default: function() {
  return {};
} }, lockScroll: { type: Boolean, default: true }, hideOverlay: { type: Boolean, default: false }, clickToClose: { type: Boolean, default: true }, escToClose: { type: Boolean, default: false }, preventClick: { type: Boolean, default: false }, attach: { type: null, default: false, validator: function(e) {
  var t2 = C(e);
  return t2 === "boolean" || t2 === "string" || e.nodeType === Node.ELEMENT_NODE;
} }, transition: { type: [String, Object], default: "vfm" }, overlayTransition: { type: [String, Object], default: "vfm" }, keepOverlay: { type: Boolean, default: false }, zIndexAuto: { type: Boolean, default: true }, zIndexBase: { type: [String, Number], default: 1e3 }, zIndex: { type: [Boolean, String, Number], default: false }, focusRetain: { type: Boolean, default: true }, focusTrap: { type: Boolean, default: false }, fitParent: { type: Boolean, default: true }, drag: { type: Boolean, default: false }, dragSelector: { type: String, default: "" }, keepChangedStyle: { type: Boolean, default: false }, resize: { type: Boolean, default: false }, resizeDirections: { type: Array, default: function() {
  return ["t", "tr", "r", "br", "b", "bl", "l", "tl"];
}, validator: function(e) {
  return ["t", "tr", "r", "br", "b", "bl", "l", "tl"].filter(function(t2) {
    return e.indexOf(t2) !== -1;
  }).length === e.length;
} }, minWidth: { type: Number, default: 0 }, minHeight: { type: Number, default: 0 }, maxWidth: { type: Number, default: 1 / 0 }, maxHeight: { type: Number, default: 1 / 0 } }, emits: ["update:modelValue", "click-outside", "before-open", "opened", "before-close", "closed", "_before-open", "_opened", "_closed", "drag:start", "drag:move", "drag:end", "resize:start", "resize:move", "resize:end"], setup: function(l, u) {
  var s = u.emit, f = Symbol("vfm"), d2 = ref(null), c = ref(null), v = ref(null), p2 = ref(null), m = ref(null), y = ref(null), h2 = ref(null), b = new D(), g = ref(false), w2 = reactive({ modal: false, overlay: false, resize: false }), x = ref(null), E = ref(null), S = ref(false), O = ref({}), z = ref({}), M = ref(null), T = ref(null), C2 = ie$2, k2 = ie$2, A2 = computed(function() {
    return typeof l.overlayTransition == "string" ? { name: l.overlayTransition } : _({}, l.overlayTransition);
  }), B2 = computed(function() {
    return typeof l.transition == "string" ? { name: l.transition } : _({}, l.transition);
  }), P2 = computed(function() {
    return (l.hideOverlay || x.value === ue) && E.value === ue;
  }), I2 = computed(function() {
    return l.zIndex === false ? !!l.zIndexAuto && +l.zIndexBase + 2 * (h2.value || 0) : l.zIndex;
  }), V2 = computed(function() {
    return _({}, I2.value !== false && { zIndex: I2.value });
  }), H2 = computed(function() {
    var e = [z.value];
    return Array.isArray(l.contentStyle) ? e.push.apply(e, j(l.contentStyle)) : e.push(l.contentStyle), e;
  });
  function F2() {
    return { uid: f, props: l, emit: s, vfmContainer: c, vfmContent: v, vfmResize: p2, vfmOverlayTransition: m, vfmTransition: y, getAttachElement: G2, modalStackIndex: h2, visibility: w2, handleLockScroll: q2, $focusTrap: b, toggle: Q2, params: O };
  }
  function W() {
    if (l.modelValue) {
      if (s("_before-open", X2({ type: "_before-open" })), Z2("before-open", false))
        return void k2("show");
      var e = G2();
      if (e || l.attach === false) {
        if (l.attach !== false) {
          if (!d2.value)
            return g.value = true, void nextTick(function() {
              W();
            });
          e.appendChild(d2.value);
        }
        var t2 = l.api.openedModals.findIndex(function(e2) {
          return e2.uid === f;
        });
        t2 !== -1 && l.api.openedModals.splice(t2, 1), l.api.openedModals.push(F2()), h2.value = l.api.openedModals.length - 1, q2(), l.api.openedModals.filter(function(e2) {
          return e2.uid !== f;
        }).forEach(function(t3, n) {
          t3.getAttachElement() === e && (t3.modalStackIndex.value = n, !t3.props.keepOverlay && (t3.visibility.overlay = false));
        }), g.value = true, w2.overlay = true, w2.modal = true;
      } else
        e !== false && console.warn("Unable to locate target ".concat(l.attach));
    }
  }
  function Y2() {
    var e = l.api.openedModals.findIndex(function(e2) {
      return e2.uid === f;
    });
    if (e !== -1 && l.api.openedModals.splice(e, 1), l.api.openedModals.length > 0) {
      var t2 = l.api.openedModals[l.api.openedModals.length - 1];
      t2.props.focusTrap && t2.$focusTrap.firstElement().focus(), (t2.props.focusRetain || t2.props.focusTrap) && t2.vfmContainer.value.focus(), !t2.props.hideOverlay && (t2.visibility.overlay = true);
    }
    l.drag && ne2(), l.resize && ce2(), M.value = null, w2.overlay = false, w2.modal = false;
  }
  function q2() {
    l.modelValue && nextTick(function() {
      l.lockScroll ? oe(c.value, { reserveScrollBarGap: true }) : re$1(c.value);
    });
  }
  function G2() {
    return l.attach !== false && (typeof l.attach == "string" ? !!window && window.document.querySelector(l.attach) : l.attach);
  }
  function X2() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return _({ ref: F2() }, e);
  }
  function Z2(e, t2) {
    var n = false, o = X2({ type: e, stop: function() {
      n = true;
    } });
    return s(e, o), !!n && (S.value = true, nextTick(function() {
      s("update:modelValue", t2);
    }), true);
  }
  function J2(e, t2, n) {
    M.value = "".concat(t2, ":").concat(n), s(M.value, e);
  }
  function Q2(e, t2) {
    var n = arguments;
    return new Promise(function(o, r) {
      C2 = function(e2) {
        o(e2), C2 = ie$2;
      }, k2 = function(e2) {
        r(e2), k2 = ie$2;
      };
      var i = typeof e == "boolean" ? e : !l.modelValue;
      i && n.length === 2 && (O.value = t2), s("update:modelValue", i);
    });
  }
  function ee2(e) {
    e.stopPropagation();
    var t2, n = "resize", o = "drag", r = e.target.getAttribute("direction");
    if (r)
      t2 = n;
    else {
      if (!function(e2, t3, n2) {
        return n2 === "" || j(t3.querySelectorAll(n2)).includes(e2.target);
      }(e, v.value, l.dragSelector))
        return;
      t2 = o;
    }
    J2(e, t2, "start");
    var i, a, u2, s2, f2 = N(e), d3 = c.value.getBoundingClientRect(), p3 = v.value.getBoundingClientRect(), m2 = window.getComputedStyle(v.value).position === "absolute", y2 = $$1(z.value.top), h3 = $$1(z.value.left), b2 = function() {
      if (l.fitParent) {
        var e2 = { absolute: function() {
          return { minTop: 0, minLeft: 0, maxTop: d3.height - p3.height, maxLeft: d3.width - p3.width };
        }, relative: function() {
          return { minTop: y2 + d3.top - p3.top, minLeft: h3 + d3.left - p3.left, maxTop: y2 + d3.bottom - p3.bottom, maxLeft: h3 + d3.right - p3.right };
        } };
        return m2 ? e2.absolute() : e2.relative();
      }
      return {};
    }(), g2 = t2 === n && (i = document.body, a = "cursor", u2 = fe[r], s2 = i.style[a], i.style[a] = u2, function() {
      i.style[a] = s2;
    }), w3 = function(e2) {
      e2.stopPropagation(), J2(e2, t2, "move");
      var i2, a2, u3 = N(e2), s3 = { x: u3.x - f2.x, y: u3.y - f2.y };
      t2 === n && (s3 = function(e3, t3, n2, o2, r2) {
        var i3 = function(e4) {
          var n3, o3 = t3[e4.axis];
          o3 = l.fitParent ? R(e4.min, o3, e4.max) : o3;
          var i4 = R(e4.minEdge, e4.getEdge(o3), e4.maxEdge);
          return o3 = e4.getOffsetAxis(i4, r2), L(n3 = {}, e4.edgeName, i4), L(n3, e4.axis, o3), n3;
        }, a3 = function(e4, t4, r3, i4) {
          var a4, u5 = o2[t4], s5 = n2[e4] - o2[e4], f3 = (a4 = t4).charAt(0).toUpperCase() + a4.slice(1);
          return { axis: r3, edgeName: t4, min: i4 ? s5 : -u5, max: i4 ? u5 : s5, minEdge: l["min".concat(f3)], maxEdge: l["max".concat(f3)], getEdge: function(e5) {
            return o2[t4] - e5 * (i4 ? 1 : -1);
          }, getOffsetAxis: function(e5, n3) {
            var r4 = o2[t4] - e5;
            return n3 ? i4 ? r4 : 0 : (i4 ? 1 : -1) * r4 / 2;
          } };
        }, u4 = { t: ["top", "height", "y", true], b: ["bottom", "height", "y", false], l: ["left", "width", "x", true], r: ["right", "width", "x", false] }, s4 = { x: 0, y: 0 };
        return e3.split("").forEach(function(e4) {
          var t4 = a3.apply(void 0, j(u4[e4]));
          s4 = _(_({}, s4), i3(t4));
        }), s4;
      }(r, s3, d3, p3, m2)), m2 ? (i2 = p3.top - d3.top + s3.y, a2 = p3.left - d3.left + s3.x) : (i2 = y2 + s3.y, a2 = h3 + s3.x), t2 === o && l.fitParent && (i2 = R(b2.minTop, i2, b2.maxTop), a2 = R(b2.minLeft, a2, b2.maxLeft));
      var c2 = _(_(_({ position: "relative", top: i2 + "px", left: a2 + "px", margin: "unset", touchAction: "none" }, m2 && { position: "absolute", transform: "unset", width: p3.width + "px", height: p3.height + "px" }), s3.width && { width: s3.width + "px" }), s3.height && { height: s3.height + "px" });
      z.value = _(_({}, z.value), c2);
    };
    K("move", document, w3), K("up", document, function e2(o2) {
      o2.stopPropagation(), t2 === n && g2 && g2(), setTimeout(function() {
        J2(o2, t2, "end");
      }), U("move", document, w3), U("up", document, e2);
    });
  }
  function te2() {
    K("down", v.value, ee2), z.value.touchAction = "none";
  }
  function ne2() {
    U("down", v.value, ee2);
  }
  function de2() {
    w2.resize = true, nextTick(function() {
      K("down", p2.value, ee2);
    });
  }
  function ce2() {
    U("down", p2.value, ee2), w2.resize = false;
  }
  return watch$1(function() {
    return l.modelValue;
  }, function(e) {
    if (S.value)
      S.value = false;
    else if (W(), !e) {
      if (Z2("before-close", true))
        return void k2("hide");
      Y2();
    }
  }), watch$1(function() {
    return l.lockScroll;
  }, q2), watch$1(function() {
    return l.hideOverlay;
  }, function(e) {
    l.modelValue && !e && (w2.overlay = true);
  }), watch$1(function() {
    return l.attach;
  }, W), watch$1(P2, function(e) {
    e && (g.value = false, c.value.style.display = "none");
  }, { flush: "post" }), watch$1(function() {
    return l.drag;
  }, function(e) {
    g.value && (e ? te2() : ne2());
  }), watch$1(function() {
    return l.resize;
  }, function(e) {
    g.value && (e ? de2() : ce2());
  }), watch$1(function() {
    return l.keepChangedStyle;
  }, function(e) {
    e || (z.value = {});
  }), l.api.modals.push(F2()), onMounted(function() {
    W();
  }), onBeforeUnmount(function() {
    var e;
    Y2(), l.lockScroll && c.value && re$1(c.value), d2 == null || (e = d2.value) === null || e === void 0 || e.remove();
    var t2 = l.api.modals.findIndex(function(e2) {
      return e2.uid === f;
    });
    l.api.modals.splice(t2, 1);
  }), { root: d2, vfmContainer: c, vfmContent: v, vfmResize: p2, vfmOverlayTransition: m, vfmTransition: y, computedOverlayTransition: A2, computedTransition: B2, visible: g, visibility: w2, params: O, calculateZIndex: I2, bindStyle: V2, bindContentStyle: H2, beforeOverlayEnter: function() {
    x.value = le$1;
  }, afterOverlayEnter: function() {
    x.value = ae;
  }, beforeOverlayLeave: function() {
    x.value = se;
  }, afterOverlayLeave: function() {
    x.value = ue;
  }, beforeModalEnter: function() {
    E.value = le$1;
  }, afterModalEnter: function() {
    E.value = ae, (l.focusRetain || l.focusTrap) && c.value.focus(), l.focusTrap && b.enable(c.value), l.drag && te2(), l.resize && de2(), s("_opened"), s("opened", X2({ type: "opened" })), C2("show");
  }, beforeModalLeave: function() {
    E.value = se, b.enabled() && b.disable();
  }, afterModalLeave: function() {
    E.value = ue, h2.value = null, l.lockScroll && re$1(c.value), l.keepChangedStyle || (z.value = {});
    var e = false, t2 = X2({ type: "closed", stop: function() {
      e = true;
    } });
    s("_closed"), s("closed", t2), C2("hide"), e || (O.value = {});
  }, onMousedown: function(e) {
    T.value = e == null ? void 0 : e.target;
  }, onMouseupContainer: function() {
    T.value === c.value && M.value !== "resize:move" && (s("click-outside", X2({ type: "click-outside" })), l.clickToClose && s("update:modelValue", false));
  }, onEsc: function() {
    g.value && l.escToClose && s("update:modelValue", false);
  } };
} }, ce = withScopeId("data-v-2836fdb5");
pushScopeId("data-v-2836fdb5");
var ve = { key: 0, ref: "vfmResize", class: "vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none" };
popScopeId();
var pe = ce(function(e, t2, n, o, r, i) {
  return n.ssr || o.visible ? withDirectives((openBlock(), createBlock("div", { key: 0, ref: "root", style: o.bindStyle, class: ["vfm vfm--inset", [n.attach === false ? "vfm--fixed" : "vfm--absolute", { "vfm--prevent-none": n.preventClick }]], onKeydown: t2[4] || (t2[4] = withKeys(function() {
    return o.onEsc && o.onEsc.apply(o, arguments);
  }, ["esc"])) }, [createVNode(Transition, mergeProps(o.computedOverlayTransition, { onBeforeEnter: o.beforeOverlayEnter, onAfterEnter: o.afterOverlayEnter, onBeforeLeave: o.beforeOverlayLeave, onAfterLeave: o.afterOverlayLeave }), { default: ce(function() {
    return [!n.hideOverlay && o.visibility.overlay ? (openBlock(), createBlock("div", { key: 0, class: ["vfm__overlay vfm--overlay vfm--absolute vfm--inset", n.overlayClass], style: n.overlayStyle }, null, 6)) : createCommentVNode("v-if", true)];
  }), _: 1 }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]), createVNode(Transition, mergeProps(o.computedTransition, { onBeforeEnter: o.beforeModalEnter, onAfterEnter: o.afterModalEnter, onBeforeLeave: o.beforeModalLeave, onAfterLeave: o.afterModalLeave }), { default: ce(function() {
    return [withDirectives(createVNode("div", { ref: "vfmContainer", class: ["vfm__container vfm--absolute vfm--inset vfm--outline-none", n.classes], style: n.styles, "aria-expanded": o.visibility.modal.toString(), role: "dialog", "aria-modal": "true", tabindex: "-1", onMouseup: t2[2] || (t2[2] = withModifiers(function() {
      return o.onMouseupContainer && o.onMouseupContainer.apply(o, arguments);
    }, ["self"])), onMousedown: t2[3] || (t2[3] = withModifiers(function() {
      return o.onMousedown && o.onMousedown.apply(o, arguments);
    }, ["self"])) }, [createVNode("div", { ref: "vfmContent", class: ["vfm__content", [n.contentClass, { "vfm--prevent-auto": n.preventClick }]], style: o.bindContentStyle, onMousedown: t2[1] || (t2[1] = function(e2) {
      return o.onMousedown(null);
    }) }, [renderSlot(e.$slots, "default", { params: o.params, close: function() {
      return e.$emit("update:modelValue", false);
    } }), o.visibility.resize && o.visibility.modal ? (openBlock(), createBlock("div", ve, [(openBlock(true), createBlock(Fragment$1, null, renderList(n.resizeDirections, function(e2) {
      return openBlock(), createBlock("div", { key: e2, direction: e2, class: ["vfm--resize-".concat(e2), "vfm--absolute vfm--prevent-auto"] }, null, 10, ["direction"]);
    }), 128))], 512)) : createCommentVNode("v-if", true)], 38)], 46, ["aria-expanded"]), [[vShow, o.visibility.modal]])];
  }), _: 3 }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])], 38)), [[vShow, !n.ssr || o.visible]]) : createCommentVNode("v-if", true);
});
!function(e, t2) {
  t2 === void 0 && (t2 = {});
  var n = t2.insertAt;
  if (e && typeof document != "undefined") {
    var o = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
    r.type = "text/css", n === "top" && o.firstChild ? o.insertBefore(r, o.firstChild) : o.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e));
  }
}("\n.vfm--fixed[data-v-2836fdb5] {\n  position: fixed;\n}\n.vfm--absolute[data-v-2836fdb5] {\n  position: absolute;\n}\n.vfm--inset[data-v-2836fdb5] {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay[data-v-2836fdb5] {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none[data-v-2836fdb5] {\n  pointer-events: none;\n}\n.vfm--prevent-auto[data-v-2836fdb5] {\n  pointer-events: auto;\n}\n.vfm--outline-none[data-v-2836fdb5]:focus {\n  outline: none;\n}\n.vfm-enter-active[data-v-2836fdb5],\n.vfm-leave-active[data-v-2836fdb5] {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from[data-v-2836fdb5],\n.vfm-leave-to[data-v-2836fdb5] {\n  opacity: 0;\n}\n.vfm--touch-none[data-v-2836fdb5] {\n  touch-action: none;\n}\n.vfm--select-none[data-v-2836fdb5] {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vfm--resize-tr[data-v-2836fdb5],\n.vfm--resize-br[data-v-2836fdb5],\n.vfm--resize-bl[data-v-2836fdb5],\n.vfm--resize-tl[data-v-2836fdb5] {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n.vfm--resize-t[data-v-2836fdb5] {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr[data-v-2836fdb5] {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r[data-v-2836fdb5] {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br[data-v-2836fdb5] {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b[data-v-2836fdb5] {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl[data-v-2836fdb5] {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l[data-v-2836fdb5] {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl[data-v-2836fdb5] {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n"), de.render = pe, de.__scopeId = "data-v-2836fdb5", de.__file = "lib/VueFinalModal.vue";
var me = { props: {}, methods: { slice: function(e) {
  this.api.dynamicModals.splice(e, 1);
}, beforeOpen: function(e, t2, n) {
  var o, r = this;
  return (o = function* () {
    e.ref.params.value = t2.params, yield r.$nextTick(), yield r.$nextTick(), t2.value || (r.slice(n), t2.reject("show"));
  }, function() {
    var e2 = this, t3 = arguments;
    return new Promise(function(n2, r2) {
      var i = o.apply(e2, t3);
      function a(e3) {
        k(i, n2, r2, a, l, "next", e3);
      }
      function l(e3) {
        k(i, n2, r2, a, l, "throw", e3);
      }
      a(void 0);
    });
  })();
}, isString: function(e) {
  return typeof e == "string";
} } }, ye = { class: "modals-container" };
function he(e, t2) {
  var n = _(_({}, e), {}, { props: _({}, e.props) });
  return Object.assign(n.props, { api: { type: Object, default: function() {
    return t2;
  } } }), n;
}
me.render = function(e, t2, n, o, r, i) {
  return openBlock(), createBlock("div", ye, [(openBlock(true), createBlock(Fragment$1, null, renderList(e.api.dynamicModals, function(e2, t3) {
    return openBlock(), createBlock(resolveDynamicComponent(e2.component), mergeProps({ key: e2.id }, e2.bind, { modelValue: e2.value, "onUpdate:modelValue": function(t4) {
      return e2.value = t4;
    } }, toHandlers(e2.on), { on_closed: function(e3) {
      return i.slice(t3);
    }, on_beforeOpen: function(t4) {
      return i.beforeOpen(t4, e2);
    }, on_opened: e2.opened }), createSlots({ _: 2 }, [renderList(e2.slots, function(e3, t4) {
      return { name: t4, fn: withCtx(function() {
        return [createCommentVNode(" eslint-disable vue/no-v-html "), i.isString(e3) ? (openBlock(), createBlock("div", { key: 0, innerHTML: e3 }, null, 8, ["innerHTML"])) : (openBlock(), createBlock(resolveDynamicComponent(e3.component), mergeProps({ key: 1 }, e3.bind, toHandlers(e3.on || {})), null, 16))];
      }) };
    })]), 1040, ["modelValue", "onUpdate:modelValue", "on_closed", "on_beforeOpen", "on_opened"]);
  }), 128))]);
}, me.__file = "lib/ModalsContainer.vue";
var be = 0, ge$1 = function() {
  var e, t2, n = (t2 = null, { show: function(e2) {
    for (var n2 = this, o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
      r[i - 1] = arguments[i];
    switch (C(e2)) {
      case "string":
        return this.toggle.apply(this, [e2, true].concat(r));
      case "object":
        return Promise.allSettled([new Promise(function(o2, i2) {
          var a = { value: true, id: Symbol("dynamicModal"), component: t2, bind: {}, slots: {}, on: {}, params: r[0], reject: i2, opened: function() {
            o2("show");
          } };
          n2.dynamicModals.push(shallowReactive(Object.assign(a, e2)));
        })]);
    }
  }, hide: function() {
    for (var e2 = arguments.length, t3 = new Array(e2), n2 = 0; n2 < e2; n2++)
      t3[n2] = arguments[n2];
    return this.toggle(t3, false);
  }, hideAll: function() {
    return this.hide.apply(this, j(this.openedModals.map(function(e2) {
      return e2.props.name;
    })));
  }, toggle: function(e2) {
    for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), o = 1; o < t3; o++)
      n2[o - 1] = arguments[o];
    var r = Array.isArray(e2) ? this.get.apply(this, j(e2)) : this.get(e2);
    return Promise.allSettled(r.map(function(e3) {
      return e3.toggle.apply(e3, n2);
    }));
  }, get: function() {
    for (var e2 = arguments.length, t3 = new Array(e2), n2 = 0; n2 < e2; n2++)
      t3[n2] = arguments[n2];
    return this.modals.filter(function(e3) {
      return t3.includes(e3.props.name);
    });
  }, dynamicModals: shallowReactive([]), openedModals: [], modals: [], _setDefaultModal: function(e2) {
    t2 = e2;
  } });
  return L(e = {}, "$vfm", n), L(e, "VueFinalModal", function(e2) {
    var t3 = he(de, e2);
    return e2._setDefaultModal(t3), t3;
  }(n)), L(e, "ModalsContainer", function(e2) {
    return he(me, e2);
  }(n)), e;
}, we = ge$1(), xe = we.$vfm, Ee = we.VueFinalModal;
we.ModalsContainer;
var Oe = function(e) {
  var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = be === 0 ? we : ge$1(), o = n.$vfm, r = n.VueFinalModal, i = n.ModalsContainer;
  be += 1;
  var a = t2.key || "$vfm", l = t2.componentName || "VueFinalModal", u = t2.dynamicContainerName || "ModalsContainer";
  Object.defineProperty(e.config.globalProperties, a, { get: function() {
    return o;
  } }), e.provide(a, o), e.component(l, r), e.component(u, i);
}, ze = function(e) {
  return { install: function(t2, n) {
    var o = Object.assign({}, e, n);
    Oe(t2, o);
  } };
};
ze.install = Oe;
const methods = {
  $idFactory(uidProperty) {
    return function $id(id = "") {
      return `${this[uidProperty]}-${id}`;
    };
  },
  $idRef(id) {
    return `#${this.$id(id)}`;
  }
};
const DEFAULTS = {
  uidProperty: "uid",
  uidPrefix: "uid-"
};
function install(Vue, options2 = {}) {
  const uidProperty = options2.uidProperty || DEFAULTS.uidProperty;
  const uidPrefix = options2.uidPrefix || DEFAULTS.uidPrefix;
  let uidCounter = 0;
  Vue.mixin({
    beforeCreate() {
      uidCounter += 1;
      const uid2 = uidPrefix + uidCounter;
      Object.defineProperties(this, {
        [uidProperty]: { get() {
          return uid2;
        } }
      });
    }
  });
  const globalPrototype = Vue.version.slice(0, 2) === "3." ? Vue.config.globalProperties : Vue.prototype;
  globalPrototype.$id = methods.$idFactory(uidProperty);
  globalPrototype.$idRef = methods.$idRef;
}
function token$2() {
  return Math.random().toString(36).substring(2, 15);
}
function dedupe(arr1, arr2) {
  const original = arr1 instanceof Set ? arr1 : new Set(arr1);
  if (arr2)
    arr2.forEach((item) => original.add(item));
  return [...original];
}
function has$3(obj, property2) {
  return Object.prototype.hasOwnProperty.call(obj, property2);
}
function eq$1(valA, valB, deep = true, explicit = ["__key"]) {
  if (valA === valB)
    return true;
  if (typeof valB === "object" && typeof valA === "object") {
    if (valA instanceof Map)
      return false;
    if (valA instanceof Set)
      return false;
    if (valA instanceof Date)
      return false;
    if (valA === null || valB === null)
      return false;
    if (Object.keys(valA).length !== Object.keys(valB).length)
      return false;
    for (const k2 of explicit) {
      if ((k2 in valA || k2 in valB) && valA[k2] !== valB[k2])
        return false;
    }
    for (const key in valA) {
      if (!(key in valB))
        return false;
      if (valA[key] !== valB[key] && !deep)
        return false;
      if (deep && !eq$1(valA[key], valB[key], deep, explicit))
        return false;
    }
    return true;
  }
  return false;
}
function empty$2(value) {
  const type = typeof value;
  if (type === "number")
    return false;
  if (value === void 0)
    return true;
  if (type === "string") {
    return value === "";
  }
  if (type === "object") {
    if (value === null)
      return true;
    for (const _i in value)
      return false;
    if (value instanceof RegExp)
      return false;
    if (value instanceof Date)
      return false;
    return true;
  }
  return false;
}
function escapeExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function regexForFormat(format3) {
  const escaped = `^${escapeExp(format3)}$`;
  const formats = {
    MM: "(0[1-9]|1[012])",
    M: "([1-9]|1[012])",
    DD: "([012][0-9]|3[01])",
    D: "([012]?[0-9]|3[01])",
    YYYY: "\\d{4}",
    YY: "\\d{2}"
  };
  const tokens = Object.keys(formats);
  return new RegExp(tokens.reduce((regex2, format4) => {
    return regex2.replace(format4, formats[format4]);
  }, escaped));
}
function isRecord(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isObject$4(o) {
  return isRecord(o) || Array.isArray(o);
}
function isPojo(o) {
  if (isRecord(o) === false)
    return false;
  if (o.__FKNode__ || o.__POJO__ === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isRecord(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function extend$1(original, additional, extendArrays = false, ignoreUndefined = false) {
  if (additional === null)
    return null;
  const merged = {};
  if (typeof additional === "string")
    return additional;
  for (const key in original) {
    if (has$3(additional, key) && (additional[key] !== void 0 || !ignoreUndefined)) {
      if (extendArrays && Array.isArray(original[key]) && Array.isArray(additional[key])) {
        merged[key] = original[key].concat(additional[key]);
        continue;
      }
      if (additional[key] === void 0) {
        continue;
      }
      if (isPojo(original[key]) && isPojo(additional[key])) {
        merged[key] = extend$1(original[key], additional[key], extendArrays, ignoreUndefined);
      } else {
        merged[key] = additional[key];
      }
    } else {
      merged[key] = original[key];
    }
  }
  for (const key in additional) {
    if (!has$3(merged, key) && additional[key] !== void 0) {
      merged[key] = additional[key];
    }
  }
  return merged;
}
function isQuotedString(str) {
  if (str[0] !== '"' && str[0] !== "'")
    return false;
  if (str[0] !== str[str.length - 1])
    return false;
  const quoteType = str[0];
  for (let p2 = 1; p2 < str.length; p2++) {
    if (str[p2] === quoteType && (p2 === 1 || str[p2 - 1] !== "\\") && p2 !== str.length - 1) {
      return false;
    }
  }
  return true;
}
function rmEscapes(str) {
  if (!str.length)
    return "";
  let clean2 = "";
  let lastChar = "";
  for (let p2 = 0; p2 < str.length; p2++) {
    const char = str.charAt(p2);
    if (char !== "\\" || lastChar === "\\") {
      clean2 += char;
    }
    lastChar = char;
  }
  return clean2;
}
function nodeProps(...sets) {
  return sets.reduce((valid, props2) => {
    const _a = props2, { value, name, modelValue, config: config2, plugins: plugins2 } = _a, validProps = __objRest(_a, ["value", "name", "modelValue", "config", "plugins"]);
    return Object.assign(valid, validProps);
  }, {});
}
function parseArgs(str) {
  const args = [];
  let arg = "";
  let depth = 0;
  let quote = "";
  let lastChar = "";
  for (let p2 = 0; p2 < str.length; p2++) {
    const char = str.charAt(p2);
    if (char === quote && lastChar !== "\\") {
      quote = "";
    } else if ((char === "'" || char === '"') && !quote && lastChar !== "\\") {
      quote = char;
    } else if (char === "(" && !quote) {
      depth++;
    } else if (char === ")" && !quote) {
      depth--;
    }
    if (char === "," && !quote && depth === 0) {
      args.push(arg);
      arg = "";
    } else if (char !== " " || quote) {
      arg += char;
    }
    lastChar = char;
  }
  if (arg) {
    args.push(arg);
  }
  return args;
}
function except(obj, toRemove) {
  const clean2 = {};
  const exps = toRemove.filter((n) => n instanceof RegExp);
  const keysToRemove = new Set(toRemove);
  for (const key in obj) {
    if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {
      clean2[key] = obj[key];
    }
  }
  return clean2;
}
function only(obj, include) {
  const clean2 = {};
  const exps = include.filter((n) => n instanceof RegExp);
  include.forEach((key) => {
    if (!(key instanceof RegExp)) {
      clean2[key] = obj[key];
    }
  });
  Object.keys(obj).forEach((key) => {
    if (exps.some((exp) => exp.test(key))) {
      clean2[key] = obj[key];
    }
  });
  return clean2;
}
function camel(str) {
  return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());
}
function kebab(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap2) => trail + "-" + cap2.toLowerCase()).replace(" ", "-").toLowerCase();
}
function clone$2(obj, explicit = ["__key", "__init"]) {
  if (obj === null || obj instanceof RegExp || obj instanceof Date || obj instanceof Map || obj instanceof Set || typeof File === "function" && obj instanceof File)
    return obj;
  let returnObject;
  if (Array.isArray(obj)) {
    returnObject = obj.map((value) => {
      if (typeof value === "object")
        return clone$2(value, explicit);
      return value;
    });
  } else {
    returnObject = Object.keys(obj).reduce((newObj, key) => {
      newObj[key] = typeof obj[key] === "object" ? clone$2(obj[key], explicit) : obj[key];
      return newObj;
    }, {});
  }
  for (const key of explicit) {
    if (key in obj) {
      Object.defineProperty(returnObject, key, {
        enumerable: false,
        value: obj[key]
      });
    }
  }
  return returnObject;
}
function cloneAny(obj) {
  return typeof obj === "object" ? clone$2(obj) : obj;
}
function getAt(obj, addr) {
  if (!obj || typeof obj !== "object")
    return null;
  const segments = addr.split(".");
  let o = obj;
  for (const i in segments) {
    const segment = segments[i];
    if (has$3(o, segment)) {
      o = o[segment];
    }
    if (+i === segments.length - 1)
      return o;
    if (!o || typeof o !== "object")
      return null;
  }
  return null;
}
function undefine(value) {
  return value !== void 0 && value !== "false" && value !== false ? true : void 0;
}
function init$3(obj) {
  return !Object.isFrozen(obj) ? Object.defineProperty(obj, "__init", {
    enumerable: false,
    value: true
  }) : obj;
}
function slugify(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, " ").trim().replace(/\s+/g, "-");
}
function createDispatcher$1() {
  const middleware = [];
  let currentIndex = 0;
  const use2 = (dispatchable) => middleware.push(dispatchable);
  const dispatch2 = (payload) => {
    const current = middleware[currentIndex];
    if (typeof current === "function") {
      return current(payload, (explicitPayload) => {
        currentIndex++;
        return dispatch2(explicitPayload === void 0 ? payload : explicitPayload);
      });
    }
    currentIndex = 0;
    return payload;
  };
  use2.dispatch = dispatch2;
  use2.unshift = (dispatchable) => middleware.unshift(dispatchable);
  use2.remove = (dispatchable) => {
    const index2 = middleware.indexOf(dispatchable);
    if (index2 > -1)
      middleware.splice(index2, 1);
  };
  return use2;
}
function createEmitter() {
  const listeners = /* @__PURE__ */ new Map();
  const receipts2 = /* @__PURE__ */ new Map();
  let buffer2 = void 0;
  const emitter = (node, event) => {
    if (buffer2) {
      buffer2.set(event.name, [node, event]);
      return;
    }
    if (listeners.has(event.name)) {
      listeners.get(event.name).forEach((wrapper2) => {
        if (event.origin === node || wrapper2.modifiers.includes("deep")) {
          wrapper2.listener(event);
        }
      });
    }
    if (event.bubble) {
      node.bubble(event);
    }
  };
  emitter.on = (eventName, listener3) => {
    const [event, ...modifiers2] = eventName.split(".");
    const receipt = listener3.receipt || token$2();
    const wrapper2 = {
      modifiers: modifiers2,
      event,
      listener: listener3,
      receipt
    };
    listeners.has(event) ? listeners.get(event).push(wrapper2) : listeners.set(event, [wrapper2]);
    receipts2.has(receipt) ? receipts2.get(receipt).push(event) : receipts2.set(receipt, [event]);
    return receipt;
  };
  emitter.off = (receipt) => {
    var _a;
    if (receipts2.has(receipt)) {
      (_a = receipts2.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {
        const eventListeners2 = listeners.get(event);
        if (Array.isArray(eventListeners2)) {
          listeners.set(event, eventListeners2.filter((wrapper2) => wrapper2.receipt !== receipt));
        }
      });
      receipts2.delete(receipt);
    }
  };
  emitter.pause = (node) => {
    if (!buffer2)
      buffer2 = /* @__PURE__ */ new Map();
    if (node) {
      node.walk((child) => child._e.pause());
    }
  };
  emitter.play = (node) => {
    if (!buffer2)
      return;
    const events2 = buffer2;
    buffer2 = void 0;
    events2.forEach(([node2, event]) => emitter(node2, event));
    if (node) {
      node.walk((child) => child._e.play());
    }
  };
  return emitter;
}
function emit$1(node, context, name, payload, bubble2 = true) {
  context._e(node, {
    payload,
    name,
    bubble: bubble2,
    origin: node
  });
  return node;
}
function bubble(node, _context, event) {
  if (isNode(node.parent)) {
    node.parent._e(node.parent, event);
  }
  return node;
}
function on$1(_node, context, name, listener3) {
  return context._e.on(name, listener3);
}
function off$1(node, context, receipt) {
  context._e.off(receipt);
  return node;
}
const errorHandler = createDispatcher$1();
errorHandler((error2, next) => {
  if (!error2.message)
    error2.message = String(`E${error2.code}`);
  return next(error2);
});
const warningHandler = createDispatcher$1();
warningHandler((warning, next) => {
  if (!warning.message)
    warning.message = String(`W${warning.code}`);
  const result = next(warning);
  if (console && typeof console.warn === "function")
    console.warn(result.message);
  return result;
});
function warn$1(code2, data = {}) {
  warningHandler.dispatch({ code: code2, data });
}
function error$1(code2, data = {}) {
  throw Error(errorHandler.dispatch({ code: code2, data }).message);
}
function createMessage(conf, node) {
  const m = __spreadValues({
    blocking: false,
    key: token$2(),
    meta: {},
    type: "state",
    visible: true
  }, conf);
  if (node && m.value && m.meta.localize !== false) {
    m.value = node.t(m);
    m.meta.locale = node.config.locale;
  }
  return m;
}
const storeTraps = {
  apply: applyMessages,
  set: setMessage,
  remove: removeMessage$1,
  filter: filterMessages,
  reduce: reduceMessages,
  release: releaseBuffer,
  touch: touchMessages
};
function createStore$1(_buffer = false) {
  const messages2 = {};
  let node;
  let buffer2 = _buffer;
  let _b = [];
  const _m = /* @__PURE__ */ new Map();
  let _r = void 0;
  const store2 = new Proxy(messages2, {
    get(...args) {
      const [_target, property2] = args;
      if (property2 === "buffer")
        return buffer2;
      if (property2 === "_b")
        return _b;
      if (property2 === "_m")
        return _m;
      if (property2 === "_r")
        return _r;
      if (has$3(storeTraps, property2)) {
        return storeTraps[property2].bind(null, messages2, store2, node);
      }
      return Reflect.get(...args);
    },
    set(_t, prop2, value) {
      if (prop2 === "_n") {
        node = value;
        if (_r === "__n")
          releaseMissed(node, store2);
        return true;
      } else if (prop2 === "_b") {
        _b = value;
        return true;
      } else if (prop2 === "buffer") {
        buffer2 = value;
        return true;
      } else if (prop2 === "_r") {
        _r = value;
        return true;
      }
      error$1(101, node);
      return false;
    }
  });
  return store2;
}
function setMessage(messageStore, store2, node, message2) {
  if (store2.buffer) {
    store2._b.push([[message2]]);
    return store2;
  }
  if (messageStore[message2.key] !== message2) {
    if (typeof message2.value === "string" && message2.meta.localize !== false) {
      const previous = message2.value;
      message2.value = node.t(message2);
      if (message2.value !== previous) {
        message2.meta.locale = node.props.locale;
      }
    }
    const e = `message-${has$3(messageStore, message2.key) ? "updated" : "added"}`;
    messageStore[message2.key] = Object.freeze(node.hook.message.dispatch(message2));
    node.emit(e, message2);
  }
  return store2;
}
function touchMessages(messageStore, store2) {
  for (const key in messageStore) {
    const message2 = __spreadValues({}, messageStore[key]);
    store2.set(message2);
  }
}
function removeMessage$1(messageStore, store2, node, key) {
  if (has$3(messageStore, key)) {
    const message2 = messageStore[key];
    delete messageStore[key];
    node.emit("message-removed", message2);
  }
  if (store2.buffer === true) {
    store2._b = store2._b.filter((buffered) => {
      buffered[0] = buffered[0].filter((m) => m.key !== key);
      return buffered[1] || buffered[0].length;
    });
  }
  return store2;
}
function filterMessages(messageStore, store2, node, callback, type) {
  for (const key in messageStore) {
    const message2 = messageStore[key];
    if ((!type || message2.type === type) && !callback(message2)) {
      removeMessage$1(messageStore, store2, node, key);
    }
  }
}
function reduceMessages(messageStore, _store, _node, reducer, accumulator) {
  for (const key in messageStore) {
    const message2 = messageStore[key];
    accumulator = reducer(accumulator, message2);
  }
  return accumulator;
}
function applyMessages(_messageStore, store2, node, messages2, clear2) {
  if (Array.isArray(messages2)) {
    if (store2.buffer) {
      store2._b.push([messages2, clear2]);
      return;
    }
    const applied = new Set(messages2.map((message2) => {
      store2.set(message2);
      return message2.key;
    }));
    if (typeof clear2 === "string") {
      store2.filter((message2) => message2.type !== clear2 || applied.has(message2.key));
    } else if (typeof clear2 === "function") {
      store2.filter((message2) => !clear2(message2) || applied.has(message2.key));
    }
  } else {
    for (const address in messages2) {
      const child = node.at(address);
      if (child) {
        child.store.apply(messages2[address], clear2);
      } else {
        missed(node, store2, address, messages2[address], clear2);
      }
    }
  }
}
function createMessages(node, ...errors2) {
  const sourceKey = `${node.name}-set`;
  const make = (error2) => createMessage({
    key: slugify(error2),
    type: "error",
    value: error2,
    meta: { source: sourceKey, autoClear: true }
  });
  return errors2.filter((m) => !!m).map((errorSet) => {
    if (typeof errorSet === "string")
      errorSet = [errorSet];
    if (Array.isArray(errorSet)) {
      return errorSet.map((error2) => make(error2));
    } else {
      const errors3 = {};
      for (const key in errorSet) {
        if (Array.isArray(errorSet[key])) {
          errors3[key] = errorSet[key].map((error2) => make(error2));
        } else {
          errors3[key] = [make(errorSet[key])];
        }
      }
      return errors3;
    }
  });
}
function missed(node, store2, address, messages2, clear2) {
  var _a;
  const misses = store2._m;
  if (!misses.has(address))
    misses.set(address, []);
  if (!store2._r)
    store2._r = releaseMissed(node, store2);
  (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages2, clear2]);
}
function releaseMissed(node, store2) {
  return node.on("child.deep", ({ payload: child }) => {
    store2._m.forEach((misses, address) => {
      if (node.at(address) === child) {
        misses.forEach(([messages2, clear2]) => {
          child.store.apply(messages2, clear2);
        });
        store2._m.delete(address);
      }
    });
    if (store2._m.size === 0 && store2._r) {
      node.off(store2._r);
      store2._r = void 0;
    }
  });
}
function releaseBuffer(_messageStore, store2) {
  store2.buffer = false;
  store2._b.forEach(([messages2, clear2]) => store2.apply(messages2, clear2));
  store2._b = [];
}
function createLedger() {
  const ledger = {};
  let n;
  return {
    count: (...args) => createCounter(n, ledger, ...args),
    init(node) {
      n = node;
      node.on("message-added.deep", add(ledger, 1));
      node.on("message-removed.deep", add(ledger, -1));
    },
    merge: (child) => merge(n, ledger, child),
    settled(counterName) {
      return has$3(ledger, counterName) ? ledger[counterName].promise : Promise.resolve();
    },
    unmerge: (child) => merge(n, ledger, child, true),
    value(counterName) {
      return has$3(ledger, counterName) ? ledger[counterName].count : 0;
    }
  };
}
function createCounter(node, ledger, counterName, condition, increment = 0) {
  condition = parseCondition(condition || counterName);
  if (!has$3(ledger, counterName)) {
    const counter = {
      condition,
      count: 0,
      name: counterName,
      node,
      promise: Promise.resolve(),
      resolve: () => {
      }
    };
    ledger[counterName] = counter;
    increment = node.store.reduce((sum2, m) => sum2 + counter.condition(m) * 1, increment);
    node.each((child) => {
      child.ledger.count(counter.name, counter.condition);
      increment += child.ledger.value(counter.name);
    });
  }
  return count(ledger[counterName], increment).promise;
}
function parseCondition(condition) {
  if (typeof condition === "function") {
    return condition;
  }
  return (m) => m.type === condition;
}
function count(counter, increment) {
  const initial2 = counter.count;
  const post = counter.count + increment;
  counter.count = post;
  if (initial2 === 0 && post !== 0) {
    counter.node.emit(`unsettled:${counter.name}`, counter.count, false);
    counter.promise = new Promise((r) => counter.resolve = r);
  } else if (initial2 !== 0 && post === 0) {
    counter.node.emit(`settled:${counter.name}`, counter.count, false);
    counter.resolve();
  }
  counter.node.emit(`count:${counter.name}`, counter.count, false);
  return counter;
}
function add(ledger, delta2) {
  return (e) => {
    for (const name in ledger) {
      const counter = ledger[name];
      if (counter.condition(e.payload)) {
        count(counter, delta2);
      }
    }
  };
}
function merge(parent, ledger, child, remove2 = false) {
  for (const key in ledger) {
    const condition = ledger[key].condition;
    if (!remove2)
      child.ledger.count(key, condition);
    const increment = child.ledger.value(key) * (remove2 ? -1 : 1);
    if (!parent)
      continue;
    do {
      parent.ledger.count(key, condition, increment);
      parent = parent.parent;
    } while (parent);
  }
}
const registry = /* @__PURE__ */ new Map();
const reflected = /* @__PURE__ */ new Map();
const emit = createEmitter();
const receipts = [];
function register(node) {
  if (node.props.id) {
    registry.set(node.props.id, node);
    reflected.set(node, node.props.id);
    emit(node, {
      payload: node,
      name: node.props.id,
      bubble: false,
      origin: node
    });
  }
}
function deregister(node) {
  if (reflected.has(node)) {
    const id = reflected.get(node);
    reflected.delete(node);
    registry.delete(id);
    emit(node, {
      payload: null,
      name: id,
      bubble: false,
      origin: node
    });
  }
}
function getNode$1(id) {
  return registry.get(id);
}
function watchRegistry(id, callback) {
  receipts.push(emit.on(id, callback));
}
function configChange(node, prop2, value) {
  let usingFallback = true;
  !(prop2 in node.config._t) ? node.emit(`config:${prop2}`, value, false) : usingFallback = false;
  if (!(prop2 in node.props)) {
    node.emit("prop", { prop: prop2, value });
    node.emit(`prop:${prop2}`, value);
  }
  return usingFallback;
}
function createConfig$1(options2 = {}) {
  const nodes = /* @__PURE__ */ new Set();
  const target2 = __spreadValues(__spreadValues({}, options2), {
    _add: (node) => nodes.add(node),
    _rm: (node) => node.remove(node)
  });
  const rootConfig = new Proxy(target2, {
    set(t2, prop2, value, r) {
      if (typeof prop2 === "string") {
        nodes.forEach((node) => configChange(node, prop2, value));
      }
      return Reflect.set(t2, prop2, value, r);
    }
  });
  return rootConfig;
}
function submitForm(id) {
  const formElement = document.getElementById(id);
  if (formElement instanceof HTMLFormElement) {
    const event = new Event("submit", { cancelable: true, bubbles: true });
    formElement.dispatchEvent(event);
    return;
  }
  warn$1(151, id);
}
function clearState(node) {
  const clear2 = (n) => {
    for (const key in n.store) {
      const message2 = n.store[key];
      if (message2.type === "error" || message2.type === "ui" && key === "incomplete") {
        n.store.remove(key);
      } else if (message2.type === "state") {
        n.store.set(__spreadProps(__spreadValues({}, message2), { value: false }));
      }
    }
  };
  clear2(node);
  node.walk(clear2);
}
function reset(id, resetTo) {
  const node = typeof id === "string" ? getNode$1(id) : id;
  if (node) {
    const initial2 = (n) => cloneAny(n.props.initial) || (n.type === "group" ? {} : n.type === "list" ? [] : void 0);
    node._e.pause(node);
    node.input(cloneAny(resetTo) || initial2(node), false);
    node.walk((child) => child.input(initial2(child), false));
    const finalInit = initial2(node);
    node.input(typeof finalInit === "object" ? cloneAny(resetTo) || init$3(finalInit) : finalInit, false);
    node._e.play(node);
    clearState(node);
    node.emit("reset", node);
    return node;
  }
  warn$1(152, id);
  return;
}
const defaultConfig$1 = {
  delimiter: ".",
  delay: 0,
  locale: "en",
  rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true })
};
const useIndex = Symbol("index");
const valueRemoved = Symbol("removed");
const valueMoved = Symbol("moved");
const valueInserted = Symbol("inserted");
function isList$1(arg) {
  return arg.type === "list" && Array.isArray(arg._value);
}
function isNode(node) {
  return node && typeof node === "object" && node.__FKNode__ === true;
}
const invalidSetter = (node, _context, property2) => {
  error$1(102, [node, property2]);
};
const traps = {
  _c: trap(getContext, invalidSetter, false),
  add: trap(addChild),
  addProps: trap(addProps),
  address: trap(getAddress, invalidSetter, false),
  at: trap(getNode),
  bubble: trap(bubble),
  clearErrors: trap(clearErrors$1),
  calm: trap(calm),
  config: trap(false),
  define: trap(define),
  disturb: trap(disturb),
  destroy: trap(destroy),
  hydrate: trap(hydrate),
  index: trap(getIndex, setIndex, false),
  input: trap(input),
  each: trap(eachChild),
  emit: trap(emit$1),
  find: trap(find$4),
  on: trap(on$1),
  off: trap(off$1),
  parent: trap(false, setParent),
  plugins: trap(false),
  remove: trap(removeChild),
  root: trap(getRoot, invalidSetter, false),
  reset: trap(resetValue),
  resetConfig: trap(resetConfig),
  setErrors: trap(setErrors$1),
  submit: trap(submit$2),
  t: trap(text$4),
  use: trap(use),
  name: trap(getName, false, false),
  walk: trap(walkTree)
};
function createTraps() {
  return new Map(Object.entries(traps));
}
function trap(getter, setter, curryGetter = true) {
  return {
    get: getter ? (node, context) => curryGetter ? (...args) => getter(node, context, ...args) : getter(node, context) : false,
    set: setter !== void 0 ? setter : invalidSetter.bind(null)
  };
}
function createHooks() {
  const hooks8 = /* @__PURE__ */ new Map();
  return new Proxy(hooks8, {
    get(_2, property2) {
      if (!hooks8.has(property2)) {
        hooks8.set(property2, createDispatcher$1());
      }
      return hooks8.get(property2);
    }
  });
}
let nameCount = 0;
let idCount = 0;
function createName(options2) {
  var _a, _b;
  if (((_a = options2.parent) === null || _a === void 0 ? void 0 : _a.type) === "list")
    return useIndex;
  return options2.name || `${((_b = options2.props) === null || _b === void 0 ? void 0 : _b.type) || "input"}_${++nameCount}`;
}
function createValue(options2) {
  if (options2.type === "group") {
    return init$3(options2.value && typeof options2.value === "object" && !Array.isArray(options2.value) ? options2.value : {});
  } else if (options2.type === "list") {
    return init$3(Array.isArray(options2.value) ? options2.value : []);
  }
  return options2.value === null ? "" : options2.value;
}
function input(node, context, value, async = true) {
  context._value = validateInput(node, node.hook.input.dispatch(value));
  node.emit("input", context._value);
  if (context.isSettled)
    node.disturb();
  if (async) {
    if (context._tmo)
      clearTimeout(context._tmo);
    context._tmo = setTimeout(commit, node.props.delay, node, context);
  } else {
    commit(node, context);
  }
  return context.settled;
}
function validateInput(node, value) {
  switch (node.type) {
    case "input":
      break;
    case "group":
      if (!value || typeof value !== "object")
        error$1(107, [node, value]);
      break;
    case "list":
      if (!Array.isArray(value))
        error$1(108, [node, value]);
      break;
  }
  return value;
}
function commit(node, context, calm2 = true, hydrate2 = true) {
  context._value = context.value = node.hook.commit.dispatch(context._value);
  if (node.type !== "input" && hydrate2)
    node.hydrate();
  node.emit("commit", context.value);
  if (calm2)
    node.calm();
}
function partial$1(context, { name, value, from: from2 }) {
  if (Object.isFrozen(context._value))
    return;
  if (isList$1(context)) {
    const insert = value === valueRemoved ? [] : value === valueMoved && typeof from2 === "number" ? context._value.splice(from2, 1) : [value];
    context._value.splice(name, value === valueMoved || from2 === valueInserted ? 0 : 1, ...insert);
    return;
  }
  if (value !== valueRemoved) {
    context._value[name] = value;
  } else {
    delete context._value[name];
  }
}
function hydrate(node, context) {
  const _value = context._value;
  context.children.forEach((child) => {
    if (typeof _value !== "object")
      return;
    if (child.name in _value) {
      const childValue = child.type !== "input" || _value[child.name] && typeof _value[child.name] === "object" ? init$3(_value[child.name]) : _value[child.name];
      child.input(childValue, false);
    } else {
      if (node.type !== "list" || typeof child.name === "number") {
        partial$1(context, { name: child.name, value: child.value });
      }
      if (!_value.__init) {
        if (child.type === "group")
          child.input({}, false);
        else if (child.type === "list")
          child.input([], false);
        else
          child.input(void 0, false);
      }
    }
  });
  return node;
}
function disturb(node, context) {
  var _a;
  if (context._d <= 0) {
    context.isSettled = false;
    node.emit("settled", false, false);
    context.settled = new Promise((resolve2) => {
      context._resolve = resolve2;
    });
    if (node.parent)
      (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();
  }
  context._d++;
  return node;
}
function calm(node, context, value) {
  var _a;
  if (value !== void 0 && node.type !== "input") {
    partial$1(context, value);
    return commit(node, context, true, false);
  }
  if (context._d > 0)
    context._d--;
  if (context._d === 0) {
    context.isSettled = true;
    node.emit("settled", true, false);
    if (node.parent)
      (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });
    if (context._resolve)
      context._resolve(context.value);
  }
}
function destroy(node, context) {
  node.emit("destroying", node);
  node.store.filter(() => false);
  if (node.parent) {
    node.parent.remove(node);
  }
  deregister(node);
  context._value = context.value = void 0;
  node.emit("destroyed", node);
}
function define(node, context, definition) {
  context.type = definition.type;
  context.props.definition = clone$2(definition);
  context.value = context._value = createValue({
    type: node.type,
    value: context.value
  });
  if (definition.features) {
    definition.features.forEach((feature) => feature(node));
  }
  if (definition.props) {
    node.addProps(definition.props);
  }
  node.emit("defined", definition);
}
function addProps(node, context, props2) {
  var _a;
  if (node.props.attrs) {
    const attrs = __spreadValues({}, node.props.attrs);
    node.props._emit = false;
    for (const attr in attrs) {
      const camelName = camel(attr);
      if (props2.includes(camelName)) {
        node.props[camelName] = attrs[attr];
        delete attrs[attr];
      }
    }
    const initial2 = cloneAny(context._value);
    node.props.initial = node.type !== "input" ? init$3(initial2) : initial2;
    node.props._emit = true;
    node.props.attrs = attrs;
    if (node.props.definition) {
      node.props.definition.props = [
        ...((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || [],
        ...props2
      ];
    }
  }
  node.emit("added-props", props2);
  return node;
}
function addChild(parent, parentContext, child, listIndex) {
  if (parent.type === "input")
    error$1(100, parent);
  if (child.parent && child.parent !== parent) {
    child.parent.remove(child);
  }
  if (!parentContext.children.includes(child)) {
    if (listIndex !== void 0 && parent.type === "list") {
      parentContext.children.splice(listIndex, 0, child);
      if (Array.isArray(parent.value) && parent.value.length < parentContext.children.length) {
        parent.disturb().calm({
          name: listIndex,
          value: child.value,
          from: valueInserted
        });
      }
    } else {
      parentContext.children.push(child);
    }
    if (!child.isSettled)
      parent.disturb();
  }
  if (child.parent !== parent) {
    child.parent = parent;
    if (child.parent !== parent) {
      parent.remove(child);
      child.parent.add(child);
      return parent;
    }
  } else {
    child.use(parent.plugins);
  }
  commit(parent, parentContext, false);
  parent.ledger.merge(child);
  parent.emit("child", child);
  return parent;
}
function setParent(child, context, _property, parent) {
  if (isNode(parent)) {
    if (child.parent && child.parent !== parent) {
      child.parent.remove(child);
    }
    context.parent = parent;
    child.resetConfig();
    !parent.children.includes(child) ? parent.add(child) : child.use(parent.plugins);
    return true;
  }
  if (parent === null) {
    context.parent = null;
    return true;
  }
  return false;
}
function removeChild(node, context, child) {
  const childIndex = context.children.indexOf(child);
  if (childIndex !== -1) {
    if (child.isSettled)
      node.disturb();
    context.children.splice(childIndex, 1);
    let preserve = undefine(child.props.preserve);
    let parent = child.parent;
    while (preserve === void 0 && parent) {
      preserve = undefine(parent.props.preserve);
      parent = parent.parent;
    }
    if (!preserve) {
      node.calm({
        name: node.type === "list" ? childIndex : child.name,
        value: valueRemoved
      });
    } else {
      node.calm();
    }
    child.parent = null;
    child.config._rmn = child;
  }
  node.ledger.unmerge(child);
  return node;
}
function eachChild(_node, context, callback) {
  context.children.forEach((child) => callback(child));
}
function walkTree(_node, context, callback, stopIfFalse = false) {
  context.children.forEach((child) => {
    if (callback(child) !== false || !stopIfFalse) {
      child.walk(callback);
    }
  });
}
function resetConfig(node, context) {
  const parent = node.parent || void 0;
  context.config = createConfig(node.config._t, parent);
  node.walk((n) => n.resetConfig());
}
function use(node, context, plugin2, run2 = true, library2 = true) {
  if (Array.isArray(plugin2) || plugin2 instanceof Set) {
    plugin2.forEach((p2) => use(node, context, p2));
    return node;
  }
  if (!context.plugins.has(plugin2)) {
    if (library2 && typeof plugin2.library === "function")
      plugin2.library(node);
    if (run2 && plugin2(node) !== false) {
      context.plugins.add(plugin2);
      node.children.forEach((child) => child.use(plugin2));
    }
  }
  return node;
}
function setIndex(node, _context, _property, setIndex2) {
  if (isNode(node.parent)) {
    const children = node.parent.children;
    const index2 = setIndex2 >= children.length ? children.length - 1 : setIndex2 < 0 ? 0 : setIndex2;
    const oldIndex2 = children.indexOf(node);
    if (oldIndex2 === -1)
      return false;
    children.splice(oldIndex2, 1);
    children.splice(index2, 0, node);
    node.parent.children = children;
    if (node.parent.type === "list")
      node.parent.disturb().calm({ name: index2, value: valueMoved, from: oldIndex2 });
    return true;
  }
  return false;
}
function getIndex(node) {
  if (node.parent) {
    const index2 = [...node.parent.children].indexOf(node);
    return index2 === -1 ? node.parent.children.length : index2;
  }
  return -1;
}
function getContext(_node, context) {
  return context;
}
function getName(node, context) {
  var _a;
  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "list")
    return node.index;
  return context.name !== useIndex ? context.name : node.index;
}
function getAddress(node, context) {
  return context.parent ? context.parent.address.concat([node.name]) : [node.name];
}
function getNode(node, _context, locator) {
  const address = typeof locator === "string" ? locator.split(node.config.delimiter) : locator;
  if (!address.length)
    return void 0;
  const first2 = address[0];
  let pointer = node.parent;
  if (!pointer) {
    if (String(address[0]) === String(node.name))
      address.shift();
    pointer = node;
  }
  if (first2 === "$parent")
    address.shift();
  while (pointer && address.length) {
    const name = address.shift();
    switch (name) {
      case "$root":
        pointer = node.root;
        break;
      case "$parent":
        pointer = pointer.parent;
        break;
      case "$self":
        pointer = node;
        break;
      default:
        pointer = pointer.children.find((c) => String(c.name) === String(name)) || select$4(pointer, name);
    }
  }
  return pointer || void 0;
}
function select$4(node, selector) {
  const matches3 = String(selector).match(/^(find)\((.*)\)$/);
  if (matches3) {
    const [, action, argStr] = matches3;
    const args = argStr.split(",").map((arg) => arg.trim());
    switch (action) {
      case "find":
        return node.find(args[0], args[1]);
      default:
        return void 0;
    }
  }
  return void 0;
}
function find$4(node, _context, searchTerm, searcher) {
  return bfs(node, searchTerm, searcher);
}
function bfs(tree, searchValue, searchGoal = "name") {
  const search2 = typeof searchGoal === "string" ? (n) => n[searchGoal] == searchValue : searchGoal;
  const stack2 = [tree];
  while (stack2.length) {
    const node = stack2.shift();
    if (search2(node, searchValue))
      return node;
    stack2.push(...node.children);
  }
  return void 0;
}
function getRoot(n) {
  let node = n;
  while (node.parent) {
    node = node.parent;
  }
  return node;
}
function createConfig(target2 = {}, parent) {
  let node = void 0;
  return new Proxy(target2, {
    get(...args) {
      const prop2 = args[1];
      if (prop2 === "_t")
        return target2;
      const localValue = Reflect.get(...args);
      if (localValue !== void 0)
        return localValue;
      if (parent) {
        const parentVal = parent.config[prop2];
        if (parentVal !== void 0)
          return parentVal;
      }
      if (target2.rootConfig && typeof prop2 === "string") {
        const rootValue = target2.rootConfig[prop2];
        if (rootValue !== void 0)
          return rootValue;
      }
      if (prop2 === "delay" && (node === null || node === void 0 ? void 0 : node.type) === "input")
        return 20;
      return defaultConfig$1[prop2];
    },
    set(...args) {
      const prop2 = args[1];
      const value = args[2];
      if (prop2 === "_n") {
        node = value;
        if (target2.rootConfig)
          target2.rootConfig._add(node);
        return true;
      }
      if (prop2 === "_rmn") {
        if (target2.rootConfig)
          target2.rootConfig._rm(node);
        node = void 0;
        return true;
      }
      if (!eq$1(target2[prop2], value, false)) {
        const didSet = Reflect.set(...args);
        if (node) {
          node.emit(`config:${prop2}`, value, false);
          configChange(node, prop2, value);
          node.walk((n) => configChange(n, prop2, value), true);
        }
        return didSet;
      }
      return true;
    }
  });
}
function text$4(node, _context, key, type = "ui") {
  const fragment2 = typeof key === "string" ? { key, value: key, type } : key;
  const value = node.hook.text.dispatch(fragment2);
  node.emit("text", value, false);
  return value.value;
}
function submit$2(node) {
  const name = node.name;
  do {
    if (node.props.isForm === true)
      break;
    if (!node.parent)
      error$1(106, name);
    node = node.parent;
  } while (node);
  if (node.props.id) {
    submitForm(node.props.id);
  }
}
function resetValue(node, _context, value) {
  return reset(node, value);
}
function setErrors$1(node, _context, localErrors, childErrors) {
  const sourceKey = `${node.name}-set`;
  createMessages(node, localErrors, childErrors).forEach((errors2) => {
    node.store.apply(errors2, (message2) => message2.meta.source === sourceKey);
  });
  return node;
}
function clearErrors$1(node, context, clearChildErrors = true) {
  setErrors$1(node, context, []);
  if (clearChildErrors) {
    const sourceKey = `${node.name}-set`;
    node.walk((child) => {
      child.store.filter((message2) => {
        return !(message2.type === "error" && message2.meta && message2.meta.source === sourceKey);
      });
    });
  }
  return node;
}
function defaultProps$1(node) {
  if (!has$3(node.props, "id"))
    node.props.id = `input_${idCount++}`;
  return node;
}
function createProps(initial2) {
  const props2 = {
    initial: typeof initial2 === "object" ? cloneAny(initial2) : initial2
  };
  let node;
  let isEmitting = true;
  return new Proxy(props2, {
    get(...args) {
      const [_t, prop2] = args;
      if (has$3(props2, prop2))
        return Reflect.get(...args);
      if (node && typeof prop2 === "string" && node.config[prop2] !== void 0)
        return node.config[prop2];
      return void 0;
    },
    set(target2, property2, originalValue, receiver) {
      if (property2 === "_n") {
        node = originalValue;
        return true;
      }
      if (property2 === "_emit") {
        isEmitting = originalValue;
        return true;
      }
      const { prop: prop2, value } = node.hook.prop.dispatch({
        prop: property2,
        value: originalValue
      });
      if (!eq$1(props2[prop2], value, false) || typeof value === "object") {
        const didSet = Reflect.set(target2, prop2, value, receiver);
        if (isEmitting) {
          node.emit("prop", { prop: prop2, value });
          if (typeof prop2 === "string")
            node.emit(`prop:${prop2}`, value);
        }
        return didSet;
      }
      return true;
    }
  });
}
function findDefinition(node, plugins2) {
  if (node.props.definition)
    return node.define(node.props.definition);
  for (const plugin2 of plugins2) {
    if (node.props.definition)
      return;
    if (typeof plugin2.library === "function") {
      plugin2.library(node);
    }
  }
}
function createContext(options2) {
  const value = createValue(options2);
  const config2 = createConfig(options2.config || {}, options2.parent);
  return {
    _d: 0,
    _e: createEmitter(),
    _resolve: false,
    _tmo: false,
    _value: value,
    children: dedupe(options2.children || []),
    config: config2,
    hook: createHooks(),
    isCreated: false,
    isSettled: true,
    ledger: createLedger(),
    name: createName(options2),
    parent: options2.parent || null,
    plugins: /* @__PURE__ */ new Set(),
    props: createProps(value),
    settled: Promise.resolve(value),
    store: createStore$1(true),
    traps: createTraps(),
    type: options2.type || "input",
    value
  };
}
function nodeInit(node, options2) {
  var _a;
  node.ledger.init(node.store._n = node.props._n = node.config._n = node);
  node.props._emit = false;
  if (options2.props)
    Object.assign(node.props, options2.props);
  node.props._emit = true;
  findDefinition(node, /* @__PURE__ */ new Set([
    ...options2.plugins || [],
    ...node.parent ? node.parent.plugins : []
  ]));
  if (options2.plugins) {
    for (const plugin2 of options2.plugins) {
      use(node, node._c, plugin2, true, false);
    }
  }
  defaultProps$1(node);
  node.each((child) => node.add(child));
  if (node.parent)
    node.parent.add(node, options2.index);
  if (node.type === "input" && node.children.length)
    error$1(100, node);
  input(node, node._c, node._value, false);
  node.store.release();
  if ((_a = options2.props) === null || _a === void 0 ? void 0 : _a.id)
    register(node);
  node.emit("created", node);
  node.isCreated = true;
  return node;
}
function createNode(options2) {
  const ops = options2 || {};
  const context = createContext(ops);
  const node = new Proxy(context, {
    get(...args) {
      const [, property2] = args;
      if (property2 === "__FKNode__")
        return true;
      const trap2 = context.traps.get(property2);
      if (trap2 && trap2.get)
        return trap2.get(node, context);
      return Reflect.get(...args);
    },
    set(...args) {
      const [, property2, value] = args;
      const trap2 = context.traps.get(property2);
      if (trap2 && trap2.set)
        return trap2.set(node, context, property2, value);
      return Reflect.set(...args);
    }
  });
  return nodeInit(node, ops);
}
function isDOM(node) {
  return typeof node !== "string" && has$3(node, "$el");
}
function isComponent$1(node) {
  return typeof node !== "string" && has$3(node, "$cmp");
}
function isConditional(node) {
  if (!node || typeof node === "string")
    return false;
  return has$3(node, "if") && has$3(node, "then");
}
function isSugar(node) {
  return typeof node !== "string" && "$formkit" in node;
}
function sugar(node) {
  if (typeof node === "string") {
    return {
      $el: "text",
      children: node
    };
  }
  if (isSugar(node)) {
    const _a = node, { $formkit: type, for: iterator, if: condition, children, bind: bind2 } = _a, props2 = __objRest(_a, ["$formkit", "for", "if", "children", "bind"]);
    return Object.assign({
      $cmp: "FormKit",
      props: __spreadProps(__spreadValues({}, props2), { type })
    }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, bind2 ? { bind: bind2 } : {});
  }
  return node;
}
function compile$1(expr) {
  let provideTokens;
  const requirements = /* @__PURE__ */ new Set();
  const x = function expand(operand, tokens) {
    return typeof operand === "function" ? operand(tokens) : operand;
  };
  const operatorRegistry = [
    {
      "&&": (l, r, t2) => x(l, t2) && x(r, t2),
      "||": (l, r, t2) => x(l, t2) || x(r, t2)
    },
    {
      "===": (l, r, t2) => !!(x(l, t2) === x(r, t2)),
      "!==": (l, r, t2) => !!(x(l, t2) !== x(r, t2)),
      "==": (l, r, t2) => !!(x(l, t2) == x(r, t2)),
      "!=": (l, r, t2) => !!(x(l, t2) != x(r, t2)),
      ">=": (l, r, t2) => !!(x(l, t2) >= x(r, t2)),
      "<=": (l, r, t2) => !!(x(l, t2) <= x(r, t2)),
      ">": (l, r, t2) => !!(x(l, t2) > x(r, t2)),
      "<": (l, r, t2) => !!(x(l, t2) < x(r, t2))
    },
    {
      "+": (l, r, t2) => x(l, t2) + x(r, t2),
      "-": (l, r, t2) => x(l, t2) - x(r, t2)
    },
    {
      "*": (l, r, t2) => x(l, t2) * x(r, t2),
      "/": (l, r, t2) => x(l, t2) / x(r, t2),
      "%": (l, r, t2) => x(l, t2) % x(r, t2)
    }
  ];
  const operatorSymbols = operatorRegistry.reduce((s, g) => {
    return s.concat(Object.keys(g));
  }, []);
  const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));
  function getOp(symbols, char, p2, expression) {
    const candidates = symbols.filter((s) => s.startsWith(char));
    if (!candidates.length)
      return false;
    return candidates.find((symbol) => {
      if (expression.length >= p2 + symbol.length) {
        const nextChars = expression.substring(p2, p2 + symbol.length);
        if (nextChars === symbol)
          return symbol;
      }
      return false;
    });
  }
  function getStep(p2, expression, direction = 1) {
    let next = direction ? expression.substring(p2 + 1).trim() : expression.substring(0, p2).trim();
    if (!next.length)
      return -1;
    if (!direction) {
      const reversed = next.split("").reverse();
      const start2 = reversed.findIndex((char2) => operatorChars.has(char2));
      next = reversed.slice(start2).join("");
    }
    const char = next[0];
    return operatorRegistry.findIndex((operators) => {
      const symbols = Object.keys(operators);
      return !!getOp(symbols, char, 0, next);
    });
  }
  function getTail(pos, expression) {
    let tail = "";
    const length3 = expression.length;
    let depth = 0;
    for (let p2 = pos; p2 < length3; p2++) {
      const char = expression.charAt(p2);
      if (char === "(") {
        depth++;
      } else if (char === ")") {
        depth--;
      } else if (depth === 0 && char === " ") {
        continue;
      }
      if (depth === 0 && getOp(operatorSymbols, char, p2, expression)) {
        return [tail, p2 - 1];
      } else {
        tail += char;
      }
    }
    return [tail, expression.length - 1];
  }
  function parseLogicals(expression, step = 0) {
    const operators = operatorRegistry[step];
    const length3 = expression.length;
    const symbols = Object.keys(operators);
    let depth = 0;
    let quote = false;
    let op = null;
    let operand = "";
    let left2 = null;
    let operation;
    let lastChar = "";
    let char = "";
    let parenthetical = "";
    let parenQuote = "";
    let startP = 0;
    const addTo = (depth2, char2) => {
      depth2 ? parenthetical += char2 : operand += char2;
    };
    for (let p2 = 0; p2 < length3; p2++) {
      lastChar = char;
      char = expression.charAt(p2);
      if ((char === "'" || char === '"') && lastChar !== "\\" && (depth === 0 && !quote || depth && !parenQuote)) {
        if (depth) {
          parenQuote = char;
        } else {
          quote = char;
        }
        addTo(depth, char);
        continue;
      } else if (quote && (char !== quote || lastChar === "\\") || parenQuote && (char !== parenQuote || lastChar === "\\")) {
        addTo(depth, char);
        continue;
      } else if (quote === char) {
        quote = false;
        addTo(depth, char);
        continue;
      } else if (parenQuote === char) {
        parenQuote = false;
        addTo(depth, char);
        continue;
      } else if (char === " ") {
        continue;
      } else if (char === "(") {
        if (depth === 0) {
          startP = p2;
        } else {
          parenthetical += char;
        }
        depth++;
      } else if (char === ")") {
        depth--;
        if (depth === 0) {
          const fn2 = typeof operand === "string" && operand.startsWith("$") ? operand : void 0;
          const hasTail = fn2 && expression.charAt(p2 + 1) === ".";
          let tail = "";
          if (hasTail) {
            [tail, p2] = getTail(p2 + 2, expression);
          }
          const lStep = op ? step : getStep(startP, expression, 0);
          const rStep = getStep(p2, expression);
          if (lStep === -1 && rStep === -1) {
            operand = evaluate(parenthetical, -1, fn2, tail);
          } else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {
            left2 = op.bind(null, evaluate(parenthetical, -1, fn2, tail));
            op = null;
            operand = "";
          } else if (rStep > lStep && step === rStep) {
            operand = evaluate(parenthetical, -1, fn2, tail);
          } else {
            operand += `(${parenthetical})${hasTail ? `.${tail}` : ""}`;
          }
          parenthetical = "";
        } else {
          parenthetical += char;
        }
      } else if (depth === 0 && (operation = getOp(symbols, char, p2, expression))) {
        if (p2 === 0) {
          error$1(103, [operation, expression]);
        }
        p2 += operation.length - 1;
        if (p2 === expression.length - 1) {
          error$1(104, [operation, expression]);
        }
        if (!op) {
          if (left2) {
            op = operators[operation].bind(null, evaluate(left2, step));
            left2 = null;
          } else {
            op = operators[operation].bind(null, evaluate(operand, step));
            operand = "";
          }
        } else if (operand) {
          left2 = op.bind(null, evaluate(operand, step));
          op = operators[operation].bind(null, left2);
          operand = "";
        }
        continue;
      } else {
        addTo(depth, char);
      }
    }
    if (operand && op) {
      op = op.bind(null, evaluate(operand, step));
    }
    op = !op && left2 ? left2 : op;
    if (!op && operand) {
      op = (v, t2) => {
        return typeof v === "function" ? v(t2) : v;
      };
      op = op.bind(null, evaluate(operand, step));
    }
    if (!op && !operand) {
      error$1(105, expression);
    }
    return op;
  }
  function evaluate(operand, step, fnToken, tail) {
    if (fnToken) {
      const fn2 = evaluate(fnToken, operatorRegistry.length);
      let userFuncReturn;
      let tailCall = tail ? compile$1(`$${tail}`) : false;
      if (typeof fn2 === "function") {
        const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));
        return (tokens) => {
          const userFunc = fn2(tokens);
          if (typeof userFunc !== "function") {
            warn$1(150, fnToken);
            return userFunc;
          }
          userFuncReturn = userFunc(...args.map((arg) => typeof arg === "function" ? arg(tokens) : arg));
          if (tailCall) {
            tailCall = tailCall.provide((subTokens) => {
              const rootTokens = provideTokens(subTokens);
              const t2 = subTokens.reduce((tokenSet, token2) => {
                const isTail = token2 === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token2}(`));
                if (isTail) {
                  const value = getAt(userFuncReturn, token2);
                  tokenSet[token2] = () => value;
                } else {
                  tokenSet[token2] = rootTokens[token2];
                }
                return tokenSet;
              }, {});
              return t2;
            });
          }
          return tailCall ? tailCall() : userFuncReturn;
        };
      }
    } else if (typeof operand === "string") {
      if (operand === "true")
        return true;
      if (operand === "false")
        return false;
      if (operand === "undefined")
        return void 0;
      if (isQuotedString(operand))
        return rmEscapes(operand.substring(1, operand.length - 1));
      if (!isNaN(+operand))
        return Number(operand);
      if (step < operatorRegistry.length - 1) {
        return parseLogicals(operand, step + 1);
      } else {
        if (operand.startsWith("$")) {
          const cleaned = operand.substring(1);
          requirements.add(cleaned);
          return function getToken(tokens) {
            return cleaned in tokens ? tokens[cleaned]() : void 0;
          };
        }
        return operand;
      }
    }
    return operand;
  }
  const compiled = parseLogicals(expr.startsWith("$:") ? expr.substring(2) : expr);
  const reqs = Array.from(requirements);
  function provide2(callback) {
    provideTokens = callback;
    return Object.assign(compiled.bind(null, callback(reqs)), {
      provide: provide2
    });
  }
  return Object.assign(compiled, {
    provide: provide2
  });
}
function createClasses(propertyKey, node, sectionClassList) {
  if (!sectionClassList)
    return {};
  if (typeof sectionClassList === "string") {
    const classKeys = sectionClassList.split(" ");
    return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});
  } else if (typeof sectionClassList === "function") {
    return createClasses(propertyKey, node, sectionClassList(node, propertyKey));
  }
  return sectionClassList;
}
function generateClassList(node, property2, ...args) {
  const combinedClassList = args.reduce((finalClassList, currentClassList) => {
    if (!currentClassList)
      return finalClassList;
    const _a = currentClassList, { $reset } = _a, classList2 = __objRest(_a, ["$reset"]);
    if ($reset) {
      return classList2;
    }
    return Object.assign(finalClassList, classList2);
  }, {});
  return Object.keys(node.hook.classes.dispatch({ property: property2, classes: combinedClassList }).classes).filter((key) => combinedClassList[key]).join(" ") || null;
}
function setErrors(id, localErrors, childErrors) {
  const node = getNode$1(id);
  if (node) {
    node.setErrors(localErrors, childErrors);
  } else {
    warn$1(651, id);
  }
}
function clearErrors(id, clearChildren = true) {
  const node = getNode$1(id);
  if (node) {
    node.clearErrors(clearChildren);
  } else {
    warn$1(652, id);
  }
}
const outer = composable("outer", () => ({
  $el: "div",
  attrs: {
    class: "$classes.outer",
    "data-type": "$type",
    "data-multiple": "$attrs.multiple",
    "data-disabled": "$disabled || undefined",
    "data-complete": "$state.complete || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined"
  }
}));
const wrapper$2 = composable("wrapper", () => ({
  $el: "div",
  attrs: {
    class: "$classes.wrapper"
  }
}));
const inner = composable("inner", () => ({
  $el: "div",
  attrs: {
    class: "$classes.inner"
  }
}));
const help = (schema = {}, children = [], target2 = "help", cond = "$help") => ({
  if: `$slots.${target2}`,
  then: `$slots.${target2}`,
  else: extend$1({
    $el: "div",
    attrs: {
      id: `$: "help-" + ${target2 == "optionHelp" ? "$option.attrs.id" : "$id"}`,
      class: `$classes.${target2}`
    },
    if: cond,
    children
  }, schema)
});
const messages = composable("messages", () => ({
  $el: "ul",
  if: "$fns.length($messages)",
  attrs: {
    class: "$classes.messages",
    "aria-live": '$type === "form" && "assertive" || "polite"'
  }
}));
const message = composable("message", () => ({
  $el: "li",
  for: ["message", "$messages"],
  attrs: {
    key: "$message.key",
    class: "$classes.message",
    id: `$id + '-' + $message.key`,
    "data-message-type": "$message.type"
  }
}));
const prefix$1 = composable("prefix", () => ({ $el: null }));
const suffix$1 = composable("suffix", () => ({ $el: null }));
function isSchemaObject(schema) {
  return typeof schema === "object" && ("$el" in schema || "$cmp" in schema || "$formkit" in schema);
}
function extendSchema(schema, extension = {}) {
  if (typeof schema === "string") {
    return isSchemaObject(extension) || typeof extension === "string" ? extension : schema;
  } else if (Array.isArray(schema)) {
    return isSchemaObject(extension) ? extension : schema;
  }
  return extend$1(schema, extension);
}
function composable(key, schema) {
  return (extendWith2 = {}, children = void 0) => {
    const root2 = typeof schema === "function" ? schema(children) : typeof schema === "object" ? clone$2(schema) : schema;
    const isObj = isSchemaObject(root2);
    if (isObj && !("children" in root2) && children) {
      if (Array.isArray(children)) {
        if (children.length) {
          root2.children = children;
        }
      } else {
        root2.children = [children];
      }
    }
    const extended = extendSchema(root2, extendWith2);
    return {
      if: `$slots.${key}`,
      then: `$slots.${key}`,
      else: Array.isArray(extended) ? extended : [extended]
    };
  };
}
function useSchema(inputSchema) {
  return (extensions2 = {}) => {
    const input2 = composable("input", inputSchema)(extensions2.input);
    return [
      outer(extensions2.outer, [
        wrapper$2(extensions2.wrapper, [
          label(extensions2.label, "$label"),
          inner(extensions2.inner, [
            prefix$1(extensions2.prefix),
            ...Array.isArray(input2) ? input2 : [input2],
            suffix$1(extensions2.suffix)
          ])
        ]),
        help(extensions2.help, "$help"),
        messages(extensions2.messages, [
          message(extensions2.message, "$message.value")
        ])
      ])
    ];
  };
}
const label = composable("label", () => ({
  $el: "label",
  if: "$label",
  attrs: {
    for: "$id",
    class: "$classes.label"
  }
}));
const text$1$1 = composable("input", () => ({
  $el: "input",
  bind: "$attrs",
  attrs: {
    type: "$type",
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    onInput: "$handlers.DOMInput",
    onBlur: "$handlers.blur",
    value: "$_value",
    id: "$id",
    "aria-describedby": "$describedBy"
  }
}));
const textSchema$1 = (extensions2 = {}) => [
  outer(extensions2.outer, [
    wrapper$2(extensions2.wrapper, [
      label(extensions2.label, "$label"),
      inner(extensions2.inner, [
        prefix$1(extensions2.prefix),
        text$1$1(extensions2.input),
        suffix$1(extensions2.suffix)
      ])
    ]),
    help(extensions2.help, "$help"),
    messages(extensions2.messages, [
      message(extensions2.message, "$message.value")
    ])
  ])
];
const file$1 = composable("input", () => ({
  $el: "input",
  bind: "$attrs",
  attrs: {
    type: "file",
    foo: "bar",
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    onChange: "$handlers.files",
    onBlur: "$handlers.blur",
    id: "$id",
    "aria-describedby": "$describedBy"
  }
}));
const fileList = composable("fileList", () => ({
  $el: "ul",
  if: "$value.length",
  attrs: {
    class: "$classes.fileList",
    "data-has-multiple": {
      if: "$value.length > 1",
      then: "true"
    }
  }
}));
const fileItem = composable("fileItem", () => ({
  $el: "li",
  for: ["file", "$value"],
  attrs: {
    class: "$classes.fileItem"
  }
}));
const fileName = composable("fileName", () => ({
  $el: "span",
  attrs: {
    class: "$classes.fileName"
  }
}));
const noFiles = composable("noFiles", () => ({
  $el: "span",
  if: "$value.length == 0",
  attrs: {
    class: "$classes.noFiles"
  }
}));
const removeFiles = composable("removeFiles", () => ({
  $el: "a",
  attrs: {
    href: "#",
    class: "$classes.removeFiles",
    onClick: "$handlers.resetFiles"
  }
}));
const fileSchema = (extensions2 = {}) => [
  outer(extensions2.outer, [
    wrapper$2(extensions2.wrapper, [
      label(extensions2.label, "$label"),
      inner(extensions2.inner, [
        prefix$1(extensions2.prefix),
        file$1(extensions2.input),
        fileList(extensions2.fileList, [
          fileItem(extensions2.file, [
            fileName(extensions2.fileName, "$file.name"),
            {
              if: "$value.length == 1",
              then: removeFiles(extensions2.removeFiles, "$ui.remove.value")
            }
          ])
        ]),
        {
          if: "$value.length > 1",
          then: removeFiles(extensions2.removeFiles, "$ui.removeAll.value")
        },
        noFiles(extensions2.noFiles, "$ui.noFiles.value"),
        suffix$1(extensions2.suffix)
      ])
    ]),
    help(extensions2.help, "$help"),
    messages(extensions2.messages, [
      message(extensions2.message, "$message.value")
    ])
  ])
];
const textarea$1 = composable("input", () => ({
  $el: "textarea",
  bind: "$attrs",
  attrs: {
    class: "$classes.input",
    disabled: "$disabled",
    name: "$node.name",
    onInput: "$handlers.DOMInput",
    onBlur: "$handlers.blur",
    value: "$_value",
    id: "$id",
    "aria-describedby": "$describedBy"
  },
  children: "$initialValue"
}));
const textareaSchema = (extensions2 = {}) => [
  outer(extensions2.outer, [
    wrapper$2(extensions2.wrapper, [
      label(extensions2.label, "$label"),
      inner(extensions2.inner, [
        prefix$1(extensions2.prefix),
        textarea$1(extensions2.input),
        suffix$1(extensions2.suffix)
      ])
    ]),
    help(extensions2.help, "$help"),
    messages(extensions2.messages, [
      message(extensions2.message, "$message.value")
    ])
  ])
];
const hiddenSchema = (extensions2 = {}) => [
  text$1$1(extensions2.input)
];
const fragment = (schema = {}, children = []) => Object.keys(schema).length || typeof children !== "string" ? extend$1({ $el: "div", children }, schema) : children;
const groupSchema = (extensions2 = {}) => {
  return [fragment(extensions2.wrapper, "$slots.default")];
};
const listSchema = (extensions2 = {}) => {
  return [fragment(extensions2.wrapper, "$slots.default")];
};
const select$2 = composable("input", (children) => ({
  $el: "select",
  bind: "$attrs",
  attrs: {
    id: "$id",
    "data-placeholder": {
      if: "$placeholder",
      then: {
        if: "$value",
        then: void 0,
        else: "true"
      }
    },
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    onInput: "$handlers.selectInput",
    onBlur: "$handlers.blur",
    "aria-describedby": "$describedBy"
  },
  children: {
    if: "$slots.default",
    then: "$slots.default",
    else: children
  }
}));
const option$1 = (schema = {}, children = []) => ({
  if: "$slots.option",
  then: [
    {
      $el: "text",
      if: "$options.length",
      for: ["option", "$options"],
      children: "$slots.option"
    }
  ],
  else: extend$1({
    $el: "option",
    if: "$options.length",
    for: ["option", "$options"],
    bind: "$option.attrs",
    attrs: {
      class: "$classes.option",
      value: "$option.value",
      selected: "$fns.isSelected($option.value)"
    },
    children
  }, schema)
});
const textSchema = (extensions2 = {}) => [
  outer(extensions2.outer, [
    wrapper$2(extensions2.wrapper, [
      label(extensions2.label, "$label"),
      inner(extensions2.inner, [
        prefix$1(extensions2.prefix),
        select$2(extensions2.input, [option$1(extensions2.option, "$option.label")]),
        suffix$1(extensions2.suffix)
      ])
    ]),
    help(extensions2.help, "$help"),
    messages(extensions2.messages, [
      message(extensions2.message, "$message.value")
    ])
  ])
];
const boxLabel = composable("label", (children) => ({
  $el: "span",
  if: typeof children === "string" ? children : "$: true",
  attrs: {
    class: "$classes.label"
  }
}));
const wrapper$1 = composable("wrapper", () => ({
  $el: "label",
  attrs: {
    class: "$classes.wrapper",
    "data-disabled": {
      if: "$options.length",
      then: void 0,
      else: "$disabled"
    }
  }
}));
const box = composable("input", () => ({
  $el: "input",
  bind: "$attrs",
  attrs: {
    type: "$type",
    class: "$classes.input",
    name: "$node.props.altName || $node.name",
    disabled: "$option.attrs.disabled || $disabled",
    onInput: "$handlers.toggleChecked",
    checked: "$fns.eq($_value, $onValue)",
    onBlur: "$handlers.blur",
    value: "$: true",
    id: "$id",
    "aria-describedby": {
      if: "$options.length",
      then: {
        if: "$option.help",
        then: '$: "help-" + $option.attrs.id',
        else: void 0
      },
      else: {
        if: "$help",
        then: '$: "help-" + $id',
        else: void 0
      }
    }
  }
}));
const fieldset = composable("fieldset", () => ({
  $el: "fieldset",
  attrs: {
    id: "$id",
    class: "$classes.fieldset",
    "aria-describedby": {
      if: "$help",
      then: '$: "help-" + $id',
      else: void 0
    }
  }
}));
const legend = composable("legend", () => ({
  $el: "legend",
  if: "$label",
  attrs: {
    class: "$classes.legend"
  }
}));
const boxes = composable("option", () => ({
  $el: "li",
  for: ["option", "$options"],
  attrs: {
    class: "$classes.option",
    "data-disabled": "$option.attrs.disabled || $disabled"
  }
}));
const wrapper = composable("options", () => ({
  $el: "ul",
  attrs: {
    class: "$classes.options"
  }
}));
const decorator = composable("decorator", () => ({
  $el: "span",
  attrs: {
    class: "$classes.decorator",
    "aria-hidden": "true"
  }
}));
const boxSchema = (extensions2 = {}) => {
  const singleCheckbox = [
    wrapper$1(extensions2.wrapper, [
      inner(extensions2.inner, [
        prefix$1(extensions2.prefix),
        box(extensions2.input),
        decorator(extensions2.decorator),
        suffix$1(extensions2.suffix)
      ]),
      boxLabel(extensions2.label, "$label")
    ]),
    help(extensions2.help, "$help")
  ];
  const multiCheckbox = fieldset(extensions2.fieldset, [
    legend(extensions2.legend, "$label"),
    help(extensions2.help, "$help"),
    wrapper(extensions2.options, [
      boxes(extensions2.option, [
        wrapper$1(extensions2.wrapper, [
          inner(extensions2.inner, [
            prefix$1(extensions2.prefix),
            box(extend$1({
              bind: "$option.attrs",
              attrs: {
                id: "$option.attrs.id",
                value: "$option.value",
                checked: "$fns.isChecked($option.value)"
              }
            }, extensions2.input || {})),
            decorator(extensions2.decorator),
            suffix$1(extensions2.suffix)
          ]),
          boxLabel(extensions2.label, "$option.label")
        ]),
        help(extensions2.optionHelp, "$option.help", "optionHelp", "$option.help")
      ])
    ])
  ]);
  return [
    outer(extensions2.outer, [
      {
        if: "$options.length",
        then: multiCheckbox,
        else: singleCheckbox
      },
      messages(extensions2.messages, [
        message(extensions2.message, "$message.value")
      ])
    ])
  ];
};
const actions$5 = composable("actions", () => ({
  $el: "div",
  if: "$actions",
  attrs: {
    class: "$classes.actions"
  }
}));
const form$2 = composable("form", () => ({
  $el: "form",
  bind: "$attrs",
  attrs: {
    id: "$id",
    class: "$classes.form",
    name: "$node.name",
    onSubmit: "$handlers.submit",
    "data-loading": "$state.loading || undefined"
  }
}));
const submit$1 = composable("submit", () => ({
  $cmp: "FormKit",
  bind: "$submitAttrs",
  props: {
    ignore: true,
    type: "submit",
    disabled: "$disabled",
    label: "$submitLabel"
  }
}));
const formSchema = (extensions2 = {}) => {
  return [
    form$2(extensions2.form, [
      "$slots.default",
      messages(extensions2.messages, [
        message(extensions2.message, "$message.value")
      ]),
      actions$5(extensions2.actions, [submit$1(extensions2.submit)])
    ])
  ];
};
const button$1 = composable("input", () => ({
  $el: "button",
  bind: "$attrs",
  attrs: {
    type: "$type",
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    id: "$id"
  }
}));
const buttonSchema = (extensions2 = {}) => [
  outer(extensions2.outer, [
    messages(extensions2.messages, [
      message(extensions2.message, "$message.value")
    ]),
    wrapper$2(extensions2.wrapper, [
      button$1(extensions2.input, [
        prefix$1(extensions2.prefix),
        {
          if: "$slots.default",
          then: "$slots.default",
          else: {
            if: "$label",
            then: "$label",
            else: "$ui.submit.value"
          }
        },
        suffix$1(extensions2.suffix)
      ])
    ]),
    help(extensions2.help, "$help")
  ])
];
function normalizeOptions(options2) {
  let i = 1;
  if (Array.isArray(options2)) {
    return options2.map((option3) => {
      if (typeof option3 === "string" || typeof option3 === "number") {
        return {
          label: option3,
          value: option3
        };
      }
      if (typeof option3 == "object") {
        if ("value" in option3 && typeof option3.value !== "string") {
          Object.assign(option3, {
            value: `__mask_${i++}`,
            __original: option3.value
          });
        }
      }
      return option3;
    });
  }
  return Object.keys(options2).map((value) => {
    return {
      label: options2[value],
      value
    };
  });
}
function optionValue(options2, value) {
  if (Array.isArray(options2)) {
    for (const option3 of options2) {
      if (value == option3.value) {
        return "__original" in option3 ? option3.__original : option3.value;
      }
    }
  }
  return value;
}
function shouldSelect(valueA, valueB) {
  if (valueA == valueB)
    return true;
  if (isPojo(valueA) && isPojo(valueB))
    return eq$1(valueA, valueB);
  return false;
}
function options(node) {
  node.hook.prop((prop2, next) => {
    if (prop2.prop === "options") {
      const options2 = normalizeOptions(prop2.value);
      prop2.value = options2;
    }
    return next(prop2);
  });
}
function isSelected(node, option3) {
  node.context && node.context.value;
  const value = optionValue(node.props.options, option3);
  return Array.isArray(node._value) ? node._value.some((optionA) => shouldSelect(optionA, value)) : node.value === void 0 && !option3 || shouldSelect(value, node._value);
}
function selectInput(node, e) {
  const target2 = e.target;
  const value = target2.hasAttribute("multiple") ? Array.from(target2.selectedOptions).map((o) => optionValue(node.props.options, o.value)) : optionValue(node.props.options, target2.value);
  node.input(value);
}
function applyPlaceholder(options2, placeholder) {
  if (!options2.some((option3) => option3.attrs && option3.attrs["data-is-placeholder"])) {
    return [
      {
        label: placeholder,
        value: "",
        attrs: {
          hidden: true,
          disabled: true,
          "data-is-placeholder": "true"
        }
      },
      ...options2
    ];
  }
  return options2;
}
function select$1(node) {
  node.on("created", () => {
    var _a, _b, _c;
    const isMultiple = undefine((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);
    if (!isMultiple && node.props.placeholder && Array.isArray(node.props.options)) {
      node.hook.prop(({ prop: prop2, value }, next) => {
        if (prop2 === "options") {
          value = applyPlaceholder(value, node.props.placeholder);
        }
        return next({ prop: prop2, value });
      });
      node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);
    }
    if (isMultiple) {
      if (node.value === void 0) {
        node.input([], false);
      }
    } else if (node.context && !node.context.options) {
      node.props.attrs = Object.assign({}, node.props.attrs, {
        value: node._value
      });
      node.on("input", ({ payload }) => {
        node.props.attrs = Object.assign({}, node.props.attrs, {
          value: payload
        });
      });
    }
    if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {
      node.context.handlers.selectInput = selectInput.bind(null, node);
    }
    if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {
      node.context.fns.isSelected = isSelected.bind(null, node);
    }
  });
  node.hook.input((value, next) => {
    var _a, _b, _c;
    if (!node.props.placeholder && value === void 0 && Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) && node.props.options.length && !undefine((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {
      value = "__original" in node.props.options[0] ? node.props.options[0].__original : node.props.options[0].value;
    }
    return next(value);
  });
}
function normalizeBoxes(node) {
  return function(prop2, next) {
    if (prop2.prop === "options" && Array.isArray(prop2.value)) {
      prop2.value = prop2.value.map((option3) => {
        var _a;
        if (!((_a = option3.attrs) === null || _a === void 0 ? void 0 : _a.id)) {
          return extend$1(option3, {
            attrs: { id: `${node.name}-option-${kebab(String(option3.value))}` }
          });
        }
        return option3;
      });
      if (node.props.type === "checkbox" && !Array.isArray(node.value)) {
        if (node.isCreated) {
          node.input([], false);
        } else {
          node.on("created", () => {
            if (!Array.isArray(node.value)) {
              node.input([], false);
            }
          });
        }
      }
    }
    return next(prop2);
  };
}
function toggleChecked$1(node, e) {
  const el2 = e.target;
  if (el2 instanceof HTMLInputElement) {
    const value = Array.isArray(node.props.options) ? optionValue(node.props.options, el2.value) : el2.value;
    if (Array.isArray(node.props.options) && node.props.options.length) {
      if (!Array.isArray(node._value)) {
        node.input([value]);
      } else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {
        node.input([...node._value, value]);
      } else {
        node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));
      }
    } else {
      if (el2.checked) {
        node.input(node.props.onValue);
      } else {
        node.input(node.props.offValue);
      }
    }
  }
}
function isChecked$1(node, value) {
  var _a, _b;
  (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
  (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
  if (Array.isArray(node._value)) {
    return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));
  }
  return false;
}
function checkboxes(node) {
  node.on("created", () => {
    var _a, _b;
    if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
      node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);
    }
    if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
      node.context.fns.isChecked = isChecked$1.bind(null, node);
    }
    if (!has$3(node.props, "onValue"))
      node.props.onValue = true;
    if (!has$3(node.props, "offValue"))
      node.props.offValue = false;
  });
  node.hook.prop(normalizeBoxes(node));
}
function toggleChecked(node, event) {
  if (event.target instanceof HTMLInputElement) {
    node.input(optionValue(node.props.options, event.target.value));
  }
}
function isChecked(node, value) {
  var _a, _b;
  (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
  (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
  return shouldSelect(optionValue(node.props.options, value), node._value);
}
function radios(node) {
  node.on("created", () => {
    var _a, _b;
    if (!Array.isArray(node.props.options)) {
      warn$1(350, node);
    }
    if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
      node.context.handlers.toggleChecked = toggleChecked.bind(null, node);
    }
    if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
      node.context.fns.isChecked = isChecked.bind(null, node);
    }
  });
  node.hook.prop(normalizeBoxes(node));
}
function disables(node) {
  node.on("created", () => {
    node.props.disabled = undefine(node.props.disabled);
  });
  node.hook.prop(({ prop: prop2, value }, next) => {
    value = prop2 === "disabled" ? undefine(value) : value;
    return next({ prop: prop2, value });
  });
  node.on("prop:disabled", ({ payload: value }) => {
    node.config.disabled = undefine(value);
  });
  node.on("created", () => {
    node.config.disabled = undefine(node.props.disabled);
  });
}
async function handleSubmit(node, submitEvent) {
  submitEvent.preventDefault();
  await node.settled;
  node.walk((n) => {
    n.store.set(createMessage({
      key: "submitted",
      value: true,
      visible: false
    }));
  });
  if (typeof node.props.onSubmitRaw === "function") {
    node.props.onSubmitRaw(submitEvent, node);
  }
  if (node.ledger.value("blocking")) {
    if (node.props.incompleteMessage !== false) {
      node.store.set(createMessage({
        blocking: false,
        key: `incomplete`,
        meta: {
          localize: node.props.incompleteMessage === void 0,
          i18nArgs: [{ node }],
          showAsMessage: true
        },
        type: "ui",
        value: node.props.incompleteMessage || "Form incomplete."
      }));
    }
  } else {
    if (typeof node.props.onSubmit === "function") {
      const retVal = node.props.onSubmit(clone$2(node.value), node);
      if (retVal instanceof Promise) {
        const autoDisable = node.props.disabled === void 0 && node.props.submitBehavior !== "live";
        if (autoDisable)
          node.props.disabled = true;
        node.store.set(createMessage({
          key: "loading",
          value: true,
          visible: false
        }));
        await retVal;
        if (autoDisable)
          node.props.disabled = false;
        node.store.remove("loading");
      }
    } else {
      if (submitEvent.target instanceof HTMLFormElement) {
        submitEvent.target.submit();
      }
    }
  }
}
function form$1(node) {
  node.props.isForm = true;
  node.on("created", () => {
    var _a;
    if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
      node.context.handlers.submit = handleSubmit.bind(null, node);
    }
    if (!has$3(node.props, "actions")) {
      node.props.actions = true;
    }
  });
  node.on("settled:blocking", () => node.store.remove("incomplete"));
}
function localize(key, value) {
  return (node) => {
    node.store.set(createMessage({
      key,
      type: "ui",
      value: value || key,
      meta: {
        localize: true,
        i18nArgs: [node]
      }
    }));
  };
}
const isBrowser$1 = typeof window !== "undefined";
function removeHover(e) {
  if (e.target instanceof HTMLElement && e.target.hasAttribute("data-file-hover")) {
    e.target.removeAttribute("data-file-hover");
  }
}
function preventStrayDrop(type, e) {
  if (!(e.target instanceof HTMLInputElement)) {
    e.preventDefault();
  } else if (type === "dragover") {
    e.target.setAttribute("data-file-hover", "true");
  }
  if (type === "drop") {
    removeHover(e);
  }
}
function files(node) {
  localize("noFiles", "Select file")(node);
  localize("removeAll", "Remove all")(node);
  localize("remove")(node);
  if (isBrowser$1) {
    if (!window._FormKit_File_Drop) {
      window.addEventListener("dragover", preventStrayDrop.bind(null, "dragover"));
      window.addEventListener("drop", preventStrayDrop.bind(null, "drop"));
      window.addEventListener("dragleave", removeHover);
      window._FormKit_File_Drop = true;
    }
  }
  node.on("created", () => {
    if (!Array.isArray(node.value)) {
      node.input([], false);
    }
    if (!node.context)
      return;
    node.context.handlers.resetFiles = (e) => {
      e.preventDefault();
      node.input([]);
      if (node.props.id && isBrowser$1) {
        const el2 = document.getElementById(node.props.id);
        if (el2)
          el2.value = "";
      }
    };
    node.context.handlers.files = (e) => {
      var _a, _b;
      const files2 = [];
      if (e.target instanceof HTMLInputElement && e.target.files) {
        for (let i = 0; i < e.target.files.length; i++) {
          let file2;
          if (file2 = e.target.files.item(i)) {
            files2.push({ name: file2.name, file: file2 });
          }
        }
        node.input(files2);
      }
      if (node.context)
        node.context.files = files2;
      if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === "function") {
        (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);
      }
    };
  });
}
function ignore(node) {
  if (node.props.ignore === void 0) {
    node.props.ignore = true;
    node.parent = null;
  }
}
function initialValue(node) {
  node.on("created", () => {
    if (node.context) {
      node.context.initialValue = node.value || "";
    }
  });
}
const textClassification = {
  type: "input",
  schema: textSchema$1
};
const color = textClassification;
const date$1 = textClassification;
const datetimeLocal = textClassification;
const email$1 = textClassification;
const month = textClassification;
const number$1 = textClassification;
const password = textClassification;
const search = textClassification;
const tel = textClassification;
const time = textClassification;
const text$3 = textClassification;
const url$1 = textClassification;
const week = textClassification;
const range$1 = textClassification;
const textarea = {
  type: "input",
  schema: textareaSchema,
  features: [initialValue]
};
const buttonClassification = {
  type: "input",
  schema: buttonSchema,
  features: [localize("submit"), ignore]
};
const submit = buttonClassification;
const button = buttonClassification;
const hidden = {
  type: "input",
  schema: hiddenSchema
};
const select$3 = {
  type: "input",
  schema: textSchema,
  props: ["options", "placeholder"],
  features: [options, select$1]
};
const checkbox = {
  type: "input",
  schema: boxSchema,
  props: ["options", "onValue", "offValue"],
  features: [options, checkboxes]
};
const radio = {
  type: "input",
  schema: boxSchema,
  props: ["options"],
  features: [options, radios]
};
const group = {
  type: "group",
  schema: groupSchema,
  features: [disables]
};
const form$3 = {
  type: "group",
  schema: formSchema,
  props: [
    "actions",
    "submit",
    "submitLabel",
    "submitAttrs",
    "submitBehavior",
    "incompleteMessage"
  ],
  features: [form$1, disables]
};
const list$2 = {
  type: "list",
  schema: listSchema,
  features: [disables]
};
const file = {
  type: "input",
  schema: fileSchema,
  features: [files],
  props: ["files"]
};
var inputs = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  color,
  date: date$1,
  datetimeLocal,
  email: email$1,
  month,
  number: number$1,
  password,
  search,
  tel,
  time,
  text: text$3,
  url: url$1,
  week,
  range: range$1,
  textarea,
  submit,
  button,
  hidden,
  select: select$3,
  checkbox,
  radio,
  group,
  form: form$3,
  list: list$2,
  file
});
function createLibraryPlugin(...libraries) {
  const library2 = libraries.reduce((merged, lib2) => extend$1(merged, lib2), {});
  const plugin2 = () => {
  };
  plugin2.library = function(node) {
    const type = camel(node.props.type);
    if (has$3(library2, type)) {
      node.define(library2[type]);
    }
  };
  return plugin2;
}
const accepted = function accepted2({ value }) {
  return ["yes", "on", "1", 1, true, "true"].includes(value);
};
const date_after = function({ value }, compare = false) {
  const timestamp = Date.parse(compare || new Date());
  const fieldValue = Date.parse(String(value));
  return isNaN(fieldValue) ? false : fieldValue > timestamp;
};
const alpha$1 = function({ value }, set3 = "default") {
  const sets = {
    default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
    latin: /^[a-zA-Z]+$/
  };
  const selectedSet = has$3(sets, set3) ? set3 : "default";
  return sets[selectedSet].test(String(value));
};
const alpha_spaces = function({ value }, set3 = "default") {
  const sets = {
    default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż ]+$/,
    latin: /^[a-zA-Z ]+$/
  };
  const selectedSet = has$3(sets, set3) ? set3 : "default";
  return sets[selectedSet].test(String(value));
};
const alphanumeric = function({ value }, set3 = "default") {
  const sets = {
    default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
    latin: /^[a-zA-Z0-9]+$/
  };
  const selectedSet = has$3(sets, set3) ? set3 : "default";
  return sets[selectedSet].test(String(value));
};
const date_before = function({ value }, compare = false) {
  const timestamp = Date.parse(compare || new Date());
  const fieldValue = Date.parse(String(value));
  return isNaN(fieldValue) ? false : fieldValue < timestamp;
};
const between$1 = function between({ value }, from2, to) {
  if (!isNaN(value) && !isNaN(from2) && !isNaN(to)) {
    const val = 1 * value;
    from2 = Number(from2);
    to = Number(to);
    const [a, b] = from2 <= to ? [from2, to] : [to, from2];
    return val >= 1 * a && val <= 1 * b;
  }
  return false;
};
const hasConfirm = /(_confirm(?:ed)?)$/;
const confirm$1 = function confirm2(node, address, comparison = "loose") {
  var _a;
  if (!address) {
    address = hasConfirm.test(node.name) ? node.name.replace(hasConfirm, "") : `${node.name}_confirm`;
  }
  const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;
  return comparison === "strict" ? node.value === foreignValue : node.value == foreignValue;
};
const date_between = function date_between2({ value }, dateA, dateB) {
  dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);
  dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);
  const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));
  if (dateA && !dateB) {
    dateB = dateA;
    dateA = Date.now();
  } else if (!dateA || !compareTo) {
    return false;
  }
  return compareTo >= dateA && compareTo <= dateB;
};
const date_format = function date({ value }, format3) {
  if (format3 && typeof format3 === "string") {
    return regexForFormat(format3).test(String(value));
  }
  return !isNaN(Date.parse(String(value)));
};
const email = function email2({ value }) {
  const isEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
  return isEmail.test(String(value));
};
const ends_with = function ends_with2({ value }, ...stack2) {
  if (typeof value === "string" && stack2.length) {
    return stack2.some((item) => {
      return value.endsWith(item);
    });
  } else if (typeof value === "string" && stack2.length === 0) {
    return true;
  }
  return false;
};
const is = function is2({ value }, ...stack2) {
  return stack2.some((item) => {
    if (typeof item === "object") {
      return eq$1(item, value);
    }
    return item == value;
  });
};
const length = function length2({ value }, first2 = 0, second = Infinity) {
  first2 = parseInt(first2);
  second = isNaN(parseInt(second)) ? Infinity : parseInt(second);
  const min3 = first2 <= second ? first2 : second;
  const max3 = second >= first2 ? second : first2;
  if (typeof value === "string" || Array.isArray(value)) {
    return value.length >= min3 && value.length <= max3;
  } else if (value && typeof value === "object") {
    const length3 = Object.keys(value).length;
    return length3 >= min3 && length3 <= max3;
  }
  return false;
};
const matches$2 = function matches({ value }, ...stack2) {
  return stack2.some((pattern) => {
    if (typeof pattern === "string" && pattern.substr(0, 1) === "/" && pattern.substr(-1) === "/") {
      pattern = new RegExp(pattern.substr(1, pattern.length - 2));
    }
    if (pattern instanceof RegExp) {
      return pattern.test(String(value));
    }
    return pattern === value;
  });
};
const max$1 = function max({ value }, maximum = 10) {
  if (Array.isArray(value)) {
    return value.length <= maximum;
  }
  return Number(value) <= Number(maximum);
};
const min$1 = function min({ value }, minimum = 1) {
  if (Array.isArray(value)) {
    return value.length >= minimum;
  }
  return Number(value) >= Number(minimum);
};
const not$2 = function not({ value }, ...stack2) {
  return !stack2.some((item) => {
    if (typeof item === "object") {
      return eq$1(item, value);
    }
    return item === value;
  });
};
const number = function number2({ value }) {
  return !isNaN(value);
};
const required$1 = function required({ value }, action = "default") {
  return action === "trim" && typeof value === "string" ? !empty$2(value.trim()) : !empty$2(value);
};
required$1.skipEmpty = false;
const starts_with = function starts_with2({ value }, ...stack2) {
  if (typeof value === "string" && stack2.length) {
    return stack2.some((item) => {
      return value.startsWith(item);
    });
  } else if (typeof value === "string" && stack2.length === 0) {
    return true;
  }
  return false;
};
const url = function url2({ value }, ...stack2) {
  try {
    const protocols = stack2.length ? stack2 : ["http:", "https:"];
    const url3 = new URL(String(value));
    return protocols.includes(url3.protocol);
  } catch {
    return false;
  }
};
var defaultRules = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accepted,
  alpha: alpha$1,
  alpha_spaces,
  alphanumeric,
  between: between$1,
  confirm: confirm$1,
  date_after,
  date_before,
  date_between,
  date_format,
  email,
  ends_with,
  is,
  length,
  matches: matches$2,
  max: max$1,
  min: min$1,
  not: not$2,
  number,
  required: required$1,
  starts_with,
  url
}, Symbol.toStringTag, { value: "Module" }));
const revokedObservers = /* @__PURE__ */ new WeakSet();
function createObserver(node, dependencies) {
  const deps = dependencies || Object.assign(/* @__PURE__ */ new Map(), { active: false });
  const receipts2 = /* @__PURE__ */ new Map();
  const addDependency = function(event) {
    var _a;
    if (!deps.active)
      return;
    if (!deps.has(node))
      deps.set(node, /* @__PURE__ */ new Set());
    (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);
  };
  const observeProps = function(props2) {
    return new Proxy(props2, {
      get(...args) {
        typeof args[1] === "string" && addDependency(`prop:${args[1]}`);
        return Reflect.get(...args);
      }
    });
  };
  const observeLedger = function(ledger) {
    return new Proxy(ledger, {
      get(...args) {
        if (args[1] === "value") {
          return (key) => {
            addDependency(`count:${key}`);
            return ledger.value(key);
          };
        }
        return Reflect.get(...args);
      }
    });
  };
  const observe2 = function(value, property2) {
    if (isNode(value)) {
      return createObserver(value, deps);
    }
    if (property2 === "value")
      addDependency("commit");
    if (property2 === "props")
      return observeProps(value);
    if (property2 === "ledger")
      return observeLedger(value);
    return value;
  };
  const { proxy: observed, revoke } = Proxy.revocable(node, {
    get(...args) {
      switch (args[1]) {
        case "deps":
          return deps;
        case "watch":
          return (block3) => watch(observed, block3);
        case "observe":
          return () => {
            const old = new Map(deps);
            deps.clear();
            deps.active = true;
            return old;
          };
        case "stopObserve":
          return () => {
            const newDeps = new Map(deps);
            deps.active = false;
            return newDeps;
          };
        case "receipts":
          return receipts2;
        case "kill":
          return () => {
            removeListeners(receipts2);
            revokedObservers.add(args[2]);
            revoke();
          };
      }
      const value = Reflect.get(...args);
      if (typeof value === "function") {
        return (...subArgs) => {
          const subValue = value(...subArgs);
          return observe2(subValue, args[1]);
        };
      }
      return observe2(value, args[1]);
    }
  });
  return observed;
}
function applyListeners(node, [toAdd, toRemove], callback) {
  toAdd.forEach((events2, depNode) => {
    events2.forEach((event) => {
      node.receipts.has(depNode) || node.receipts.set(depNode, {});
      node.receipts.set(depNode, Object.assign(node.receipts.get(depNode), {
        [event]: depNode.on(event, callback)
      }));
    });
  });
  toRemove.forEach((events2, depNode) => {
    events2.forEach((event) => {
      if (node.receipts.has(depNode)) {
        const nodeReceipts = node.receipts.get(depNode);
        if (nodeReceipts && has$3(nodeReceipts, event)) {
          depNode.off(nodeReceipts[event]);
          delete nodeReceipts[event];
          node.receipts.set(depNode, nodeReceipts);
        }
      }
    });
  });
}
function removeListeners(receipts2) {
  receipts2.forEach((events2, node) => {
    for (const event in events2) {
      node.off(events2[event]);
    }
  });
}
async function watch(node, block3) {
  const oldDeps = new Map(node.deps);
  node.observe();
  const res = block3(node);
  if (res instanceof Promise)
    await res;
  const newDeps = node.stopObserve();
  applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block3));
}
function diffDeps(previous, current) {
  const toAdd = /* @__PURE__ */ new Map();
  const toRemove = /* @__PURE__ */ new Map();
  current.forEach((events2, node) => {
    if (!previous.has(node)) {
      toAdd.set(node, events2);
    } else {
      const eventsToAdd = /* @__PURE__ */ new Set();
      const previousEvents = previous.get(node);
      events2.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));
      toAdd.set(node, eventsToAdd);
    }
  });
  previous.forEach((events2, node) => {
    if (!current.has(node)) {
      toRemove.set(node, events2);
    } else {
      const eventsToRemove = /* @__PURE__ */ new Set();
      const newEvents = current.get(node);
      events2.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));
      toRemove.set(node, eventsToRemove);
    }
  });
  return [toAdd, toRemove];
}
function isKilled(node) {
  return revokedObservers.has(node);
}
const validatingMessage = createMessage({
  type: "state",
  blocking: true,
  visible: false,
  value: true,
  key: "validating"
});
function createValidationPlugin(baseRules = {}) {
  return function validationPlugin(node) {
    const availableRules = Object.assign({}, baseRules, node.props.validationRules);
    let observedNode = createObserver(node);
    const state2 = { input: token$2(), rerun: null, isPassing: true };
    let validation = cloneAny(node.props.validation);
    node.on("prop:validation", ({ payload: value }) => {
      if (eq$1(validation, value))
        return;
      validation = cloneAny(value);
      removeListeners(observedNode.receipts);
      node.store.filter(() => false, "validation");
      node.props.parsedRules = parseRules(value, availableRules);
      observedNode.kill();
      observedNode = createObserver(node);
      validate(observedNode, node.props.parsedRules, state2);
    });
    node.props.parsedRules = parseRules(validation, availableRules);
    validate(observedNode, node.props.parsedRules, state2);
  };
}
function validate(node, validations, state2) {
  if (isKilled(node))
    return;
  state2.input = token$2();
  state2.isPassing = true;
  node.store.filter((message2) => !message2.meta.removeImmediately, "validation");
  validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));
  if (validations.length) {
    node.store.set(validatingMessage);
    run$3(0, validations, node, state2, false, () => {
      node.store.remove(validatingMessage.key);
    });
  }
}
function run$3(current, validations, node, state2, removeImmediately, complete) {
  const validation = validations[current];
  if (!validation)
    return complete();
  const currentRun = state2.input;
  validation.state = null;
  function next(async, result) {
    state2.isPassing = state2.isPassing && !!result;
    validation.queued = false;
    const newDeps = node.stopObserve();
    applyListeners(node, diffDeps(validation.deps, newDeps), () => {
      validation.queued = true;
      if (state2.rerun)
        clearTimeout(state2.rerun);
      state2.rerun = setTimeout(validate, 0, node, validations, state2);
    });
    validation.deps = newDeps;
    if (state2.input === currentRun) {
      validation.state = result;
      if (result === false) {
        createFailedMessage(node, validation, removeImmediately || async);
      } else {
        removeMessage(node, validation);
      }
      if (validations.length > current + 1) {
        run$3(current + 1, validations, node, state2, removeImmediately || async, complete);
      } else {
        complete();
      }
    }
  }
  if ((!empty$2(node.value) || !validation.skipEmpty) && (state2.isPassing || validation.force)) {
    if (validation.queued) {
      runRule(validation, node, (result) => {
        result instanceof Promise ? result.then((r) => next(true, r)) : next(false, result);
      });
    } else {
      run$3(current + 1, validations, node, state2, removeImmediately, complete);
    }
  } else {
    if (empty$2(node.value) && validation.skipEmpty && state2.isPassing) {
      node.observe();
      node.value;
    }
    next(false, null);
  }
}
function runRule(validation, node, after) {
  if (validation.debounce) {
    validation.timer = setTimeout(() => {
      node.observe();
      after(validation.rule(node, ...validation.args));
    }, validation.debounce);
  } else {
    node.observe();
    after(validation.rule(node, ...validation.args));
  }
}
function removeMessage(node, validation) {
  const key = `rule_${validation.name}`;
  if (has$3(node.store, key)) {
    node.store.remove(key);
  }
}
function createFailedMessage(node, validation, removeImmediately) {
  const i18nArgs = createI18nArgs(node, validation);
  const customMessage = createCustomMessage(node, validation, i18nArgs);
  const message2 = createMessage({
    blocking: validation.blocking,
    key: `rule_${validation.name}`,
    meta: {
      messageKey: validation.name,
      removeImmediately,
      localize: !customMessage,
      i18nArgs
    },
    type: "validation",
    value: customMessage || "This field is not valid."
  });
  node.store.set(message2);
  return message2;
}
function createCustomMessage(node, validation, i18nArgs) {
  const customMessage = node.props.validationMessages && has$3(node.props.validationMessages, validation.name) ? node.props.validationMessages[validation.name] : void 0;
  if (typeof customMessage === "function") {
    return customMessage(...i18nArgs);
  }
  return customMessage;
}
function createI18nArgs(node, validation) {
  return [
    {
      node,
      name: createMessageName(node),
      args: validation.args
    }
  ];
}
function createMessageName(node) {
  if (typeof node.props.validationLabel === "function") {
    return node.props.validationLabel(node);
  }
  return node.props.validationLabel || node.props.label || node.props.name || String(node.name);
}
const hintPattern = "(?:[\\*+?()0-9]+)";
const rulePattern = "[a-zA-Z][a-zA-Z0-9_]+";
const ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\:(.*)+)?$`, "i");
const hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, "i");
const debounceExtractor = /([\*+?]+)?(\(\d+\))([\*+?]+)?/;
const hasDebounce = /\(\d+\)/;
const defaultHints = {
  blocking: true,
  debounce: 0,
  force: false,
  skipEmpty: true,
  name: ""
};
function parseRules(validation, rules) {
  if (!validation)
    return [];
  const intents = typeof validation === "string" ? extractRules(validation) : clone$2(validation);
  return intents.reduce((validations, args) => {
    let rule = args.shift();
    const hints = {};
    if (typeof rule === "string") {
      const [ruleName, parsedHints] = parseHints(rule);
      if (has$3(rules, ruleName)) {
        rule = rules[ruleName];
        Object.assign(hints, parsedHints);
      }
    }
    if (typeof rule === "function") {
      validations.push(__spreadValues(__spreadValues({
        rule,
        args,
        timer: 0,
        state: null,
        queued: true,
        deps: /* @__PURE__ */ new Map()
      }, defaultHints), fnHints(hints, rule)));
    }
    return validations;
  }, []);
}
function extractRules(validation) {
  return validation.split("|").reduce((rules, rule) => {
    const parsedRule = parseRule(rule);
    if (parsedRule) {
      rules.push(parsedRule);
    }
    return rules;
  }, []);
}
function parseRule(rule) {
  const trimmed = rule.trim();
  if (trimmed) {
    const matches3 = trimmed.match(ruleExtractor);
    if (matches3 && typeof matches3[1] === "string") {
      const ruleName = matches3[1].trim();
      const args = matches3[2] && typeof matches3[2] === "string" ? matches3[2].split(",").map((s) => s.trim()) : [];
      return [ruleName, ...args];
    }
  }
  return false;
}
function parseHints(ruleName) {
  const matches3 = ruleName.match(hintExtractor);
  if (!matches3) {
    return [ruleName, { name: ruleName }];
  }
  const map3 = {
    "*": { force: true },
    "+": { skipEmpty: false },
    "?": { blocking: false }
  };
  const [, hints, rule] = matches3;
  const hintGroups = hasDebounce.test(hints) ? hints.match(debounceExtractor) || [] : [, hints];
  return [
    rule,
    [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints2, group2) => {
      if (!group2)
        return hints2;
      if (hasDebounce.test(group2)) {
        hints2.debounce = parseInt(group2.substr(1, group2.length - 1));
      } else {
        group2.split("").forEach((hint) => has$3(map3, hint) && Object.assign(hints2, map3[hint]));
      }
      return hints2;
    }, { name: rule })
  ];
}
function fnHints(existingHints, rule) {
  if (!existingHints.name) {
    existingHints.name = rule.ruleName || rule.name;
  }
  return ["skipEmpty", "force", "debounce", "blocking"].reduce((hints, hint) => {
    if (has$3(rule, hint) && !has$3(hints, hint)) {
      Object.assign(hints, {
        [hint]: rule[hint]
      });
    }
    return hints;
  }, existingHints);
}
function sentence(str) {
  return str[0].toUpperCase() + str.substr(1);
}
function list$1(items, conjunction = "or") {
  return items.reduce((oxford, item, index2) => {
    oxford += item;
    if (index2 <= items.length - 2 && items.length > 2) {
      oxford += ", ";
    }
    if (index2 === items.length - 2) {
      oxford += `${items.length === 2 ? " " : ""}${conjunction} `;
    }
    return oxford;
  }, "");
}
function date2(date3) {
  const dateTime = typeof date3 === "string" ? new Date(Date.parse(date3)) : date3;
  if (!(dateTime instanceof Date)) {
    return "(unknown)";
  }
  return new Intl.DateTimeFormat(void 0, {
    dateStyle: "medium"
  }).format(dateTime);
}
function order$2(first2, second) {
  return Number(first2) >= Number(second) ? [second, first2] : [first2, second];
}
const ui$m = {
  add: "Add",
  remove: "Remove",
  removeAll: "Remove all",
  incomplete: "Sorry, not all fields are filled out correctly.",
  submit: "Submit",
  noFiles: "No file chosen"
};
const validation$m = {
  accepted({ name }) {
    return `Please accept the ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} must be after ${date2(args[0])}.`;
    }
    return `${sentence(name)} must be in the future.`;
  },
  alpha({ name }) {
    return `${sentence(name)} can only contain alphabetical characters.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} can only contain letters and numbers.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} can only contain letters and spaces.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} must be before ${date2(args[0])}.`;
    }
    return `${sentence(name)} must be in the past.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `This field was configured incorrectly and can\u2019t be submitted.`;
    }
    const [a, b] = order$2(args[0], args[1]);
    return `${sentence(name)} must be between ${a} and ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} does not match.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} is not a valid date, please use the format ${args[0]}`;
    }
    return "This field was configured incorrectly and can\u2019t be submitted";
  },
  date_between({ name, args }) {
    return `${sentence(name)} must be between ${date2(args[0])} and ${date2(args[1])}`;
  },
  email: "Please enter a valid email address.",
  ends_with({ name, args }) {
    return `${sentence(name)} doesn\u2019t end with ${list$1(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} is not an allowed value.`;
  },
  length({ name, args: [first2 = 0, second = Infinity] }) {
    const min3 = Number(first2) <= Number(second) ? first2 : second;
    const max3 = Number(second) >= Number(first2) ? second : first2;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} must be at least one character.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} must be less than or equal to ${max3} characters.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} must be greater than or equal to ${min3} characters.`;
    }
    return `${sentence(name)} must be between ${min3} and ${max3} characters.`;
  },
  matches({ name }) {
    return `${sentence(name)} is not an allowed value.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Cannot have more than ${args[0]} ${name}.`;
    }
    return `${sentence(name)} must be less than or equal to ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "No file formats allowed.";
    }
    return `${sentence(name)} must be of the type: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Cannot have less than ${args[0]} ${name}.`;
    }
    return `${sentence(name)} must be at least ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D is not an allowed ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} must be a number.`;
  },
  required({ name }) {
    return `${sentence(name)} is required.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} doesn\u2019t start with ${list$1(args)}.`;
  },
  url() {
    return `Please include a valid url.`;
  }
};
var en = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ui: ui$m,
  validation: validation$m
});
function createI18nPlugin(registry2) {
  return function i18nPlugin(node) {
    let localeKey = parseLocale(node.config.locale, registry2);
    let locale = localeKey ? registry2[localeKey] : {};
    node.on("prop:locale", ({ payload: lang2 }) => {
      localeKey = parseLocale(lang2, registry2);
      locale = localeKey ? registry2[localeKey] : {};
      node.store.touch();
    });
    node.on("prop:label", () => node.store.touch());
    node.on("prop:validationLabel", () => node.store.touch());
    node.hook.text((fragment2, next) => {
      var _a, _b;
      const key = ((_a = fragment2.meta) === null || _a === void 0 ? void 0 : _a.messageKey) || fragment2.key;
      if (has$3(locale, fragment2.type) && has$3(locale[fragment2.type], key)) {
        const t2 = locale[fragment2.type][key];
        if (typeof t2 === "function") {
          fragment2.value = Array.isArray((_b = fragment2.meta) === null || _b === void 0 ? void 0 : _b.i18nArgs) ? t2(...fragment2.meta.i18nArgs) : t2(fragment2);
        } else {
          fragment2.value = t2;
        }
      }
      return next(fragment2);
    });
  };
}
function parseLocale(locale, availableLocales) {
  if (has$3(availableLocales, locale)) {
    return locale;
  }
  const [lang2] = locale.split("-");
  if (has$3(availableLocales, lang2)) {
    return lang2;
  }
  for (const locale2 in availableLocales) {
    return locale2;
  }
  return false;
}
let registered = false;
const errors$1 = {
  100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,
  101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,
  102: ({ data: [node, property2] }) => `You cannot directly assign node.${property2} (${node.name})`,
  103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,
  104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in "${expression}")`,
  105: ({ data: expression }) => `Invalid schema expression: ${expression}`,
  106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,
  107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,
  108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,
  600: ({ data: node }) => `Unknown input type${typeof node.props.type === "string" ? ' "' + node.props.type + '"' : ""} ("${node.name}")`,
  601: ({ data: node }) => `Input definition${typeof node.props.type === "string" ? ' "' + node.props.type + '"' : ""} is missing a schema or component property (${node.name}).`
};
const warnings = {
  150: ({ data: fn2 }) => `Schema function "${fn2}()" is not a valid function.`,
  151: ({ data: id }) => `No form element with id: ${id}`,
  152: ({ data: id }) => `No input element with id: ${id}`,
  350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,
  650: 'Schema "$get()" must use the id of an input to access.',
  651: ({ data: id }) => `Cannot setErrors() on "${id}" because no such id exists.`,
  652: ({ data: id }) => `Cannot clearErrors() on "${id}" because no such id exists.`
};
const decodeErrors = (error2, next) => {
  if (error2.code in errors$1) {
    const err = errors$1[error2.code];
    error2.message = typeof err === "function" ? err(error2) : err;
  }
  return next(error2);
};
if (!registered)
  errorHandler(decodeErrors);
const decodeWarnings = (warning, next) => {
  if (warning.code in warnings) {
    const warn2 = warnings[warning.code];
    warning.message = typeof warn2 === "function" ? warn2(warning) : warn2;
  }
  return next(warning);
};
if (!registered)
  warningHandler(decodeWarnings);
registered = true;
const memo = {};
let instanceKey;
const instanceScopes = /* @__PURE__ */ new Map();
const raw = "__raw__";
const isClassProp = /[a-zA-Z0-9\-][cC]lass$/;
function getRef(token2, data) {
  const value = ref(null);
  if (token2 === "get") {
    const nodeRefs = {};
    value.value = get$1.bind(null, nodeRefs);
    return value;
  }
  const path = token2.split(".");
  watchEffect(() => value.value = getValue$1(data, path));
  return value;
}
function getValue$1(set3, path) {
  if (Array.isArray(set3)) {
    for (const subset2 of set3) {
      const value = subset2 !== false && getValue$1(subset2, path);
      if (value !== void 0)
        return value;
    }
    return void 0;
  }
  let foundValue = void 0;
  path.reduce((obj, segment, i, arr) => {
    if (typeof obj !== "object") {
      foundValue = void 0;
      return arr.splice(1);
    }
    const currentValue = obj[segment];
    if (i === path.length - 1 && currentValue !== void 0) {
      foundValue = currentValue;
    }
    return obj[segment];
  }, set3);
  return foundValue;
}
function get$1(nodeRefs, id) {
  if (typeof id !== "string")
    return warn$1(650);
  if (!(id in nodeRefs))
    nodeRefs[id] = ref(void 0);
  if (nodeRefs[id].value === void 0) {
    nodeRefs[id].value = null;
    const root2 = getNode$1(id);
    if (root2)
      nodeRefs[id].value = root2.context;
    watchRegistry(id, ({ payload: node }) => {
      nodeRefs[id].value = isNode(node) ? node.context : node;
    });
  }
  return nodeRefs[id].value;
}
function parseSchema(library2, schema) {
  function parseCondition2(library3, node) {
    const condition = provider(compile$1(node.if), { if: true });
    const children = createElements(library3, node.then);
    const alternate = node.else ? createElements(library3, node.else) : null;
    return [condition, children, alternate];
  }
  function parseConditionAttr(attr, _default2) {
    var _a, _b;
    const condition = provider(compile$1(attr.if));
    let b = () => _default2;
    let a = () => _default2;
    if (typeof attr.then === "object") {
      a = parseAttrs(attr.then, void 0);
    } else if (typeof attr.then === "string" && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith("$"))) {
      a = provider(compile$1(attr.then));
    } else {
      a = () => attr.then;
    }
    if (has$3(attr, "else")) {
      if (typeof attr.else === "object") {
        b = parseAttrs(attr.else);
      } else if (typeof attr.else === "string" && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith("$"))) {
        b = provider(compile$1(attr.else));
      } else {
        b = () => attr.else;
      }
    }
    return () => condition() ? a() : b();
  }
  function parseAttrs(unparsedAttrs, bindExp, _default2 = {}) {
    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));
    const boundAttrs = bindExp ? provider(compile$1(bindExp)) : () => ({});
    const staticAttrs = {};
    const setters = [
      (attrs) => {
        const bound = boundAttrs();
        for (const attr in bound) {
          if (!explicitAttrs.has(attr)) {
            attrs[attr] = bound[attr];
          }
        }
      }
    ];
    if (unparsedAttrs) {
      if (isConditional(unparsedAttrs)) {
        const condition = parseConditionAttr(unparsedAttrs, _default2);
        return condition;
      }
      for (let attr in unparsedAttrs) {
        const value = unparsedAttrs[attr];
        let getValue2;
        const isStr = typeof value === "string";
        if (attr.startsWith(raw)) {
          attr = attr.substring(7);
          getValue2 = () => value;
        } else if (isStr && value.startsWith("$") && value.length > 1 && !(value.startsWith("$reset") && isClassProp.test(attr))) {
          getValue2 = provider(compile$1(value));
        } else if (typeof value === "object" && isConditional(value)) {
          getValue2 = parseConditionAttr(value, void 0);
        } else if (typeof value === "object" && isPojo(value)) {
          getValue2 = parseAttrs(value);
        } else {
          getValue2 = () => value;
          staticAttrs[attr] = value;
        }
        setters.push((attrs) => {
          attrs[attr] = getValue2();
        });
      }
    }
    return () => {
      const attrs = {};
      setters.forEach((setter) => setter(attrs));
      return attrs;
    };
  }
  function parseNode(library3, _node) {
    let element = null;
    let attrs = () => null;
    let condition = false;
    let children = null;
    let alternate = null;
    let iterator = null;
    let resolve2 = false;
    const node = sugar(_node);
    if (isDOM(node)) {
      element = node.$el;
      attrs = node.$el !== "text" ? parseAttrs(node.attrs, node.bind) : () => null;
    } else if (isComponent$1(node)) {
      if (typeof node.$cmp === "string") {
        if (has$3(library3, node.$cmp)) {
          element = library3[node.$cmp];
        } else {
          element = node.$cmp;
          resolve2 = true;
        }
      } else {
        element = node.$cmp;
      }
      attrs = parseAttrs(node.props, node.bind);
    } else if (isConditional(node)) {
      [condition, children, alternate] = parseCondition2(library3, node);
    }
    if (!isConditional(node) && "if" in node) {
      condition = provider(compile$1(node.if));
    } else if (!isConditional(node) && element === null) {
      condition = () => true;
    }
    if ("children" in node && node.children) {
      if (typeof node.children === "string") {
        if (node.children.startsWith("$slots.")) {
          element = element === "text" ? "slot" : element;
          children = provider(compile$1(node.children));
        } else if (node.children.startsWith("$") && node.children.length > 1) {
          const value = provider(compile$1(node.children));
          children = () => String(value());
        } else {
          children = () => String(node.children);
        }
      } else if (Array.isArray(node.children)) {
        children = createElements(library3, node.children);
      } else {
        const [childCondition, c, a] = parseCondition2(library3, node.children);
        children = (iterationData) => childCondition && childCondition() ? c && c(iterationData) : a && a(iterationData);
      }
    }
    if (isComponent$1(node)) {
      if (children) {
        const produceChildren = children;
        children = (iterationData) => {
          return {
            default(slotData2, key) {
              var _a, _b, _c, _d;
              const currentKey = instanceKey;
              if (key)
                instanceKey = key;
              if (slotData2)
                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData2);
              if (iterationData)
                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);
              const c = produceChildren(iterationData);
              if (slotData2)
                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();
              if (iterationData)
                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();
              instanceKey = currentKey;
              return c;
            }
          };
        };
        children.slot = true;
      } else {
        children = () => ({});
      }
    }
    if ("for" in node && node.for) {
      const values = node.for.length === 3 ? node.for[2] : node.for[1];
      const getValues = typeof values === "string" && values.startsWith("$") ? provider(compile$1(values)) : () => values;
      iterator = [
        getValues,
        node.for[0],
        node.for.length === 3 ? String(node.for[1]) : null
      ];
    }
    return [condition, element, attrs, children, alternate, iterator, resolve2];
  }
  function createSlots2(children, iterationData) {
    const slots = children(iterationData);
    const currentKey = instanceKey;
    return Object.keys(slots).reduce((allSlots, slotName) => {
      const slotFn = slots && slots[slotName];
      allSlots[slotName] = (data) => {
        return slotFn && slotFn(data, currentKey) || null;
      };
      return allSlots;
    }, {});
  }
  function createElement2(library3, node) {
    const [condition, element, attrs, children, alternate, iterator, resolve2] = parseNode(library3, node);
    let createNodes = (iterationData) => {
      if (condition && element === null && children) {
        return condition() ? children(iterationData) : alternate && alternate(iterationData);
      }
      if (element && (!condition || condition())) {
        if (element === "text" && children) {
          return createTextVNode(String(children()));
        }
        if (element === "slot" && children)
          return children(iterationData);
        const el2 = resolve2 ? resolveComponent(element) : element;
        const slots = (children === null || children === void 0 ? void 0 : children.slot) ? createSlots2(children, iterationData) : null;
        return h(el2, attrs(), slots || (children ? children(iterationData) : []));
      }
      return typeof alternate === "function" ? alternate(iterationData) : alternate;
    };
    if (iterator) {
      const repeatedNode = createNodes;
      const [getValues, valueName, keyName2] = iterator;
      createNodes = () => {
        const _v = getValues();
        const values = !isNaN(_v) ? Array(Number(_v)).fill(0).map((_2, i) => i) : _v;
        const fragment2 = [];
        if (typeof values !== "object")
          return null;
        const instanceScope = instanceScopes.get(instanceKey) || [];
        for (const key in values) {
          const iterationData = Object.defineProperty(__spreadValues(__spreadProps(__spreadValues({}, instanceScope.reduce((previousIterationData, scopedData) => {
            if (previousIterationData.__idata) {
              return __spreadValues(__spreadValues({}, previousIterationData), scopedData);
            }
            return scopedData;
          }, {})), {
            [valueName]: values[key]
          }), keyName2 !== null ? { [keyName2]: key } : {}), "__idata", { enumerable: false, value: true });
          instanceScope.unshift(iterationData);
          fragment2.push(repeatedNode.bind(null, iterationData)());
          instanceScope.shift();
        }
        return fragment2;
      };
    }
    return createNodes;
  }
  function createElements(library3, schema2) {
    if (Array.isArray(schema2)) {
      const els2 = schema2.map(createElement2.bind(null, library3));
      return (iterationData) => els2.map((element2) => element2(iterationData));
    }
    const element = createElement2(library3, schema2);
    return (iterationData) => element(iterationData);
  }
  const providers2 = [];
  function provider(compiled, hints = {}) {
    const compiledFns = {};
    providers2.push((callback, key) => {
      compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));
    });
    return () => compiledFns[instanceKey]();
  }
  return function createInstance(providerCallback, key) {
    const memoKey = JSON.stringify(schema);
    const [render3, compiledProviders] = has$3(memo, memoKey) ? memo[memoKey] : [createElements(library2, schema), providers2];
    memo[memoKey] = [render3, compiledProviders];
    compiledProviders.forEach((compiledProvider) => {
      compiledProvider(providerCallback, key);
    });
    return () => {
      instanceKey = key;
      return render3();
    };
  };
}
function useScope(token2, defaultValue) {
  const scopedData = instanceScopes.get(instanceKey) || [];
  let scopedValue = void 0;
  if (scopedData.length) {
    scopedValue = getValue$1(scopedData, token2.split("."));
  }
  return scopedValue === void 0 ? defaultValue : scopedValue;
}
function slotData(data, key) {
  return new Proxy(data, {
    get(...args) {
      let data2 = void 0;
      const property2 = args[1];
      if (typeof property2 === "string") {
        const prevKey = instanceKey;
        instanceKey = key;
        data2 = useScope(property2, void 0);
        instanceKey = prevKey;
      }
      return data2 !== void 0 ? data2 : Reflect.get(...args);
    }
  });
}
function createRenderFn(instanceCreator, data, instanceKey2) {
  return instanceCreator((requirements, hints = {}) => {
    return requirements.reduce((tokens, token2) => {
      if (token2.startsWith("slots.")) {
        const slot = token2.substring(6);
        const hasSlot = data.slots && has$3(data.slots, slot);
        if (hints.if) {
          tokens[token2] = () => hasSlot;
        } else if (data.slots && hasSlot) {
          const scopedData = slotData(data, instanceKey2);
          tokens[token2] = () => data.slots[slot](scopedData);
          return tokens;
        }
      }
      const value = getRef(token2, data);
      tokens[token2] = () => useScope(token2, value.value);
      return tokens;
    }, {});
  }, instanceKey2);
}
let i$2 = 0;
const FormKitSchema = defineComponent({
  name: "FormKitSchema",
  props: {
    schema: {
      type: [Array, Object],
      required: true
    },
    data: {
      type: Object,
      default: () => ({})
    },
    library: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props2, context) {
    const instance = getCurrentInstance();
    let instanceKey2 = Symbol(String(i$2++));
    instanceScopes.set(instanceKey2, []);
    let provider = parseSchema(props2.library, props2.schema);
    let render3;
    let data;
    watch$1(() => props2.schema, (newSchema, oldSchema) => {
      var _a;
      instanceKey2 = Symbol(String(i$2++));
      provider = parseSchema(props2.library, props2.schema);
      render3 = createRenderFn(provider, data, instanceKey2);
      if (newSchema === oldSchema) {
        ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();
      }
    }, { deep: true });
    watchEffect(() => {
      data = Object.assign(reactive(props2.data), {
        slots: context.slots
      });
      render3 = createRenderFn(provider, data, instanceKey2);
    });
    return () => render3();
  }
});
const nativeProps = {
  config: {
    type: Object,
    default: {}
  },
  classes: {
    type: Object,
    required: false
  },
  delay: {
    type: Number,
    required: false
  },
  errors: {
    type: Array,
    default: []
  },
  inputErrors: {
    type: Object,
    default: () => ({})
  },
  index: {
    type: Number,
    required: false
  },
  id: {
    type: String,
    required: false
  },
  modelValue: {
    required: false
  },
  name: {
    type: String,
    required: false
  },
  parent: {
    type: Object,
    required: false
  },
  plugins: {
    type: Array,
    default: []
  },
  sectionsSchema: {
    type: Object,
    default: {}
  },
  type: {
    type: [String, Object],
    default: "text"
  },
  validation: {
    type: [String, Array],
    required: false
  },
  validationMessages: {
    type: Object,
    required: false
  },
  validationRules: {
    type: Object,
    required: false
  },
  validationLabel: {
    type: [String, Function],
    required: false
  }
};
const props = nativeProps;
const parentSymbol = Symbol("FormKitParent");
const FormKit = defineComponent({
  props,
  emits: {
    input: (_value, _node) => true,
    inputRaw: (_value, _node) => true,
    "update:modelValue": (_value) => true,
    node: (node) => !!node,
    submit: (_data, _node) => true,
    submitRaw: (_event, _node) => true
  },
  inheritAttrs: false,
  setup(props2, context) {
    const node = useInput(props2, context);
    if (!node.props.definition)
      error$1(600, node);
    if (node.props.definition.component) {
      return () => {
        var _a;
        return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {
          context: node.context
        }, __spreadValues({}, context.slots));
      };
    }
    const schema = ref([]);
    const generateSchema = () => {
      var _a, _b;
      const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;
      if (!schemaDefinition)
        error$1(601, node);
      schema.value = typeof schemaDefinition === "function" ? schemaDefinition(__spreadValues({}, props2.sectionsSchema)) : schemaDefinition;
    };
    generateSchema();
    node.on("schema", generateSchema);
    context.emit("node", node);
    const library2 = node.props.definition.library;
    context.expose({ node });
    return () => h(FormKitSchema, { schema: schema.value, data: node.context, library: library2 }, __spreadValues({}, context.slots));
  }
});
function createPlugin(app, options2) {
  app.component(options2.alias || "FormKit", FormKit).component(options2.schemaAlias || "FormKitSchema", FormKitSchema);
  return {
    get: getNode$1,
    setLocale: (locale) => {
      var _a;
      if ((_a = options2.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {
        options2.config.rootConfig.locale = locale;
      }
    },
    clearErrors,
    setErrors,
    submit: submitForm,
    reset
  };
}
const optionsSymbol = Symbol.for("FormKitOptions");
const configSymbol = Symbol.for("FormKitConfig");
const plugin = {
  install(app, _options) {
    const options2 = Object.assign({
      alias: "FormKit",
      schemaAlias: "FormKitSchema"
    }, typeof _options === "function" ? _options() : _options);
    const rootConfig = createConfig$1(options2.config || {});
    options2.config = { rootConfig };
    app.config.globalProperties.$formkit = createPlugin(app, options2);
    app.provide(optionsSymbol, options2);
    app.provide(configSymbol, rootConfig);
  }
};
const invalidGet = Symbol();
function watchVerbose(obj, callback) {
  const watchers = {};
  const applyWatch = (paths) => {
    for (const path of paths) {
      if (path.__str in watchers)
        watchers[path.__str]();
      watchers[path.__str] = watch$1(touch.bind(null, obj, path), dispatcher.bind(null, path), { deep: false });
    }
  };
  const clearWatch = (path) => {
    if (!path.length)
      return;
    for (const key in watchers) {
      if (`${key}`.startsWith(`${path.__str}.`)) {
        watchers[key]();
        delete watchers[key];
      }
    }
  };
  const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);
  applyWatch(getPaths(obj));
}
function createDispatcher(obj, callback, applyWatch, clearChildWatches) {
  return (path) => {
    const value = get$2(obj, path);
    if (value === invalidGet)
      return;
    if (path.__deep)
      clearChildWatches(path);
    if (typeof value === "object")
      applyWatch(getPaths(value, [path], ...path));
    callback(path, value, obj);
  };
}
function touch(obj, path) {
  const value = get$2(obj, path);
  return value && typeof value === "object" ? Object.keys(value) : value;
}
function get$2(obj, path) {
  if (isRef(obj)) {
    if (path.length === 0)
      return obj.value;
    obj = obj.value;
  }
  return path.reduce((value, segment) => {
    if (value === invalidGet)
      return value;
    if (value === null || typeof value !== "object") {
      return invalidGet;
    }
    return value[segment];
  }, obj);
}
function getPaths(obj, paths = [], ...parents) {
  if (obj === null)
    return paths;
  if (!parents.length) {
    const path = Object.defineProperty([], "__str", {
      value: ""
    });
    obj = isRef(obj) ? obj.value : obj;
    if (obj && typeof obj === "object") {
      Object.defineProperty(path, "__deep", { value: true });
      paths.push(path);
    } else {
      return [path];
    }
  }
  if (obj === null || typeof obj !== "object")
    return paths;
  for (const key in obj) {
    const path = parents.concat(key);
    Object.defineProperty(path, "__str", { value: path.join(".") });
    const value = obj[key];
    if (isPojo(value) || Array.isArray(value)) {
      paths.push(Object.defineProperty(path, "__deep", { value: true }));
      paths = paths.concat(getPaths(value, [], ...path));
    } else {
      paths.push(path);
    }
  }
  return paths;
}
function useRaw(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (isReactive(obj)) {
    obj = toRaw(obj);
  } else if (isRef(obj)) {
    obj = isReactive(obj.value) ? useRaw(obj.value) : obj.value;
  }
  return obj;
}
const pseudoProps = [
  "help",
  "label",
  "ignore",
  "disabled",
  "preserve",
  /^preserve(-e|E)rrors/,
  /^[a-z]+(?:-visibility|Visibility)$/,
  /^[a-zA-Z-]+(?:-class|Class)$/
];
function classesToNodeProps(node, props2) {
  if (props2.classes) {
    Object.keys(props2.classes).forEach((key) => {
      if (typeof key === "string") {
        node.props[`_${key}Class`] = props2.classes[key];
        if (isObject$4(props2.classes[key]) && key === "inner")
          Object.values(props2.classes[key]);
      }
    });
  }
}
function onlyListeners(props2) {
  if (!props2)
    return {};
  const knownListeners = ["Submit", "SubmitRaw"].reduce((listeners, listener3) => {
    const name = `on${listener3}`;
    if (name in props2) {
      if (typeof props2[name] === "function") {
        listeners[name] = props2[name];
      }
    }
    return listeners;
  }, {});
  return knownListeners;
}
function useInput(props2, context, options2 = {}) {
  const config2 = Object.assign({}, inject(optionsSymbol) || {}, options2);
  const instance = getCurrentInstance();
  const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);
  const isVModeled = props2.modelValue !== void 0;
  const value = props2.modelValue !== void 0 ? props2.modelValue : cloneAny(context.attrs.value);
  function createInitialProps() {
    const initialProps2 = __spreadValues(__spreadValues({}, nodeProps(props2)), listeners);
    const attrs = except(nodeProps(context.attrs), pseudoProps);
    initialProps2.attrs = attrs;
    const propValues = only(nodeProps(context.attrs), pseudoProps);
    for (const propName in propValues) {
      initialProps2[camel(propName)] = propValues[propName];
    }
    const classesProps = { props: {} };
    classesToNodeProps(classesProps, props2);
    Object.assign(initialProps2, classesProps.props);
    if (typeof initialProps2.type !== "string") {
      initialProps2.definition = initialProps2.type;
      delete initialProps2.type;
    }
    return initialProps2;
  }
  const initialProps = createInitialProps();
  const parent = initialProps.ignore ? null : props2.parent || inject(parentSymbol, null);
  const node = createNode(extend$1(config2 || {}, {
    name: props2.name || void 0,
    value,
    parent,
    plugins: (config2.plugins || []).concat(props2.plugins),
    config: props2.config,
    props: initialProps,
    index: props2.index
  }, false, true));
  if (!node.props.definition)
    error$1(600, node);
  const lateBoundProps = ref(new Set(node.props.definition.props || []));
  node.on("added-props", ({ payload: lateProps }) => {
    if (Array.isArray(lateProps))
      lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));
  });
  const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop2) => {
    if (typeof prop2 === "string") {
      names.push(camel(prop2));
      names.push(kebab(prop2));
    } else {
      names.push(prop2);
    }
    return names;
  }, []));
  watchEffect(() => classesToNodeProps(node, props2));
  const passThrough = nodeProps(props2);
  for (const prop2 in passThrough) {
    watch$1(() => props2[prop2], () => {
      if (props2[prop2] !== void 0) {
        node.props[prop2] = props2[prop2];
      }
    });
  }
  const attributeWatchers = /* @__PURE__ */ new Set();
  const possibleProps = nodeProps(context.attrs);
  watchEffect(() => {
    watchAttributes(only(possibleProps, pseudoPropNames.value));
  });
  function watchAttributes(attrProps) {
    attributeWatchers.forEach((stop2) => {
      stop2();
      attributeWatchers.delete(stop2);
    });
    for (const prop2 in attrProps) {
      const camelName = camel(prop2);
      attributeWatchers.add(watch$1(() => context.attrs[prop2], () => {
        node.props[camelName] = context.attrs[prop2];
      }));
    }
  }
  watchEffect(() => {
    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);
    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);
  });
  watchEffect(() => {
    const messages2 = props2.errors.map((error2) => createMessage({
      key: slugify(error2),
      type: "error",
      value: error2,
      meta: { source: "prop" }
    }));
    node.store.apply(messages2, (message2) => message2.type === "error" && message2.meta.source === "prop");
  });
  if (node.type !== "input") {
    const sourceKey = `${node.name}-prop`;
    watchEffect(() => {
      const keys2 = Object.keys(props2.inputErrors);
      const messages2 = keys2.reduce((messages3, key) => {
        let value2 = props2.inputErrors[key];
        if (typeof value2 === "string")
          value2 = [value2];
        if (Array.isArray(value2)) {
          messages3[key] = value2.map((error2) => createMessage({
            key: error2,
            type: "error",
            value: error2,
            meta: { source: sourceKey }
          }));
        }
        return messages3;
      }, {});
      node.store.apply(messages2, (message2) => message2.type === "error" && message2.meta.source === sourceKey);
    });
  }
  watchEffect(() => Object.assign(node.config, props2.config));
  if (node.type !== "input") {
    provide(parentSymbol, node);
  }
  let inputTimeout;
  const mutex = /* @__PURE__ */ new WeakSet();
  node.on("modelUpdated", () => {
    var _a, _b;
    context.emit("inputRaw", (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);
    clearTimeout(inputTimeout);
    inputTimeout = setTimeout(context.emit, 20, "input", (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);
    if (isVModeled && node.context) {
      const newValue = useRaw(node.context.value);
      if (isObject$4(newValue) && useRaw(props2.modelValue) !== newValue) {
        mutex.add(newValue);
      }
      context.emit("update:modelValue", newValue);
    }
  });
  if (isVModeled) {
    watchVerbose(toRef(props2, "modelValue"), (path, value2) => {
      var _a;
      const rawValue = useRaw(value2);
      if (isObject$4(rawValue) && mutex.has(rawValue)) {
        return mutex.delete(rawValue);
      }
      if (!path.length)
        node.input(value2, false);
      else
        (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value2, false);
    });
  }
  onUnmounted(() => node.destroy());
  return node;
}
let totalCreated = 1;
function isComponent(obj) {
  return typeof obj === "function" && obj.length === 2 || typeof obj === "object" && !Array.isArray(obj) && !("$el" in obj) && !("$cmp" in obj) && !("if" in obj);
}
function createInput(schemaOrComponent, definitionOptions = {}) {
  const definition = __spreadValues({
    type: "input"
  }, definitionOptions);
  let schema = void 0;
  if (isComponent(schemaOrComponent)) {
    const cmpName = `SchemaComponent${totalCreated++}`;
    schema = () => ({
      $cmp: cmpName,
      props: {
        context: "$node.context"
      }
    });
    definition.library = { [cmpName]: markRaw(schemaOrComponent) };
  } else {
    schema = schemaOrComponent;
  }
  definition.schema = useSchema(schema || "Schema undefined");
  return definition;
}
const vueBindings = function vueBindings2(node) {
  node.ledger.count("blocking", (m) => m.blocking);
  const isValid = ref(!node.ledger.value("blocking"));
  node.ledger.count("errors", (m) => m.type === "error");
  const hasErrors = ref(!!node.ledger.value("errors"));
  let hasTicked = false;
  nextTick(() => {
    hasTicked = true;
  });
  const availableMessages = reactive(node.store.reduce((store2, message2) => {
    if (message2.visible) {
      store2[message2.key] = message2;
    }
    return store2;
  }, {}));
  const validationVisibility = ref(node.props.validationVisibility || "blur");
  node.on("prop:validationVisibility", ({ payload }) => {
    validationVisibility.value = payload;
  });
  const hasShownErrors = ref(validationVisibility.value === "live");
  const validationVisible = computed(() => {
    if (context.state.submitted)
      return true;
    if (!hasShownErrors.value && !context.state.settled) {
      return false;
    }
    switch (validationVisibility.value) {
      case "live":
        return true;
      case "blur":
        return context.state.blurred;
      case "dirty":
        return context.state.dirty;
      default:
        return false;
    }
  });
  const isComplete = computed(() => {
    return hasValidation.value ? isValid.value && !hasErrors.value : context.state.dirty && !empty$2(context.value);
  });
  const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);
  node.on("prop:parsedRules", ({ payload: rules }) => {
    hasValidation.value = Array.isArray(rules) && rules.length > 0;
  });
  const messages2 = computed(() => {
    const visibleMessages = {};
    for (const key in availableMessages) {
      const message2 = availableMessages[key];
      if (message2.type !== "validation" || validationVisible.value) {
        visibleMessages[key] = message2;
      }
    }
    return visibleMessages;
  });
  const ui = reactive(node.store.reduce((messages3, message2) => {
    if (message2.type === "ui" && message2.visible)
      messages3[message2.key] = message2;
    return messages3;
  }, {}));
  const cachedClasses = reactive({});
  const classes = new Proxy(cachedClasses, {
    get(...args) {
      const [target2, property2] = args;
      let className = Reflect.get(...args);
      if (!className && typeof property2 === "string") {
        if (!has$3(target2, property2) && !property2.startsWith("__v")) {
          const observedNode = createObserver(node);
          observedNode.watch((node2) => {
            const rootClasses = typeof node2.config.rootClasses === "function" ? node2.config.rootClasses(property2, node2) : {};
            const globalConfigClasses = node2.config.classes ? createClasses(property2, node2, node2.config.classes[property2]) : {};
            const classesPropClasses = createClasses(property2, node2, node2.props[`_${property2}Class`]);
            const sectionPropClasses = createClasses(property2, node2, node2.props[`${property2}Class`]);
            className = generateClassList(node2, property2, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);
            target2[property2] = className;
          });
        }
      }
      return className;
    }
  });
  const describedBy = computed(() => {
    const describers = [];
    if (context.help) {
      describers.push(`help-${node.props.id}`);
    }
    for (const key in messages2.value) {
      describers.push(`${node.props.id}-${key}`);
    }
    return describers.length ? describers.join(" ") : void 0;
  });
  const value = ref(node.value);
  const _value = ref(node.value);
  const context = reactive({
    _value,
    attrs: node.props.attrs,
    disabled: node.props.disabled,
    describedBy,
    fns: {
      length: (obj) => Object.keys(obj).length,
      number: (value2) => Number(value2),
      string: (value2) => String(value2),
      json: (value2) => JSON.stringify(value2),
      eq: eq$1
    },
    handlers: {
      blur: () => node.store.set(createMessage({ key: "blurred", visible: false, value: true })),
      touch: () => {
        node.store.set(createMessage({ key: "dirty", visible: false, value: true }));
      },
      DOMInput: (e) => {
        node.input(e.target.value);
        node.emit("dom-input-event", e);
      }
    },
    help: node.props.help,
    id: node.props.id,
    label: node.props.label,
    messages: messages2,
    node: markRaw(node),
    options: node.props.options,
    state: {
      blurred: false,
      complete: isComplete,
      dirty: false,
      submitted: false,
      settled: node.isSettled,
      valid: isValid,
      errors: hasErrors,
      rules: hasValidation,
      validationVisible
    },
    type: node.props.type,
    ui,
    value,
    classes
  });
  node.on("created", () => {
    if (!eq$1(context.value, node.value)) {
      _value.value = node.value;
      value.value = node.value;
      triggerRef(value);
      triggerRef(_value);
    }
  });
  node.on("settled", ({ payload: isSettled }) => {
    context.state.settled = isSettled;
  });
  function observeProps(observe2) {
    observe2.forEach((prop2) => {
      prop2 = camel(prop2);
      if (!has$3(context, prop2) && has$3(node.props, prop2)) {
        context[prop2] = node.props[prop2];
      }
      node.on(`prop:${prop2}`, ({ payload }) => {
        context[prop2] = payload;
      });
    });
  }
  const rootProps = [
    "help",
    "label",
    "disabled",
    "options",
    "type",
    "attrs",
    "preserve",
    "preserveErrors",
    "id"
  ];
  observeProps(rootProps);
  function definedAs(definition) {
    if (definition.props)
      observeProps(definition.props);
  }
  node.props.definition && definedAs(node.props.definition);
  node.on("added-props", ({ payload }) => observeProps(payload));
  node.on("input", ({ payload }) => {
    _value.value = payload;
    triggerRef(_value);
  });
  node.on("commit", ({ payload }) => {
    value.value = _value.value = payload;
    triggerRef(value);
    node.emit("modelUpdated");
    if (!context.state.dirty && node.isCreated && hasTicked)
      context.handlers.touch();
    if (isComplete && node.type === "input" && hasErrors.value && !undefine(node.props.preserveErrors)) {
      node.store.filter((message2) => {
        var _a;
        return !(message2.type === "error" && ((_a = message2.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true);
      });
    }
  });
  const updateState = async (message2) => {
    if (message2.type === "ui" && message2.visible && !message2.meta.showAsMessage) {
      ui[message2.key] = message2;
    } else if (message2.visible) {
      availableMessages[message2.key] = message2;
    } else if (message2.type === "state") {
      context.state[message2.key] = !!message2.value;
    }
  };
  node.on("message-added", (e) => updateState(e.payload));
  node.on("message-updated", (e) => updateState(e.payload));
  node.on("message-removed", ({ payload: message2 }) => {
    delete ui[message2.key];
    delete availableMessages[message2.key];
    delete context.state[message2.key];
  });
  node.on("settled:blocking", () => {
    isValid.value = true;
  });
  node.on("unsettled:blocking", () => {
    isValid.value = false;
  });
  node.on("settled:errors", () => {
    hasErrors.value = false;
  });
  node.on("unsettled:errors", () => {
    hasErrors.value = true;
  });
  watch$1(validationVisible, (value2) => {
    if (value2) {
      hasShownErrors.value = true;
    }
  });
  node.context = context;
  node.emit("context", node, false);
};
const defaultConfig = (options2 = {}) => {
  const _a = options2, { rules = {}, locales = {}, inputs: inputs$1 = {}, messages: messages2 = {}, locale = void 0 } = _a, nodeOptions = __objRest(_a, ["rules", "locales", "inputs", "messages", "locale"]);
  const validation = createValidationPlugin(__spreadValues(__spreadValues({}, defaultRules), rules || {}));
  const i18n = createI18nPlugin(extend$1(__spreadValues({ en }, locales || {}), messages2));
  const library2 = createLibraryPlugin(inputs, inputs$1);
  return extend$1(__spreadValues({
    plugins: [library2, vueBindings, i18n, validation]
  }, !locale ? {} : { config: { locale } }), nodeOptions || {}, true);
};
function generateClasses(classes) {
  const classesBySectionKey = {};
  Object.keys(classes).forEach((type) => {
    Object.keys(classes[type]).forEach((sectionKey) => {
      if (!classesBySectionKey[sectionKey]) {
        classesBySectionKey[sectionKey] = {
          [type]: classes[type][sectionKey]
        };
      } else {
        classesBySectionKey[sectionKey][type] = classes[type][sectionKey];
      }
    });
  });
  Object.keys(classesBySectionKey).forEach((sectionKey) => {
    const classesObject = classesBySectionKey[sectionKey];
    classesBySectionKey[sectionKey] = function(node, sectionKey2) {
      return addClassesBySection(node, sectionKey2, classesObject);
    };
  });
  return classesBySectionKey;
}
function addClassesBySection(node, _sectionKey, classesByType) {
  const type = node.props.type;
  let classList2 = "";
  if (classesByType.global) {
    classList2 += classesByType.global + " ";
  }
  if (classesByType[type]) {
    classList2 += classesByType[type];
  }
  const listParts = classList2.split("$reset");
  if (listParts.length > 1) {
    return `$reset ${listParts[listParts.length - 1].trim()}`;
  }
  return listParts[0].trim();
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var utils$1 = {};
const Aacute = "\xC1";
const aacute = "\xE1";
const Abreve = "\u0102";
const abreve = "\u0103";
const ac = "\u223E";
const acd = "\u223F";
const acE = "\u223E\u0333";
const Acirc = "\xC2";
const acirc = "\xE2";
const acute = "\xB4";
const Acy = "\u0410";
const acy = "\u0430";
const AElig = "\xC6";
const aelig = "\xE6";
const af = "\u2061";
const Afr = "\u{1D504}";
const afr = "\u{1D51E}";
const Agrave = "\xC0";
const agrave = "\xE0";
const alefsym = "\u2135";
const aleph = "\u2135";
const Alpha = "\u0391";
const alpha = "\u03B1";
const Amacr = "\u0100";
const amacr = "\u0101";
const amalg = "\u2A3F";
const amp = "&";
const AMP = "&";
const andand = "\u2A55";
const And = "\u2A53";
const and = "\u2227";
const andd = "\u2A5C";
const andslope = "\u2A58";
const andv = "\u2A5A";
const ang = "\u2220";
const ange = "\u29A4";
const angle = "\u2220";
const angmsdaa = "\u29A8";
const angmsdab = "\u29A9";
const angmsdac = "\u29AA";
const angmsdad = "\u29AB";
const angmsdae = "\u29AC";
const angmsdaf = "\u29AD";
const angmsdag = "\u29AE";
const angmsdah = "\u29AF";
const angmsd = "\u2221";
const angrt = "\u221F";
const angrtvb = "\u22BE";
const angrtvbd = "\u299D";
const angsph = "\u2222";
const angst = "\xC5";
const angzarr = "\u237C";
const Aogon = "\u0104";
const aogon = "\u0105";
const Aopf = "\u{1D538}";
const aopf = "\u{1D552}";
const apacir = "\u2A6F";
const ap = "\u2248";
const apE = "\u2A70";
const ape = "\u224A";
const apid = "\u224B";
const apos = "'";
const ApplyFunction = "\u2061";
const approx = "\u2248";
const approxeq = "\u224A";
const Aring = "\xC5";
const aring = "\xE5";
const Ascr = "\u{1D49C}";
const ascr = "\u{1D4B6}";
const Assign = "\u2254";
const ast = "*";
const asymp = "\u2248";
const asympeq = "\u224D";
const Atilde = "\xC3";
const atilde = "\xE3";
const Auml = "\xC4";
const auml = "\xE4";
const awconint = "\u2233";
const awint = "\u2A11";
const backcong = "\u224C";
const backepsilon = "\u03F6";
const backprime = "\u2035";
const backsim = "\u223D";
const backsimeq = "\u22CD";
const Backslash = "\u2216";
const Barv = "\u2AE7";
const barvee = "\u22BD";
const barwed = "\u2305";
const Barwed = "\u2306";
const barwedge = "\u2305";
const bbrk = "\u23B5";
const bbrktbrk = "\u23B6";
const bcong = "\u224C";
const Bcy = "\u0411";
const bcy = "\u0431";
const bdquo = "\u201E";
const becaus = "\u2235";
const because = "\u2235";
const Because = "\u2235";
const bemptyv = "\u29B0";
const bepsi = "\u03F6";
const bernou = "\u212C";
const Bernoullis = "\u212C";
const Beta = "\u0392";
const beta = "\u03B2";
const beth = "\u2136";
const between2 = "\u226C";
const Bfr = "\u{1D505}";
const bfr = "\u{1D51F}";
const bigcap = "\u22C2";
const bigcirc = "\u25EF";
const bigcup = "\u22C3";
const bigodot = "\u2A00";
const bigoplus = "\u2A01";
const bigotimes = "\u2A02";
const bigsqcup = "\u2A06";
const bigstar = "\u2605";
const bigtriangledown = "\u25BD";
const bigtriangleup = "\u25B3";
const biguplus = "\u2A04";
const bigvee = "\u22C1";
const bigwedge = "\u22C0";
const bkarow = "\u290D";
const blacklozenge = "\u29EB";
const blacksquare = "\u25AA";
const blacktriangle = "\u25B4";
const blacktriangledown = "\u25BE";
const blacktriangleleft = "\u25C2";
const blacktriangleright = "\u25B8";
const blank = "\u2423";
const blk12 = "\u2592";
const blk14 = "\u2591";
const blk34 = "\u2593";
const block$1 = "\u2588";
const bne = "=\u20E5";
const bnequiv = "\u2261\u20E5";
const bNot = "\u2AED";
const bnot = "\u2310";
const Bopf = "\u{1D539}";
const bopf = "\u{1D553}";
const bot = "\u22A5";
const bottom$1 = "\u22A5";
const bowtie = "\u22C8";
const boxbox = "\u29C9";
const boxdl = "\u2510";
const boxdL = "\u2555";
const boxDl = "\u2556";
const boxDL = "\u2557";
const boxdr = "\u250C";
const boxdR = "\u2552";
const boxDr = "\u2553";
const boxDR = "\u2554";
const boxh = "\u2500";
const boxH = "\u2550";
const boxhd = "\u252C";
const boxHd = "\u2564";
const boxhD = "\u2565";
const boxHD = "\u2566";
const boxhu = "\u2534";
const boxHu = "\u2567";
const boxhU = "\u2568";
const boxHU = "\u2569";
const boxminus = "\u229F";
const boxplus = "\u229E";
const boxtimes = "\u22A0";
const boxul = "\u2518";
const boxuL = "\u255B";
const boxUl = "\u255C";
const boxUL = "\u255D";
const boxur = "\u2514";
const boxuR = "\u2558";
const boxUr = "\u2559";
const boxUR = "\u255A";
const boxv = "\u2502";
const boxV = "\u2551";
const boxvh = "\u253C";
const boxvH = "\u256A";
const boxVh = "\u256B";
const boxVH = "\u256C";
const boxvl = "\u2524";
const boxvL = "\u2561";
const boxVl = "\u2562";
const boxVL = "\u2563";
const boxvr = "\u251C";
const boxvR = "\u255E";
const boxVr = "\u255F";
const boxVR = "\u2560";
const bprime = "\u2035";
const breve = "\u02D8";
const Breve = "\u02D8";
const brvbar = "\xA6";
const bscr = "\u{1D4B7}";
const Bscr = "\u212C";
const bsemi = "\u204F";
const bsim = "\u223D";
const bsime = "\u22CD";
const bsolb = "\u29C5";
const bsol = "\\";
const bsolhsub = "\u27C8";
const bull = "\u2022";
const bullet = "\u2022";
const bump = "\u224E";
const bumpE = "\u2AAE";
const bumpe = "\u224F";
const Bumpeq = "\u224E";
const bumpeq = "\u224F";
const Cacute = "\u0106";
const cacute = "\u0107";
const capand = "\u2A44";
const capbrcup = "\u2A49";
const capcap = "\u2A4B";
const cap = "\u2229";
const Cap = "\u22D2";
const capcup = "\u2A47";
const capdot = "\u2A40";
const CapitalDifferentialD = "\u2145";
const caps = "\u2229\uFE00";
const caret = "\u2041";
const caron = "\u02C7";
const Cayleys = "\u212D";
const ccaps = "\u2A4D";
const Ccaron = "\u010C";
const ccaron = "\u010D";
const Ccedil = "\xC7";
const ccedil = "\xE7";
const Ccirc = "\u0108";
const ccirc = "\u0109";
const Cconint = "\u2230";
const ccups = "\u2A4C";
const ccupssm = "\u2A50";
const Cdot = "\u010A";
const cdot = "\u010B";
const cedil = "\xB8";
const Cedilla = "\xB8";
const cemptyv = "\u29B2";
const cent = "\xA2";
const centerdot = "\xB7";
const CenterDot = "\xB7";
const cfr = "\u{1D520}";
const Cfr = "\u212D";
const CHcy = "\u0427";
const chcy = "\u0447";
const check = "\u2713";
const checkmark = "\u2713";
const Chi = "\u03A7";
const chi = "\u03C7";
const circ = "\u02C6";
const circeq = "\u2257";
const circlearrowleft = "\u21BA";
const circlearrowright = "\u21BB";
const circledast = "\u229B";
const circledcirc = "\u229A";
const circleddash = "\u229D";
const CircleDot = "\u2299";
const circledR = "\xAE";
const circledS = "\u24C8";
const CircleMinus = "\u2296";
const CirclePlus = "\u2295";
const CircleTimes = "\u2297";
const cir = "\u25CB";
const cirE = "\u29C3";
const cire = "\u2257";
const cirfnint = "\u2A10";
const cirmid = "\u2AEF";
const cirscir = "\u29C2";
const ClockwiseContourIntegral = "\u2232";
const CloseCurlyDoubleQuote = "\u201D";
const CloseCurlyQuote = "\u2019";
const clubs = "\u2663";
const clubsuit = "\u2663";
const colon = ":";
const Colon = "\u2237";
const Colone = "\u2A74";
const colone = "\u2254";
const coloneq = "\u2254";
const comma = ",";
const commat = "@";
const comp = "\u2201";
const compfn = "\u2218";
const complement = "\u2201";
const complexes = "\u2102";
const cong = "\u2245";
const congdot = "\u2A6D";
const Congruent = "\u2261";
const conint = "\u222E";
const Conint = "\u222F";
const ContourIntegral = "\u222E";
const copf = "\u{1D554}";
const Copf = "\u2102";
const coprod = "\u2210";
const Coproduct = "\u2210";
const copy$1 = "\xA9";
const COPY = "\xA9";
const copysr = "\u2117";
const CounterClockwiseContourIntegral = "\u2233";
const crarr = "\u21B5";
const cross = "\u2717";
const Cross = "\u2A2F";
const Cscr = "\u{1D49E}";
const cscr = "\u{1D4B8}";
const csub = "\u2ACF";
const csube = "\u2AD1";
const csup = "\u2AD0";
const csupe = "\u2AD2";
const ctdot = "\u22EF";
const cudarrl = "\u2938";
const cudarrr = "\u2935";
const cuepr = "\u22DE";
const cuesc = "\u22DF";
const cularr = "\u21B6";
const cularrp = "\u293D";
const cupbrcap = "\u2A48";
const cupcap = "\u2A46";
const CupCap = "\u224D";
const cup = "\u222A";
const Cup = "\u22D3";
const cupcup = "\u2A4A";
const cupdot = "\u228D";
const cupor = "\u2A45";
const cups = "\u222A\uFE00";
const curarr = "\u21B7";
const curarrm = "\u293C";
const curlyeqprec = "\u22DE";
const curlyeqsucc = "\u22DF";
const curlyvee = "\u22CE";
const curlywedge = "\u22CF";
const curren = "\xA4";
const curvearrowleft = "\u21B6";
const curvearrowright = "\u21B7";
const cuvee = "\u22CE";
const cuwed = "\u22CF";
const cwconint = "\u2232";
const cwint = "\u2231";
const cylcty = "\u232D";
const dagger = "\u2020";
const Dagger = "\u2021";
const daleth = "\u2138";
const darr = "\u2193";
const Darr = "\u21A1";
const dArr = "\u21D3";
const dash = "\u2010";
const Dashv = "\u2AE4";
const dashv = "\u22A3";
const dbkarow = "\u290F";
const dblac = "\u02DD";
const Dcaron = "\u010E";
const dcaron = "\u010F";
const Dcy = "\u0414";
const dcy = "\u0434";
const ddagger = "\u2021";
const ddarr = "\u21CA";
const DD = "\u2145";
const dd = "\u2146";
const DDotrahd = "\u2911";
const ddotseq = "\u2A77";
const deg = "\xB0";
const Del = "\u2207";
const Delta = "\u0394";
const delta = "\u03B4";
const demptyv = "\u29B1";
const dfisht = "\u297F";
const Dfr = "\u{1D507}";
const dfr = "\u{1D521}";
const dHar = "\u2965";
const dharl = "\u21C3";
const dharr = "\u21C2";
const DiacriticalAcute = "\xB4";
const DiacriticalDot = "\u02D9";
const DiacriticalDoubleAcute = "\u02DD";
const DiacriticalGrave = "`";
const DiacriticalTilde = "\u02DC";
const diam = "\u22C4";
const diamond = "\u22C4";
const Diamond = "\u22C4";
const diamondsuit = "\u2666";
const diams = "\u2666";
const die = "\xA8";
const DifferentialD = "\u2146";
const digamma = "\u03DD";
const disin = "\u22F2";
const div$1 = "\xF7";
const divide = "\xF7";
const divideontimes = "\u22C7";
const divonx = "\u22C7";
const DJcy = "\u0402";
const djcy = "\u0452";
const dlcorn = "\u231E";
const dlcrop = "\u230D";
const dollar = "$";
const Dopf = "\u{1D53B}";
const dopf = "\u{1D555}";
const Dot = "\xA8";
const dot = "\u02D9";
const DotDot = "\u20DC";
const doteq = "\u2250";
const doteqdot = "\u2251";
const DotEqual = "\u2250";
const dotminus = "\u2238";
const dotplus = "\u2214";
const dotsquare = "\u22A1";
const doublebarwedge = "\u2306";
const DoubleContourIntegral = "\u222F";
const DoubleDot = "\xA8";
const DoubleDownArrow = "\u21D3";
const DoubleLeftArrow = "\u21D0";
const DoubleLeftRightArrow = "\u21D4";
const DoubleLeftTee = "\u2AE4";
const DoubleLongLeftArrow = "\u27F8";
const DoubleLongLeftRightArrow = "\u27FA";
const DoubleLongRightArrow = "\u27F9";
const DoubleRightArrow = "\u21D2";
const DoubleRightTee = "\u22A8";
const DoubleUpArrow = "\u21D1";
const DoubleUpDownArrow = "\u21D5";
const DoubleVerticalBar = "\u2225";
const DownArrowBar = "\u2913";
const downarrow = "\u2193";
const DownArrow = "\u2193";
const Downarrow = "\u21D3";
const DownArrowUpArrow = "\u21F5";
const DownBreve = "\u0311";
const downdownarrows = "\u21CA";
const downharpoonleft = "\u21C3";
const downharpoonright = "\u21C2";
const DownLeftRightVector = "\u2950";
const DownLeftTeeVector = "\u295E";
const DownLeftVectorBar = "\u2956";
const DownLeftVector = "\u21BD";
const DownRightTeeVector = "\u295F";
const DownRightVectorBar = "\u2957";
const DownRightVector = "\u21C1";
const DownTeeArrow = "\u21A7";
const DownTee = "\u22A4";
const drbkarow = "\u2910";
const drcorn = "\u231F";
const drcrop = "\u230C";
const Dscr = "\u{1D49F}";
const dscr = "\u{1D4B9}";
const DScy = "\u0405";
const dscy = "\u0455";
const dsol = "\u29F6";
const Dstrok = "\u0110";
const dstrok = "\u0111";
const dtdot = "\u22F1";
const dtri = "\u25BF";
const dtrif = "\u25BE";
const duarr = "\u21F5";
const duhar = "\u296F";
const dwangle = "\u29A6";
const DZcy = "\u040F";
const dzcy = "\u045F";
const dzigrarr = "\u27FF";
const Eacute = "\xC9";
const eacute = "\xE9";
const easter = "\u2A6E";
const Ecaron = "\u011A";
const ecaron = "\u011B";
const Ecirc = "\xCA";
const ecirc = "\xEA";
const ecir = "\u2256";
const ecolon = "\u2255";
const Ecy = "\u042D";
const ecy = "\u044D";
const eDDot = "\u2A77";
const Edot = "\u0116";
const edot = "\u0117";
const eDot = "\u2251";
const ee = "\u2147";
const efDot = "\u2252";
const Efr = "\u{1D508}";
const efr = "\u{1D522}";
const eg = "\u2A9A";
const Egrave = "\xC8";
const egrave = "\xE8";
const egs = "\u2A96";
const egsdot = "\u2A98";
const el = "\u2A99";
const Element$1 = "\u2208";
const elinters = "\u23E7";
const ell = "\u2113";
const els = "\u2A95";
const elsdot = "\u2A97";
const Emacr = "\u0112";
const emacr = "\u0113";
const empty$1 = "\u2205";
const emptyset = "\u2205";
const EmptySmallSquare = "\u25FB";
const emptyv = "\u2205";
const EmptyVerySmallSquare = "\u25AB";
const emsp13 = "\u2004";
const emsp14 = "\u2005";
const emsp = "\u2003";
const ENG = "\u014A";
const eng = "\u014B";
const ensp = "\u2002";
const Eogon = "\u0118";
const eogon = "\u0119";
const Eopf = "\u{1D53C}";
const eopf = "\u{1D556}";
const epar = "\u22D5";
const eparsl = "\u29E3";
const eplus = "\u2A71";
const epsi = "\u03B5";
const Epsilon = "\u0395";
const epsilon = "\u03B5";
const epsiv = "\u03F5";
const eqcirc = "\u2256";
const eqcolon = "\u2255";
const eqsim = "\u2242";
const eqslantgtr = "\u2A96";
const eqslantless = "\u2A95";
const Equal = "\u2A75";
const equals = "=";
const EqualTilde = "\u2242";
const equest = "\u225F";
const Equilibrium = "\u21CC";
const equiv = "\u2261";
const equivDD = "\u2A78";
const eqvparsl = "\u29E5";
const erarr = "\u2971";
const erDot = "\u2253";
const escr = "\u212F";
const Escr = "\u2130";
const esdot = "\u2250";
const Esim = "\u2A73";
const esim = "\u2242";
const Eta = "\u0397";
const eta = "\u03B7";
const ETH = "\xD0";
const eth = "\xF0";
const Euml = "\xCB";
const euml = "\xEB";
const euro = "\u20AC";
const excl = "!";
const exist = "\u2203";
const Exists = "\u2203";
const expectation = "\u2130";
const exponentiale = "\u2147";
const ExponentialE = "\u2147";
const fallingdotseq = "\u2252";
const Fcy = "\u0424";
const fcy = "\u0444";
const female = "\u2640";
const ffilig = "\uFB03";
const fflig = "\uFB00";
const ffllig = "\uFB04";
const Ffr = "\u{1D509}";
const ffr = "\u{1D523}";
const filig = "\uFB01";
const FilledSmallSquare = "\u25FC";
const FilledVerySmallSquare = "\u25AA";
const fjlig = "fj";
const flat = "\u266D";
const fllig = "\uFB02";
const fltns = "\u25B1";
const fnof = "\u0192";
const Fopf = "\u{1D53D}";
const fopf = "\u{1D557}";
const forall = "\u2200";
const ForAll = "\u2200";
const fork = "\u22D4";
const forkv = "\u2AD9";
const Fouriertrf = "\u2131";
const fpartint = "\u2A0D";
const frac12 = "\xBD";
const frac13 = "\u2153";
const frac14 = "\xBC";
const frac15 = "\u2155";
const frac16 = "\u2159";
const frac18 = "\u215B";
const frac23 = "\u2154";
const frac25 = "\u2156";
const frac34 = "\xBE";
const frac35 = "\u2157";
const frac38 = "\u215C";
const frac45 = "\u2158";
const frac56 = "\u215A";
const frac58 = "\u215D";
const frac78 = "\u215E";
const frasl = "\u2044";
const frown = "\u2322";
const fscr = "\u{1D4BB}";
const Fscr = "\u2131";
const gacute = "\u01F5";
const Gamma = "\u0393";
const gamma = "\u03B3";
const Gammad = "\u03DC";
const gammad = "\u03DD";
const gap = "\u2A86";
const Gbreve = "\u011E";
const gbreve = "\u011F";
const Gcedil = "\u0122";
const Gcirc = "\u011C";
const gcirc = "\u011D";
const Gcy = "\u0413";
const gcy = "\u0433";
const Gdot = "\u0120";
const gdot = "\u0121";
const ge = "\u2265";
const gE = "\u2267";
const gEl = "\u2A8C";
const gel = "\u22DB";
const geq = "\u2265";
const geqq = "\u2267";
const geqslant = "\u2A7E";
const gescc = "\u2AA9";
const ges = "\u2A7E";
const gesdot = "\u2A80";
const gesdoto = "\u2A82";
const gesdotol = "\u2A84";
const gesl = "\u22DB\uFE00";
const gesles = "\u2A94";
const Gfr = "\u{1D50A}";
const gfr = "\u{1D524}";
const gg = "\u226B";
const Gg = "\u22D9";
const ggg = "\u22D9";
const gimel = "\u2137";
const GJcy = "\u0403";
const gjcy = "\u0453";
const gla = "\u2AA5";
const gl = "\u2277";
const glE = "\u2A92";
const glj = "\u2AA4";
const gnap = "\u2A8A";
const gnapprox = "\u2A8A";
const gne = "\u2A88";
const gnE = "\u2269";
const gneq = "\u2A88";
const gneqq = "\u2269";
const gnsim = "\u22E7";
const Gopf = "\u{1D53E}";
const gopf = "\u{1D558}";
const grave = "`";
const GreaterEqual = "\u2265";
const GreaterEqualLess = "\u22DB";
const GreaterFullEqual = "\u2267";
const GreaterGreater = "\u2AA2";
const GreaterLess = "\u2277";
const GreaterSlantEqual = "\u2A7E";
const GreaterTilde = "\u2273";
const Gscr = "\u{1D4A2}";
const gscr = "\u210A";
const gsim = "\u2273";
const gsime = "\u2A8E";
const gsiml = "\u2A90";
const gtcc = "\u2AA7";
const gtcir = "\u2A7A";
const gt = ">";
const GT = ">";
const Gt = "\u226B";
const gtdot = "\u22D7";
const gtlPar = "\u2995";
const gtquest = "\u2A7C";
const gtrapprox = "\u2A86";
const gtrarr = "\u2978";
const gtrdot = "\u22D7";
const gtreqless = "\u22DB";
const gtreqqless = "\u2A8C";
const gtrless = "\u2277";
const gtrsim = "\u2273";
const gvertneqq = "\u2269\uFE00";
const gvnE = "\u2269\uFE00";
const Hacek = "\u02C7";
const hairsp = "\u200A";
const half = "\xBD";
const hamilt = "\u210B";
const HARDcy = "\u042A";
const hardcy = "\u044A";
const harrcir = "\u2948";
const harr = "\u2194";
const hArr = "\u21D4";
const harrw = "\u21AD";
const Hat = "^";
const hbar = "\u210F";
const Hcirc = "\u0124";
const hcirc = "\u0125";
const hearts = "\u2665";
const heartsuit = "\u2665";
const hellip = "\u2026";
const hercon = "\u22B9";
const hfr = "\u{1D525}";
const Hfr = "\u210C";
const HilbertSpace = "\u210B";
const hksearow = "\u2925";
const hkswarow = "\u2926";
const hoarr = "\u21FF";
const homtht = "\u223B";
const hookleftarrow = "\u21A9";
const hookrightarrow = "\u21AA";
const hopf = "\u{1D559}";
const Hopf = "\u210D";
const horbar = "\u2015";
const HorizontalLine = "\u2500";
const hscr = "\u{1D4BD}";
const Hscr = "\u210B";
const hslash = "\u210F";
const Hstrok = "\u0126";
const hstrok = "\u0127";
const HumpDownHump = "\u224E";
const HumpEqual = "\u224F";
const hybull = "\u2043";
const hyphen = "\u2010";
const Iacute = "\xCD";
const iacute = "\xED";
const ic = "\u2063";
const Icirc = "\xCE";
const icirc = "\xEE";
const Icy = "\u0418";
const icy = "\u0438";
const Idot = "\u0130";
const IEcy = "\u0415";
const iecy = "\u0435";
const iexcl = "\xA1";
const iff = "\u21D4";
const ifr = "\u{1D526}";
const Ifr = "\u2111";
const Igrave = "\xCC";
const igrave = "\xEC";
const ii = "\u2148";
const iiiint = "\u2A0C";
const iiint = "\u222D";
const iinfin = "\u29DC";
const iiota = "\u2129";
const IJlig = "\u0132";
const ijlig = "\u0133";
const Imacr = "\u012A";
const imacr = "\u012B";
const image$1 = "\u2111";
const ImaginaryI = "\u2148";
const imagline = "\u2110";
const imagpart = "\u2111";
const imath = "\u0131";
const Im = "\u2111";
const imof = "\u22B7";
const imped = "\u01B5";
const Implies = "\u21D2";
const incare = "\u2105";
const infin = "\u221E";
const infintie = "\u29DD";
const inodot = "\u0131";
const intcal = "\u22BA";
const int = "\u222B";
const Int = "\u222C";
const integers = "\u2124";
const Integral = "\u222B";
const intercal = "\u22BA";
const Intersection = "\u22C2";
const intlarhk = "\u2A17";
const intprod = "\u2A3C";
const InvisibleComma = "\u2063";
const InvisibleTimes = "\u2062";
const IOcy = "\u0401";
const iocy = "\u0451";
const Iogon = "\u012E";
const iogon = "\u012F";
const Iopf = "\u{1D540}";
const iopf = "\u{1D55A}";
const Iota = "\u0399";
const iota = "\u03B9";
const iprod = "\u2A3C";
const iquest = "\xBF";
const iscr = "\u{1D4BE}";
const Iscr = "\u2110";
const isin = "\u2208";
const isindot = "\u22F5";
const isinE = "\u22F9";
const isins = "\u22F4";
const isinsv = "\u22F3";
const isinv = "\u2208";
const it = "\u2062";
const Itilde = "\u0128";
const itilde = "\u0129";
const Iukcy = "\u0406";
const iukcy = "\u0456";
const Iuml = "\xCF";
const iuml = "\xEF";
const Jcirc = "\u0134";
const jcirc = "\u0135";
const Jcy = "\u0419";
const jcy = "\u0439";
const Jfr = "\u{1D50D}";
const jfr = "\u{1D527}";
const jmath = "\u0237";
const Jopf = "\u{1D541}";
const jopf = "\u{1D55B}";
const Jscr = "\u{1D4A5}";
const jscr = "\u{1D4BF}";
const Jsercy = "\u0408";
const jsercy = "\u0458";
const Jukcy = "\u0404";
const jukcy = "\u0454";
const Kappa = "\u039A";
const kappa = "\u03BA";
const kappav = "\u03F0";
const Kcedil = "\u0136";
const kcedil = "\u0137";
const Kcy = "\u041A";
const kcy = "\u043A";
const Kfr = "\u{1D50E}";
const kfr = "\u{1D528}";
const kgreen = "\u0138";
const KHcy = "\u0425";
const khcy = "\u0445";
const KJcy = "\u040C";
const kjcy = "\u045C";
const Kopf = "\u{1D542}";
const kopf = "\u{1D55C}";
const Kscr = "\u{1D4A6}";
const kscr = "\u{1D4C0}";
const lAarr = "\u21DA";
const Lacute = "\u0139";
const lacute = "\u013A";
const laemptyv = "\u29B4";
const lagran = "\u2112";
const Lambda = "\u039B";
const lambda = "\u03BB";
const lang = "\u27E8";
const Lang = "\u27EA";
const langd = "\u2991";
const langle = "\u27E8";
const lap = "\u2A85";
const Laplacetrf = "\u2112";
const laquo = "\xAB";
const larrb = "\u21E4";
const larrbfs = "\u291F";
const larr = "\u2190";
const Larr = "\u219E";
const lArr = "\u21D0";
const larrfs = "\u291D";
const larrhk = "\u21A9";
const larrlp = "\u21AB";
const larrpl = "\u2939";
const larrsim = "\u2973";
const larrtl = "\u21A2";
const latail = "\u2919";
const lAtail = "\u291B";
const lat = "\u2AAB";
const late = "\u2AAD";
const lates = "\u2AAD\uFE00";
const lbarr = "\u290C";
const lBarr = "\u290E";
const lbbrk = "\u2772";
const lbrace = "{";
const lbrack = "[";
const lbrke = "\u298B";
const lbrksld = "\u298F";
const lbrkslu = "\u298D";
const Lcaron = "\u013D";
const lcaron = "\u013E";
const Lcedil = "\u013B";
const lcedil = "\u013C";
const lceil = "\u2308";
const lcub = "{";
const Lcy = "\u041B";
const lcy = "\u043B";
const ldca = "\u2936";
const ldquo = "\u201C";
const ldquor = "\u201E";
const ldrdhar = "\u2967";
const ldrushar = "\u294B";
const ldsh = "\u21B2";
const le = "\u2264";
const lE = "\u2266";
const LeftAngleBracket = "\u27E8";
const LeftArrowBar = "\u21E4";
const leftarrow = "\u2190";
const LeftArrow = "\u2190";
const Leftarrow = "\u21D0";
const LeftArrowRightArrow = "\u21C6";
const leftarrowtail = "\u21A2";
const LeftCeiling = "\u2308";
const LeftDoubleBracket = "\u27E6";
const LeftDownTeeVector = "\u2961";
const LeftDownVectorBar = "\u2959";
const LeftDownVector = "\u21C3";
const LeftFloor = "\u230A";
const leftharpoondown = "\u21BD";
const leftharpoonup = "\u21BC";
const leftleftarrows = "\u21C7";
const leftrightarrow = "\u2194";
const LeftRightArrow = "\u2194";
const Leftrightarrow = "\u21D4";
const leftrightarrows = "\u21C6";
const leftrightharpoons = "\u21CB";
const leftrightsquigarrow = "\u21AD";
const LeftRightVector = "\u294E";
const LeftTeeArrow = "\u21A4";
const LeftTee = "\u22A3";
const LeftTeeVector = "\u295A";
const leftthreetimes = "\u22CB";
const LeftTriangleBar = "\u29CF";
const LeftTriangle = "\u22B2";
const LeftTriangleEqual = "\u22B4";
const LeftUpDownVector = "\u2951";
const LeftUpTeeVector = "\u2960";
const LeftUpVectorBar = "\u2958";
const LeftUpVector = "\u21BF";
const LeftVectorBar = "\u2952";
const LeftVector = "\u21BC";
const lEg = "\u2A8B";
const leg = "\u22DA";
const leq = "\u2264";
const leqq = "\u2266";
const leqslant = "\u2A7D";
const lescc = "\u2AA8";
const les = "\u2A7D";
const lesdot = "\u2A7F";
const lesdoto = "\u2A81";
const lesdotor = "\u2A83";
const lesg = "\u22DA\uFE00";
const lesges = "\u2A93";
const lessapprox = "\u2A85";
const lessdot = "\u22D6";
const lesseqgtr = "\u22DA";
const lesseqqgtr = "\u2A8B";
const LessEqualGreater = "\u22DA";
const LessFullEqual = "\u2266";
const LessGreater = "\u2276";
const lessgtr = "\u2276";
const LessLess = "\u2AA1";
const lesssim = "\u2272";
const LessSlantEqual = "\u2A7D";
const LessTilde = "\u2272";
const lfisht = "\u297C";
const lfloor = "\u230A";
const Lfr = "\u{1D50F}";
const lfr = "\u{1D529}";
const lg = "\u2276";
const lgE = "\u2A91";
const lHar = "\u2962";
const lhard = "\u21BD";
const lharu = "\u21BC";
const lharul = "\u296A";
const lhblk = "\u2584";
const LJcy = "\u0409";
const ljcy = "\u0459";
const llarr = "\u21C7";
const ll = "\u226A";
const Ll = "\u22D8";
const llcorner = "\u231E";
const Lleftarrow = "\u21DA";
const llhard = "\u296B";
const lltri = "\u25FA";
const Lmidot = "\u013F";
const lmidot = "\u0140";
const lmoustache = "\u23B0";
const lmoust = "\u23B0";
const lnap = "\u2A89";
const lnapprox = "\u2A89";
const lne = "\u2A87";
const lnE = "\u2268";
const lneq = "\u2A87";
const lneqq = "\u2268";
const lnsim = "\u22E6";
const loang = "\u27EC";
const loarr = "\u21FD";
const lobrk = "\u27E6";
const longleftarrow = "\u27F5";
const LongLeftArrow = "\u27F5";
const Longleftarrow = "\u27F8";
const longleftrightarrow = "\u27F7";
const LongLeftRightArrow = "\u27F7";
const Longleftrightarrow = "\u27FA";
const longmapsto = "\u27FC";
const longrightarrow = "\u27F6";
const LongRightArrow = "\u27F6";
const Longrightarrow = "\u27F9";
const looparrowleft = "\u21AB";
const looparrowright = "\u21AC";
const lopar = "\u2985";
const Lopf = "\u{1D543}";
const lopf = "\u{1D55D}";
const loplus = "\u2A2D";
const lotimes = "\u2A34";
const lowast = "\u2217";
const lowbar = "_";
const LowerLeftArrow = "\u2199";
const LowerRightArrow = "\u2198";
const loz = "\u25CA";
const lozenge = "\u25CA";
const lozf = "\u29EB";
const lpar = "(";
const lparlt = "\u2993";
const lrarr = "\u21C6";
const lrcorner = "\u231F";
const lrhar = "\u21CB";
const lrhard = "\u296D";
const lrm = "\u200E";
const lrtri = "\u22BF";
const lsaquo = "\u2039";
const lscr = "\u{1D4C1}";
const Lscr = "\u2112";
const lsh = "\u21B0";
const Lsh = "\u21B0";
const lsim = "\u2272";
const lsime = "\u2A8D";
const lsimg = "\u2A8F";
const lsqb = "[";
const lsquo = "\u2018";
const lsquor = "\u201A";
const Lstrok = "\u0141";
const lstrok = "\u0142";
const ltcc = "\u2AA6";
const ltcir = "\u2A79";
const lt = "<";
const LT = "<";
const Lt = "\u226A";
const ltdot = "\u22D6";
const lthree = "\u22CB";
const ltimes = "\u22C9";
const ltlarr = "\u2976";
const ltquest = "\u2A7B";
const ltri = "\u25C3";
const ltrie = "\u22B4";
const ltrif = "\u25C2";
const ltrPar = "\u2996";
const lurdshar = "\u294A";
const luruhar = "\u2966";
const lvertneqq = "\u2268\uFE00";
const lvnE = "\u2268\uFE00";
const macr = "\xAF";
const male = "\u2642";
const malt = "\u2720";
const maltese = "\u2720";
const map$2 = "\u21A6";
const mapsto = "\u21A6";
const mapstodown = "\u21A7";
const mapstoleft = "\u21A4";
const mapstoup = "\u21A5";
const marker = "\u25AE";
const mcomma = "\u2A29";
const Mcy = "\u041C";
const mcy = "\u043C";
const mdash = "\u2014";
const mDDot = "\u223A";
const measuredangle = "\u2221";
const MediumSpace = "\u205F";
const Mellintrf = "\u2133";
const Mfr = "\u{1D510}";
const mfr = "\u{1D52A}";
const mho = "\u2127";
const micro = "\xB5";
const midast = "*";
const midcir = "\u2AF0";
const mid = "\u2223";
const middot = "\xB7";
const minusb = "\u229F";
const minus = "\u2212";
const minusd = "\u2238";
const minusdu = "\u2A2A";
const MinusPlus = "\u2213";
const mlcp = "\u2ADB";
const mldr = "\u2026";
const mnplus = "\u2213";
const models = "\u22A7";
const Mopf = "\u{1D544}";
const mopf = "\u{1D55E}";
const mp = "\u2213";
const mscr = "\u{1D4C2}";
const Mscr = "\u2133";
const mstpos = "\u223E";
const Mu = "\u039C";
const mu = "\u03BC";
const multimap = "\u22B8";
const mumap = "\u22B8";
const nabla = "\u2207";
const Nacute = "\u0143";
const nacute = "\u0144";
const nang = "\u2220\u20D2";
const nap = "\u2249";
const napE = "\u2A70\u0338";
const napid = "\u224B\u0338";
const napos = "\u0149";
const napprox = "\u2249";
const natural = "\u266E";
const naturals = "\u2115";
const natur = "\u266E";
const nbsp = "\xA0";
const nbump = "\u224E\u0338";
const nbumpe = "\u224F\u0338";
const ncap = "\u2A43";
const Ncaron = "\u0147";
const ncaron = "\u0148";
const Ncedil = "\u0145";
const ncedil = "\u0146";
const ncong = "\u2247";
const ncongdot = "\u2A6D\u0338";
const ncup = "\u2A42";
const Ncy = "\u041D";
const ncy = "\u043D";
const ndash = "\u2013";
const nearhk = "\u2924";
const nearr = "\u2197";
const neArr = "\u21D7";
const nearrow = "\u2197";
const ne = "\u2260";
const nedot = "\u2250\u0338";
const NegativeMediumSpace = "\u200B";
const NegativeThickSpace = "\u200B";
const NegativeThinSpace = "\u200B";
const NegativeVeryThinSpace = "\u200B";
const nequiv = "\u2262";
const nesear = "\u2928";
const nesim = "\u2242\u0338";
const NestedGreaterGreater = "\u226B";
const NestedLessLess = "\u226A";
const NewLine = "\n";
const nexist = "\u2204";
const nexists = "\u2204";
const Nfr = "\u{1D511}";
const nfr = "\u{1D52B}";
const ngE = "\u2267\u0338";
const nge = "\u2271";
const ngeq = "\u2271";
const ngeqq = "\u2267\u0338";
const ngeqslant = "\u2A7E\u0338";
const nges = "\u2A7E\u0338";
const nGg = "\u22D9\u0338";
const ngsim = "\u2275";
const nGt = "\u226B\u20D2";
const ngt = "\u226F";
const ngtr = "\u226F";
const nGtv = "\u226B\u0338";
const nharr = "\u21AE";
const nhArr = "\u21CE";
const nhpar = "\u2AF2";
const ni = "\u220B";
const nis = "\u22FC";
const nisd = "\u22FA";
const niv = "\u220B";
const NJcy = "\u040A";
const njcy = "\u045A";
const nlarr = "\u219A";
const nlArr = "\u21CD";
const nldr = "\u2025";
const nlE = "\u2266\u0338";
const nle = "\u2270";
const nleftarrow = "\u219A";
const nLeftarrow = "\u21CD";
const nleftrightarrow = "\u21AE";
const nLeftrightarrow = "\u21CE";
const nleq = "\u2270";
const nleqq = "\u2266\u0338";
const nleqslant = "\u2A7D\u0338";
const nles = "\u2A7D\u0338";
const nless = "\u226E";
const nLl = "\u22D8\u0338";
const nlsim = "\u2274";
const nLt = "\u226A\u20D2";
const nlt = "\u226E";
const nltri = "\u22EA";
const nltrie = "\u22EC";
const nLtv = "\u226A\u0338";
const nmid = "\u2224";
const NoBreak = "\u2060";
const NonBreakingSpace = "\xA0";
const nopf = "\u{1D55F}";
const Nopf = "\u2115";
const Not = "\u2AEC";
const not$1 = "\xAC";
const NotCongruent = "\u2262";
const NotCupCap = "\u226D";
const NotDoubleVerticalBar = "\u2226";
const NotElement = "\u2209";
const NotEqual = "\u2260";
const NotEqualTilde = "\u2242\u0338";
const NotExists = "\u2204";
const NotGreater = "\u226F";
const NotGreaterEqual = "\u2271";
const NotGreaterFullEqual = "\u2267\u0338";
const NotGreaterGreater = "\u226B\u0338";
const NotGreaterLess = "\u2279";
const NotGreaterSlantEqual = "\u2A7E\u0338";
const NotGreaterTilde = "\u2275";
const NotHumpDownHump = "\u224E\u0338";
const NotHumpEqual = "\u224F\u0338";
const notin = "\u2209";
const notindot = "\u22F5\u0338";
const notinE = "\u22F9\u0338";
const notinva = "\u2209";
const notinvb = "\u22F7";
const notinvc = "\u22F6";
const NotLeftTriangleBar = "\u29CF\u0338";
const NotLeftTriangle = "\u22EA";
const NotLeftTriangleEqual = "\u22EC";
const NotLess = "\u226E";
const NotLessEqual = "\u2270";
const NotLessGreater = "\u2278";
const NotLessLess = "\u226A\u0338";
const NotLessSlantEqual = "\u2A7D\u0338";
const NotLessTilde = "\u2274";
const NotNestedGreaterGreater = "\u2AA2\u0338";
const NotNestedLessLess = "\u2AA1\u0338";
const notni = "\u220C";
const notniva = "\u220C";
const notnivb = "\u22FE";
const notnivc = "\u22FD";
const NotPrecedes = "\u2280";
const NotPrecedesEqual = "\u2AAF\u0338";
const NotPrecedesSlantEqual = "\u22E0";
const NotReverseElement = "\u220C";
const NotRightTriangleBar = "\u29D0\u0338";
const NotRightTriangle = "\u22EB";
const NotRightTriangleEqual = "\u22ED";
const NotSquareSubset = "\u228F\u0338";
const NotSquareSubsetEqual = "\u22E2";
const NotSquareSuperset = "\u2290\u0338";
const NotSquareSupersetEqual = "\u22E3";
const NotSubset = "\u2282\u20D2";
const NotSubsetEqual = "\u2288";
const NotSucceeds = "\u2281";
const NotSucceedsEqual = "\u2AB0\u0338";
const NotSucceedsSlantEqual = "\u22E1";
const NotSucceedsTilde = "\u227F\u0338";
const NotSuperset = "\u2283\u20D2";
const NotSupersetEqual = "\u2289";
const NotTilde = "\u2241";
const NotTildeEqual = "\u2244";
const NotTildeFullEqual = "\u2247";
const NotTildeTilde = "\u2249";
const NotVerticalBar = "\u2224";
const nparallel = "\u2226";
const npar = "\u2226";
const nparsl = "\u2AFD\u20E5";
const npart = "\u2202\u0338";
const npolint = "\u2A14";
const npr = "\u2280";
const nprcue = "\u22E0";
const nprec = "\u2280";
const npreceq = "\u2AAF\u0338";
const npre = "\u2AAF\u0338";
const nrarrc = "\u2933\u0338";
const nrarr = "\u219B";
const nrArr = "\u21CF";
const nrarrw = "\u219D\u0338";
const nrightarrow = "\u219B";
const nRightarrow = "\u21CF";
const nrtri = "\u22EB";
const nrtrie = "\u22ED";
const nsc = "\u2281";
const nsccue = "\u22E1";
const nsce = "\u2AB0\u0338";
const Nscr = "\u{1D4A9}";
const nscr = "\u{1D4C3}";
const nshortmid = "\u2224";
const nshortparallel = "\u2226";
const nsim = "\u2241";
const nsime = "\u2244";
const nsimeq = "\u2244";
const nsmid = "\u2224";
const nspar = "\u2226";
const nsqsube = "\u22E2";
const nsqsupe = "\u22E3";
const nsub = "\u2284";
const nsubE = "\u2AC5\u0338";
const nsube = "\u2288";
const nsubset = "\u2282\u20D2";
const nsubseteq = "\u2288";
const nsubseteqq = "\u2AC5\u0338";
const nsucc = "\u2281";
const nsucceq = "\u2AB0\u0338";
const nsup = "\u2285";
const nsupE = "\u2AC6\u0338";
const nsupe = "\u2289";
const nsupset = "\u2283\u20D2";
const nsupseteq = "\u2289";
const nsupseteqq = "\u2AC6\u0338";
const ntgl = "\u2279";
const Ntilde = "\xD1";
const ntilde = "\xF1";
const ntlg = "\u2278";
const ntriangleleft = "\u22EA";
const ntrianglelefteq = "\u22EC";
const ntriangleright = "\u22EB";
const ntrianglerighteq = "\u22ED";
const Nu = "\u039D";
const nu = "\u03BD";
const num = "#";
const numero = "\u2116";
const numsp = "\u2007";
const nvap = "\u224D\u20D2";
const nvdash = "\u22AC";
const nvDash = "\u22AD";
const nVdash = "\u22AE";
const nVDash = "\u22AF";
const nvge = "\u2265\u20D2";
const nvgt = ">\u20D2";
const nvHarr = "\u2904";
const nvinfin = "\u29DE";
const nvlArr = "\u2902";
const nvle = "\u2264\u20D2";
const nvlt = "<\u20D2";
const nvltrie = "\u22B4\u20D2";
const nvrArr = "\u2903";
const nvrtrie = "\u22B5\u20D2";
const nvsim = "\u223C\u20D2";
const nwarhk = "\u2923";
const nwarr = "\u2196";
const nwArr = "\u21D6";
const nwarrow = "\u2196";
const nwnear = "\u2927";
const Oacute = "\xD3";
const oacute = "\xF3";
const oast = "\u229B";
const Ocirc = "\xD4";
const ocirc = "\xF4";
const ocir = "\u229A";
const Ocy = "\u041E";
const ocy = "\u043E";
const odash = "\u229D";
const Odblac = "\u0150";
const odblac = "\u0151";
const odiv = "\u2A38";
const odot = "\u2299";
const odsold = "\u29BC";
const OElig = "\u0152";
const oelig = "\u0153";
const ofcir = "\u29BF";
const Ofr = "\u{1D512}";
const ofr = "\u{1D52C}";
const ogon = "\u02DB";
const Ograve = "\xD2";
const ograve = "\xF2";
const ogt = "\u29C1";
const ohbar = "\u29B5";
const ohm = "\u03A9";
const oint = "\u222E";
const olarr = "\u21BA";
const olcir = "\u29BE";
const olcross = "\u29BB";
const oline = "\u203E";
const olt = "\u29C0";
const Omacr = "\u014C";
const omacr = "\u014D";
const Omega = "\u03A9";
const omega = "\u03C9";
const Omicron = "\u039F";
const omicron = "\u03BF";
const omid = "\u29B6";
const ominus = "\u2296";
const Oopf = "\u{1D546}";
const oopf = "\u{1D560}";
const opar = "\u29B7";
const OpenCurlyDoubleQuote = "\u201C";
const OpenCurlyQuote = "\u2018";
const operp = "\u29B9";
const oplus = "\u2295";
const orarr = "\u21BB";
const Or = "\u2A54";
const or = "\u2228";
const ord = "\u2A5D";
const order$1 = "\u2134";
const orderof = "\u2134";
const ordf = "\xAA";
const ordm = "\xBA";
const origof = "\u22B6";
const oror = "\u2A56";
const orslope = "\u2A57";
const orv = "\u2A5B";
const oS = "\u24C8";
const Oscr = "\u{1D4AA}";
const oscr = "\u2134";
const Oslash = "\xD8";
const oslash = "\xF8";
const osol = "\u2298";
const Otilde = "\xD5";
const otilde = "\xF5";
const otimesas = "\u2A36";
const Otimes = "\u2A37";
const otimes = "\u2297";
const Ouml = "\xD6";
const ouml = "\xF6";
const ovbar = "\u233D";
const OverBar = "\u203E";
const OverBrace = "\u23DE";
const OverBracket = "\u23B4";
const OverParenthesis = "\u23DC";
const para = "\xB6";
const parallel = "\u2225";
const par = "\u2225";
const parsim = "\u2AF3";
const parsl = "\u2AFD";
const part = "\u2202";
const PartialD = "\u2202";
const Pcy = "\u041F";
const pcy = "\u043F";
const percnt = "%";
const period = ".";
const permil = "\u2030";
const perp = "\u22A5";
const pertenk = "\u2031";
const Pfr = "\u{1D513}";
const pfr = "\u{1D52D}";
const Phi = "\u03A6";
const phi = "\u03C6";
const phiv = "\u03D5";
const phmmat = "\u2133";
const phone = "\u260E";
const Pi = "\u03A0";
const pi = "\u03C0";
const pitchfork = "\u22D4";
const piv = "\u03D6";
const planck = "\u210F";
const planckh = "\u210E";
const plankv = "\u210F";
const plusacir = "\u2A23";
const plusb = "\u229E";
const pluscir = "\u2A22";
const plus = "+";
const plusdo = "\u2214";
const plusdu = "\u2A25";
const pluse = "\u2A72";
const PlusMinus = "\xB1";
const plusmn = "\xB1";
const plussim = "\u2A26";
const plustwo = "\u2A27";
const pm = "\xB1";
const Poincareplane = "\u210C";
const pointint = "\u2A15";
const popf = "\u{1D561}";
const Popf = "\u2119";
const pound = "\xA3";
const prap = "\u2AB7";
const Pr = "\u2ABB";
const pr = "\u227A";
const prcue = "\u227C";
const precapprox = "\u2AB7";
const prec = "\u227A";
const preccurlyeq = "\u227C";
const Precedes = "\u227A";
const PrecedesEqual = "\u2AAF";
const PrecedesSlantEqual = "\u227C";
const PrecedesTilde = "\u227E";
const preceq = "\u2AAF";
const precnapprox = "\u2AB9";
const precneqq = "\u2AB5";
const precnsim = "\u22E8";
const pre = "\u2AAF";
const prE = "\u2AB3";
const precsim = "\u227E";
const prime = "\u2032";
const Prime = "\u2033";
const primes = "\u2119";
const prnap = "\u2AB9";
const prnE = "\u2AB5";
const prnsim = "\u22E8";
const prod = "\u220F";
const Product = "\u220F";
const profalar = "\u232E";
const profline = "\u2312";
const profsurf = "\u2313";
const prop = "\u221D";
const Proportional = "\u221D";
const Proportion = "\u2237";
const propto = "\u221D";
const prsim = "\u227E";
const prurel = "\u22B0";
const Pscr = "\u{1D4AB}";
const pscr = "\u{1D4C5}";
const Psi = "\u03A8";
const psi = "\u03C8";
const puncsp = "\u2008";
const Qfr = "\u{1D514}";
const qfr = "\u{1D52E}";
const qint = "\u2A0C";
const qopf = "\u{1D562}";
const Qopf = "\u211A";
const qprime = "\u2057";
const Qscr = "\u{1D4AC}";
const qscr = "\u{1D4C6}";
const quaternions = "\u210D";
const quatint = "\u2A16";
const quest = "?";
const questeq = "\u225F";
const quot = '"';
const QUOT = '"';
const rAarr = "\u21DB";
const race = "\u223D\u0331";
const Racute = "\u0154";
const racute = "\u0155";
const radic = "\u221A";
const raemptyv = "\u29B3";
const rang = "\u27E9";
const Rang = "\u27EB";
const rangd = "\u2992";
const range = "\u29A5";
const rangle = "\u27E9";
const raquo = "\xBB";
const rarrap = "\u2975";
const rarrb = "\u21E5";
const rarrbfs = "\u2920";
const rarrc = "\u2933";
const rarr = "\u2192";
const Rarr = "\u21A0";
const rArr = "\u21D2";
const rarrfs = "\u291E";
const rarrhk = "\u21AA";
const rarrlp = "\u21AC";
const rarrpl = "\u2945";
const rarrsim = "\u2974";
const Rarrtl = "\u2916";
const rarrtl = "\u21A3";
const rarrw = "\u219D";
const ratail = "\u291A";
const rAtail = "\u291C";
const ratio = "\u2236";
const rationals = "\u211A";
const rbarr = "\u290D";
const rBarr = "\u290F";
const RBarr = "\u2910";
const rbbrk = "\u2773";
const rbrace = "}";
const rbrack = "]";
const rbrke = "\u298C";
const rbrksld = "\u298E";
const rbrkslu = "\u2990";
const Rcaron = "\u0158";
const rcaron = "\u0159";
const Rcedil = "\u0156";
const rcedil = "\u0157";
const rceil = "\u2309";
const rcub = "}";
const Rcy = "\u0420";
const rcy = "\u0440";
const rdca = "\u2937";
const rdldhar = "\u2969";
const rdquo = "\u201D";
const rdquor = "\u201D";
const rdsh = "\u21B3";
const real = "\u211C";
const realine = "\u211B";
const realpart = "\u211C";
const reals = "\u211D";
const Re = "\u211C";
const rect = "\u25AD";
const reg = "\xAE";
const REG = "\xAE";
const ReverseElement = "\u220B";
const ReverseEquilibrium = "\u21CB";
const ReverseUpEquilibrium = "\u296F";
const rfisht = "\u297D";
const rfloor = "\u230B";
const rfr = "\u{1D52F}";
const Rfr = "\u211C";
const rHar = "\u2964";
const rhard = "\u21C1";
const rharu = "\u21C0";
const rharul = "\u296C";
const Rho = "\u03A1";
const rho = "\u03C1";
const rhov = "\u03F1";
const RightAngleBracket = "\u27E9";
const RightArrowBar = "\u21E5";
const rightarrow = "\u2192";
const RightArrow = "\u2192";
const Rightarrow = "\u21D2";
const RightArrowLeftArrow = "\u21C4";
const rightarrowtail = "\u21A3";
const RightCeiling = "\u2309";
const RightDoubleBracket = "\u27E7";
const RightDownTeeVector = "\u295D";
const RightDownVectorBar = "\u2955";
const RightDownVector = "\u21C2";
const RightFloor = "\u230B";
const rightharpoondown = "\u21C1";
const rightharpoonup = "\u21C0";
const rightleftarrows = "\u21C4";
const rightleftharpoons = "\u21CC";
const rightrightarrows = "\u21C9";
const rightsquigarrow = "\u219D";
const RightTeeArrow = "\u21A6";
const RightTee = "\u22A2";
const RightTeeVector = "\u295B";
const rightthreetimes = "\u22CC";
const RightTriangleBar = "\u29D0";
const RightTriangle = "\u22B3";
const RightTriangleEqual = "\u22B5";
const RightUpDownVector = "\u294F";
const RightUpTeeVector = "\u295C";
const RightUpVectorBar = "\u2954";
const RightUpVector = "\u21BE";
const RightVectorBar = "\u2953";
const RightVector = "\u21C0";
const ring = "\u02DA";
const risingdotseq = "\u2253";
const rlarr = "\u21C4";
const rlhar = "\u21CC";
const rlm = "\u200F";
const rmoustache = "\u23B1";
const rmoust = "\u23B1";
const rnmid = "\u2AEE";
const roang = "\u27ED";
const roarr = "\u21FE";
const robrk = "\u27E7";
const ropar = "\u2986";
const ropf = "\u{1D563}";
const Ropf = "\u211D";
const roplus = "\u2A2E";
const rotimes = "\u2A35";
const RoundImplies = "\u2970";
const rpar = ")";
const rpargt = "\u2994";
const rppolint = "\u2A12";
const rrarr = "\u21C9";
const Rrightarrow = "\u21DB";
const rsaquo = "\u203A";
const rscr = "\u{1D4C7}";
const Rscr = "\u211B";
const rsh = "\u21B1";
const Rsh = "\u21B1";
const rsqb = "]";
const rsquo = "\u2019";
const rsquor = "\u2019";
const rthree = "\u22CC";
const rtimes = "\u22CA";
const rtri = "\u25B9";
const rtrie = "\u22B5";
const rtrif = "\u25B8";
const rtriltri = "\u29CE";
const RuleDelayed = "\u29F4";
const ruluhar = "\u2968";
const rx = "\u211E";
const Sacute = "\u015A";
const sacute = "\u015B";
const sbquo = "\u201A";
const scap = "\u2AB8";
const Scaron = "\u0160";
const scaron = "\u0161";
const Sc = "\u2ABC";
const sc = "\u227B";
const sccue = "\u227D";
const sce = "\u2AB0";
const scE = "\u2AB4";
const Scedil = "\u015E";
const scedil = "\u015F";
const Scirc = "\u015C";
const scirc = "\u015D";
const scnap = "\u2ABA";
const scnE = "\u2AB6";
const scnsim = "\u22E9";
const scpolint = "\u2A13";
const scsim = "\u227F";
const Scy = "\u0421";
const scy = "\u0441";
const sdotb = "\u22A1";
const sdot = "\u22C5";
const sdote = "\u2A66";
const searhk = "\u2925";
const searr = "\u2198";
const seArr = "\u21D8";
const searrow = "\u2198";
const sect = "\xA7";
const semi = ";";
const seswar = "\u2929";
const setminus = "\u2216";
const setmn = "\u2216";
const sext = "\u2736";
const Sfr = "\u{1D516}";
const sfr = "\u{1D530}";
const sfrown = "\u2322";
const sharp = "\u266F";
const SHCHcy = "\u0429";
const shchcy = "\u0449";
const SHcy = "\u0428";
const shcy = "\u0448";
const ShortDownArrow = "\u2193";
const ShortLeftArrow = "\u2190";
const shortmid = "\u2223";
const shortparallel = "\u2225";
const ShortRightArrow = "\u2192";
const ShortUpArrow = "\u2191";
const shy = "\xAD";
const Sigma = "\u03A3";
const sigma = "\u03C3";
const sigmaf = "\u03C2";
const sigmav = "\u03C2";
const sim = "\u223C";
const simdot = "\u2A6A";
const sime = "\u2243";
const simeq = "\u2243";
const simg = "\u2A9E";
const simgE = "\u2AA0";
const siml = "\u2A9D";
const simlE = "\u2A9F";
const simne = "\u2246";
const simplus = "\u2A24";
const simrarr = "\u2972";
const slarr = "\u2190";
const SmallCircle = "\u2218";
const smallsetminus = "\u2216";
const smashp = "\u2A33";
const smeparsl = "\u29E4";
const smid = "\u2223";
const smile = "\u2323";
const smt = "\u2AAA";
const smte = "\u2AAC";
const smtes = "\u2AAC\uFE00";
const SOFTcy = "\u042C";
const softcy = "\u044C";
const solbar = "\u233F";
const solb = "\u29C4";
const sol = "/";
const Sopf = "\u{1D54A}";
const sopf = "\u{1D564}";
const spades = "\u2660";
const spadesuit = "\u2660";
const spar = "\u2225";
const sqcap = "\u2293";
const sqcaps = "\u2293\uFE00";
const sqcup = "\u2294";
const sqcups = "\u2294\uFE00";
const Sqrt = "\u221A";
const sqsub = "\u228F";
const sqsube = "\u2291";
const sqsubset = "\u228F";
const sqsubseteq = "\u2291";
const sqsup = "\u2290";
const sqsupe = "\u2292";
const sqsupset = "\u2290";
const sqsupseteq = "\u2292";
const square = "\u25A1";
const Square = "\u25A1";
const SquareIntersection = "\u2293";
const SquareSubset = "\u228F";
const SquareSubsetEqual = "\u2291";
const SquareSuperset = "\u2290";
const SquareSupersetEqual = "\u2292";
const SquareUnion = "\u2294";
const squarf = "\u25AA";
const squ = "\u25A1";
const squf = "\u25AA";
const srarr = "\u2192";
const Sscr = "\u{1D4AE}";
const sscr = "\u{1D4C8}";
const ssetmn = "\u2216";
const ssmile = "\u2323";
const sstarf = "\u22C6";
const Star = "\u22C6";
const star = "\u2606";
const starf = "\u2605";
const straightepsilon = "\u03F5";
const straightphi = "\u03D5";
const strns = "\xAF";
const sub = "\u2282";
const Sub = "\u22D0";
const subdot = "\u2ABD";
const subE = "\u2AC5";
const sube = "\u2286";
const subedot = "\u2AC3";
const submult = "\u2AC1";
const subnE = "\u2ACB";
const subne = "\u228A";
const subplus = "\u2ABF";
const subrarr = "\u2979";
const subset = "\u2282";
const Subset = "\u22D0";
const subseteq = "\u2286";
const subseteqq = "\u2AC5";
const SubsetEqual = "\u2286";
const subsetneq = "\u228A";
const subsetneqq = "\u2ACB";
const subsim = "\u2AC7";
const subsub = "\u2AD5";
const subsup = "\u2AD3";
const succapprox = "\u2AB8";
const succ = "\u227B";
const succcurlyeq = "\u227D";
const Succeeds = "\u227B";
const SucceedsEqual = "\u2AB0";
const SucceedsSlantEqual = "\u227D";
const SucceedsTilde = "\u227F";
const succeq = "\u2AB0";
const succnapprox = "\u2ABA";
const succneqq = "\u2AB6";
const succnsim = "\u22E9";
const succsim = "\u227F";
const SuchThat = "\u220B";
const sum = "\u2211";
const Sum = "\u2211";
const sung = "\u266A";
const sup1 = "\xB9";
const sup2 = "\xB2";
const sup3 = "\xB3";
const sup = "\u2283";
const Sup = "\u22D1";
const supdot = "\u2ABE";
const supdsub = "\u2AD8";
const supE = "\u2AC6";
const supe = "\u2287";
const supedot = "\u2AC4";
const Superset = "\u2283";
const SupersetEqual = "\u2287";
const suphsol = "\u27C9";
const suphsub = "\u2AD7";
const suplarr = "\u297B";
const supmult = "\u2AC2";
const supnE = "\u2ACC";
const supne = "\u228B";
const supplus = "\u2AC0";
const supset = "\u2283";
const Supset = "\u22D1";
const supseteq = "\u2287";
const supseteqq = "\u2AC6";
const supsetneq = "\u228B";
const supsetneqq = "\u2ACC";
const supsim = "\u2AC8";
const supsub = "\u2AD4";
const supsup = "\u2AD6";
const swarhk = "\u2926";
const swarr = "\u2199";
const swArr = "\u21D9";
const swarrow = "\u2199";
const swnwar = "\u292A";
const szlig = "\xDF";
const Tab = "	";
const target = "\u2316";
const Tau = "\u03A4";
const tau = "\u03C4";
const tbrk = "\u23B4";
const Tcaron = "\u0164";
const tcaron = "\u0165";
const Tcedil = "\u0162";
const tcedil = "\u0163";
const Tcy = "\u0422";
const tcy = "\u0442";
const tdot = "\u20DB";
const telrec = "\u2315";
const Tfr = "\u{1D517}";
const tfr = "\u{1D531}";
const there4 = "\u2234";
const therefore = "\u2234";
const Therefore = "\u2234";
const Theta = "\u0398";
const theta = "\u03B8";
const thetasym = "\u03D1";
const thetav = "\u03D1";
const thickapprox = "\u2248";
const thicksim = "\u223C";
const ThickSpace = "\u205F\u200A";
const ThinSpace = "\u2009";
const thinsp = "\u2009";
const thkap = "\u2248";
const thksim = "\u223C";
const THORN = "\xDE";
const thorn = "\xFE";
const tilde = "\u02DC";
const Tilde = "\u223C";
const TildeEqual = "\u2243";
const TildeFullEqual = "\u2245";
const TildeTilde = "\u2248";
const timesbar = "\u2A31";
const timesb = "\u22A0";
const times = "\xD7";
const timesd = "\u2A30";
const tint = "\u222D";
const toea = "\u2928";
const topbot = "\u2336";
const topcir = "\u2AF1";
const top$1 = "\u22A4";
const Topf = "\u{1D54B}";
const topf = "\u{1D565}";
const topfork = "\u2ADA";
const tosa = "\u2929";
const tprime = "\u2034";
const trade = "\u2122";
const TRADE = "\u2122";
const triangle = "\u25B5";
const triangledown = "\u25BF";
const triangleleft = "\u25C3";
const trianglelefteq = "\u22B4";
const triangleq = "\u225C";
const triangleright = "\u25B9";
const trianglerighteq = "\u22B5";
const tridot = "\u25EC";
const trie = "\u225C";
const triminus = "\u2A3A";
const TripleDot = "\u20DB";
const triplus = "\u2A39";
const trisb = "\u29CD";
const tritime = "\u2A3B";
const trpezium = "\u23E2";
const Tscr = "\u{1D4AF}";
const tscr = "\u{1D4C9}";
const TScy = "\u0426";
const tscy = "\u0446";
const TSHcy = "\u040B";
const tshcy = "\u045B";
const Tstrok = "\u0166";
const tstrok = "\u0167";
const twixt = "\u226C";
const twoheadleftarrow = "\u219E";
const twoheadrightarrow = "\u21A0";
const Uacute = "\xDA";
const uacute = "\xFA";
const uarr = "\u2191";
const Uarr = "\u219F";
const uArr = "\u21D1";
const Uarrocir = "\u2949";
const Ubrcy = "\u040E";
const ubrcy = "\u045E";
const Ubreve = "\u016C";
const ubreve = "\u016D";
const Ucirc = "\xDB";
const ucirc = "\xFB";
const Ucy = "\u0423";
const ucy = "\u0443";
const udarr = "\u21C5";
const Udblac = "\u0170";
const udblac = "\u0171";
const udhar = "\u296E";
const ufisht = "\u297E";
const Ufr = "\u{1D518}";
const ufr = "\u{1D532}";
const Ugrave = "\xD9";
const ugrave = "\xF9";
const uHar = "\u2963";
const uharl = "\u21BF";
const uharr = "\u21BE";
const uhblk = "\u2580";
const ulcorn = "\u231C";
const ulcorner = "\u231C";
const ulcrop = "\u230F";
const ultri = "\u25F8";
const Umacr = "\u016A";
const umacr = "\u016B";
const uml = "\xA8";
const UnderBar = "_";
const UnderBrace = "\u23DF";
const UnderBracket = "\u23B5";
const UnderParenthesis = "\u23DD";
const Union = "\u22C3";
const UnionPlus = "\u228E";
const Uogon = "\u0172";
const uogon = "\u0173";
const Uopf = "\u{1D54C}";
const uopf = "\u{1D566}";
const UpArrowBar = "\u2912";
const uparrow = "\u2191";
const UpArrow = "\u2191";
const Uparrow = "\u21D1";
const UpArrowDownArrow = "\u21C5";
const updownarrow = "\u2195";
const UpDownArrow = "\u2195";
const Updownarrow = "\u21D5";
const UpEquilibrium = "\u296E";
const upharpoonleft = "\u21BF";
const upharpoonright = "\u21BE";
const uplus = "\u228E";
const UpperLeftArrow = "\u2196";
const UpperRightArrow = "\u2197";
const upsi = "\u03C5";
const Upsi = "\u03D2";
const upsih = "\u03D2";
const Upsilon = "\u03A5";
const upsilon = "\u03C5";
const UpTeeArrow = "\u21A5";
const UpTee = "\u22A5";
const upuparrows = "\u21C8";
const urcorn = "\u231D";
const urcorner = "\u231D";
const urcrop = "\u230E";
const Uring = "\u016E";
const uring = "\u016F";
const urtri = "\u25F9";
const Uscr = "\u{1D4B0}";
const uscr = "\u{1D4CA}";
const utdot = "\u22F0";
const Utilde = "\u0168";
const utilde = "\u0169";
const utri = "\u25B5";
const utrif = "\u25B4";
const uuarr = "\u21C8";
const Uuml = "\xDC";
const uuml = "\xFC";
const uwangle = "\u29A7";
const vangrt = "\u299C";
const varepsilon = "\u03F5";
const varkappa = "\u03F0";
const varnothing = "\u2205";
const varphi = "\u03D5";
const varpi = "\u03D6";
const varpropto = "\u221D";
const varr = "\u2195";
const vArr = "\u21D5";
const varrho = "\u03F1";
const varsigma = "\u03C2";
const varsubsetneq = "\u228A\uFE00";
const varsubsetneqq = "\u2ACB\uFE00";
const varsupsetneq = "\u228B\uFE00";
const varsupsetneqq = "\u2ACC\uFE00";
const vartheta = "\u03D1";
const vartriangleleft = "\u22B2";
const vartriangleright = "\u22B3";
const vBar = "\u2AE8";
const Vbar = "\u2AEB";
const vBarv = "\u2AE9";
const Vcy = "\u0412";
const vcy = "\u0432";
const vdash = "\u22A2";
const vDash = "\u22A8";
const Vdash = "\u22A9";
const VDash = "\u22AB";
const Vdashl = "\u2AE6";
const veebar = "\u22BB";
const vee = "\u2228";
const Vee = "\u22C1";
const veeeq = "\u225A";
const vellip = "\u22EE";
const verbar = "|";
const Verbar = "\u2016";
const vert = "|";
const Vert = "\u2016";
const VerticalBar = "\u2223";
const VerticalLine = "|";
const VerticalSeparator = "\u2758";
const VerticalTilde = "\u2240";
const VeryThinSpace = "\u200A";
const Vfr = "\u{1D519}";
const vfr = "\u{1D533}";
const vltri = "\u22B2";
const vnsub = "\u2282\u20D2";
const vnsup = "\u2283\u20D2";
const Vopf = "\u{1D54D}";
const vopf = "\u{1D567}";
const vprop = "\u221D";
const vrtri = "\u22B3";
const Vscr = "\u{1D4B1}";
const vscr = "\u{1D4CB}";
const vsubnE = "\u2ACB\uFE00";
const vsubne = "\u228A\uFE00";
const vsupnE = "\u2ACC\uFE00";
const vsupne = "\u228B\uFE00";
const Vvdash = "\u22AA";
const vzigzag = "\u299A";
const Wcirc = "\u0174";
const wcirc = "\u0175";
const wedbar = "\u2A5F";
const wedge = "\u2227";
const Wedge = "\u22C0";
const wedgeq = "\u2259";
const weierp = "\u2118";
const Wfr = "\u{1D51A}";
const wfr = "\u{1D534}";
const Wopf = "\u{1D54E}";
const wopf = "\u{1D568}";
const wp = "\u2118";
const wr = "\u2240";
const wreath = "\u2240";
const Wscr = "\u{1D4B2}";
const wscr = "\u{1D4CC}";
const xcap = "\u22C2";
const xcirc = "\u25EF";
const xcup = "\u22C3";
const xdtri = "\u25BD";
const Xfr = "\u{1D51B}";
const xfr = "\u{1D535}";
const xharr = "\u27F7";
const xhArr = "\u27FA";
const Xi = "\u039E";
const xi = "\u03BE";
const xlarr = "\u27F5";
const xlArr = "\u27F8";
const xmap = "\u27FC";
const xnis = "\u22FB";
const xodot = "\u2A00";
const Xopf = "\u{1D54F}";
const xopf = "\u{1D569}";
const xoplus = "\u2A01";
const xotime = "\u2A02";
const xrarr = "\u27F6";
const xrArr = "\u27F9";
const Xscr = "\u{1D4B3}";
const xscr = "\u{1D4CD}";
const xsqcup = "\u2A06";
const xuplus = "\u2A04";
const xutri = "\u25B3";
const xvee = "\u22C1";
const xwedge = "\u22C0";
const Yacute = "\xDD";
const yacute = "\xFD";
const YAcy = "\u042F";
const yacy = "\u044F";
const Ycirc = "\u0176";
const ycirc = "\u0177";
const Ycy = "\u042B";
const ycy = "\u044B";
const yen = "\xA5";
const Yfr = "\u{1D51C}";
const yfr = "\u{1D536}";
const YIcy = "\u0407";
const yicy = "\u0457";
const Yopf = "\u{1D550}";
const yopf = "\u{1D56A}";
const Yscr = "\u{1D4B4}";
const yscr = "\u{1D4CE}";
const YUcy = "\u042E";
const yucy = "\u044E";
const yuml = "\xFF";
const Yuml = "\u0178";
const Zacute = "\u0179";
const zacute = "\u017A";
const Zcaron = "\u017D";
const zcaron = "\u017E";
const Zcy = "\u0417";
const zcy = "\u0437";
const Zdot = "\u017B";
const zdot = "\u017C";
const zeetrf = "\u2128";
const ZeroWidthSpace = "\u200B";
const Zeta = "\u0396";
const zeta = "\u03B6";
const zfr = "\u{1D537}";
const Zfr = "\u2128";
const ZHcy = "\u0416";
const zhcy = "\u0436";
const zigrarr = "\u21DD";
const zopf = "\u{1D56B}";
const Zopf = "\u2124";
const Zscr = "\u{1D4B5}";
const zscr = "\u{1D4CF}";
const zwj = "\u200D";
const zwnj = "\u200C";
var require$$0$1 = {
  Aacute,
  aacute,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc,
  acirc,
  acute,
  Acy,
  acy,
  AElig,
  aelig,
  af,
  Afr,
  afr,
  Agrave,
  agrave,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp,
  AMP,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos,
  ApplyFunction,
  approx,
  approxeq,
  Aring,
  aring,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde,
  atilde,
  Auml,
  auml,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between: between2,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom: bottom$1,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil,
  ccedil,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil,
  Cedilla,
  cemptyv,
  cent,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div: div$1,
  divide,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute,
  eacute,
  easter,
  Ecaron,
  ecaron,
  Ecirc,
  ecirc,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave,
  egrave,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty: empty$1,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH,
  eth,
  Euml,
  euml,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt,
  GT,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute,
  iacute,
  ic,
  Icirc,
  icirc,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl,
  iff,
  ifr,
  Ifr,
  Igrave,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$1,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "\u2208",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml,
  iuml,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt,
  LT,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr,
  male,
  malt,
  maltese,
  "Map": "\u2905",
  map: map$2,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro,
  midast,
  midcir,
  mid,
  middot,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute,
  oacute,
  oast,
  Ocirc,
  ocirc,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order: order$1,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash,
  oslash,
  osol,
  Otilde,
  otilde,
  otimesas,
  Otimes,
  otimes,
  Ouml,
  ouml,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot,
  QUOT,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg,
  REG,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1,
  sup2,
  sup3,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN,
  thorn,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top: top$1,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute,
  uacute,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc,
  ucirc,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave,
  ugrave,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml,
  uuml,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute,
  yacute,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var entities$1 = require$$0$1;
var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var mdurl$1 = {};
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode$1(string, exclude, keepEscaped) {
  var i, l, code2, nextCode, cache, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache = getEncodeCache(exclude);
  for (i = 0, l = string.length; i < l; i++) {
    code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var decodeCache = {};
function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode$1(string, exclude) {
  var cache;
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr, result = "";
    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
var decode_1 = decode$1;
var format$1 = function format(url3) {
  var result = "";
  result += url3.protocol || "";
  result += url3.slashes ? "//" : "";
  result += url3.auth ? url3.auth + "@" : "";
  if (url3.hostname && url3.hostname.indexOf(":") !== -1) {
    result += "[" + url3.hostname + "]";
  } else {
    result += url3.hostname || "";
  }
  result += url3.port ? ":" + url3.port : "";
  result += url3.pathname || "";
  result += url3.search || "";
  result += url3.hash || "";
  return result;
};
function Url$1() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url3, slashesDenoteHost) {
  if (url3 && url3 instanceof Url$1) {
    return url3;
  }
  var u = new Url$1();
  u.parse(url3, slashesDenoteHost);
  return u;
}
Url$1.prototype.parse = function(url3, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes, rest = url3;
  rest = rest.trim();
  if (!slashesDenoteHost && url3.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part2 = hostparts[i];
        if (!part2) {
          continue;
        }
        if (!part2.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part2.length; j2 < k2; j2++) {
            if (part2.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part2[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part2.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url$1.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse$2 = urlParse;
mdurl$1.encode = encode_1;
mdurl$1.decode = decode_1;
mdurl$1.format = format$1;
mdurl$1.parse = parse$2;
var uc_micro = {};
var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var regex$2 = /[\0-\x1F\x7F-\x9F]/;
var regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
uc_micro.Any = regex$3;
uc_micro.Cc = regex$2;
uc_micro.Cf = regex$1;
uc_micro.P = regex$4;
uc_micro.Z = regex;
(function(exports2) {
  function _class2(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString2(obj) {
    return _class2(obj) === "[object String]";
  }
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has2(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  function assign2(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt2(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode2(c) {
    if (c >= 55296 && c <= 57343) {
      return false;
    }
    if (c >= 64976 && c <= 65007) {
      return false;
    }
    if ((c & 65535) === 65535 || (c & 65535) === 65534) {
      return false;
    }
    if (c >= 0 && c <= 8) {
      return false;
    }
    if (c === 11) {
      return false;
    }
    if (c >= 14 && c <= 31) {
      return false;
    }
    if (c >= 127 && c <= 159) {
      return false;
    }
    if (c > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint2(c) {
    if (c > 65535) {
      c -= 65536;
      var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
  }
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
  var entities2 = entities$1;
  function replaceEntityPattern(match2, name) {
    var code2 = 0;
    if (has2(entities2, name)) {
      return entities2[name];
    }
    if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
      code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
      if (isValidEntityCode2(code2)) {
        return fromCodePoint2(code2);
      }
    }
    return match2;
  }
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll2(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity3) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match2, entity3);
    });
  }
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }
  function escapeHtml2(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE2(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace2(code2) {
    switch (code2) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace2(code2) {
    if (code2 >= 8192 && code2 <= 8202) {
      return true;
    }
    switch (code2) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var UNICODE_PUNCT_RE = regex$4;
  function isPunctChar2(ch) {
    return UNICODE_PUNCT_RE.test(ch);
  }
  function isMdAsciiPunct2(ch) {
    switch (ch) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference2(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(/ẞ/g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  exports2.lib = {};
  exports2.lib.mdurl = mdurl$1;
  exports2.lib.ucmicro = uc_micro;
  exports2.assign = assign2;
  exports2.isString = isString2;
  exports2.has = has2;
  exports2.unescapeMd = unescapeMd;
  exports2.unescapeAll = unescapeAll2;
  exports2.isValidEntityCode = isValidEntityCode2;
  exports2.fromCodePoint = fromCodePoint2;
  exports2.escapeHtml = escapeHtml2;
  exports2.arrayReplaceAt = arrayReplaceAt2;
  exports2.isSpace = isSpace2;
  exports2.isWhiteSpace = isWhiteSpace2;
  exports2.isMdAsciiPunct = isMdAsciiPunct2;
  exports2.isPunctChar = isPunctChar2;
  exports2.escapeRE = escapeRE2;
  exports2.normalizeReference = normalizeReference2;
})(utils$1);
var helpers$1 = {};
var parse_link_label = function parseLinkLabel(state2, start2, disableNested) {
  var level, found2, marker2, prevPos, labelEnd = -1, max3 = state2.posMax, oldPos = state2.pos;
  state2.pos = start2 + 1;
  level = 1;
  while (state2.pos < max3) {
    marker2 = state2.src.charCodeAt(state2.pos);
    if (marker2 === 93) {
      level--;
      if (level === 0) {
        found2 = true;
        break;
      }
    }
    prevPos = state2.pos;
    state2.md.inline.skipToken(state2);
    if (marker2 === 91) {
      if (prevPos === state2.pos - 1) {
        level++;
      } else if (disableNested) {
        state2.pos = oldPos;
        return -1;
      }
    }
  }
  if (found2) {
    labelEnd = state2.pos;
  }
  state2.pos = oldPos;
  return labelEnd;
};
var unescapeAll$2 = utils$1.unescapeAll;
var parse_link_destination = function parseLinkDestination(str, pos, max3) {
  var code2, level, lines = 0, start2 = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max3) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll$2(str.slice(start2 + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max3) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  level = 0;
  while (pos < max3) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max3) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start2 === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll$2(str.slice(start2, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};
var unescapeAll$1 = utils$1.unescapeAll;
var parse_link_title = function parseLinkTitle(str, pos, max3) {
  var code2, marker2, lines = 0, start2 = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (pos >= max3) {
    return result;
  }
  marker2 = str.charCodeAt(pos);
  if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
    return result;
  }
  pos++;
  if (marker2 === 40) {
    marker2 = 41;
  }
  while (pos < max3) {
    code2 = str.charCodeAt(pos);
    if (code2 === marker2) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll$1(str.slice(start2 + 1, pos));
      result.ok = true;
      return result;
    } else if (code2 === 40 && marker2 === 41) {
      return result;
    } else if (code2 === 10) {
      lines++;
    } else if (code2 === 92 && pos + 1 < max3) {
      pos++;
      if (str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
    pos++;
  }
  return result;
};
helpers$1.parseLinkLabel = parse_link_label;
helpers$1.parseLinkDestination = parse_link_destination;
helpers$1.parseLinkTitle = parse_link_title;
var assign$1 = utils$1.assign;
var unescapeAll = utils$1.unescapeAll;
var escapeHtml = utils$1.escapeHtml;
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options2, env, slf) {
  var token2 = tokens[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(tokens[idx].content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options2, env, slf) {
  var token2 = tokens[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options2, env, slf) {
  var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  if (options2.highlight) {
    highlighted = options2.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
  } else {
    highlighted = escapeHtml(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    i = token2.attrIndex("class");
    tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options2.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options2.langPrefix + langName;
    }
    tmpToken = {
      attrs: tmpAttrs
    };
    return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
  }
  return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
};
default_rules.image = function(tokens, idx, options2, env, slf) {
  var token2 = tokens[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options2, env);
  return slf.renderToken(tokens, idx, options2);
};
default_rules.hardbreak = function(tokens, idx, options2) {
  return options2.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options2) {
  return options2.breaks ? options2.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer$1() {
  this.rules = assign$1({}, default_rules);
}
Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
  var i, l, result;
  if (!token2.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token2.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token2.attrs[i][0]) + '="' + escapeHtml(token2.attrs[i][1]) + '"';
  }
  return result;
};
Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options2) {
  var nextToken, result = "", needLf = false, token2 = tokens[idx];
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result += this.renderAttrs(token2);
  if (token2.nesting === 0 && options2.xhtmlOut) {
    result += " /";
  }
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer$1.prototype.renderInline = function(tokens, options2, env) {
  var type, result = "", rules = this.rules;
  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options2, env, this);
    } else {
      result += this.renderToken(tokens, i, options2);
    }
  }
  return result;
};
Renderer$1.prototype.renderInlineAsText = function(tokens, options2, env) {
  var result = "";
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === "text") {
      result += tokens[i].content;
    } else if (tokens[i].type === "image") {
      result += this.renderInlineAsText(tokens[i].children, options2, env);
    } else if (tokens[i].type === "softbreak") {
      result += "\n";
    }
  }
  return result;
};
Renderer$1.prototype.render = function(tokens, options2, env) {
  var i, len, type, result = "", rules = this.rules;
  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options2, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[tokens[i].type](tokens, i, options2, env, this);
    } else {
      result += this.renderToken(tokens, i, options2, env);
    }
  }
  return result;
};
var renderer = Renderer$1;
function Ruler$3() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler$3.prototype.__find__ = function(name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};
Ruler$3.prototype.__compile__ = function() {
  var self2 = this;
  var chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler$3.prototype.at = function(name, fn2, options2) {
  var index2 = this.__find__(name);
  var opt = options2 || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index2].fn = fn2;
  this.__rules__[index2].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler$3.prototype.before = function(beforeName, ruleName, fn2, options2) {
  var index2 = this.__find__(beforeName);
  var opt = options2 || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn: fn2,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.after = function(afterName, ruleName, fn2, options2) {
  var index2 = this.__find__(afterName);
  var opt = options2 || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn2,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.push = function(ruleName, fn2, options2) {
  var opt = options2 || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn2,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.enable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.enableOnly = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list3, ignoreInvalid);
};
Ruler$3.prototype.disable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler = Ruler$3;
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
var normalize$1 = function normalize(state2) {
  var str;
  str = state2.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state2.src = str;
};
var block = function block2(state2) {
  var token2;
  if (state2.inlineMode) {
    token2 = new state2.Token("inline", "", 0);
    token2.content = state2.src;
    token2.map = [0, 1];
    token2.children = [];
    state2.tokens.push(token2);
  } else {
    state2.md.block.parse(state2.src, state2.md, state2.env, state2.tokens);
  }
};
var inline = function inline2(state2) {
  var tokens = state2.tokens, tok, i, l;
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === "inline") {
      state2.md.inline.parse(tok.content, state2.md, state2.env, tok.children);
    }
  }
};
var arrayReplaceAt = utils$1.arrayReplaceAt;
function isLinkOpen$1(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose$1(str) {
  return /^<\/a\s*>/i.test(str);
}
var linkify$1 = function linkify(state2) {
  var i, j2, l, tokens, token2, currentToken, nodes, ln, text3, pos, lastPos, level, htmlLinkLevel, url3, fullUrl, urlText, blockTokens = state2.tokens, links;
  if (!state2.md.options.linkify) {
    return;
  }
  for (j2 = 0, l = blockTokens.length; j2 < l; j2++) {
    if (blockTokens[j2].type !== "inline" || !state2.md.linkify.pretest(blockTokens[j2].content)) {
      continue;
    }
    tokens = blockTokens[j2].children;
    htmlLinkLevel = 0;
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose$1(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state2.md.linkify.test(currentToken.content)) {
        text3 = currentToken.content;
        links = state2.md.linkify.match(text3);
        nodes = [];
        level = currentToken.level;
        lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (ln = 0; ln < links.length; ln++) {
          url3 = links[ln].url;
          fullUrl = state2.md.normalizeLink(url3);
          if (!state2.md.validateLink(fullUrl)) {
            continue;
          }
          urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state2.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state2.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state2.md.normalizeLinkText(urlText);
          }
          pos = links[ln].index;
          if (pos > lastPos) {
            token2 = new state2.Token("text", "", 0);
            token2.content = text3.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          token2 = new state2.Token("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.level = level++;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          token2 = new state2.Token("text", "", 0);
          token2.content = urlText;
          token2.level = level;
          nodes.push(token2);
          token2 = new state2.Token("link_close", "a", -1);
          token2.level = --level;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text3.length) {
          token2 = new state2.Token("text", "", 0);
          token2.content = text3.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j2].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  tm: "\u2122"
};
function replaceFn(match2, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
var replacements = function replace(state2) {
  var blkIdx;
  if (!state2.md.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state2.tokens[blkIdx].content)) {
      replace_scoped(state2.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state2.tokens[blkIdx].content)) {
      replace_rare(state2.tokens[blkIdx].children);
    }
  }
};
var isWhiteSpace$1 = utils$1.isWhiteSpace;
var isPunctChar$1 = utils$1.isPunctChar;
var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE$1 = "\u2019";
function replaceAt(str, index2, ch) {
  return str.slice(0, index2) + ch + str.slice(index2 + 1);
}
function process_inlines(tokens, state2) {
  var i, token2, text3, t2, pos, max3, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j2, isSingle, stack2, openQuote, closeQuote;
  stack2 = [];
  for (i = 0; i < tokens.length; i++) {
    token2 = tokens[i];
    thisLevel = tokens[i].level;
    for (j2 = stack2.length - 1; j2 >= 0; j2--) {
      if (stack2[j2].level <= thisLevel) {
        break;
      }
    }
    stack2.length = j2 + 1;
    if (token2.type !== "text") {
      continue;
    }
    text3 = token2.content;
    pos = 0;
    max3 = text3.length;
    OUTER:
      while (pos < max3) {
        QUOTE_RE.lastIndex = pos;
        t2 = QUOTE_RE.exec(text3);
        if (!t2) {
          break;
        }
        canOpen = canClose = true;
        pos = t2.index + 1;
        isSingle = t2[0] === "'";
        lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text3.charCodeAt(t2.index - 1);
        } else {
          for (j2 = i - 1; j2 >= 0; j2--) {
            if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak")
              break;
            if (!tokens[j2].content)
              continue;
            lastChar = tokens[j2].content.charCodeAt(tokens[j2].content.length - 1);
            break;
          }
        }
        nextChar = 32;
        if (pos < max3) {
          nextChar = text3.charCodeAt(pos);
        } else {
          for (j2 = i + 1; j2 < tokens.length; j2++) {
            if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak")
              break;
            if (!tokens[j2].content)
              continue;
            nextChar = tokens[j2].content.charCodeAt(0);
            break;
          }
        }
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t2.index, APOSTROPHE$1);
          }
          continue;
        }
        if (canClose) {
          for (j2 = stack2.length - 1; j2 >= 0; j2--) {
            item = stack2[j2];
            if (stack2[j2].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack2[j2].level === thisLevel) {
              item = stack2[j2];
              if (isSingle) {
                openQuote = state2.md.options.quotes[2];
                closeQuote = state2.md.options.quotes[3];
              } else {
                openQuote = state2.md.options.quotes[0];
                closeQuote = state2.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t2.index, closeQuote);
              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text3 = token2.content;
              max3 = text3.length;
              stack2.length = j2;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack2.push({
            token: i,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t2.index, APOSTROPHE$1);
        }
      }
  }
}
var smartquotes = function smartquotes2(state2) {
  var blkIdx;
  if (!state2.md.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state2.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state2.tokens[blkIdx].children, state2);
  }
};
var text_join = function text_join2(state2) {
  var j2, l, tokens, curr, max3, last2, blockTokens = state2.tokens;
  for (j2 = 0, l = blockTokens.length; j2 < l; j2++) {
    if (blockTokens[j2].type !== "inline")
      continue;
    tokens = blockTokens[j2].children;
    max3 = tokens.length;
    for (curr = 0; curr < max3; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last2 = 0; curr < max3; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max3 && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last2) {
          tokens[last2] = tokens[curr];
        }
        last2++;
      }
    }
    if (curr !== last2) {
      tokens.length = last2;
    }
  }
};
function Token$3(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token$3.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;
  if (!this.attrs) {
    return -1;
  }
  attrs = this.attrs;
  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};
Token$3.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token$3.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name), attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token$3.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token$3.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token$1 = Token$3;
var Token$2 = token$1;
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = Token$2;
var state_core = StateCore;
var Ruler$2 = ruler;
var _rules$2 = [
  ["normalize", normalize$1],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify$1],
  ["replacements", replacements],
  ["smartquotes", smartquotes],
  ["text_join", text_join]
];
function Core() {
  this.ruler = new Ruler$2();
  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
Core.prototype.process = function(state2) {
  var i, l, rules;
  rules = this.ruler.getRules("");
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state2);
  }
};
Core.prototype.State = state_core;
var parser_core = Core;
var isSpace$a = utils$1.isSpace;
function getLine(state2, line) {
  var pos = state2.bMarks[line] + state2.tShift[line], max3 = state2.eMarks[line];
  return state2.src.slice(pos, max3);
}
function escapedSplit(str) {
  var result = [], pos = 0, max3 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
  ch = str.charCodeAt(pos);
  while (pos < max3) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
var table = function table2(state2, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token2, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state2.sCount[nextLine] < state2.blkIndent) {
    return false;
  }
  if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
    return false;
  }
  pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  firstCh = state2.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  secondCh = state2.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace$a(secondCh)) {
    return false;
  }
  while (pos < state2.eMarks[nextLine]) {
    ch = state2.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
      return false;
    }
    pos++;
  }
  lineText = getLine(state2, startLine + 1);
  columns = lineText.split("|");
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t2 = columns[i].trim();
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state2, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  oldParentType = state2.parentType;
  state2.parentType = "table";
  terminatorRules = state2.md.block.ruler.getRules("blockquote");
  token2 = state2.push("table_open", "table", 1);
  token2.map = tableLines = [startLine, 0];
  token2 = state2.push("thead_open", "thead", 1);
  token2.map = [startLine, startLine + 1];
  token2 = state2.push("tr_open", "tr", 1);
  token2.map = [startLine, startLine + 1];
  for (i = 0; i < columns.length; i++) {
    token2 = state2.push("th_open", "th", 1);
    if (aligns[i]) {
      token2.attrs = [["style", "text-align:" + aligns[i]]];
    }
    token2 = state2.push("inline", "", 0);
    token2.content = columns[i].trim();
    token2.children = [];
    token2 = state2.push("th_close", "th", -1);
  }
  token2 = state2.push("tr_close", "tr", -1);
  token2 = state2.push("thead_close", "thead", -1);
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state2, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    if (nextLine === startLine + 2) {
      token2 = state2.push("tbody_open", "tbody", 1);
      token2.map = tbodyLines = [startLine + 2, 0];
    }
    token2 = state2.push("tr_open", "tr", 1);
    token2.map = [nextLine, nextLine + 1];
    for (i = 0; i < columnCount; i++) {
      token2 = state2.push("td_open", "td", 1);
      if (aligns[i]) {
        token2.attrs = [["style", "text-align:" + aligns[i]]];
      }
      token2 = state2.push("inline", "", 0);
      token2.content = columns[i] ? columns[i].trim() : "";
      token2.children = [];
      token2 = state2.push("td_close", "td", -1);
    }
    token2 = state2.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    token2 = state2.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  token2 = state2.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state2.parentType = oldParentType;
  state2.line = nextLine;
  return true;
};
var code$1 = function code(state2, startLine, endLine) {
  var nextLine, last2, token2;
  if (state2.sCount[startLine] - state2.blkIndent < 4) {
    return false;
  }
  last2 = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state2.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      nextLine++;
      last2 = nextLine;
      continue;
    }
    break;
  }
  state2.line = last2;
  token2 = state2.push("code_block", "code", 0);
  token2.content = state2.getLines(startLine, last2, 4 + state2.blkIndent, false) + "\n";
  token2.map = [startLine, state2.line];
  return true;
};
var fence = function fence2(state2, startLine, endLine, silent) {
  var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max3) {
    return false;
  }
  marker2 = state2.src.charCodeAt(pos);
  if (marker2 !== 126 && marker2 !== 96) {
    return false;
  }
  mem = pos;
  pos = state2.skipChars(pos, marker2);
  len = pos - mem;
  if (len < 3) {
    return false;
  }
  markup = state2.src.slice(mem, pos);
  params = state2.src.slice(pos, max3);
  if (marker2 === 96) {
    if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  nextLine = startLine;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max3 = state2.eMarks[nextLine];
    if (pos < max3 && state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.src.charCodeAt(pos) !== marker2) {
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      continue;
    }
    pos = state2.skipChars(pos, marker2);
    if (pos - mem < len) {
      continue;
    }
    pos = state2.skipSpaces(pos);
    if (pos < max3) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state2.sCount[startLine];
  state2.line = nextLine + (haveEndMarker ? 1 : 0);
  token2 = state2.push("fence", "code", 0);
  token2.info = params;
  token2.content = state2.getLines(startLine + 1, nextLine, len, true);
  token2.markup = markup;
  token2.map = [startLine, state2.line];
  return true;
};
var isSpace$9 = utils$1.isSpace;
var blockquote = function blockquote2(state2, startLine, endLine, silent) {
  var adjustTab, ch, i, initial2, l, lastLineEmpty, lines, nextLine, offset2, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state2.lineMax, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos++) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  initial2 = offset2 = state2.sCount[startLine] + 1;
  if (state2.src.charCodeAt(pos) === 32) {
    pos++;
    initial2++;
    offset2++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state2.src.charCodeAt(pos) === 9) {
    spaceAfterMarker = true;
    if ((state2.bsCount[startLine] + offset2) % 4 === 3) {
      pos++;
      initial2++;
      offset2++;
      adjustTab = false;
    } else {
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }
  oldBMarks = [state2.bMarks[startLine]];
  state2.bMarks[startLine] = pos;
  while (pos < max3) {
    ch = state2.src.charCodeAt(pos);
    if (isSpace$9(ch)) {
      if (ch === 9) {
        offset2 += 4 - (offset2 + state2.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset2++;
      }
    } else {
      break;
    }
    pos++;
  }
  oldBSCount = [state2.bsCount[startLine]];
  state2.bsCount[startLine] = state2.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max3;
  oldSCount = [state2.sCount[startLine]];
  state2.sCount[startLine] = offset2 - initial2;
  oldTShift = [state2.tShift[startLine]];
  state2.tShift[startLine] = pos - state2.bMarks[startLine];
  terminatorRules = state2.md.block.ruler.getRules("blockquote");
  oldParentType = state2.parentType;
  state2.parentType = "blockquote";
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    isOutdented = state2.sCount[nextLine] < state2.blkIndent;
    pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max3 = state2.eMarks[nextLine];
    if (pos >= max3) {
      break;
    }
    if (state2.src.charCodeAt(pos++) === 62 && !isOutdented) {
      initial2 = offset2 = state2.sCount[nextLine] + 1;
      if (state2.src.charCodeAt(pos) === 32) {
        pos++;
        initial2++;
        offset2++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state2.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state2.bsCount[nextLine] + offset2) % 4 === 3) {
          pos++;
          initial2++;
          offset2++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks.push(state2.bMarks[nextLine]);
      state2.bMarks[nextLine] = pos;
      while (pos < max3) {
        ch = state2.src.charCodeAt(pos);
        if (isSpace$9(ch)) {
          if (ch === 9) {
            offset2 += 4 - (offset2 + state2.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset2++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max3;
      oldBSCount.push(state2.bsCount[nextLine]);
      state2.bsCount[nextLine] = state2.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state2.sCount[nextLine]);
      state2.sCount[nextLine] = offset2 - initial2;
      oldTShift.push(state2.tShift[nextLine]);
      state2.tShift[nextLine] = pos - state2.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state2.lineMax = nextLine;
      if (state2.blkIndent !== 0) {
        oldBMarks.push(state2.bMarks[nextLine]);
        oldBSCount.push(state2.bsCount[nextLine]);
        oldTShift.push(state2.tShift[nextLine]);
        oldSCount.push(state2.sCount[nextLine]);
        state2.sCount[nextLine] -= state2.blkIndent;
      }
      break;
    }
    oldBMarks.push(state2.bMarks[nextLine]);
    oldBSCount.push(state2.bsCount[nextLine]);
    oldTShift.push(state2.tShift[nextLine]);
    oldSCount.push(state2.sCount[nextLine]);
    state2.sCount[nextLine] = -1;
  }
  oldIndent = state2.blkIndent;
  state2.blkIndent = 0;
  token2 = state2.push("blockquote_open", "blockquote", 1);
  token2.markup = ">";
  token2.map = lines = [startLine, 0];
  state2.md.block.tokenize(state2, startLine, nextLine);
  token2 = state2.push("blockquote_close", "blockquote", -1);
  token2.markup = ">";
  state2.lineMax = oldLineMax;
  state2.parentType = oldParentType;
  lines[1] = state2.line;
  for (i = 0; i < oldTShift.length; i++) {
    state2.bMarks[i + startLine] = oldBMarks[i];
    state2.tShift[i + startLine] = oldTShift[i];
    state2.sCount[i + startLine] = oldSCount[i];
    state2.bsCount[i + startLine] = oldBSCount[i];
  }
  state2.blkIndent = oldIndent;
  return true;
};
var isSpace$8 = utils$1.isSpace;
var hr = function hr2(state2, startLine, endLine, silent) {
  var marker2, cnt, ch, token2, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  marker2 = state2.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
    return false;
  }
  cnt = 1;
  while (pos < max3) {
    ch = state2.src.charCodeAt(pos++);
    if (ch !== marker2 && !isSpace$8(ch)) {
      return false;
    }
    if (ch === marker2) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state2.line = startLine + 1;
  token2 = state2.push("hr", "hr", 0);
  token2.map = [startLine, state2.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
  return true;
};
var isSpace$7 = utils$1.isSpace;
function skipBulletListMarker(state2, startLine) {
  var marker2, pos, max3, ch;
  pos = state2.bMarks[startLine] + state2.tShift[startLine];
  max3 = state2.eMarks[startLine];
  marker2 = state2.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
    return -1;
  }
  if (pos < max3) {
    ch = state2.src.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state2, startLine) {
  var ch, start2 = state2.bMarks[startLine] + state2.tShift[startLine], pos = start2, max3 = state2.eMarks[startLine];
  if (pos + 1 >= max3) {
    return -1;
  }
  ch = state2.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max3) {
      return -1;
    }
    ch = state2.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start2 >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max3) {
    ch = state2.src.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state2, idx) {
  var i, l, level = state2.level + 2;
  for (i = idx + 2, l = state2.tokens.length - 2; i < l; i++) {
    if (state2.tokens[i].level === level && state2.tokens[i].type === "paragraph_open") {
      state2.tokens[i + 2].hidden = true;
      state2.tokens[i].hidden = true;
      i += 2;
    }
  }
}
var list = function list2(state2, startLine, endLine, silent) {
  var ch, contentStart, i, indent, indentAfterMarker, initial2, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max3, nextLine, offset2, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.listIndent >= 0 && state2.sCount[startLine] - state2.listIndent >= 4 && state2.sCount[startLine] < state2.blkIndent) {
    return false;
  }
  if (silent && state2.parentType === "paragraph") {
    if (state2.sCount[startLine] >= state2.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  if ((posAfterMarker = skipOrderedListMarker(state2, startLine)) >= 0) {
    isOrdered = true;
    start2 = state2.bMarks[startLine] + state2.tShift[startLine];
    markerValue = Number(state2.src.slice(start2, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state2, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state2.skipSpaces(posAfterMarker) >= state2.eMarks[startLine])
      return false;
  }
  markerCharCode = state2.src.charCodeAt(posAfterMarker - 1);
  if (silent) {
    return true;
  }
  listTokIdx = state2.tokens.length;
  if (isOrdered) {
    token2 = state2.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state2.push("bullet_list_open", "ul", 1);
  }
  token2.map = listLines = [startLine, 0];
  token2.markup = String.fromCharCode(markerCharCode);
  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state2.md.block.ruler.getRules("list");
  oldParentType = state2.parentType;
  state2.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max3 = state2.eMarks[nextLine];
    initial2 = offset2 = state2.sCount[nextLine] + posAfterMarker - (state2.bMarks[startLine] + state2.tShift[startLine]);
    while (pos < max3) {
      ch = state2.src.charCodeAt(pos);
      if (ch === 9) {
        offset2 += 4 - (offset2 + state2.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset2++;
      } else {
        break;
      }
      pos++;
    }
    contentStart = pos;
    if (contentStart >= max3) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset2 - initial2;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    indent = initial2 + indentAfterMarker;
    token2 = state2.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    token2.map = itemLines = [startLine, 0];
    if (isOrdered) {
      token2.info = state2.src.slice(start2, posAfterMarker - 1);
    }
    oldTight = state2.tight;
    oldTShift = state2.tShift[startLine];
    oldSCount = state2.sCount[startLine];
    oldListIndent = state2.listIndent;
    state2.listIndent = state2.blkIndent;
    state2.blkIndent = indent;
    state2.tight = true;
    state2.tShift[startLine] = contentStart - state2.bMarks[startLine];
    state2.sCount[startLine] = offset2;
    if (contentStart >= max3 && state2.isEmpty(startLine + 1)) {
      state2.line = Math.min(state2.line + 2, endLine);
    } else {
      state2.md.block.tokenize(state2, startLine, endLine, true);
    }
    if (!state2.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state2.line - startLine > 1 && state2.isEmpty(state2.line - 1);
    state2.blkIndent = state2.listIndent;
    state2.listIndent = oldListIndent;
    state2.tShift[startLine] = oldTShift;
    state2.sCount[startLine] = oldSCount;
    state2.tight = oldTight;
    token2 = state2.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state2.line;
    itemLines[1] = nextLine;
    contentStart = state2.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.sCount[startLine] - state2.blkIndent >= 4) {
      break;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start2 = state2.bMarks[nextLine] + state2.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state2.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state2.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state2.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state2.line = nextLine;
  state2.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state2, listTokIdx);
  }
  return true;
};
var normalizeReference$2 = utils$1.normalizeReference;
var isSpace$6 = utils$1.isSpace;
var reference$1 = function reference(state2, startLine, _endLine, silent) {
  var ch, destEndPos, destEndLineNo, endLine, href, i, l, label2, labelEnd, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine], nextLine = startLine + 1;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 91) {
    return false;
  }
  while (++pos < max3) {
    if (state2.src.charCodeAt(pos) === 93 && state2.src.charCodeAt(pos - 1) !== 92) {
      if (pos + 1 === max3) {
        return false;
      }
      if (state2.src.charCodeAt(pos + 1) !== 58) {
        return false;
      }
      break;
    }
  }
  endLine = state2.lineMax;
  terminatorRules = state2.md.block.ruler.getRules("reference");
  oldParentType = state2.parentType;
  state2.parentType = "reference";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  str = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  max3 = str.length;
  for (pos = 1; pos < max3; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      lines++;
    } else if (ch === 92) {
      pos++;
      if (pos < max3 && str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max3; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$6(ch))
      ;
    else {
      break;
    }
  }
  res = state2.md.helpers.parseLinkDestination(str, pos, max3);
  if (!res.ok) {
    return false;
  }
  href = state2.md.normalizeLink(res.str);
  if (!state2.md.validateLink(href)) {
    return false;
  }
  pos = res.pos;
  lines += res.lines;
  destEndPos = pos;
  destEndLineNo = lines;
  start2 = pos;
  for (; pos < max3; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$6(ch))
      ;
    else {
      break;
    }
  }
  res = state2.md.helpers.parseLinkTitle(str, pos, max3);
  if (pos < max3 && start2 !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = "";
    pos = destEndPos;
    lines = destEndLineNo;
  }
  while (pos < max3) {
    ch = str.charCodeAt(pos);
    if (!isSpace$6(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max3 && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max3) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max3 && str.charCodeAt(pos) !== 10) {
    return false;
  }
  label2 = normalizeReference$2(str.slice(1, labelEnd));
  if (!label2) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state2.env.references === "undefined") {
    state2.env.references = {};
  }
  if (typeof state2.env.references[label2] === "undefined") {
    state2.env.references[label2] = { title, href };
  }
  state2.parentType = oldParentType;
  state2.line = startLine + lines + 1;
  return true;
};
var html_blocks = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var html_re = {};
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
html_re.HTML_TAG_RE = HTML_TAG_RE$1;
html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
var block_names = html_blocks;
var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
var html_block = function html_block2(state2, startLine, endLine, silent) {
  var i, nextLine, token2, lineText, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (!state2.md.options.html) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  lineText = state2.src.slice(pos, max3);
  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state2.sCount[nextLine] < state2.blkIndent) {
        break;
      }
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      max3 = state2.eMarks[nextLine];
      lineText = state2.src.slice(pos, max3);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state2.line = nextLine;
  token2 = state2.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state2.getLines(startLine, nextLine, state2.blkIndent, true);
  return true;
};
var isSpace$5 = utils$1.isSpace;
var heading = function heading2(state2, startLine, endLine, silent) {
  var ch, level, tmp, token2, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  ch = state2.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max3) {
    return false;
  }
  level = 1;
  ch = state2.src.charCodeAt(++pos);
  while (ch === 35 && pos < max3 && level <= 6) {
    level++;
    ch = state2.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max3 && !isSpace$5(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max3 = state2.skipSpacesBack(max3, pos);
  tmp = state2.skipCharsBack(max3, 35, pos);
  if (tmp > pos && isSpace$5(state2.src.charCodeAt(tmp - 1))) {
    max3 = tmp;
  }
  state2.line = startLine + 1;
  token2 = state2.push("heading_open", "h" + String(level), 1);
  token2.markup = "########".slice(0, level);
  token2.map = [startLine, state2.line];
  token2 = state2.push("inline", "", 0);
  token2.content = state2.src.slice(pos, max3).trim();
  token2.map = [startLine, state2.line];
  token2.children = [];
  token2 = state2.push("heading_close", "h" + String(level), -1);
  token2.markup = "########".slice(0, level);
  return true;
};
var lheading = function lheading2(state2, startLine, endLine) {
  var content, terminate, i, l, token2, pos, max3, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state2.md.block.ruler.getRules("paragraph");
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  oldParentType = state2.parentType;
  state2.parentType = "paragraph";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] >= state2.blkIndent) {
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      max3 = state2.eMarks[nextLine];
      if (pos < max3) {
        marker2 = state2.src.charCodeAt(pos);
        if (marker2 === 45 || marker2 === 61) {
          pos = state2.skipChars(pos, marker2);
          pos = state2.skipSpaces(pos);
          if (pos >= max3) {
            level = marker2 === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine + 1;
  token2 = state2.push("heading_open", "h" + String(level), 1);
  token2.markup = String.fromCharCode(marker2);
  token2.map = [startLine, state2.line];
  token2 = state2.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state2.line - 1];
  token2.children = [];
  token2 = state2.push("heading_close", "h" + String(level), -1);
  token2.markup = String.fromCharCode(marker2);
  state2.parentType = oldParentType;
  return true;
};
var paragraph = function paragraph2(state2, startLine) {
  var content, terminate, i, l, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state2.md.block.ruler.getRules("paragraph"), endLine = state2.lineMax;
  oldParentType = state2.parentType;
  state2.parentType = "paragraph";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine;
  token2 = state2.push("paragraph_open", "p", 1);
  token2.map = [startLine, state2.line];
  token2 = state2.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state2.line];
  token2.children = [];
  token2 = state2.push("paragraph_close", "p", -1);
  state2.parentType = oldParentType;
  return true;
};
var Token$1 = token$1;
var isSpace$4 = utils$1.isSpace;
function StateBlock(src, md, env, tokens) {
  var ch, s, start2, pos, len, indent, offset2, indent_found;
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  this.result = "";
  s = this.src;
  indent_found = false;
  for (start2 = pos = indent = offset2 = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace$4(ch)) {
        indent++;
        if (ch === 9) {
          offset2 += 4 - offset2 % 4;
        } else {
          offset2++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start2);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset2);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset2 = 0;
      start2 = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  var token2 = new Token$1(type, tag, nesting);
  token2.block = true;
  if (nesting < 0)
    this.level--;
  token2.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from2) {
  for (var max3 = this.lineMax; from2 < max3; from2++) {
    if (this.bMarks[from2] + this.tShift[from2] < this.eMarks[from2]) {
      break;
    }
  }
  return from2;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;
  for (var max3 = this.src.length; pos < max3; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace$4(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min3) {
  if (pos <= min3) {
    return pos;
  }
  while (pos > min3) {
    if (!isSpace$4(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (var max3 = this.src.length; pos < max3; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min3) {
  if (pos <= min3) {
    return pos;
  }
  while (pos > min3) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin3, end3, indent, keepLastLF) {
  var i, lineIndent, ch, first2, last2, queue2, lineStart, line = begin3;
  if (begin3 >= end3) {
    return "";
  }
  queue2 = new Array(end3 - begin3);
  for (i = 0; line < end3; line++, i++) {
    lineIndent = 0;
    lineStart = first2 = this.bMarks[line];
    if (line + 1 < end3 || keepLastLF) {
      last2 = this.eMarks[line] + 1;
    } else {
      last2 = this.eMarks[line];
    }
    while (first2 < last2 && lineIndent < indent) {
      ch = this.src.charCodeAt(first2);
      if (isSpace$4(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first2 - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first2++;
    }
    if (lineIndent > indent) {
      queue2[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last2);
    } else {
      queue2[i] = this.src.slice(first2, last2);
    }
  }
  return queue2.join("");
};
StateBlock.prototype.Token = Token$1;
var state_block = StateBlock;
var Ruler$1 = ruler;
var _rules$1 = [
  ["table", table, ["paragraph", "reference"]],
  ["code", code$1],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference$1],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock$1() {
  this.ruler = new Ruler$1();
  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
ParserBlock$1.prototype.tokenize = function(state2, startLine, endLine) {
  var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state2.md.options.maxNesting;
  while (line < endLine) {
    state2.line = line = state2.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state2.sCount[line] < state2.blkIndent) {
      break;
    }
    if (state2.level >= maxNesting) {
      state2.line = endLine;
      break;
    }
    for (i = 0; i < len; i++) {
      ok = rules[i](state2, line, endLine, false);
      if (ok) {
        break;
      }
    }
    state2.tight = !hasEmptyLines;
    if (state2.isEmpty(state2.line - 1)) {
      hasEmptyLines = true;
    }
    line = state2.line;
    if (line < endLine && state2.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state2.line = line;
    }
  }
};
ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
  var state2;
  if (!src) {
    return;
  }
  state2 = new this.State(src, md, env, outTokens);
  this.tokenize(state2, state2.line, state2.lineMax);
};
ParserBlock$1.prototype.State = state_block;
var parser_block = ParserBlock$1;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
var text$2 = function text(state2, silent) {
  var pos = state2.pos;
  while (pos < state2.posMax && !isTerminatorChar(state2.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state2.pos) {
    return false;
  }
  if (!silent) {
    state2.pending += state2.src.slice(state2.pos, pos);
  }
  state2.pos = pos;
  return true;
};
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
var linkify2 = function linkify3(state2, silent) {
  var pos, max3, match2, proto, link3, url3, fullUrl, token2;
  if (!state2.md.options.linkify)
    return false;
  if (state2.linkLevel > 0)
    return false;
  pos = state2.pos;
  max3 = state2.posMax;
  if (pos + 3 > max3)
    return false;
  if (state2.src.charCodeAt(pos) !== 58)
    return false;
  if (state2.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state2.src.charCodeAt(pos + 2) !== 47)
    return false;
  match2 = state2.pending.match(SCHEME_RE);
  if (!match2)
    return false;
  proto = match2[1];
  link3 = state2.md.linkify.matchAtStart(state2.src.slice(pos - proto.length));
  if (!link3)
    return false;
  url3 = link3.url;
  url3 = url3.replace(/\*+$/, "");
  fullUrl = state2.md.normalizeLink(url3);
  if (!state2.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state2.pending = state2.pending.slice(0, -proto.length);
    token2 = state2.push("link_open", "a", 1);
    token2.attrs = [["href", fullUrl]];
    token2.markup = "linkify";
    token2.info = "auto";
    token2 = state2.push("text", "", 0);
    token2.content = state2.md.normalizeLinkText(url3);
    token2 = state2.push("link_close", "a", -1);
    token2.markup = "linkify";
    token2.info = "auto";
  }
  state2.pos += url3.length - proto.length;
  return true;
};
var isSpace$3 = utils$1.isSpace;
var newline = function newline2(state2, silent) {
  var pmax, max3, ws, pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 10) {
    return false;
  }
  pmax = state2.pending.length - 1;
  max3 = state2.posMax;
  if (!silent) {
    if (pmax >= 0 && state2.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state2.pending.charCodeAt(pmax - 1) === 32) {
        ws = pmax - 1;
        while (ws >= 1 && state2.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state2.pending = state2.pending.slice(0, ws);
        state2.push("hardbreak", "br", 0);
      } else {
        state2.pending = state2.pending.slice(0, -1);
        state2.push("softbreak", "br", 0);
      }
    } else {
      state2.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max3 && isSpace$3(state2.src.charCodeAt(pos))) {
    pos++;
  }
  state2.pos = pos;
  return true;
};
var isSpace$2 = utils$1.isSpace;
var ESCAPED = [];
for (var i$1 = 0; i$1 < 256; i$1++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
var _escape = function escape(state2, silent) {
  var ch1, ch2, origStr, escapedStr, token2, pos = state2.pos, max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max3)
    return false;
  ch1 = state2.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state2.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max3) {
      ch1 = state2.src.charCodeAt(pos);
      if (!isSpace$2(ch1))
        break;
      pos++;
    }
    state2.pos = pos;
    return true;
  }
  escapedStr = state2.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max3) {
    ch2 = state2.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state2.src[pos + 1];
      pos++;
    }
  }
  origStr = "\\" + escapedStr;
  if (!silent) {
    token2 = state2.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token2.content = escapedStr;
    } else {
      token2.content = origStr;
    }
    token2.markup = origStr;
    token2.info = "escape";
  }
  state2.pos = pos + 1;
  return true;
};
var backticks = function backtick(state2, silent) {
  var start2, max3, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state2.pos, ch = state2.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  start2 = pos;
  pos++;
  max3 = state2.posMax;
  while (pos < max3 && state2.src.charCodeAt(pos) === 96) {
    pos++;
  }
  marker2 = state2.src.slice(start2, pos);
  openerLength = marker2.length;
  if (state2.backticksScanned && (state2.backticks[openerLength] || 0) <= start2) {
    if (!silent)
      state2.pending += marker2;
    state2.pos += openerLength;
    return true;
  }
  matchStart = matchEnd = pos;
  while ((matchStart = state2.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max3 && state2.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        token2 = state2.push("code_inline", "code", 0);
        token2.markup = marker2;
        token2.content = state2.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state2.pos = matchEnd;
      return true;
    }
    state2.backticks[closerLength] = matchStart;
  }
  state2.backticksScanned = true;
  if (!silent)
    state2.pending += marker2;
  state2.pos += openerLength;
  return true;
};
var strikethrough = {};
strikethrough.tokenize = function strikethrough2(state2, silent) {
  var i, scanned, token2, len, ch, start2 = state2.pos, marker2 = state2.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker2 !== 126) {
    return false;
  }
  scanned = state2.scanDelims(state2.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker2);
  if (len < 2) {
    return false;
  }
  if (len % 2) {
    token2 = state2.push("text", "", 0);
    token2.content = ch;
    len--;
  }
  for (i = 0; i < len; i += 2) {
    token2 = state2.push("text", "", 0);
    token2.content = ch + ch;
    state2.delimiters.push({
      marker: marker2,
      length: 0,
      token: state2.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
};
function postProcess$1(state2, delimiters) {
  var i, j2, startDelim, endDelim, token2, loneMarkers = [], max3 = delimiters.length;
  for (i = 0; i < max3; i++) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    token2 = state2.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state2.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state2.tokens[endDelim.token - 1].type === "text" && state2.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j2 = i + 1;
    while (j2 < state2.tokens.length && state2.tokens[j2].type === "s_close") {
      j2++;
    }
    j2--;
    if (i !== j2) {
      token2 = state2.tokens[j2];
      state2.tokens[j2] = state2.tokens[i];
      state2.tokens[i] = token2;
    }
  }
}
strikethrough.postProcess = function strikethrough3(state2) {
  var curr, tokens_meta = state2.tokens_meta, max3 = state2.tokens_meta.length;
  postProcess$1(state2, state2.delimiters);
  for (curr = 0; curr < max3; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state2, tokens_meta[curr].delimiters);
    }
  }
};
var emphasis = {};
emphasis.tokenize = function emphasis2(state2, silent) {
  var i, scanned, token2, start2 = state2.pos, marker2 = state2.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker2 !== 95 && marker2 !== 42) {
    return false;
  }
  scanned = state2.scanDelims(state2.pos, marker2 === 42);
  for (i = 0; i < scanned.length; i++) {
    token2 = state2.push("text", "", 0);
    token2.content = String.fromCharCode(marker2);
    state2.delimiters.push({
      marker: marker2,
      length: scanned.length,
      token: state2.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
};
function postProcess(state2, delimiters) {
  var i, startDelim, endDelim, token2, ch, isStrong, max3 = delimiters.length;
  for (i = max3 - 1; i >= 0; i--) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
    ch = String.fromCharCode(startDelim.marker);
    token2 = state2.tokens[startDelim.token];
    token2.type = isStrong ? "strong_open" : "em_open";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = 1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    token2 = state2.tokens[endDelim.token];
    token2.type = isStrong ? "strong_close" : "em_close";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = -1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    if (isStrong) {
      state2.tokens[delimiters[i - 1].token].content = "";
      state2.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
emphasis.postProcess = function emphasis3(state2) {
  var curr, tokens_meta = state2.tokens_meta, max3 = state2.tokens_meta.length;
  postProcess(state2, state2.delimiters);
  for (curr = 0; curr < max3; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state2, tokens_meta[curr].delimiters);
    }
  }
};
var normalizeReference$1 = utils$1.normalizeReference;
var isSpace$1 = utils$1.isSpace;
var link = function link2(state2, silent) {
  var attrs, code2, label2, labelEnd, labelStart, pos, res, ref2, token2, href = "", title = "", oldPos = state2.pos, max3 = state2.posMax, start2 = state2.pos, parseReference = true;
  if (state2.src.charCodeAt(state2.pos) !== 91) {
    return false;
  }
  labelStart = state2.pos + 1;
  labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max3 && state2.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max3; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace$1(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max3) {
      return false;
    }
    start2 = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start2 = pos;
      for (; pos < max3; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (!isSpace$1(code2) && code2 !== 10) {
          break;
        }
      }
      res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
      if (pos < max3 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max3; pos++) {
          code2 = state2.src.charCodeAt(pos);
          if (!isSpace$1(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max3 || state2.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max3 && state2.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label2 = state2.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label2) {
      label2 = state2.src.slice(labelStart, labelEnd);
    }
    ref2 = state2.env.references[normalizeReference$1(label2)];
    if (!ref2) {
      state2.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    state2.pos = labelStart;
    state2.posMax = labelEnd;
    token2 = state2.push("link_open", "a", 1);
    token2.attrs = attrs = [["href", href]];
    if (title) {
      attrs.push(["title", title]);
    }
    state2.linkLevel++;
    state2.md.inline.tokenize(state2);
    state2.linkLevel--;
    token2 = state2.push("link_close", "a", -1);
  }
  state2.pos = pos;
  state2.posMax = max3;
  return true;
};
var normalizeReference = utils$1.normalizeReference;
var isSpace = utils$1.isSpace;
var image = function image2(state2, silent) {
  var attrs, code2, content, label2, labelEnd, labelStart, pos, ref2, res, title, token2, tokens, start2, href = "", oldPos = state2.pos, max3 = state2.posMax;
  if (state2.src.charCodeAt(state2.pos) !== 33) {
    return false;
  }
  if (state2.src.charCodeAt(state2.pos + 1) !== 91) {
    return false;
  }
  labelStart = state2.pos + 2;
  labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max3 && state2.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max3; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max3) {
      return false;
    }
    start2 = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start2 = pos;
    for (; pos < max3; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
    if (pos < max3 && start2 !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max3; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max3 || state2.src.charCodeAt(pos) !== 41) {
      state2.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max3 && state2.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label2 = state2.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label2) {
      label2 = state2.src.slice(labelStart, labelEnd);
    }
    ref2 = state2.env.references[normalizeReference(label2)];
    if (!ref2) {
      state2.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    content = state2.src.slice(labelStart, labelEnd);
    state2.md.inline.parse(content, state2.md, state2.env, tokens = []);
    token2 = state2.push("image", "img", 0);
    token2.attrs = attrs = [["src", href], ["alt", ""]];
    token2.children = tokens;
    token2.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state2.pos = pos;
  state2.posMax = max3;
  return true;
};
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var autolink$1 = function autolink(state2, silent) {
  var url3, fullUrl, token2, ch, start2, max3, pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  start2 = state2.pos;
  max3 = state2.posMax;
  for (; ; ) {
    if (++pos >= max3)
      return false;
    ch = state2.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  url3 = state2.src.slice(start2 + 1, pos);
  if (AUTOLINK_RE.test(url3)) {
    fullUrl = state2.md.normalizeLink(url3);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state2.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state2.push("text", "", 0);
      token2.content = state2.md.normalizeLinkText(url3);
      token2 = state2.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state2.pos += url3.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url3)) {
    fullUrl = state2.md.normalizeLink("mailto:" + url3);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state2.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state2.push("text", "", 0);
      token2.content = state2.md.normalizeLinkText(url3);
      token2 = state2.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state2.pos += url3.length + 2;
    return true;
  }
  return false;
};
var HTML_TAG_RE = html_re.HTML_TAG_RE;
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  var lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
var html_inline = function html_inline2(state2, silent) {
  var ch, match2, max3, token2, pos = state2.pos;
  if (!state2.md.options.html) {
    return false;
  }
  max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 60 || pos + 2 >= max3) {
    return false;
  }
  ch = state2.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  match2 = state2.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    token2 = state2.push("html_inline", "", 0);
    token2.content = state2.src.slice(pos, pos + match2[0].length);
    if (isLinkOpen(token2.content))
      state2.linkLevel++;
    if (isLinkClose(token2.content))
      state2.linkLevel--;
  }
  state2.pos += match2[0].length;
  return true;
};
var entities = entities$1;
var has$2 = utils$1.has;
var isValidEntityCode = utils$1.isValidEntityCode;
var fromCodePoint = utils$1.fromCodePoint;
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
var entity = function entity2(state2, silent) {
  var ch, code2, match2, token2, pos = state2.pos, max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max3)
    return false;
  ch = state2.src.charCodeAt(pos + 1);
  if (ch === 35) {
    match2 = state2.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        token2 = state2.push("text_special", "", 0);
        token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
        token2.markup = match2[0];
        token2.info = "entity";
      }
      state2.pos += match2[0].length;
      return true;
    }
  } else {
    match2 = state2.src.slice(pos).match(NAMED_RE);
    if (match2) {
      if (has$2(entities, match2[1])) {
        if (!silent) {
          token2 = state2.push("text_special", "", 0);
          token2.content = entities[match2[1]];
          token2.markup = match2[0];
          token2.info = "entity";
        }
        state2.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
};
function processDelimiters(state2, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max3 = delimiters.length;
  if (!max3)
    return;
  var headerIdx = 0;
  var lastTokenIdx = -2;
  var jumps = [];
  for (closerIdx = 0; closerIdx < max3; closerIdx++) {
    closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    openerIdx = headerIdx - jumps[headerIdx] - 1;
    newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
var balance_pairs = function link_pairs(state2) {
  var curr, tokens_meta = state2.tokens_meta, max3 = state2.tokens_meta.length;
  processDelimiters(state2, state2.delimiters);
  for (curr = 0; curr < max3; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state2, tokens_meta[curr].delimiters);
    }
  }
};
var fragments_join = function fragments_join2(state2) {
  var curr, last2, level = 0, tokens = state2.tokens, max3 = state2.tokens.length;
  for (curr = last2 = 0; curr < max3; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max3 && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last2) {
        tokens[last2] = tokens[curr];
      }
      last2++;
    }
  }
  if (curr !== last2) {
    tokens.length = last2;
  }
};
var Token = token$1;
var isWhiteSpace = utils$1.isWhiteSpace;
var isPunctChar = utils$1.isPunctChar;
var isMdAsciiPunct = utils$1.isMdAsciiPunct;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  var token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  var token2 = new Token(type, tag, nesting);
  var token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start2, canSplitWord) {
  var pos = start2, lastChar, nextChar, count2, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max3 = this.posMax, marker2 = this.src.charCodeAt(start2);
  lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
  while (pos < max3 && this.src.charCodeAt(pos) === marker2) {
    pos++;
  }
  count2 = pos - start2;
  nextChar = pos < max3 ? this.src.charCodeAt(pos) : 32;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);
  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }
  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }
  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }
  return {
    can_open,
    can_close,
    length: count2
  };
};
StateInline.prototype.Token = Token;
var state_inline = StateInline;
var Ruler = ruler;
var _rules = [
  ["text", text$2],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", _escape],
  ["backticks", backticks],
  ["strikethrough", strikethrough.tokenize],
  ["emphasis", emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink$1],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules2 = [
  ["balance_pairs", balance_pairs],
  ["strikethrough", strikethrough.postProcess],
  ["emphasis", emphasis.postProcess],
  ["fragments_join", fragments_join]
];
function ParserInline$1() {
  var i;
  this.ruler = new Ruler();
  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
ParserInline$1.prototype.skipToken = function(state2) {
  var ok, i, pos = state2.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state2.md.options.maxNesting, cache = state2.cache;
  if (typeof cache[pos] !== "undefined") {
    state2.pos = cache[pos];
    return;
  }
  if (state2.level < maxNesting) {
    for (i = 0; i < len; i++) {
      state2.level++;
      ok = rules[i](state2, true);
      state2.level--;
      if (ok) {
        break;
      }
    }
  } else {
    state2.pos = state2.posMax;
  }
  if (!ok) {
    state2.pos++;
  }
  cache[pos] = state2.pos;
};
ParserInline$1.prototype.tokenize = function(state2) {
  var ok, i, rules = this.ruler.getRules(""), len = rules.length, end3 = state2.posMax, maxNesting = state2.md.options.maxNesting;
  while (state2.pos < end3) {
    if (state2.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state2, false);
        if (ok) {
          break;
        }
      }
    }
    if (ok) {
      if (state2.pos >= end3) {
        break;
      }
      continue;
    }
    state2.pending += state2.src[state2.pos++];
  }
  if (state2.pending) {
    state2.pushPending();
  }
};
ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
  var i, rules, len;
  var state2 = new this.State(str, md, env, outTokens);
  this.tokenize(state2);
  rules = this.ruler2.getRules("");
  len = rules.length;
  for (i = 0; i < len; i++) {
    rules[i](state2);
  }
};
ParserInline$1.prototype.State = state_inline;
var parser_inline = ParserInline$1;
var re = function(opts) {
  var re2 = {};
  opts = opts || {};
  re2.src_Any = regex$3.source;
  re2.src_Cc = regex$2.source;
  re2.src_Z = regex.source;
  re2.src_P = regex$4.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  var text_separators = "[><\uFF5C]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
};
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
function isObject$3(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp$3(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction$2(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k2) {
    return acc || defaultOptions.hasOwnProperty(k2);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text3[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text3[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text3, pos) {
    var tail = text3.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile(self2) {
  var re$12 = self2.re = re(self2.__opts__);
  var tlds3 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds3.push(tlds_2ch_src_re);
  }
  tlds3.push(re$12.src_xn);
  re$12.src_tlds = tlds3.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re$12.src_tlds);
  }
  re$12.email_fuzzy = RegExp(untpl(re$12.tpl_email_fuzzy), "i");
  re$12.link_fuzzy = RegExp(untpl(re$12.tpl_link_fuzzy), "i");
  re$12.link_no_ip_fuzzy = RegExp(untpl(re$12.tpl_link_no_ip_fuzzy), "i");
  re$12.host_fuzzy_test = RegExp(untpl(re$12.tpl_host_fuzzy_test), "i");
  var aliases = [];
  self2.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name) {
    var val = self2.__schemas__[name];
    if (val === null) {
      return;
    }
    var compiled = { validate: null, link: null };
    self2.__compiled__[name] = compiled;
    if (isObject$3(val)) {
      if (isRegExp$3(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction$2(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction$2(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  var slist = Object.keys(self2.__compiled__).filter(function(name) {
    return name.length > 0 && self2.__compiled__[name];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$12.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$12.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
  resetScanCache(self2);
}
function Match(self2, shift2) {
  var start2 = self2.__index__, end3 = self2.__last_index__, text3 = self2.__text_cache__.slice(start2, end3);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start2 + shift2;
  this.lastIndex = end3 + shift2;
  this.raw = text3;
  this.text = text3;
  this.url = text3;
}
function createMatch(self2, shift2) {
  var match2 = new Match(self2, shift2);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt$1(schemas, options2) {
  if (!(this instanceof LinkifyIt$1)) {
    return new LinkifyIt$1(schemas, options2);
  }
  if (!options2) {
    if (isOptionsObj(schemas)) {
      options2 = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options2);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt$1.prototype.add = function add2(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt$1.prototype.set = function set2(options2) {
  this.__opts__ = assign(this.__opts__, options2);
  return this;
};
LinkifyIt$1.prototype.test = function test(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length) {
    return false;
  }
  var m, ml, me2, len, shift2, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text3)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m = re2.exec(text3)) !== null) {
      len = this.testSchemaAt(text3, m[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text3.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift2 = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift2 < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift2;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text3.indexOf("@");
    if (at_pos >= 0) {
      if ((me2 = text3.match(this.re.email_fuzzy)) !== null) {
        shift2 = me2.index + me2[1].length;
        next = me2.index + me2[0].length;
        if (this.__index__ < 0 || shift2 < this.__index__ || shift2 === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift2;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt$1.prototype.pretest = function pretest(text3) {
  return this.re.pretest.test(text3);
};
LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text3, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text3, pos, this);
};
LinkifyIt$1.prototype.match = function match(text3) {
  var shift2 = 0, result = [];
  if (this.__index__ >= 0 && this.__text_cache__ === text3) {
    result.push(createMatch(this, shift2));
    shift2 = this.__last_index__;
  }
  var tail = shift2 ? text3.slice(shift2) : text3;
  while (this.test(tail)) {
    result.push(createMatch(this, shift2));
    tail = tail.slice(this.__last_index__);
    shift2 += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt$1.prototype.matchAtStart = function matchAtStart(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length)
    return null;
  var m = this.re.schema_at_start.exec(text3);
  if (!m)
    return null;
  var len = this.testSchemaAt(text3, m[2], m[0].length);
  if (!len)
    return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt$1.prototype.tlds = function tlds(list3, keepOld) {
  list3 = Array.isArray(list3) ? list3 : [list3];
  if (!keepOld) {
    this.__tlds__ = list3.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list3).sort().filter(function(el2, idx, arr) {
    return el2 !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt$1.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt$1.prototype.onCompile = function onCompile() {
};
var linkifyIt = LinkifyIt$1;
const maxInt = 2147483647;
const base$1 = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base$1 - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$1(array, fn2) {
  const result = [];
  let length3 = array.length;
  while (length3--) {
    result[length3] = fn2(array[length3]);
  }
  return result;
}
function mapDomain(string, fn2) {
  const parts = string.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map$1(labels, fn2).join(".");
  return result + encoded;
}
function ucs2decode$1(string) {
  const output = [];
  let counter = 0;
  const length3 = string.length;
  while (counter < length3) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length3) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (array) => String.fromCodePoint(...array);
const basicToDigit = function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base$1;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta2, numPoints, firstTime) {
  let k2 = 0;
  delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
  delta2 += floor(delta2 / numPoints);
  for (; delta2 > baseMinusTMin * tMax >> 1; k2 += base$1) {
    delta2 = floor(delta2 / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
};
const decode = function(input2) {
  const output = [];
  const inputLength = input2.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input2.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j2 = 0; j2 < basic; ++j2) {
    if (input2.charCodeAt(j2) >= 128) {
      error("not-basic");
    }
    output.push(input2.charCodeAt(j2));
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    let oldi = i;
    for (let w2 = 1, k2 = base$1; ; k2 += base$1) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input2.charCodeAt(index2++));
      if (digit >= base$1 || digit > floor((maxInt - i) / w2)) {
        error("overflow");
      }
      i += digit * w2;
      const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base$1 - t2;
      if (w2 > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w2 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input2) {
  const output = [];
  input2 = ucs2decode$1(input2);
  let inputLength = input2.length;
  let n = initialN;
  let delta2 = 0;
  let bias = initialBias;
  for (const currentValue of input2) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input2) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta2) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta2 += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input2) {
      if (currentValue < n && ++delta2 > maxInt) {
        error("overflow");
      }
      if (currentValue == n) {
        let q2 = delta2;
        for (let k2 = base$1; ; k2 += base$1) {
          const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q2 < t2) {
            break;
          }
          const qMinusT = q2 - t2;
          const baseMinusT = base$1 - t2;
          output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
        delta2 = 0;
        ++handledCPCount;
      }
    }
    ++delta2;
    ++n;
  }
  return output.join("");
};
const toUnicode = function(input2) {
  return mapDomain(input2, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};
const toASCII = function(input2) {
  return mapDomain(input2, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
};
const punycode$1 = {
  "version": "2.1.0",
  "ucs2": {
    "decode": ucs2decode$1,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ucs2decode: ucs2decode$1,
  ucs2encode,
  decode,
  encode,
  toASCII,
  toUnicode,
  "default": punycode$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
var _default$1 = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var zero = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var commonmark = {
  options: {
    html: true,
    xhtmlOut: true,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var utils = utils$1;
var helpers = helpers$1;
var Renderer = renderer;
var ParserCore = parser_core;
var ParserBlock = parser_block;
var ParserInline = parser_inline;
var LinkifyIt = linkifyIt;
var mdurl = mdurl$1;
var punycode = require$$8;
var config$2 = {
  default: _default$1,
  zero,
  commonmark
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url3) {
  var str = url3.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url3) {
  var parsed = mdurl.parse(url3, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.encode(mdurl.format(parsed));
}
function normalizeLinkText(url3) {
  var parsed = mdurl.parse(url3, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
}
function MarkdownIt(presetName, options2) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options2);
  }
  if (!options2) {
    if (!utils.isString(presetName)) {
      options2 = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new ParserCore();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils;
  this.helpers = utils.assign({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options2) {
    this.set(options2);
  }
}
MarkdownIt.prototype.set = function(options2) {
  utils.assign(this.options, options2);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  var self2 = this, presetName;
  if (utils.isString(presets)) {
    presetName = presets;
    presets = config$2[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self2[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self2[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list3, true));
  var missed2 = list3.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed2.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed2);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list3, true));
  var missed2 = list3.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed2.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed2);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin2) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin2.apply(plugin2, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  var state2 = new this.core.State(src, this, env);
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  var state2 = new this.core.State(src, this, env);
  state2.inlineMode = true;
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib = MarkdownIt;
var markdownIt = lib;
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end$1 = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference2 = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end$1]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end$1]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref2) {
  var state2 = _ref2.state;
  Object.keys(state2.elements).forEach(function(name) {
    var style2 = state2.styles[name] || {};
    var attributes = state2.attributes[name] || {};
    var element = state2.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name) {
      var element = state2.elements[name];
      var attributes = state2.attributes[name] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property2) {
        style3[property2] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute2) {
        element.removeAttribute(attribute2);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect2.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect2.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect2.width / scaleX,
    height: rect2.height / scaleY,
    top: rect2.top / scaleY,
    right: rect2.right / scaleX,
    bottom: rect2.bottom / scaleY,
    left: rect2.left / scaleX,
    x: rect2.left / scaleX,
    y: rect2.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE2 = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE2 && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max2(min$12, min2(value, max$12));
}
function withinMaxClamp(min3, value, max3) {
  var v = within(min3, value, max3);
  return v > max3 ? max3 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$1(_ref2) {
  var _state$modifiersData$;
  var state2 = _ref2.state, name = _ref2.name, options2 = _ref2.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min3, center, max3);
  var axisProp = axis;
  state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state2.elements.popper, arrowElement)) {
    {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state2.elements.arrow = arrowElement;
}
var arrow$2 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$1,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref2) {
  var x = _ref2.x, y = _ref2.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end$1) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end$1) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  {
    var transitionProperty = getComputedStyle$1(state2.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property2) {
      return transitionProperty.indexOf(property2) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement$1(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref2) {
  var state2 = _ref2.state, instance = _ref2.instance, options2 = _ref2.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list3) {
  var _element$ownerDocumen;
  if (list3 === void 0) {
    list3 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list3.concat(target2);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target2)));
}
function rectToClientRect(rect2) {
  return Object.assign({}, rect2, {
    left: rect2.x,
    top: rect2.y,
    right: rect2.x + rect2.width,
    bottom: rect2.y + rect2.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect2 = getBoundingClientRect(element);
  rect2.top = rect2.top + element.clientTop;
  rect2.left = rect2.left + element.clientLeft;
  rect2.bottom = rect2.top + element.clientHeight;
  rect2.right = rect2.left + element.clientWidth;
  rect2.width = element.clientWidth;
  rect2.height = element.clientHeight;
  rect2.x = rect2.left;
  rect2.y = rect2.top;
  return rect2;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect2 = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max2(rect2.top, accRect.top);
    accRect.right = min2(rect2.right, accRect.right);
    accRect.bottom = min2(rect2.bottom, accRect.bottom);
    accRect.left = max2(rect2.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref2) {
  var reference3 = _ref2.reference, element = _ref2.element, placement = _ref2.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference3.x + reference3.width / 2 - element.width / 2;
  var commonY = reference3.y + reference3.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference3.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference3.y + reference3.height
      };
      break;
    case right:
      offsets = {
        x: reference3.x + reference3.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference3.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference3.x,
        y: reference3.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference3[len] / 2 - element[len] / 2);
        break;
      case end$1:
        offsets[mainAxis] = offsets[mainAxis] + (reference3[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference2 : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$12 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$12.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$12;
    {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  if (state2.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect2, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect2.height - preventedOffsets.y,
    right: overflow.right - rect2.width + preventedOffsets.x,
    bottom: overflow.bottom - rect2.height + preventedOffsets.y,
    left: overflow.left - rect2.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref2) {
  var state2 = _ref2.state, name = _ref2.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref2[0], distance = _ref2[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x;
    state2.modifiersData.popperOffsets.y += y;
  }
  state2.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref2) {
  var state2 = _ref2.state, name = _ref2.name;
  state2.modifiersData[name] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref2) {
  var state2 = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min$12, tetherMin) : min$12, offset2, tether ? max2(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect2 = element.getBoundingClientRect();
  var scaleX = round(rect2.width) / element.offsetWidth || 1;
  var scaleY = round(rect2.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect2 = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect2.left + scroll.scrollLeft - offsets.x,
    y: rect2.top + scroll.scrollTop - offsets.y,
    width: rect2.width,
    height: rect2.height
  };
}
function order(modifiers2) {
  var map3 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map3.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map3.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function format2(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c) {
    return p2.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers2) {
  modifiers2.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
      return self2.indexOf(value) === index2;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format2(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers2.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format2(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference3, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions2;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference3,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions2, state2.options, options3);
        state2.scrollParents = {
          reference: isElement$1(reference3) ? listScrollParents(reference3) : reference3.contextElement ? listScrollParents(reference3.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        {
          var modifiers2 = uniqueBy([].concat(orderedModifiers, state2.options.modifiers), function(_ref2) {
            var name = _ref2.name;
            return name;
          });
          validateModifiers(modifiers2);
          if (getBasePlacement$1(state2.options.placement) === auto) {
            var flipModifier = state2.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle$1(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference4 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference4, popper3)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference4, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
          {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state2.reset === true) {
            state2.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name,
              instance
            }) || state2;
          }
        }
      },
      update: debounce$1(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state2);
        });
      }),
      destroy: function destroy3() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference3, popper2)) {
      {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options2).then(function(state3) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options3 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state: state2,
            name,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$2, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty$g(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index2];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone2 = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone2[key];
  });
  return clone2;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique$1(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els2, value) {
  els2.forEach(function(el2) {
    if (el2) {
      el2.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els2, state2) {
  els2.forEach(function(el2) {
    if (el2) {
      el2.setAttribute("data-state", state2);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref2) {
    var popperRect = _ref2.popperRect, popperState = _ref2.popperState, props2 = _ref2.props;
    var interactiveBorder = props2.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box2, action, listener3) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box2[method](event, listener3);
  });
}
function actualContains(parent, child) {
  var target2 = child;
  while (target2) {
    var _target$getRootNode;
    if (parent.contains(target2)) {
      return true;
    }
    target2 = target2.getRootNode == null ? void 0 : (_target$getRootNode = target2.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? !!window.msCrypto : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message2) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message2) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message2) {
  return [
    getDevMessage(message2),
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    "line-height: 1.5",
    "color: #a6a095;"
  ];
}
var visitedMessages;
{
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message2) {
  if (condition && !visitedMessages.has(message2)) {
    var _console;
    visitedMessages.add(message2);
    (_console = console).warn.apply(_console, getFormattedMessage(message2));
  }
}
function errorWhen(condition, message2) {
  if (condition && !visitedMessages.has(message2)) {
    var _console2;
    visitedMessages.add(message2);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message2));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate2() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins2 = passedProps.plugins || [];
  var pluginProps2 = plugins2.reduce(function(acc, plugin2) {
    var name = plugin2.name, defaultValue = plugin2.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference3, plugins2) {
  var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins2
  }))) : defaultKeys;
  var props2 = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference3.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props2;
}
function evaluateProps(reference3, props2) {
  var out = Object.assign({}, props2, {
    content: invokeWithArgsOrReturn(props2.content, [reference3])
  }, props2.ignoreAttributes ? {} : getDataAttributeProps(reference3, props2.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props2.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props2.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins2) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins2 === void 0) {
    plugins2 = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop2) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty$g(nonPluginProps, prop2);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins2.filter(function(plugin2) {
        return plugin2.name === prop2;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop2 + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent$1(content, props2) {
  if (isElement(props2.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props2.content);
  } else if (typeof props2.content !== "function") {
    if (props2.allowHTML) {
      dangerouslySetInnerHTML(content, props2.content);
    } else {
      content.textContent = props2.content;
    }
  }
}
function getChildren(popper2) {
  var box2 = popper2.firstElementChild;
  var boxChildren = arrayFrom(box2.children);
  return {
    box: box2,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render$2(instance) {
  var popper2 = div();
  var box2 = div();
  box2.className = BOX_CLASS;
  box2.setAttribute("data-state", "hidden");
  box2.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent$1(content, instance.props);
  popper2.appendChild(box2);
  box2.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box3 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box3.setAttribute("data-theme", nextProps.theme);
    } else {
      box3.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box3.setAttribute("data-animation", nextProps.animation);
    } else {
      box3.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box3.setAttribute("data-inertia", "");
    } else {
      box3.removeAttribute("data-inertia");
    }
    box3.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box3.setAttribute("role", nextProps.role);
    } else {
      box3.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent$1(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box3.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box3.removeChild(arrow2);
        box3.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box3.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render$2.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference3, passedProps) {
  var props2 = evaluateProps(reference3, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props2.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins2 = unique$1(props2.plugins);
  var state2 = {
    isEnabled: true,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false
  };
  var instance = {
    id,
    reference: reference3,
    popper: div(),
    popperInstance,
    props: props2,
    state: state2,
    plugins: plugins2,
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy: destroy3
  };
  if (!props2.render) {
    {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props2.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference3._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins2.map(function(plugin2) {
    return plugin2.fn(instance);
  });
  var hasAriaExpanded = reference3.hasAttribute("aria-expanded");
  addListeners2();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props2.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch2 = instance.props.touch;
    return Array.isArray(touch2) ? touch2 : [touch2, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference3;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference3);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference3);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener3) {
      return listener3 !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference3).some(function(el2) {
      return actualContains(el2, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart2() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart2, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart2, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box2 = getDefaultTemplateChildren().box;
    function listener3(event) {
      if (event.target === box2) {
        updateTransitionEndListener(box2, "remove", listener3);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box2, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box2, "add", listener3);
    currentTransitionEndListener = listener3;
  }
  function on2(eventType, handler, options2) {
    if (options2 === void 0) {
      options2 = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference3);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options2);
      listeners.push({
        node,
        eventType,
        handler,
        options: options2
      });
    });
  }
  function addListeners2() {
    if (getIsCustomTouchBehavior()) {
      on2("touchstart", onTrigger2, {
        passive: true
      });
      on2("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on2(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on2("mouseleave", onMouseLeave);
          break;
        case "focus":
          on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on2("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners2() {
    listeners.forEach(function(_ref2) {
      var node = _ref2.node, eventType = _ref2.eventType, handler = _ref2.handler, options2 = _ref2.options;
      node.removeEventListener(eventType, handler, options2);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener3) {
        return listener3(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target2 = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target2) || popper2.contains(target2);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state3 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state3) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state3,
          props: props2
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference3;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state3 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box2 = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box2.setAttribute("data-placement", state3.placement);
            } else {
              if (state3.attributes.popper["data-popper-" + attr]) {
                box2.setAttribute("data-" + attr, "");
              } else {
                box2.removeAttribute("data-" + attr);
              }
            }
          });
          state3.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount2() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners2();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference3, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners2();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference3.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box2 = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box2, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount2();
  }
  function hide2() {
    {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box2 = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box2, content], duration);
        setVisibilityState([box2, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy3() {
    {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners2();
    delete reference3._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy$1(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins2 = defaultProps.plugins.concat(optionalProps.plugins || []);
  {
    validateTargets(targets);
    validateProps(optionalProps, plugins2);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins2
  });
  var elements = getArrayOfElements(targets);
  {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference3) {
    var instance = reference3 && createTippy(reference3, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy$1.defaultProps = defaultProps;
tippy$1.setDefaultProps = setDefaultProps;
tippy$1.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref2) {
    var state2 = _ref2.state;
    var initialStyles = {
      popper: {
        position: state2.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state2.elements.popper.style, initialStyles.popper);
    state2.styles = initialStyles;
    if (state2.elements.arrow) {
      Object.assign(state2.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy$1.setDefaultProps({
  render: render$2
});
var tippy = /* @__PURE__ */ (() => '.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}')();
var light = /* @__PURE__ */ (() => ".tippy-box[data-theme~=light]{color:#26323d;box-shadow:0 0 20px 4px rgba(154,161,177,.15),0 4px 80px -8px rgba(36,40,47,.25),0 4px 4px -2px rgba(91,94,105,.15);background-color:#fff}.tippy-box[data-theme~=light][data-placement^=top]>.tippy-arrow:before{border-top-color:#fff}.tippy-box[data-theme~=light][data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:#fff}.tippy-box[data-theme~=light][data-placement^=left]>.tippy-arrow:before{border-left-color:#fff}.tippy-box[data-theme~=light][data-placement^=right]>.tippy-arrow:before{border-right-color:#fff}.tippy-box[data-theme~=light]>.tippy-backdrop{background-color:#fff}.tippy-box[data-theme~=light]>.tippy-svg-arrow{fill:#fff}")();
function moveLabelPlugin(node) {
  node.on("created", () => {
    const inputDefinition = clone$2(node.props.definition);
    if (!node.props.label) {
      return;
    }
    if (["radio", "checkbox"].includes(node.props.type)) {
      return;
    }
    const originalSchema = inputDefinition.schema;
    const markdown = new markdownIt();
    const higherOrderSchema = (extensions2) => {
      const { required: required3 } = node.props.attrs;
      let warningText = node.props.attrs.warning;
      const helpText = node.context.help;
      const infoText = node.props.attrs.info;
      let helpElement = {};
      let tabElement = {};
      let infoElement = {};
      if (node.props.attrs.tab) {
        tabElement = {
          $el: "span",
          children: node.props.attrs.tab
        };
      }
      if (infoText) {
        infoElement = {
          $el: "span",
          attrs: {
            "data-tippy-content": markdown.renderInline(infoText),
            "data-icon": "info"
          }
        };
        setTimeout(() => {
          tippy$1("[data-tippy-content]", {
            theme: "light fui-field-instructions-tooltip",
            trigger: "click",
            interactive: true,
            allowHTML: true,
            appendTo: document.body
          });
        }, 500);
      }
      const labelElement = {
        $el: "label",
        if: "$label",
        attrs: {
          id: `$: "label-" + ${"$id"}`,
          for: "$id",
          class: `$: ${"$classes.label"} + ' ' + ${required3 ? "required" : null}`
        },
        children: [
          "$label",
          infoElement
        ]
      };
      if (helpText) {
        helpElement = {
          $el: "div",
          attrs: {
            id: `$: "help-" + ${"$id"}`,
            class: "$classes.help",
            innerHTML: markdown.render(helpText)
          }
        };
      }
      extensions2.label = {
        $el: "div",
        attrs: {
          class: "heading",
          for: null
        },
        children: [
          labelElement,
          tabElement,
          helpElement
        ]
      };
      if (node.name === "required") {
        const $store = node.parent.props.attrs["formie-store"];
        if ($store && $store.state && $store.state.formie) {
          const { editingField } = $store.state.formie;
          if (editingField && editingField.field && editingField.field.isSynced) {
            warningText = Craft.t("formie", "The required attribute will not be synced across field instances.");
          }
        }
      }
      if (warningText) {
        extensions2.help = {
          $el: "div",
          attrs: {
            class: "warning with-icon",
            innerHTML: markdown.renderInline(warningText)
          },
          children: null
        };
      } else {
        extensions2.help = { $el: null, children: null };
      }
      return originalSchema(extensions2);
    };
    inputDefinition.schema = higherOrderSchema;
    node.props.definition = inputDefinition;
  });
}
const prefix = composable("prefix", () => {
  return { $el: null };
});
const suffix = composable("suffix", () => {
  return { $el: null };
});
const select = composable("input", (children) => {
  return {
    $el: "select",
    bind: "$attrs",
    attrs: {
      id: "$id",
      "data-placeholder": {
        if: "$placeholder",
        then: {
          if: "$value",
          then: void 0,
          else: "true"
        }
      },
      disabled: "$disabled",
      class: "$classes.input",
      name: "$node.name",
      onInput: "$handlers.selectInput",
      onBlur: "$handlers.blur",
      "aria-describedby": "$describedBy"
    },
    children: {
      if: "$slots.default",
      then: "$slots.default",
      else: children
    }
  };
});
const option = (schema = {}, children = []) => {
  return {
    if: "$slots.option",
    then: [
      {
        $el: "text",
        if: "$options.length",
        for: ["option", "$options"],
        children: "$slots.option"
      }
    ],
    else: extend$1({
      $el: "option",
      if: "$options.length",
      for: ["option", "$options"],
      bind: "$option.attrs",
      attrs: {
        class: "$classes.option",
        value: "$option.value",
        selected: "$fns.isSelected($option.value)"
      },
      children
    }, schema)
  };
};
const addSelectWrapperPlugin = function(node) {
  node.on("created", () => {
    if (!["select"].includes(node.props.type)) {
      return;
    }
    const inputDefinition = clone$2(node.props.definition);
    const originalSchema = inputDefinition.schema;
    const higherOrderSchema = (extensions2) => {
      extensions2.inner = {
        $el: "div",
        children: [{
          $el: "div",
          attrs: { class: "select" },
          children: [
            prefix(extensions2.prefix),
            select(extensions2.input, [option(extensions2.option, "$option.label")]),
            suffix(extensions2.suffix)
          ]
        }]
      };
      return originalSchema(extensions2);
    };
    inputDefinition.schema = higherOrderSchema;
    node.props.definition = inputDefinition;
  });
};
var _export_sfc = (sfc, props2) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$u = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  computed: {
    options() {
      let options2 = [];
      if (this.context.attrs.options[0] && !this.context.attrs.options[0].label) {
        this.context.attrs.options.forEach((value) => {
          options2.push({
            label: value,
            value
          });
        });
      } else {
        options2 = this.clone(this.context.attrs.options);
      }
      options2.forEach((option3, index2) => {
        if (option3.value === "*") {
          options2.unshift(options2.splice(index2, 1)[0]);
        }
      });
      return options2;
    }
  },
  methods: {
    checked(value) {
      if (this.context._value === "*") {
        return true;
      }
      if (Array.isArray(this.context._value) && this.context._value.includes(value.toString())) {
        return true;
      }
      return false;
    },
    onInput(e) {
      const { checked, value } = e.target;
      if (value === "*") {
        if (checked) {
          this.context.node.input("*");
        } else {
          this.context.node.input([]);
        }
      } else {
        if (!Array.isArray(this.context._value)) {
          this.context.node.input([]);
        }
        if (checked) {
          this.context._value.push(value);
        } else {
          const index2 = this.context._value.indexOf(value);
          if (index2 > -1) {
            this.context._value.splice(index2, 1);
          }
        }
      }
    }
  }
};
const _hoisted_1$r = { class: "checkbox-select" };
const _hoisted_2$n = ["id", "checked", "name", "value"];
const _hoisted_3$j = ["id"];
const _hoisted_4$g = ["for"];
const _hoisted_5$b = ["for"];
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$r, [
    (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.options, (option3, index2) => {
      return openBlock(), createElementBlock("div", { key: index2 }, [
        option3.value === "*" || $props.context._value !== "*" ? (openBlock(), createElementBlock("input", {
          key: 0,
          id: $props.context.id + "-" + index2,
          checked: $options.checked(option3.value),
          class: normalizeClass(["checkbox", { "all": option3.value === "*" }]),
          type: "checkbox",
          name: `${$props.context.name}[]`,
          value: option3.value,
          onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args))
        }, null, 42, _hoisted_2$n)) : (openBlock(), createElementBlock("input", {
          key: 1,
          id: $props.context.id + "-" + index2,
          class: "checkbox",
          type: "checkbox",
          checked: true,
          disabled: ""
        }, null, 8, _hoisted_3$j)),
        option3.value === "*" ? (openBlock(), createElementBlock("label", {
          key: 2,
          for: $props.context.id + "-" + index2
        }, [
          createBaseVNode("strong", null, toDisplayString(option3.label), 1)
        ], 8, _hoisted_4$g)) : (openBlock(), createElementBlock("label", {
          key: 3,
          for: $props.context.id + "-" + index2
        }, toDisplayString(option3.label), 9, _hoisted_5$b))
      ]);
    }), 128))
  ]);
}
var CheckboxSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$t], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/CheckboxSelectInput.vue"]]);
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf$1;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf$1 = window.performance;
  } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf$1 = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf$1.now() : Date.now();
}
class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id in plugin2.settings) {
        const item = plugin2.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw2 = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw2);
      Object.assign(currentSettings, data);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop2) => {
        if (this.target) {
          return this.target.on[prop2];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop2,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop2) => {
        if (this.target) {
          return this.target[prop2];
        } else if (prop2 === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop2)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop2,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop2](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop2,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target2) {
    this.target = target2;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target2 = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target2.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list3 = target2.__VUE_DEVTOOLS_PLUGINS__ = target2.__VUE_DEVTOOLS_PLUGINS__ || [];
    list3.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function forEachValue(obj, fn2) {
  Object.keys(obj).forEach(function(key) {
    return fn2(obj[key], key);
  });
}
function isObject$2(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}
function partial(fn2, arg) {
  return function() {
    return fn2(arg);
  };
}
function genericSubscribe(fn2, subs, options2) {
  if (subs.indexOf(fn2) < 0) {
    options2 && options2.prepend ? subs.unshift(fn2) : subs.push(fn2);
  }
  return function() {
    var i = subs.indexOf(fn2);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}
function resetStore(store2, hot) {
  store2._actions = /* @__PURE__ */ Object.create(null);
  store2._mutations = /* @__PURE__ */ Object.create(null);
  store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state2 = store2.state;
  installModule(store2, state2, [], store2._modules.root, true);
  resetStoreState(store2, state2, hot);
}
function resetStoreState(store2, state2, hot) {
  var oldState = store2._state;
  store2.getters = {};
  store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store2._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn2, key) {
    computedObj[key] = partial(fn2, store2);
    Object.defineProperty(store2.getters, key, {
      get: function() {
        return computedObj[key]();
      },
      enumerable: true
    });
  });
  store2._state = reactive({
    data: state2
  });
  if (store2.strict) {
    enableStrictMode(store2);
  }
  if (oldState) {
    if (hot) {
      store2._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
function installModule(store2, rootState, path, module2, hot) {
  var isRoot = !path.length;
  var namespace2 = store2._modules.getNamespace(path);
  if (module2.namespaced) {
    if (store2._modulesNamespaceMap[namespace2] && true) {
      console.error("[vuex] duplicate namespace " + namespace2 + " for the namespaced module " + path.join("/"));
    }
    store2._modulesNamespaceMap[namespace2] = module2;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store2._withCommit(function() {
      {
        if (moduleName in parentState) {
          console.warn('[vuex] state field "' + moduleName + '" was overridden by a module with the same name at "' + path.join(".") + '"');
        }
      }
      parentState[moduleName] = module2.state;
    });
  }
  var local = module2.context = makeLocalContext(store2, namespace2, path);
  module2.forEachMutation(function(mutation, key) {
    var namespacedType = namespace2 + key;
    registerMutation(store2, namespacedType, mutation, local);
  });
  module2.forEachAction(function(action, key) {
    var type = action.root ? key : namespace2 + key;
    var handler = action.handler || action;
    registerAction(store2, type, handler, local);
  });
  module2.forEachGetter(function(getter, key) {
    var namespacedType = namespace2 + key;
    registerGetter(store2, namespacedType, getter, local);
  });
  module2.forEachChild(function(child, key) {
    installModule(store2, rootState, path.concat(key), child, hot);
  });
}
function makeLocalContext(store2, namespace2, path) {
  var noNamespace = namespace2 === "";
  var local = {
    dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options2 = args.options;
      var type = args.type;
      if (!options2 || !options2.root) {
        type = namespace2 + type;
        if (!store2._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }
      return store2.dispatch(type, payload);
    },
    commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options2 = args.options;
      var type = args.type;
      if (!options2 || !options2.root) {
        type = namespace2 + type;
        if (!store2._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }
      store2.commit(type, payload, options2);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store2.getters;
      } : function() {
        return makeLocalGetters(store2, namespace2);
      }
    },
    state: {
      get: function() {
        return getNestedState(store2.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store2, namespace2) {
  if (!store2._makeLocalGettersCache[namespace2]) {
    var gettersProxy = {};
    var splitPos = namespace2.length;
    Object.keys(store2.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace2) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store2.getters[type];
        },
        enumerable: true
      });
    });
    store2._makeLocalGettersCache[namespace2] = gettersProxy;
  }
  return store2._makeLocalGettersCache[namespace2];
}
function registerMutation(store2, type, handler, local) {
  var entry = store2._mutations[type] || (store2._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store2, local.state, payload);
  });
}
function registerAction(store2, type, handler, local) {
  var entry = store2._actions[type] || (store2._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store2, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store2.getters,
      rootState: store2.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store2._devtoolHook) {
      return res.catch(function(err) {
        store2._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store2, type, rawGetter, local) {
  if (store2._wrappedGetters[type]) {
    {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store2._wrappedGetters[type] = function wrappedGetter(store3) {
    return rawGetter(local.state, local.getters, store3.state, store3.getters);
  };
}
function enableStrictMode(store2) {
  watch$1(function() {
    return store2._state.data;
  }, function() {
    {
      assert(store2._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, flush: "sync" });
}
function getNestedState(state2, path) {
  return path.reduce(function(state3, key) {
    return state3[key];
  }, state2);
}
function unifyObjectStyle(type, payload, options2) {
  if (isObject$2(type) && type.type) {
    options2 = payload;
    payload = type;
    type = type.type;
  }
  {
    assert(typeof type === "string", "expects string as the type, but found " + typeof type + ".");
  }
  return { type, payload, options: options2 };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app, store2) {
  setupDevtoolsPlugin({
    id: "org.vuejs.vuex",
    app,
    label: "Vuex",
    homepage: "https://next.vuex.vuejs.org/",
    logo: "https://vuejs.org/images/icons/favicon-96x96.png",
    packageName: "vuex",
    componentStateTypes: [LABEL_VUEX_BINDINGS]
  }, function(api2) {
    api2.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: "Vuex Mutations",
      color: COLOR_LIME_500
    });
    api2.addTimelineLayer({
      id: ACTIONS_LAYER_ID,
      label: "Vuex Actions",
      color: COLOR_LIME_500
    });
    api2.addInspector({
      id: INSPECTOR_ID,
      label: "Vuex",
      icon: "storage",
      treeFilterPlaceholder: "Filter stores..."
    });
    api2.on.getInspectorTree(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        if (payload.filter) {
          var nodes = [];
          flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
          payload.rootNodes = nodes;
        } else {
          payload.rootNodes = [
            formatStoreForInspectorTree(store2._modules.root, "")
          ];
        }
      }
    });
    api2.on.getInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        makeLocalGetters(store2, modulePath);
        payload.state = formatStoreForInspectorState(getStoreModule(store2._modules, modulePath), modulePath === "root" ? store2.getters : store2._makeLocalGettersCache, modulePath);
      }
    });
    api2.on.editInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        var path = payload.path;
        if (modulePath !== "root") {
          path = modulePath.split("/").filter(Boolean).concat(path);
        }
        store2._withCommit(function() {
          payload.set(store2._state.data, path, payload.state.value);
        });
      }
    });
    store2.subscribe(function(mutation, state2) {
      var data = {};
      if (mutation.payload) {
        data.payload = mutation.payload;
      }
      data.state = state2;
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
      api2.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: Date.now(),
          title: mutation.type,
          data
        }
      });
    });
    store2.subscribeAction({
      before: function(action, state2) {
        var data = {};
        if (action.payload) {
          data.payload = action.payload;
        }
        action._id = actionId++;
        action._time = Date.now();
        data.state = state2;
        api2.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: action._time,
            title: action.type,
            groupId: action._id,
            subtitle: "start",
            data
          }
        });
      },
      after: function(action, state2) {
        var data = {};
        var duration = Date.now() - action._time;
        data.duration = {
          _custom: {
            type: "duration",
            display: duration + "ms",
            tooltip: "Action duration",
            value: duration
          }
        };
        if (action.payload) {
          data.payload = action.payload;
        }
        data.state = state2;
        api2.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: action.type,
            groupId: action._id,
            subtitle: "end",
            data
          }
        });
      }
    });
  });
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path) {
  return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module2, path) {
  return {
    id: path || "root",
    label: extractNameFromPath(path),
    tags: module2.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module2._children).map(function(moduleName) {
      return formatStoreForInspectorTree(module2._children[moduleName], path + moduleName + "/");
    })
  };
}
function flattenStoreForInspectorTree(result, module2, filter2, path) {
  if (path.includes(filter2)) {
    result.push({
      id: path || "root",
      label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
      tags: module2.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module2._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result, module2._children[moduleName], filter2, path + moduleName + "/");
  });
}
function formatStoreForInspectorState(module2, getters2, path) {
  getters2 = path === "root" ? getters2 : getters2[path];
  var gettersKeys = Object.keys(getters2);
  var storeState = {
    state: Object.keys(module2.state).map(function(key) {
      return {
        key,
        editable: true,
        value: module2.state[key]
      };
    })
  };
  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters2);
    storeState.getters = Object.keys(tree).map(function(key) {
      return {
        key: key.endsWith("/") ? extractNameFromPath(key) : key,
        editable: false,
        value: canThrow(function() {
          return tree[key];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters2) {
  var result = {};
  Object.keys(getters2).forEach(function(key) {
    var path = key.split("/");
    if (path.length > 1) {
      var target2 = result;
      var leafKey = path.pop();
      path.forEach(function(p2) {
        if (!target2[p2]) {
          target2[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target2 = target2[p2]._custom.value;
      });
      target2[leafKey] = canThrow(function() {
        return getters2[key];
      });
    } else {
      result[key] = canThrow(function() {
        return getters2[key];
      });
    }
  });
  return result;
}
function getStoreModule(moduleMap, path) {
  var names = path.split("/").filter(function(n) {
    return n;
  });
  return names.reduce(function(module2, moduleName, i) {
    var child = module2[moduleName];
    if (!child) {
      throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
    }
    return i === names.length - 1 ? child : child._children;
  }, path === "root" ? moduleMap : moduleMap.root._children);
}
function canThrow(cb) {
  try {
    return cb();
  } catch (e) {
    return e;
  }
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild2(key, module2) {
  this._children[key] = module2;
};
Module.prototype.removeChild = function removeChild2(key) {
  delete this._children[key];
};
Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};
Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};
Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn2) {
  forEachValue(this._children, fn2);
};
Module.prototype.forEachGetter = function forEachGetter(fn2) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn2);
  }
};
Module.prototype.forEachAction = function forEachAction(fn2) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn2);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn2) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn2);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function(module2, key) {
    return module2.getChild(key);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module2 = this.root;
  return path.reduce(function(namespace2, key) {
    module2 = module2.getChild(key);
    return namespace2 + (module2.namespaced ? key + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update2([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register2(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  {
    assertRawModule(path, rawModule);
  }
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);
  if (!child) {
    {
      console.warn("[vuex] trying to unregister module '" + key + "', which is not registered");
    }
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent.removeChild(key);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (parent) {
    return parent.hasChild(key);
  }
  return false;
};
function update2(path, targetModule, newModule) {
  {
    assertRawModule(path, newModule);
  }
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, manual reload is needed");
        }
        return;
      }
      update2(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}
var functionAssert = {
  assert: function(value) {
    return typeof value === "function";
  },
  expected: "function"
};
var objectAssert = {
  assert: function(value) {
    return typeof value === "function" || typeof value === "object" && typeof value.handler === "function";
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};
function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function(key) {
    if (!rawModule[key]) {
      return;
    }
    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function(value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}
function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + ' but "' + key + "." + type + '"';
  if (path.length > 0) {
    buf += ' in module "' + path.join(".") + '"';
  }
  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}
function createStore(options2) {
  return new Store(options2);
}
var Store = function Store2(options2) {
  var this$1$1 = this;
  if (options2 === void 0)
    options2 = {};
  {
    assert(typeof Promise !== "undefined", "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store2, "store must be called with the new operator.");
  }
  var plugins2 = options2.plugins;
  if (plugins2 === void 0)
    plugins2 = [];
  var strict = options2.strict;
  if (strict === void 0)
    strict = false;
  var devtools2 = options2.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options2);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._devtools = devtools2;
  var store2 = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit3 = ref2.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch2.call(store2, type, payload);
  };
  this.commit = function boundCommit(type, payload, options3) {
    return commit3.call(store2, type, payload, options3);
  };
  this.strict = strict;
  var state2 = this._modules.root.state;
  installModule(this, state2, [], this._modules.root);
  resetStoreState(this, state2);
  plugins2.forEach(function(plugin2) {
    return plugin2(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install2(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : true;
  if (useDevtools) {
    addDevtools(app, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v) {
  {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};
Store.prototype.commit = function commit2(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type = ref2.type;
  var payload = ref2.payload;
  var options2 = ref2.options;
  var mutation = { type, payload };
  var entry = this._mutations[type];
  if (!entry) {
    {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub2) {
    return sub2(mutation, this$1$1.state);
  });
  if (options2 && options2.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. Use the filter functionality in the vue-devtools");
  }
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type = ref2.type;
  var payload = ref2.payload;
  var action = { type, payload };
  var entry = this._actions[type];
  if (!entry) {
    {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub2) {
      return sub2.before;
    }).forEach(function(sub2) {
      return sub2.before(action, this$1$1.state);
    });
  } catch (e) {
    {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve2, reject) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub2) {
          return sub2.after;
        }).forEach(function(sub2) {
          return sub2.after(action, this$1$1.state);
        });
      } catch (e) {
        {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve2(res);
    }, function(error2) {
      try {
        this$1$1._actionSubscribers.filter(function(sub2) {
          return sub2.error;
        }).forEach(function(sub2) {
          return sub2.error(action, this$1$1.state, error2);
        });
      } catch (e) {
        {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error2);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn2, options2) {
  return genericSubscribe(fn2, this._subscribers, options2);
};
Store.prototype.subscribeAction = function subscribeAction(fn2, options2) {
  var subs = typeof fn2 === "function" ? { before: fn2 } : fn2;
  return genericSubscribe(subs, this._actionSubscribers, options2);
};
Store.prototype.watch = function watch$1$1(getter, cb, options2) {
  var this$1$1 = this;
  {
    assert(typeof getter === "function", "store.watch only accepts a function.");
  }
  return watch$1(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options2));
};
Store.prototype.replaceState = function replaceState(state2) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state2;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options2) {
  if (options2 === void 0)
    options2 = {};
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, "cannot register the root module by using registerModule.");
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options2.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn2) {
  var committing = this._committing;
  this._committing = true;
  fn2();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
var mapState = normalizeNamespace(function(namespace2, states) {
  var res = {};
  if (!isValidMap(states)) {
    console.error("[vuex] mapState: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(states).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    res[key] = function mappedState() {
      var state2 = this.$store.state;
      var getters2 = this.$store.getters;
      if (namespace2) {
        var module2 = getModuleByNamespace(this.$store, "mapState", namespace2);
        if (!module2) {
          return;
        }
        state2 = module2.context.state;
        getters2 = module2.context.getters;
      }
      return typeof val === "function" ? val.call(this, state2, getters2) : state2[val];
    };
    res[key].vuex = true;
  });
  return res;
});
function normalizeMap(map3) {
  if (!isValidMap(map3)) {
    return [];
  }
  return Array.isArray(map3) ? map3.map(function(key) {
    return { key, val: key };
  }) : Object.keys(map3).map(function(key) {
    return { key, val: map3[key] };
  });
}
function isValidMap(map3) {
  return Array.isArray(map3) || isObject$2(map3);
}
function normalizeNamespace(fn2) {
  return function(namespace2, map3) {
    if (typeof namespace2 !== "string") {
      map3 = namespace2;
      namespace2 = "";
    } else if (namespace2.charAt(namespace2.length - 1) !== "/") {
      namespace2 += "/";
    }
    return fn2(namespace2, map3);
  };
}
function getModuleByNamespace(store2, helper, namespace2) {
  var module2 = store2._modulesNamespaceMap[namespace2];
  if (!module2) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace2);
  }
  return module2;
}
const generateHandle = function(sourceValue, handleCasing = "camelCase", allowNonAlphaStart = false) {
  let handle = sourceValue.replace("/<(.*?)>/g", "");
  handle = handle.replace(/['"‘’“”\[\]\(\)\{\}:]/g, "");
  handle = handle.toLowerCase();
  handle = Craft.asciiString(handle);
  if (!allowNonAlphaStart) {
    handle = handle.replace(/^[^a-z]+/, "");
  }
  const words = Craft.filterArray(handle.split(/[^a-z0-9]+/));
  handle = "";
  if (handleCasing === "snake") {
    return words.join("_");
  }
  if (handleCasing === "kebab") {
    return words.join("-");
  }
  for (let i = 0; i < words.length; i++) {
    if (handleCasing !== "pascal" && i === 0) {
      handle += words[i];
    } else {
      handle += words[i].charAt(0).toUpperCase() + words[i].substr(1);
    }
  }
  return handle;
};
const getNextAvailableHandle = function(handleCollection, handle, suffix2) {
  let newHandle = handle;
  if (suffix2) {
    newHandle = handle + suffix2;
  }
  if (handleCollection.includes(newHandle)) {
    return getNextAvailableHandle(handleCollection, handle, suffix2 + 1);
  }
  return newHandle;
};
const generateKebab = function(sourceValue) {
  let kebab2 = sourceValue.replace("/<(.*?)>/g", "");
  kebab2 = kebab2.replace(/['"‘’“”[]\(\){}:]/g, "");
  kebab2 = kebab2.toLowerCase();
  kebab2 = Craft.asciiString(kebab2);
  const words = Craft.filterArray(kebab2.split(/[^a-z0-9]+/));
  kebab2 = words.join("-");
  return kebab2;
};
const newId = function() {
  return `new${Math.floor(9999 * Math.random())}-${Math.floor(9999 * Math.random())}`;
};
const token = function(length3 = 13) {
  return Math.random().toString(36).substring(2, length3 + 2);
};
const has$1 = function(ctx, prop2) {
  return Object.prototype.hasOwnProperty.call(ctx, prop2);
};
const setId = function(o, id) {
  if (!has$1(o, "__id") || id) {
    return Object.defineProperty(o, "__id", Object.assign(/* @__PURE__ */ Object.create(null), { value: id || token(9) }));
  }
  return o;
};
const getDisplayName = function(type) {
  const parts = type.split("\\");
  return parts[parts.length - 1];
};
const parseDate = function(date3) {
  if (date3 === null) {
    return "";
  }
  if (typeof date3 === "object") {
    if (has$1(date3, "jsDate")) {
      return date3.jsDate;
    }
    if (has$1(date3, "date")) {
      return date3.date;
    }
  }
  return date3;
};
const _sfc_main$t = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      savedDate: null,
      proxyValue: {
        date: "",
        time: "",
        timezone: Craft.timezone
      }
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    includeTime() {
      if (this.editingField) {
        return this.editingField.field.settings.includeTime;
      }
      return false;
    }
  }),
  created() {
    this.savedDate = parseDate(this.clone(this.context._value));
  },
  mounted() {
    const { dateInput, timeInput } = this.$refs;
    if (dateInput) {
      this.$datePicker = $(dateInput).datepicker($.extend({}, Craft.datepickerOptions));
      this.$datePicker.on("change", (e) => {
        this.proxyValue.date = e.target.value;
        this.context.node.input(this.proxyValue);
      });
      if (this.savedDate) {
        this.$datePicker.datepicker("setDate", new Date(parseDate(this.savedDate)));
      }
      this.$datePicker.trigger("change");
    }
    if (timeInput) {
      this.$timePicker = $(timeInput).timepicker($.extend({}, Craft.timepickerOptions));
      this.$timePicker.on("change", (e) => {
        this.proxyValue.time = e.target.value;
        this.context.node.input(this.proxyValue);
      });
      if (this.savedDate) {
        this.$timePicker.timepicker("setTime", new Date(parseDate(this.savedDate)));
      }
      this.$timePicker.trigger("change");
    }
  }
};
const _hoisted_1$q = { class: "datewrapper" };
const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("div", { "data-icon": "date" }, null, -1);
const _hoisted_3$i = { class: "timewrapper" };
const _hoisted_4$f = /* @__PURE__ */ createBaseVNode("div", { "data-icon": "time" }, null, -1);
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("div", _hoisted_1$q, [
      createBaseVNode("input", mergeProps({
        ref: "dateInput",
        size: "10",
        autocomplete: "off",
        class: "text",
        placeholder: " "
      }, $props.context.attrs, {
        onBlur: _cache[0] || (_cache[0] = (...args) => $props.context.handlers.blur && $props.context.handlers.blur(...args))
      }), null, 16),
      _hoisted_2$m
    ]),
    withDirectives(createBaseVNode("div", _hoisted_3$i, [
      createBaseVNode("input", mergeProps({
        ref: "timeInput",
        size: "10",
        autocomplete: "off",
        class: "text",
        placeholder: " "
      }, $props.context.attrs, {
        onBlur: _cache[1] || (_cache[1] = (...args) => $props.context.handlers.blur && $props.context.handlers.blur(...args))
      }), null, 16),
      _hoisted_4$f
    ], 512), [
      [vShow, $options.includeTime]
    ])
  ]);
}
var DateInput = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$s], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/DateInput.vue"]]);
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$i = Object.prototype;
var hasOwnProperty$f = objectProto$i.hasOwnProperty;
var nativeObjectToString$1 = objectProto$i.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$f.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$h = Object.prototype;
var nativeObjectToString = objectProto$h.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length, result = Array(length3);
  while (++index2 < length3) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray = Array.isArray;
var isArray$1 = isArray;
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function identity(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$g = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$e = objectProto$g.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$e).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root$1, "WeakMap");
var WeakMap$2 = WeakMap$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty$1 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$2 = defineProperty$1;
var baseSetToString = !defineProperty$2 ? identity : function(func, string) {
  return defineProperty$2(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function arrayEach(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length3 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length3) {
  var type = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER$1 : length3;
  return !!length3 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$d.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props2, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length3 = props2.length;
  while (++index2 < length3) {
    var key = props2[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax$1 = Math.max;
function overRest(func, start2, transform2) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length3 = nativeMax$1(args.length - start2, 0), array = Array(length3);
    while (++index2 < length3) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform2(array);
    return apply$1(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length3 = sources.length, customizer = length3 > 1 ? sources[length3 - 1] : void 0, guard = length3 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length3--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length3 < 3 ? void 0 : customizer;
      length3 = 1;
    }
    object = Object(object);
    while (++index2 < length3) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$e = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$e;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$c.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer2 = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$2 = "[object Error]", funcTag = "[object Function]", mapTag$3 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag] = typedArrayTags[mapTag$3] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$3] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$b.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$a.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});
var extendWith = assignInWith;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length3 = array.length;
  while (length3--) {
    if (eq(array[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number3, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length3 = path.length;
  while (object != null && index2 < length3) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length3 ? object : void 0;
}
function get2(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values) {
  var index2 = -1, length3 = values.length, offset2 = array.length;
  while (++index2 < length3) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length3 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length3) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectTag$2 = "[object Object]";
var funcProto = Function.prototype, objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var domExcTag = "[object DOMException]", errorTag$1 = "[object Error]";
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject$1(value);
}
var attempt = baseRest(function(func, args) {
  try {
    return apply$1(func, void 0, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});
var attempt$1 = attempt;
function baseSlice(array, start2, end3) {
  var index2 = -1, length3 = array.length;
  if (start2 < 0) {
    start2 = -start2 > length3 ? 0 : length3 + start2;
  }
  end3 = end3 > length3 ? length3 : end3;
  if (end3 < 0) {
    end3 += length3;
  }
  length3 = start2 > end3 ? 0 : end3 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length3);
  while (++index2 < length3) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
function castSlice(array, start2, end3) {
  var length3 = array.length;
  end3 = end3 === void 0 ? length3 : end3;
  return !start2 && end3 >= length3 ? array : baseSlice(array, start2, end3);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$2 + rsVarRange$2 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral$1 = "[" + rsAstralRange$1 + "]", rsCombo$1 = "[" + rsComboRange$1 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol$1 = "(?:" + [rsNonAstral$1 + rsCombo$1 + "?", rsCombo$1, rsRegional$1, rsSurrPair$1, rsAstral$1].join("|") + ")";
var reUnicode$1 = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol$1 + rsSeq$1, "g");
function unicodeToArray(string) {
  return string.match(reUnicode$1) || [];
}
function stringToArray$1(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayFilter(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length3) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$6 = Object.prototype;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys$1, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$2 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$2 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$2 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$2 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$2;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var Uint8Array2 = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length3 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length3) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array, other);
  stack2.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen2) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen2.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array);
  stack2["delete"](other);
  return result;
}
function mapToArray(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert2 = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object, other);
      var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length3 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length3;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length3) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack2);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$1(value);
}
function getMatchData(object) {
  var result = keys$1(object), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object[key];
    result[length3] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length3 = path.length, result = false;
  while (++index2 < length3) {
    var key = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length3) {
    return result;
  }
  length3 = object == null ? 0 : object.length;
  return !!length3 && isLength(length3) && isIndex(key, length3) && (isArray$1(object) || isArguments$1(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length3 = props2.length;
    while (length3--) {
      var key = props2[fromRight ? length3 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
function baseForOwn(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys$1);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index2 = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length3) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
var baseEach$1 = baseEach;
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach$1(collection, iteratee) {
  var func = isArray$1(collection) ? arrayEach : baseEach$1;
  return func(collection, castFunction(iteratee));
}
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf(htmlEscapes);
var escapeHtmlChar$1 = escapeHtmlChar;
var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape2(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar$1) : string;
}
function baseFilter(collection, predicate) {
  var result = [];
  baseEach$1(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
function filter(collection, predicate) {
  var func = isArray$1(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate));
}
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys$1(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var nativeMax = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length3 = array == null ? 0 : array.length;
  if (!length3) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax(length3 + index2, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate), index2);
}
var find$2 = createFind(findIndex);
var find$3 = find$2;
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
function flatMap(collection, iteratee) {
  return baseFlatten(map(collection, iteratee), 1);
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty$3.call(object, key);
}
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}
function baseValues(object, props2) {
  return arrayMap(props2, function(key) {
    return object[key];
  });
}
var mapTag = "[object Map]", setTag = "[object Set]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function isEmpty$1(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) && (isArray$1(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var regexpTag = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}
var nodeIsRegExp = nodeUtil$1 && nodeUtil$1.isRegExp;
var isRegExp$1 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
var isRegExp$2 = isRegExp$1;
var FUNC_ERROR_TEXT = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
function baseSet(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath(path, object);
  var index2 = -1, length3 = path.length, lastIndex = length3 - 1, nested = object;
  while (nested != null && ++index2 < length3) {
    var key = toKey(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function basePickBy(object, paths, predicate) {
  var index2 = -1, length3 = paths.length, result = {};
  while (++index2 < length3) {
    var path = paths[index2], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props2 = arrayMap(getAllKeysIn(object), function(prop2) {
    return [prop2];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props2, function(value, path) {
    return predicate(value, path[0]);
  });
}
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}
var asciiSize = baseProperty("length");
var asciiSize$1 = asciiSize;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}
function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize$1(string);
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq(objValue, objectProto$1[key]) && !hasOwnProperty$1.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate$1 = reInterpolate;
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape$1 = reEscape;
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate$1 = reEvaluate;
var templateSettings = {
  "escape": reEscape$1,
  "evaluate": reEvaluate$1,
  "interpolate": reInterpolate$1,
  "variable": "",
  "imports": {
    "_": { "escape": escape2 }
  }
};
var templateSettings$1 = templateSettings;
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function template(string, options2, guard) {
  var settings = templateSettings$1.imports._.templateSettings || templateSettings$1;
  if (guard && isIterateeCall(string, options2, guard)) {
    options2 = void 0;
  }
  string = toString(string);
  options2 = extendWith({}, options2, settings, customDefaultsAssignIn);
  var imports = extendWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys$1(imports), importsValues = baseValues(imports, importsKeys);
  var isEscaping, isEvaluating, index2 = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp((options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate$1 ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$", "g");
  var sourceURL = hasOwnProperty.call(options2, "sourceURL") ? "//# sourceURL=" + (options2.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index2 = offset2 + match2.length;
    return match2;
  });
  source += "';\n";
  var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result = attempt$1(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}
var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
var reFlags = /\w*$/;
function truncate(string, options2) {
  var length3 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject$1(options2)) {
    var separator = "separator" in options2 ? options2.separator : separator;
    length3 = "length" in options2 ? toInteger(options2.length) : length3;
    omission = "omission" in options2 ? baseToString(options2.omission) : omission;
  }
  string = toString(string);
  var strLength = string.length;
  if (hasUnicode(string)) {
    var strSymbols = stringToArray$1(string);
    strLength = strSymbols.length;
  }
  if (length3 >= strLength) {
    return string;
  }
  var end3 = length3 - stringSize(omission);
  if (end3 < 1) {
    return omission;
  }
  var result = strSymbols ? castSlice(strSymbols, 0, end3).join("") : string.slice(0, end3);
  if (separator === void 0) {
    return result + omission;
  }
  if (strSymbols) {
    end3 += result.length - end3;
  }
  if (isRegExp$2(separator)) {
    if (string.slice(end3).search(separator)) {
      var match2, substring = result;
      if (!separator.global) {
        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match2 = separator.exec(substring)) {
        var newEnd = match2.index;
      }
      result = result.slice(0, newEnd === void 0 ? end3 : newEnd);
    }
  } else if (string.indexOf(baseToString(separator), end3) != end3) {
    var index2 = result.lastIndexOf(separator);
    if (index2 > -1) {
      result = result.slice(0, index2);
    }
  }
  return result + omission;
}
const _sfc_main$s = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      id: `element-${Craft.randomString(10)}`,
      modal: null
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    },
    editingNotification: (state2) => {
      return state2.formie.editingNotification;
    }
  })), {
    selectionLabel() {
      return get2(this.context.attrs, "selectionLabel");
    },
    sources() {
      if (this.editingField) {
        return this.editingField.field.settings.sources;
      }
      return get2(this.context.attrs, "sources");
    },
    source() {
      if (this.editingField) {
        return this.editingField.field.settings.source;
      }
      return [];
    },
    displayType() {
      if (this.editingField) {
        return this.editingField.field.settings.displayType;
      }
      return "dropdown";
    },
    elementsHtml() {
      if (this.editingField) {
        return this.editingField.field[`${this.context.id}Html`];
      }
      if (this.editingNotification) {
        return this.editingNotification.notification.attachAssetsHtml;
      }
      return "";
    }
  }),
  watch: {
    sources(newValue) {
      this.createModal();
    },
    source(newValue) {
      this.createModal();
    },
    displayType(newValue) {
      this.createModal();
    }
  },
  created() {
    if (!this.context._value) {
      this.context.node.input([]);
    }
  },
  mounted() {
    this.createModal();
  },
  methods: {
    createModal() {
      const { config: config2 } = this.context.node;
      if (config2) {
        config2.id = this.id;
        config2.storageKey = Craft.randomString(10);
        config2.onSelectElements = this.onSelectElements;
        config2.onRemoveElements = this.onRemoveElements;
        config2.sources = this.sources;
        if (this.source && this.source.length) {
          config2.sources = [this.source];
        }
        if (config2.limit === void 0 && this.displayType !== "checkboxes") {
          config2.limit = 1;
        }
        if (this.modal) {
          this.modal.setSettings(config2, this.modal.settings);
          if (this.modal.modal) {
            this.modal.modal.destroy();
            delete this.modal.modal;
          }
        } else {
          this.modal = new Craft.BaseElementSelectInput(config2);
        }
      }
    },
    onSelectElements(elements) {
      this.domToModel();
    },
    onRemoveElements() {
      this.domToModel();
    },
    domToModel() {
      const elements = [];
      this.modal.$elements.each((index2, $element) => {
        elements.push({ id: $element.dataset.id, siteId: $element.dataset.siteId });
      });
      this.context.node.input(elements);
    }
  }
};
const _hoisted_1$p = ["id"];
const _hoisted_2$l = ["innerHTML"];
const _hoisted_3$h = { class: "flex" };
const _hoisted_4$e = {
  type: "button",
  class: "btn add icon dashed"
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: $data.id,
    class: "elementselect"
  }, [
    createBaseVNode("div", {
      class: "elements",
      innerHTML: $options.elementsHtml
    }, null, 8, _hoisted_2$l),
    createBaseVNode("div", _hoisted_3$h, [
      createBaseVNode("button", _hoisted_4$e, toDisplayString($options.selectionLabel), 1)
    ])
  ], 8, _hoisted_1$p);
}
var ElementSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$r], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/ElementSelectInput.vue"]]);
const _sfc_main$r = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    field() {
      if (this.editingField) {
        return this.editingField.field;
      }
      return [];
    }
  }),
  methods: {
    isSelected(node, option3) {
      node.context && node.context.value;
      return Array.isArray(node._value) ? node._value.includes(option3) : node.value === void 0 && !option3 || node._value == option3;
    },
    selectInput(e) {
      this.context.node.input(e.target.value);
    },
    getFieldOptions() {
      const fields = [];
      const allFields = this.$store.getters["form/fields"];
      const excludeSelf = this.context.attrs.excludeSelf || false;
      const fieldTypes = this.context.attrs.fieldTypes || [];
      allFields.forEach((field) => {
        if (fieldTypes.length && !fieldTypes.includes(field.type)) {
          return;
        }
        if (excludeSelf && this.field && this.field.handle === field.handle) {
          return;
        }
        fields.push({ label: field.label, value: `{${field.handle}}` });
      });
      return fields;
    }
  }
};
const _hoisted_1$o = { class: "select" };
const _hoisted_2$k = ["id", "name", "aria-describedby", "value"];
const _hoisted_3$g = ["selected"];
const _hoisted_4$d = ["value", "selected"];
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$o, [
    createBaseVNode("select", mergeProps($props.context.attrs, {
      id: $props.context.id,
      name: $props.context.node.name,
      "aria-describedby": $props.context.describedBy,
      value: $props.context._value,
      onInput: _cache[0] || (_cache[0] = (...args) => $options.selectInput && $options.selectInput(...args))
    }), [
      createBaseVNode("option", {
        value: "",
        selected: !$props.context._value
      }, toDisplayString(_ctx.t("formie", "Select an option")), 9, _hoisted_3$g),
      (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.getFieldOptions(), (option3, j2) => {
        return openBlock(), createElementBlock("option", {
          key: j2,
          value: option3.value,
          selected: $options.isSelected($props.context.node, option3.value)
        }, toDisplayString(option3.label), 9, _hoisted_4$d);
      }), 128))
    ], 16, _hoisted_2$k)
  ]);
}
var FieldSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$q], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/FieldSelectInput.vue"]]);
var HandleInput_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".input-wrap {\n  position: relative;\n}\n.fui-field-handle-generate-icon {\n  position: absolute;\n  top: 50%;\n  right: 0;\n  padding: 7px 10px;\n  opacity: 0.5;\n  cursor: pointer;\n  color: #606d7b;\n  transition: all 0.2s ease;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.fui-field-handle-generate-icon svg {\n  width: 14px;\n  height: 14px;\n  display: block;\n}\n.fui-field-handle-generate-icon:hover {\n  opacity: 1;\n}")();
const _sfc_main$q = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    },
    fieldId: {
      type: [String, Number],
      default: ""
    },
    sourceValue: {
      type: String,
      default: ""
    },
    collection: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  data() {
    return {
      savedValue: "",
      rotate: 0
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    proxySourceValue() {
      if (this.editingField) {
        return this.editingField.field.label;
      }
      return get2(this.context.attrs, "source-value", this.sourceValue);
    },
    proxyFieldId() {
      if (this.editingField) {
        return this.editingField.field.vid;
      }
      return get2(this.context.attrs, "field-id", this.fieldId);
    },
    proxyCollection() {
      return get2(this.context.attrs, "collection", this.collection);
    }
  }),
  watch: {
    proxySourceValue(newValue) {
      if (!this.savedValue) {
        this.generateHandle();
      }
    }
  },
  created() {
    this.savedValue = this.clone(this.context._value);
  },
  methods: {
    refreshHandle(e) {
      this.rotate = this.rotate + 180;
      this.generateHandle();
    },
    generateHandle() {
      const parentFieldId = this.editingField && this.editingField.parentFieldId ? this.editingField.parentFieldId : null;
      if (!this.proxySourceValue) {
        return;
      }
      const generatedHandle = generateHandle(this.proxySourceValue);
      let handles = this.$store.getters["form/fieldHandlesExcluding"](this.proxyFieldId, parentFieldId);
      if (this.proxyCollection.length) {
        handles = this.proxyCollection;
      }
      const value = getNextAvailableHandle(handles, generatedHandle, 0);
      const maxHandleLength = this.$store.getters["formie/maxFieldHandleLength"]();
      this.context.node.input(value.substr(0, maxHandleLength), false);
    }
  }
};
const _hoisted_1$n = ["name"];
const _hoisted_2$j = /* @__PURE__ */ createBaseVNode("svg", {
  "aria-hidden": "true",
  focusable: "false",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    fill: "currentColor",
    d: "M440.65 12.57l4 82.77A247.16 247.16 0 0 0 255.83 8C134.73 8 33.91 94.92 12.29 209.82A12 12 0 0 0 24.09 224h49.05a12 12 0 0 0 11.67-9.26 175.91 175.91 0 0 1 317-56.94l-101.46-4.86a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12H500a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12h-47.37a12 12 0 0 0-11.98 12.57zM255.83 432a175.61 175.61 0 0 1-146-77.8l101.8 4.87a12 12 0 0 0 12.57-12v-47.4a12 12 0 0 0-12-12H12a12 12 0 0 0-12 12V500a12 12 0 0 0 12 12h47.35a12 12 0 0 0 12-12.6l-4.15-82.57A247.17 247.17 0 0 0 255.83 504c121.11 0 221.93-86.92 243.55-201.82a12 12 0 0 0-11.8-14.18h-49.05a12 12 0 0 0-11.67 9.26A175.86 175.86 0 0 1 255.83 432z"
  })
], -1);
const _hoisted_3$f = [
  _hoisted_2$j
];
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment$1, null, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.context._value = $event),
      name: $props.context.node.name,
      type: "text",
      class: "text fullwidth code",
      onInput: _cache[1] || (_cache[1] = (...args) => $props.context.handlers.DOMInput && $props.context.handlers.DOMInput(...args)),
      onBlur: _cache[2] || (_cache[2] = (...args) => $props.context.handlers.blur && $props.context.handlers.blur(...args))
    }, null, 40, _hoisted_1$n), [
      [vModelText, $props.context._value]
    ]),
    createBaseVNode("div", {
      class: "fui-field-handle-generate-icon",
      style: normalizeStyle({ transform: "translateY(-50%) rotate(" + $data.rotate + "deg)" }),
      onClick: _cache[3] || (_cache[3] = withModifiers((...args) => $options.refreshHandle && $options.refreshHandle(...args), ["prevent"]))
    }, _hoisted_3$f, 4)
  ], 64);
}
var HandleInput = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$p], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/HandleInput.vue"]]);
function boolMatch(s, matchers) {
  let i, matcher;
  const down = s.toLowerCase();
  matchers = [].concat(matchers);
  for (i = 0; i < matchers.length; i += 1) {
    matcher = matchers[i];
    if (!matcher) {
      continue;
    }
    if (matcher.test && matcher.test(s)) {
      return true;
    }
    if (matcher.toLowerCase() === down) {
      return true;
    }
  }
}
const toBoolean = (str, trueValues, falseValues) => {
  if (typeof str === "number") {
    str = `${str}`;
  }
  if (typeof str !== "string") {
    return !!str;
  }
  str = str.trim();
  if (boolMatch(str, trueValues || ["true", "1"])) {
    return true;
  }
  if (boolMatch(str, falseValues || ["false", "0"])) {
    return false;
  }
};
const _sfc_main$p = {
  name: "LightswitchField",
  props: {
    context: {
      type: Object,
      default: () => {
      }
    },
    small: {
      type: Boolean,
      default: false
    },
    extraSmall: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      dragger: null,
      dragging: false,
      innerStyle: {}
    };
  },
  computed: {
    localClasses() {
      const classes = [];
      if (this.context.attrs.extraSmall || this.context.attrs["extra-small"]) {
        classes.push("extra-small");
      }
      if (this.context.attrs.small) {
        classes.push("small");
      }
      return classes.join(" ");
    },
    offMargin() {
      return this.small ? -10 : -12;
    }
  },
  mounted() {
    const { container } = this.$refs;
    this.$nextTick(() => {
      const lightswitch = $(container).data("lightswitch");
      if (lightswitch) {
        lightswitch.destroy();
      }
      this.dragger = new Garnish.BaseDrag(container, {
        axis: Garnish.X_AXIS,
        ignoreHandleSelector: null,
        onDragStart: this.onDragStart.bind(this),
        onDrag: this.onDrag.bind(this),
        onDragStop: this.onDragStop.bind(this)
      });
    });
  },
  beforeUnmount() {
    if (this.dragger) {
      this.dragger.destroy();
    }
  },
  methods: {
    turnOn() {
      this.context.node.input(true);
      this.dragging = true;
      const { innerContainer } = this.$refs;
      const animateCss = {
        [`margin-${Craft.left}`]: 0
      };
      $(innerContainer).velocity("stop").velocity(animateCss, Craft.LightSwitch.animationDuration, this.onSettle.bind(this));
    },
    turnOff() {
      this.context.node.input(false);
      this.dragging = true;
      const { innerContainer } = this.$refs;
      const animateCss = {
        [`margin-${Craft.left}`]: this.offMargin
      };
      $(innerContainer).velocity("stop").velocity(animateCss, Craft.LightSwitch.animationDuration, this.onSettle.bind(this));
    },
    toggle() {
      if (!this.context._value) {
        this.turnOn();
      } else {
        this.turnOff();
      }
    },
    onMouseUp() {
      if (!this.dragger.dragging) {
        this.toggle();
      }
    },
    onKeyDown(event) {
      switch (event.keyCode) {
        case Garnish.SPACE_KEY: {
          this.toggle();
          event.preventDefault();
          break;
        }
        case Garnish.RIGHT_KEY: {
          if (Craft.orientation === "ltr") {
            this.turnOn();
          } else {
            this.turnOff();
          }
          event.preventDefault();
          break;
        }
        case Garnish.LEFT_KEY: {
          if (Craft.orientation === "ltr") {
            this.turnOff();
          } else {
            this.turnOn();
          }
          event.preventDefault();
          break;
        }
      }
    },
    onDragStart() {
      this.dragging = true;
      this.dragStartMargin = this.getMargin();
    },
    onDrag() {
      let margin;
      if (Craft.orientation === "ltr") {
        margin = this.dragStartMargin + this.dragger.mouseDistX;
      } else {
        margin = this.dragStartMargin - this.dragger.mouseDistX;
      }
      if (margin < this.offMargin) {
        margin = this.offMargin;
      } else if (margin > 0) {
        margin = 0;
      }
      const { innerContainer } = this.$refs;
      $(innerContainer).css(`margin-${Craft.left}`, margin);
    },
    onDragStop() {
      const margin = this.getMargin();
      if (margin > this.offMargin / 2) {
        this.turnOn();
      } else {
        this.turnOff();
      }
    },
    onSettle() {
      this.dragging = false;
    },
    getMargin() {
      const { innerContainer } = this.$refs;
      const style2 = innerContainer.currentStyle || window.getComputedStyle(innerContainer);
      return parseInt(style2.marginLeft);
    },
    toBoolean(value) {
      return toBoolean(value);
    }
  }
};
const _hoisted_1$m = { class: "ltr" };
const _hoisted_2$i = ["id", "aria-labelledby", "aria-checked"];
const _hoisted_3$e = {
  ref: "innerContainer",
  class: "lightswitch-container"
};
const _hoisted_4$c = /* @__PURE__ */ createBaseVNode("div", { class: "handle" }, null, -1);
const _hoisted_5$a = [
  _hoisted_4$c
];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$m, [
    createBaseVNode("div", {
      id: $props.context.id,
      ref: "container",
      tabindex: "0",
      role: "checkbox",
      class: normalizeClass(["lightswitch", [{
        on: $options.toBoolean($props.context._value),
        dragging: $data.dragging
      }, $options.localClasses]]),
      "aria-labelledby": `${$props.context.id}-label`,
      "aria-checked": $props.context._value ? "true" : "false",
      onMouseup: _cache[1] || (_cache[1] = (...args) => $options.onMouseUp && $options.onMouseUp(...args)),
      onKeydown: _cache[2] || (_cache[2] = (...args) => $options.onKeyDown && $options.onKeyDown(...args))
    }, [
      createBaseVNode("div", _hoisted_3$e, _hoisted_5$a, 512),
      withDirectives(createBaseVNode("input", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.context._value = $event),
        type: "hidden"
      }, null, 512), [
        [vModelText, $props.context._value]
      ])
    ], 42, _hoisted_2$i)
  ]);
}
var LightswitchInput = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/LightswitchInput.vue"]]);
function isEmpty2(opt) {
  if (opt === 0)
    return false;
  if (Array.isArray(opt) && opt.length === 0)
    return true;
  return !opt;
}
function not2(fun) {
  return (...params) => !fun(...params);
}
function includes(str, query) {
  if (str === void 0)
    str = "undefined";
  if (str === null)
    str = "null";
  if (str === false)
    str = "false";
  const text3 = str.toString().toLowerCase();
  return text3.indexOf(query.trim()) !== -1;
}
function filterOptions(options2, search2, label2, customLabel) {
  return search2 ? options2.filter((option3) => includes(customLabel(option3, label2), search2)).sort((a, b) => customLabel(a, label2).length - customLabel(b, label2).length) : options2;
}
function stripGroups(options2) {
  return options2.filter((option3) => !option3.$isLabel);
}
function flattenOptions(values, label2) {
  return (options2) => options2.reduce((prev, curr) => {
    if (curr[values] && curr[values].length) {
      prev.push({
        $groupLabel: curr[label2],
        $isLabel: true
      });
      return prev.concat(curr[values]);
    }
    return prev;
  }, []);
}
function filterGroups(search2, label2, values, groupLabel, customLabel) {
  return (groups) => groups.map((group2) => {
    if (!group2[values]) {
      console.warn(`Options passed to vue-multiselect do not contain groups, despite the config.`);
      return [];
    }
    const groupOptions = filterOptions(group2[values], search2, label2, customLabel);
    return groupOptions.length ? {
      [groupLabel]: group2[groupLabel],
      [values]: groupOptions
    } : [];
  });
}
const flow = (...fns) => (x) => fns.reduce((v, f) => f(v), x);
var multiselectMixin = {
  data() {
    return {
      search: "",
      isOpen: false,
      preferredOpenDirection: "below",
      optimizedHeight: this.maxHeight
    };
  },
  props: {
    internalSearch: {
      type: Boolean,
      default: true
    },
    options: {
      type: Array,
      required: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    trackBy: {
      type: String
    },
    label: {
      type: String
    },
    searchable: {
      type: Boolean,
      default: true
    },
    clearOnSelect: {
      type: Boolean,
      default: true
    },
    hideSelected: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: "Select option"
    },
    allowEmpty: {
      type: Boolean,
      default: true
    },
    resetAfter: {
      type: Boolean,
      default: false
    },
    closeOnSelect: {
      type: Boolean,
      default: true
    },
    customLabel: {
      type: Function,
      default(option3, label2) {
        if (isEmpty2(option3))
          return "";
        return label2 ? option3[label2] : option3;
      }
    },
    taggable: {
      type: Boolean,
      default: false
    },
    tagPlaceholder: {
      type: String,
      default: "Press enter to create a tag"
    },
    tagPosition: {
      type: String,
      default: "top"
    },
    max: {
      type: [Number, Boolean],
      default: false
    },
    id: {
      default: null
    },
    optionsLimit: {
      type: Number,
      default: 1e3
    },
    groupValues: {
      type: String
    },
    groupLabel: {
      type: String
    },
    groupSelect: {
      type: Boolean,
      default: false
    },
    blockKeys: {
      type: Array,
      default() {
        return [];
      }
    },
    preserveSearch: {
      type: Boolean,
      default: false
    },
    preselectFirst: {
      type: Boolean,
      default: false
    }
  },
  mounted() {
    if (!this.multiple && this.max) {
      console.warn("[Vue-Multiselect warn]: Max prop should not be used when prop Multiple equals false.");
    }
    if (this.preselectFirst && !this.internalValue.length && this.options.length) {
      this.select(this.filteredOptions[0]);
    }
  },
  computed: {
    internalValue() {
      return this.modelValue || this.modelValue === 0 ? Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue] : [];
    },
    filteredOptions() {
      const search2 = this.search || "";
      const normalizedSearch = search2.toLowerCase().trim();
      let options2 = this.options.concat();
      if (this.internalSearch) {
        options2 = this.groupValues ? this.filterAndFlat(options2, normalizedSearch, this.label) : filterOptions(options2, normalizedSearch, this.label, this.customLabel);
      } else {
        options2 = this.groupValues ? flattenOptions(this.groupValues, this.groupLabel)(options2) : options2;
      }
      options2 = this.hideSelected ? options2.filter(not2(this.isSelected)) : options2;
      if (this.taggable && normalizedSearch.length && !this.isExistingOption(normalizedSearch)) {
        if (this.tagPosition === "bottom") {
          options2.push({ isTag: true, label: search2 });
        } else {
          options2.unshift({ isTag: true, label: search2 });
        }
      }
      return options2.slice(0, this.optionsLimit);
    },
    valueKeys() {
      if (this.trackBy) {
        return this.internalValue.map((element) => element[this.trackBy]);
      } else {
        return this.internalValue;
      }
    },
    optionKeys() {
      const options2 = this.groupValues ? this.flatAndStrip(this.options) : this.options;
      return options2.map((element) => this.customLabel(element, this.label).toString().toLowerCase());
    },
    currentOptionLabel() {
      return this.multiple ? this.searchable ? "" : this.placeholder : this.internalValue.length ? this.getOptionLabel(this.internalValue[0]) : this.searchable ? "" : this.placeholder;
    }
  },
  watch: {
    internalValue() {
      if (this.resetAfter && this.internalValue.length) {
        this.search = "";
        this.$emit("update:modelValue", this.multiple ? [] : null);
      }
    },
    search() {
      this.$emit("search-change", this.search);
    }
  },
  emits: ["open", "search-change", "close", "select", "update:modelValue", "remove", "tag"],
  methods: {
    getValue() {
      return this.multiple ? this.internalValue : this.internalValue.length === 0 ? null : this.internalValue[0];
    },
    filterAndFlat(options2, search2, label2) {
      return flow(filterGroups(search2, label2, this.groupValues, this.groupLabel, this.customLabel), flattenOptions(this.groupValues, this.groupLabel))(options2);
    },
    flatAndStrip(options2) {
      return flow(flattenOptions(this.groupValues, this.groupLabel), stripGroups)(options2);
    },
    updateSearch(query) {
      this.search = query;
    },
    isExistingOption(query) {
      return !this.options ? false : this.optionKeys.indexOf(query) > -1;
    },
    isSelected(option3) {
      const opt = this.trackBy ? option3[this.trackBy] : option3;
      return this.valueKeys.indexOf(opt) > -1;
    },
    isOptionDisabled(option3) {
      return !!option3.$isDisabled;
    },
    getOptionLabel(option3) {
      if (isEmpty2(option3))
        return "";
      if (option3.isTag)
        return option3.label;
      if (option3.$isLabel)
        return option3.$groupLabel;
      const label2 = this.customLabel(option3, this.label);
      if (isEmpty2(label2))
        return "";
      return label2;
    },
    select(option3, key) {
      if (option3.$isLabel && this.groupSelect) {
        this.selectGroup(option3);
        return;
      }
      if (this.blockKeys.indexOf(key) !== -1 || this.disabled || option3.$isDisabled || option3.$isLabel)
        return;
      if (this.max && this.multiple && this.internalValue.length === this.max)
        return;
      if (key === "Tab" && !this.pointerDirty)
        return;
      if (option3.isTag) {
        this.$emit("tag", option3.label, this.id);
        this.search = "";
        if (this.closeOnSelect && !this.multiple)
          this.deactivate();
      } else {
        const isSelected2 = this.isSelected(option3);
        if (isSelected2) {
          if (key !== "Tab")
            this.removeElement(option3);
          return;
        }
        this.$emit("select", option3, this.id);
        if (this.multiple) {
          this.$emit("update:modelValue", this.internalValue.concat([option3]));
        } else {
          this.$emit("update:modelValue", option3);
        }
        if (this.clearOnSelect)
          this.search = "";
      }
      if (this.closeOnSelect)
        this.deactivate();
    },
    selectGroup(selectedGroup) {
      const group2 = this.options.find((option3) => {
        return option3[this.groupLabel] === selectedGroup.$groupLabel;
      });
      if (!group2)
        return;
      if (this.wholeGroupSelected(group2)) {
        this.$emit("remove", group2[this.groupValues], this.id);
        const newValue = this.internalValue.filter((option3) => group2[this.groupValues].indexOf(option3) === -1);
        this.$emit("update:modelValue", newValue);
      } else {
        const optionsToAdd = group2[this.groupValues].filter((option3) => !(this.isOptionDisabled(option3) || this.isSelected(option3)));
        this.$emit("select", optionsToAdd, this.id);
        this.$emit("update:modelValue", this.internalValue.concat(optionsToAdd));
      }
      if (this.closeOnSelect)
        this.deactivate();
    },
    wholeGroupSelected(group2) {
      return group2[this.groupValues].every((option3) => this.isSelected(option3) || this.isOptionDisabled(option3));
    },
    wholeGroupDisabled(group2) {
      return group2[this.groupValues].every(this.isOptionDisabled);
    },
    removeElement(option3, shouldClose = true) {
      if (this.disabled)
        return;
      if (option3.$isDisabled)
        return;
      if (!this.allowEmpty && this.internalValue.length <= 1) {
        this.deactivate();
        return;
      }
      const index2 = typeof option3 === "object" ? this.valueKeys.indexOf(option3[this.trackBy]) : this.valueKeys.indexOf(option3);
      this.$emit("remove", option3, this.id);
      if (this.multiple) {
        const newValue = this.internalValue.slice(0, index2).concat(this.internalValue.slice(index2 + 1));
        this.$emit("update:modelValue", newValue);
      } else {
        this.$emit("update:modelValue", null);
      }
      if (this.closeOnSelect && shouldClose)
        this.deactivate();
    },
    removeLastElement() {
      if (this.blockKeys.indexOf("Delete") !== -1)
        return;
      if (this.search.length === 0 && Array.isArray(this.internalValue) && this.internalValue.length) {
        this.removeElement(this.internalValue[this.internalValue.length - 1], false);
      }
    },
    activate() {
      if (this.isOpen || this.disabled)
        return;
      this.adjustPosition();
      if (this.groupValues && this.pointer === 0 && this.filteredOptions.length) {
        this.pointer = 1;
      }
      this.isOpen = true;
      if (this.searchable) {
        if (!this.preserveSearch)
          this.search = "";
        this.$nextTick(() => this.$refs.search && this.$refs.search.focus());
      } else {
        this.$el.focus();
      }
      this.$emit("open", this.id);
    },
    deactivate() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      if (this.searchable) {
        this.$refs.search && this.$refs.search.blur();
      } else {
        this.$el.blur();
      }
      if (!this.preserveSearch)
        this.search = "";
      this.$emit("close", this.getValue(), this.id);
    },
    toggle() {
      this.isOpen ? this.deactivate() : this.activate();
    },
    adjustPosition() {
      if (typeof window === "undefined")
        return;
      const spaceAbove = this.$el.getBoundingClientRect().top;
      const spaceBelow = window.innerHeight - this.$el.getBoundingClientRect().bottom;
      const hasEnoughSpaceBelow = spaceBelow > this.maxHeight;
      if (hasEnoughSpaceBelow || spaceBelow > spaceAbove || this.openDirection === "below" || this.openDirection === "bottom") {
        this.preferredOpenDirection = "below";
        this.optimizedHeight = Math.min(spaceBelow - 40, this.maxHeight);
      } else {
        this.preferredOpenDirection = "above";
        this.optimizedHeight = Math.min(spaceAbove - 40, this.maxHeight);
      }
    }
  }
};
var pointerMixin = {
  data() {
    return {
      pointer: 0,
      pointerDirty: false
    };
  },
  props: {
    showPointer: {
      type: Boolean,
      default: true
    },
    optionHeight: {
      type: Number,
      default: 40
    }
  },
  computed: {
    pointerPosition() {
      return this.pointer * this.optionHeight;
    },
    visibleElements() {
      return this.optimizedHeight / this.optionHeight;
    }
  },
  watch: {
    filteredOptions() {
      this.pointerAdjust();
    },
    isOpen() {
      this.pointerDirty = false;
    },
    pointer() {
      this.$refs.search && this.$refs.search.setAttribute("aria-activedescendant", this.id + "-" + this.pointer.toString());
    }
  },
  methods: {
    optionHighlight(index2, option3) {
      return {
        "multiselect__option--highlight": index2 === this.pointer && this.showPointer,
        "multiselect__option--selected": this.isSelected(option3)
      };
    },
    groupHighlight(index2, selectedGroup) {
      if (!this.groupSelect) {
        return [
          "multiselect__option--disabled",
          { "multiselect__option--group": selectedGroup.$isLabel }
        ];
      }
      const group2 = this.options.find((option3) => {
        return option3[this.groupLabel] === selectedGroup.$groupLabel;
      });
      return group2 && !this.wholeGroupDisabled(group2) ? [
        "multiselect__option--group",
        { "multiselect__option--highlight": index2 === this.pointer && this.showPointer },
        { "multiselect__option--group-selected": this.wholeGroupSelected(group2) }
      ] : "multiselect__option--disabled";
    },
    addPointerElement({ key } = "Enter") {
      if (this.filteredOptions.length > 0) {
        this.select(this.filteredOptions[this.pointer], key);
      }
      this.pointerReset();
    },
    pointerForward() {
      if (this.pointer < this.filteredOptions.length - 1) {
        this.pointer++;
        if (this.$refs.list.scrollTop <= this.pointerPosition - (this.visibleElements - 1) * this.optionHeight) {
          this.$refs.list.scrollTop = this.pointerPosition - (this.visibleElements - 1) * this.optionHeight;
        }
        if (this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect)
          this.pointerForward();
      }
      this.pointerDirty = true;
    },
    pointerBackward() {
      if (this.pointer > 0) {
        this.pointer--;
        if (this.$refs.list.scrollTop >= this.pointerPosition) {
          this.$refs.list.scrollTop = this.pointerPosition;
        }
        if (this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect)
          this.pointerBackward();
      } else {
        if (this.filteredOptions[this.pointer] && this.filteredOptions[0].$isLabel && !this.groupSelect)
          this.pointerForward();
      }
      this.pointerDirty = true;
    },
    pointerReset() {
      if (!this.closeOnSelect)
        return;
      this.pointer = 0;
      if (this.$refs.list) {
        this.$refs.list.scrollTop = 0;
      }
    },
    pointerAdjust() {
      if (this.pointer >= this.filteredOptions.length - 1) {
        this.pointer = this.filteredOptions.length ? this.filteredOptions.length - 1 : 0;
      }
      if (this.filteredOptions.length > 0 && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect) {
        this.pointerForward();
      }
    },
    pointerSet(index2) {
      this.pointer = index2;
      this.pointerDirty = true;
    }
  }
};
var script = {
  name: "vue-multiselect",
  mixins: [multiselectMixin, pointerMixin],
  props: {
    name: {
      type: String,
      default: ""
    },
    modelValue: {
      type: null,
      default() {
        return [];
      }
    },
    selectLabel: {
      type: String,
      default: "Press enter to select"
    },
    selectGroupLabel: {
      type: String,
      default: "Press enter to select group"
    },
    selectedLabel: {
      type: String,
      default: "Selected"
    },
    deselectLabel: {
      type: String,
      default: "Press enter to remove"
    },
    deselectGroupLabel: {
      type: String,
      default: "Press enter to deselect group"
    },
    showLabels: {
      type: Boolean,
      default: true
    },
    limit: {
      type: Number,
      default: 99999
    },
    maxHeight: {
      type: Number,
      default: 300
    },
    limitText: {
      type: Function,
      default: (count2) => `and ${count2} more`
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    openDirection: {
      type: String,
      default: ""
    },
    showNoOptions: {
      type: Boolean,
      default: true
    },
    showNoResults: {
      type: Boolean,
      default: true
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },
  computed: {
    isSingleLabelVisible() {
      return (this.singleValue || this.singleValue === 0) && (!this.isOpen || !this.searchable) && !this.visibleValues.length;
    },
    isPlaceholderVisible() {
      return !this.internalValue.length && (!this.searchable || !this.isOpen);
    },
    visibleValues() {
      return this.multiple ? this.internalValue.slice(0, this.limit) : [];
    },
    singleValue() {
      return this.internalValue[0];
    },
    deselectLabelText() {
      return this.showLabels ? this.deselectLabel : "";
    },
    deselectGroupLabelText() {
      return this.showLabels ? this.deselectGroupLabel : "";
    },
    selectLabelText() {
      return this.showLabels ? this.selectLabel : "";
    },
    selectGroupLabelText() {
      return this.showLabels ? this.selectGroupLabel : "";
    },
    selectedLabelText() {
      return this.showLabels ? this.selectedLabel : "";
    },
    inputStyle() {
      if (this.searchable || this.multiple && this.modelValue && this.modelValue.length) {
        return this.isOpen ? { width: "100%" } : { width: "0", position: "absolute", padding: "0" };
      }
      return "";
    },
    contentStyle() {
      return this.options.length ? { display: "inline-block" } : { display: "block" };
    },
    isAbove() {
      if (this.openDirection === "above" || this.openDirection === "top") {
        return true;
      } else if (this.openDirection === "below" || this.openDirection === "bottom") {
        return false;
      } else {
        return this.preferredOpenDirection === "above";
      }
    },
    showSearchInput() {
      return this.searchable && (this.hasSingleSelectedSlot && (this.visibleSingleValue || this.visibleSingleValue === 0) ? this.isOpen : true);
    }
  }
};
const _hoisted_1$l = {
  ref: "tags",
  class: "multiselect__tags"
};
const _hoisted_2$h = { class: "multiselect__tags-wrap" };
const _hoisted_3$d = { class: "multiselect__spinner" };
const _hoisted_4$b = { key: 0 };
const _hoisted_5$9 = { class: "multiselect__option" };
const _hoisted_6$7 = { class: "multiselect__option" };
const _hoisted_7$6 = /* @__PURE__ */ createTextVNode("No elements found. Consider changing the search query.");
const _hoisted_8$6 = { class: "multiselect__option" };
const _hoisted_9$6 = /* @__PURE__ */ createTextVNode("List is empty.");
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("div", {
    tabindex: _ctx.searchable ? -1 : $props.tabindex,
    class: [{ "multiselect--active": _ctx.isOpen, "multiselect--disabled": $props.disabled, "multiselect--above": $options.isAbove }, "multiselect"],
    onFocus: _cache[14] || (_cache[14] = ($event) => _ctx.activate()),
    onBlur: _cache[15] || (_cache[15] = ($event) => _ctx.searchable ? false : _ctx.deactivate()),
    onKeydown: [
      _cache[16] || (_cache[16] = withKeys(withModifiers(($event) => _ctx.pointerForward(), ["self", "prevent"]), ["down"])),
      _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.pointerBackward(), ["self", "prevent"]), ["up"]))
    ],
    onKeypress: _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.addPointerElement($event), ["stop", "self"]), ["enter", "tab"])),
    onKeyup: _cache[19] || (_cache[19] = withKeys(($event) => _ctx.deactivate(), ["esc"])),
    role: "combobox",
    "aria-owns": "listbox-" + _ctx.id
  }, [
    renderSlot(_ctx.$slots, "caret", { toggle: _ctx.toggle }, () => [
      createVNode("div", {
        onMousedown: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.toggle(), ["prevent", "stop"])),
        class: "multiselect__select"
      }, null, 32)
    ]),
    renderSlot(_ctx.$slots, "clear", { search: _ctx.search }),
    createVNode("div", _hoisted_1$l, [
      renderSlot(_ctx.$slots, "selection", {
        search: _ctx.search,
        remove: _ctx.removeElement,
        values: $options.visibleValues,
        isOpen: _ctx.isOpen
      }, () => [
        withDirectives(createVNode("div", _hoisted_2$h, [
          (openBlock(true), createBlock(Fragment$1, null, renderList($options.visibleValues, (option3, index2) => {
            return renderSlot(_ctx.$slots, "tag", {
              option: option3,
              search: _ctx.search,
              remove: _ctx.removeElement
            }, () => [
              (openBlock(), createBlock("span", {
                class: "multiselect__tag",
                key: index2
              }, [
                createVNode("span", {
                  textContent: toDisplayString(_ctx.getOptionLabel(option3))
                }, null, 8, ["textContent"]),
                createVNode("i", {
                  tabindex: "1",
                  onKeypress: withKeys(withModifiers(($event) => _ctx.removeElement(option3), ["prevent"]), ["enter"]),
                  onMousedown: withModifiers(($event) => _ctx.removeElement(option3), ["prevent"]),
                  class: "multiselect__tag-icon"
                }, null, 40, ["onKeypress", "onMousedown"])
              ]))
            ]);
          }), 256))
        ], 512), [
          [vShow, $options.visibleValues.length > 0]
        ]),
        _ctx.internalValue && _ctx.internalValue.length > $props.limit ? renderSlot(_ctx.$slots, "limit", { key: 0 }, () => [
          createVNode("strong", {
            class: "multiselect__strong",
            textContent: toDisplayString($props.limitText(_ctx.internalValue.length - $props.limit))
          }, null, 8, ["textContent"])
        ]) : createCommentVNode("v-if", true)
      ]),
      createVNode(Transition, { name: "multiselect__loading" }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "loading", {}, () => [
            withDirectives(createVNode("div", _hoisted_3$d, null, 512), [
              [vShow, $props.loading]
            ])
          ])
        ]),
        _: 3
      }),
      _ctx.searchable ? (openBlock(), createBlock("input", {
        key: 0,
        ref: "search",
        name: $props.name,
        id: _ctx.id,
        type: "text",
        autocomplete: "off",
        spellcheck: "false",
        placeholder: _ctx.placeholder,
        style: $options.inputStyle,
        value: _ctx.search,
        disabled: $props.disabled,
        tabindex: $props.tabindex,
        onInput: _cache[2] || (_cache[2] = ($event) => _ctx.updateSearch($event.target.value)),
        onFocus: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.activate(), ["prevent"])),
        onBlur: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.deactivate(), ["prevent"])),
        onKeyup: _cache[5] || (_cache[5] = withKeys(($event) => _ctx.deactivate(), ["esc"])),
        onKeydown: [
          _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.pointerForward(), ["prevent"]), ["down"])),
          _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.pointerBackward(), ["prevent"]), ["up"])),
          _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.removeLastElement(), ["stop"]), ["delete"]))
        ],
        onKeypress: _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.addPointerElement($event), ["prevent", "stop", "self"]), ["enter"])),
        class: "multiselect__input",
        "aria-controls": "listbox-" + _ctx.id
      }, null, 44, ["name", "id", "placeholder", "value", "disabled", "tabindex", "aria-controls"])) : createCommentVNode("v-if", true),
      $options.isSingleLabelVisible ? (openBlock(), createBlock("span", {
        key: 1,
        class: "multiselect__single",
        onMousedown: _cache[10] || (_cache[10] = withModifiers((...args) => _ctx.toggle && _ctx.toggle(...args), ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "singleLabel", { option: $options.singleValue }, () => [
          createTextVNode(toDisplayString(_ctx.currentOptionLabel), 1)
        ])
      ], 32)) : createCommentVNode("v-if", true),
      $options.isPlaceholderVisible ? (openBlock(), createBlock("span", {
        key: 2,
        class: "multiselect__placeholder",
        onMousedown: _cache[11] || (_cache[11] = withModifiers((...args) => _ctx.toggle && _ctx.toggle(...args), ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "placeholder", {}, () => [
          createTextVNode(toDisplayString(_ctx.placeholder), 1)
        ])
      ], 32)) : createCommentVNode("v-if", true)
    ], 512),
    createVNode(Transition, { name: "multiselect" }, {
      default: withCtx(() => [
        withDirectives(createVNode("div", {
          class: "multiselect__content-wrapper",
          onFocus: _cache[12] || (_cache[12] = (...args) => _ctx.activate && _ctx.activate(...args)),
          tabindex: "-1",
          onMousedown: _cache[13] || (_cache[13] = withModifiers(() => {
          }, ["prevent"])),
          style: { maxHeight: _ctx.optimizedHeight + "px" },
          ref: "list"
        }, [
          createVNode("ul", {
            class: "multiselect__content",
            style: $options.contentStyle,
            role: "listbox",
            id: "listbox-" + _ctx.id
          }, [
            renderSlot(_ctx.$slots, "beforeList"),
            _ctx.multiple && _ctx.max === _ctx.internalValue.length ? (openBlock(), createBlock("li", _hoisted_4$b, [
              createVNode("span", _hoisted_5$9, [
                renderSlot(_ctx.$slots, "maxElements", {}, () => [
                  createTextVNode("Maximum of " + toDisplayString(_ctx.max) + " options selected. First remove a selected option to select another.", 1)
                ])
              ])
            ])) : createCommentVNode("v-if", true),
            !_ctx.max || _ctx.internalValue.length < _ctx.max ? (openBlock(true), createBlock(Fragment$1, { key: 1 }, renderList(_ctx.filteredOptions, (option3, index2) => {
              return openBlock(), createBlock("li", {
                class: "multiselect__element",
                key: index2,
                id: _ctx.id + "-" + index2,
                role: !(option3 && (option3.$isLabel || option3.$isDisabled)) ? "option" : null
              }, [
                !(option3 && (option3.$isLabel || option3.$isDisabled)) ? (openBlock(), createBlock("span", {
                  key: 0,
                  class: [_ctx.optionHighlight(index2, option3), "multiselect__option"],
                  onClick: withModifiers(($event) => _ctx.select(option3), ["stop"]),
                  onMouseenter: withModifiers(($event) => _ctx.pointerSet(index2), ["self"]),
                  "data-select": option3 && option3.isTag ? _ctx.tagPlaceholder : $options.selectLabelText,
                  "data-selected": $options.selectedLabelText,
                  "data-deselect": $options.deselectLabelText
                }, [
                  renderSlot(_ctx.$slots, "option", {
                    option: option3,
                    search: _ctx.search,
                    index: index2
                  }, () => [
                    createVNode("span", null, toDisplayString(_ctx.getOptionLabel(option3)), 1)
                  ])
                ], 42, ["onClick", "onMouseenter", "data-select", "data-selected", "data-deselect"])) : createCommentVNode("v-if", true),
                option3 && (option3.$isLabel || option3.$isDisabled) ? (openBlock(), createBlock("span", {
                  key: 1,
                  "data-select": _ctx.groupSelect && $options.selectGroupLabelText,
                  "data-deselect": _ctx.groupSelect && $options.deselectGroupLabelText,
                  class: [_ctx.groupHighlight(index2, option3), "multiselect__option"],
                  onMouseenter: withModifiers(($event) => _ctx.groupSelect && _ctx.pointerSet(index2), ["self"]),
                  onMousedown: withModifiers(($event) => _ctx.selectGroup(option3), ["prevent"])
                }, [
                  renderSlot(_ctx.$slots, "option", {
                    option: option3,
                    search: _ctx.search,
                    index: index2
                  }, () => [
                    createVNode("span", null, toDisplayString(_ctx.getOptionLabel(option3)), 1)
                  ])
                ], 42, ["data-select", "data-deselect", "onMouseenter", "onMousedown"])) : createCommentVNode("v-if", true)
              ], 8, ["id", "role"]);
            }), 128)) : createCommentVNode("v-if", true),
            withDirectives(createVNode("li", null, [
              createVNode("span", _hoisted_6$7, [
                renderSlot(_ctx.$slots, "noResult", { search: _ctx.search }, () => [
                  _hoisted_7$6
                ])
              ])
            ], 512), [
              [vShow, $props.showNoResults && (_ctx.filteredOptions.length === 0 && _ctx.search && !$props.loading)]
            ]),
            withDirectives(createVNode("li", null, [
              createVNode("span", _hoisted_8$6, [
                renderSlot(_ctx.$slots, "noOptions", {}, () => [
                  _hoisted_9$6
                ])
              ])
            ], 512), [
              [vShow, $props.showNoOptions && (_ctx.options.length === 0 && !_ctx.search && !$props.loading)]
            ]),
            renderSlot(_ctx.$slots, "afterList")
          ], 12, ["id"])
        ], 36), [
          [vShow, _ctx.isOpen]
        ])
      ]),
      _: 3
    })
  ], 42, ["tabindex", "aria-owns"]);
}
script.render = render$1;
var vueMultiselect_css_vue_type_style_index_0_src_7631fa11_lang = /* @__PURE__ */ (() => 'fieldset[disabled] .multiselect{pointer-events:none}.multiselect__spinner{position:absolute;right:1px;top:1px;width:48px;height:35px;background:#fff;display:block}.multiselect__spinner:after,.multiselect__spinner:before{position:absolute;content:"";top:50%;left:50%;margin:-8px 0 0 -8px;width:16px;height:16px;border-radius:100%;border-color:#41b883 transparent transparent;border-style:solid;border-width:2px;box-shadow:0 0 0 1px transparent}.multiselect__spinner:before{-webkit-animation:spinning 2.4s cubic-bezier(.41,.26,.2,.62);animation:spinning 2.4s cubic-bezier(.41,.26,.2,.62);-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}.multiselect__spinner:after{-webkit-animation:spinning 2.4s cubic-bezier(.51,.09,.21,.8);animation:spinning 2.4s cubic-bezier(.51,.09,.21,.8);-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}.multiselect__loading-enter-active,.multiselect__loading-leave-active{transition:opacity .4s ease-in-out;opacity:1}.multiselect__loading-enter,.multiselect__loading-leave-active{opacity:0}.multiselect,.multiselect__input,.multiselect__single{font-family:inherit;font-size:16px;touch-action:manipulation}.multiselect{box-sizing:content-box;display:block;position:relative;width:100%;min-height:40px;text-align:left;color:#35495e}.multiselect *{box-sizing:border-box}.multiselect:focus{outline:none}.multiselect--disabled{background:#ededed;pointer-events:none;opacity:.6}.multiselect--active{z-index:50}.multiselect--active:not(.multiselect--above) .multiselect__current,.multiselect--active:not(.multiselect--above) .multiselect__input,.multiselect--active:not(.multiselect--above) .multiselect__tags{border-bottom-left-radius:0;border-bottom-right-radius:0}.multiselect--active .multiselect__select{transform:rotate(180deg)}.multiselect--above.multiselect--active .multiselect__current,.multiselect--above.multiselect--active .multiselect__input,.multiselect--above.multiselect--active .multiselect__tags{border-top-left-radius:0;border-top-right-radius:0}.multiselect__input,.multiselect__single{position:relative;display:inline-block;min-height:20px;line-height:20px;border:none;border-radius:5px;background:#fff;padding:0 0 0 5px;width:100%;transition:border .1s ease;box-sizing:border-box;margin-bottom:8px;vertical-align:top}.multiselect__input::-moz-placeholder{color:#35495e}.multiselect__input:-ms-input-placeholder{color:#35495e}.multiselect__input::placeholder{color:#35495e}.multiselect__tag~.multiselect__input,.multiselect__tag~.multiselect__single{width:auto}.multiselect__input:hover,.multiselect__single:hover{border-color:#cfcfcf}.multiselect__input:focus,.multiselect__single:focus{border-color:#a8a8a8;outline:none}.multiselect__single{padding-left:5px;margin-bottom:8px}.multiselect__tags-wrap{display:inline}.multiselect__tags{min-height:40px;display:block;padding:8px 40px 0 8px;border-radius:5px;border:1px solid #e8e8e8;background:#fff;font-size:14px}.multiselect__tag{position:relative;display:inline-block;padding:4px 26px 4px 10px;border-radius:5px;margin-right:10px;color:#fff;line-height:1;background:#41b883;margin-bottom:5px;white-space:nowrap;overflow:hidden;max-width:100%;text-overflow:ellipsis}.multiselect__tag-icon{cursor:pointer;margin-left:7px;position:absolute;right:0;top:0;bottom:0;font-weight:700;font-style:normal;width:22px;text-align:center;line-height:22px;transition:all .2s ease;border-radius:5px}.multiselect__tag-icon:after{content:"\xD7";color:#266d4d;font-size:14px}.multiselect__tag-icon:focus:after,.multiselect__tag-icon:hover:after{color:#fff}.multiselect__current{min-height:40px;overflow:hidden;padding:8px 12px 0;padding-right:30px;white-space:nowrap;border-radius:5px;border:1px solid #e8e8e8}.multiselect__current,.multiselect__select{line-height:16px;box-sizing:border-box;display:block;margin:0;text-decoration:none;cursor:pointer}.multiselect__select{position:absolute;width:40px;height:38px;right:1px;top:1px;padding:4px 8px;text-align:center;transition:transform .2s ease}.multiselect__select:before{position:relative;right:0;top:65%;color:#999;margin-top:4px;border-style:solid;border-width:5px 5px 0 5px;border-color:#999 transparent transparent transparent;content:""}.multiselect__placeholder{color:#adadad;display:inline-block;margin-bottom:10px;padding-top:2px}.multiselect--active .multiselect__placeholder{display:none}.multiselect__content-wrapper{position:absolute;display:block;background:#fff;width:100%;max-height:240px;overflow:auto;border:1px solid #e8e8e8;border-top:none;border-bottom-left-radius:5px;border-bottom-right-radius:5px;z-index:50;-webkit-overflow-scrolling:touch}.multiselect__content{list-style:none;display:inline-block;padding:0;margin:0;min-width:100%;vertical-align:top}.multiselect--above .multiselect__content-wrapper{bottom:100%;border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:5px;border-top-right-radius:5px;border-bottom:none;border-top:1px solid #e8e8e8}.multiselect__content::-webkit-scrollbar{display:none}.multiselect__element{display:block}.multiselect__option{display:block;padding:12px;min-height:40px;line-height:16px;text-decoration:none;text-transform:none;vertical-align:middle;position:relative;cursor:pointer;white-space:nowrap}.multiselect__option:after{top:0;right:0;position:absolute;line-height:40px;padding-right:12px;padding-left:20px;font-size:13px}.multiselect__option--highlight{background:#41b883;outline:none;color:#fff}.multiselect__option--highlight:after{content:attr(data-select);background:#41b883;color:#fff}.multiselect__option--selected{background:#f3f3f3;color:#35495e;font-weight:700}.multiselect__option--selected:after{content:attr(data-selected);color:silver}.multiselect__option--selected.multiselect__option--highlight{background:#ff6a6a;color:#fff}.multiselect__option--selected.multiselect__option--highlight:after{background:#ff6a6a;content:attr(data-deselect);color:#fff}.multiselect--disabled .multiselect__current,.multiselect--disabled .multiselect__select{background:#ededed;color:#a6a6a6}.multiselect__option--disabled{background:#ededed!important;color:#a6a6a6!important;cursor:text;pointer-events:none}.multiselect__option--group{background:#ededed;color:#35495e}.multiselect__option--group.multiselect__option--highlight{background:#35495e;color:#fff}.multiselect__option--group.multiselect__option--highlight:after{background:#35495e}.multiselect__option--disabled.multiselect__option--highlight{background:#dedede}.multiselect__option--group-selected.multiselect__option--highlight{background:#ff6a6a;color:#fff}.multiselect__option--group-selected.multiselect__option--highlight:after{background:#ff6a6a;content:attr(data-deselect);color:#fff}.multiselect-enter-active,.multiselect-leave-active{transition:all .15s ease}.multiselect-enter,.multiselect-leave-active{opacity:0}.multiselect__strong{margin-bottom:8px;line-height:20px;display:inline-block;vertical-align:top}[dir=rtl] .multiselect{text-align:right}[dir=rtl] .multiselect__select{right:auto;left:1px}[dir=rtl] .multiselect__tags{padding:8px 8px 0 40px}[dir=rtl] .multiselect__content{text-align:right}[dir=rtl] .multiselect__option:after{right:auto;left:0}[dir=rtl] .multiselect__clear{right:auto;left:12px}[dir=rtl] .multiselect__spinner{right:auto;left:1px}@-webkit-keyframes spinning{0%{transform:rotate(0)}to{transform:rotate(2turn)}}@keyframes spinning{0%{transform:rotate(0)}to{transform:rotate(2turn)}}')();
var MultiSelectInput_vue_vue_type_style_index_1_lang = /* @__PURE__ */ (() => ".multiselect__tags {\n  border: 1px solid rgba(96, 125, 159, 0.25);\n  font-size: 13px;\n}\n.multiselect__tag {\n  color: #3f4d5a;\n  background-color: rgba(96, 125, 159, 0.25);\n  padding: 6px 26px 6px 10px;\n  border-radius: 3px;\n}\n.multiselect__tag-icon {\n  border-radius: 0;\n}\n.multiselect__tag-icon:focus:after,\n.multiselect__tag-icon:hover:after,\n.multiselect__tag-icon:after {\n  color: #3f4d5a;\n}\n.multiselect__tag-icon:focus,\n.multiselect__tag-icon:hover {\n  background: rgba(96, 125, 159, 0.1);\n}\n.multiselect__input,\n.multiselect__single {\n  font-size: 14px;\n  min-height: 18px;\n  line-height: 26px;\n  border-radius: 0;\n  padding: 0;\n}\n.multiselect__input:focus,\n.multiselect__single:focus {\n  box-shadow: none;\n}\n.multiselect__option {\n  padding: 8px;\n  min-height: auto;\n  font-size: 14px;\n  line-height: 14px;\n}\n.multiselect__option--highlight {\n  background: #e4edf6;\n  color: inherit;\n}\n.multiselect__placeholder {\n  color: #596673;\n  font-size: 14px;\n}")();
const _sfc_main$o = {
  components: {
    Multiselect: script
  },
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      proxyValue: []
    };
  },
  computed: {
    options() {
      return get2(this.context.attrs, "options", {});
    }
  },
  watch: {
    proxyValue(newValue) {
      this.context.node.input(newValue);
    }
  },
  created() {
    if (Array.isArray(this.context._value)) {
      this.proxyValue = this.context._value;
    }
  }
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_multiselect = resolveComponent("multiselect");
  return openBlock(), createBlock(_component_multiselect, mergeProps({
    modelValue: $data.proxyValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.proxyValue = $event)
  }, $props.context.attrs, {
    options: $options.options,
    multiple: true,
    "track-by": "value",
    label: "label",
    searchable: true,
    "hide-selected": true,
    "allow-empty": true,
    "show-labels": false,
    "close-on-select": false,
    "tag-placeholder": "test"
  }), null, 16, ["modelValue", "options"]);
}
var MultiSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/MultiSelectInput.vue"]]);
const _sfc_main$n = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      fieldOptions: [],
      conditions: [
        { label: Craft.t("formie", "Select an option"), value: "" },
        { label: Craft.t("formie", "is"), value: "=" },
        { label: Craft.t("formie", "is not"), value: "!=" },
        { label: Craft.t("formie", "greater than"), value: ">" },
        { label: Craft.t("formie", "less than"), value: "<" },
        { label: Craft.t("formie", "contains"), value: "contains" },
        { label: Craft.t("formie", "starts with"), value: "startsWith" },
        { label: Craft.t("formie", "ends with"), value: "endsWith" }
      ],
      settings: {},
      defaultSettings: {
        toRecipients: []
      }
    };
  },
  watch: {
    settings: {
      deep: true,
      handler(newValue) {
        this.context.node.input(this.serializeContent(newValue));
      }
    }
  },
  created() {
    this.fieldOptions = this.getFieldOptions();
    this.settings = this.unserializeContent(this.clone(this.context._value));
  },
  methods: {
    unserializeContent(value) {
      let parsedValue = null;
      if (!value) {
        return this.defaultSettings;
      }
      if (!Array.isArray(value) && !isPlainObject$1(value)) {
        try {
          parsedValue = JSON.parse(value);
        } catch (e) {
          console.log(e);
          console.log(value);
        }
      } else {
        parsedValue = value;
      }
      if (parsedValue && parsedValue.toRecipients) {
        parsedValue.toRecipients.forEach((row) => {
          const field = this.getField(row.field);
          row.valueType = this.getValueType(field, row.condition);
          row.valueOptions = this.getValueOptions(field, row.condition);
        });
        return parsedValue;
      }
      return this.defaultSettings;
    },
    serializeContent(content) {
      const value = this.clone(content);
      value.toRecipients.forEach((row) => {
        delete row.valueType;
        delete row.valueOptions;
      });
      return JSON.stringify(value);
    },
    addRow() {
      this.settings.toRecipients.push({
        id: newId(),
        email: "",
        field: "",
        condition: "",
        value: "",
        valueType: "text",
        valueOptions: []
      });
    },
    removeRow(index2) {
      this.settings.toRecipients.splice(index2, 1);
    },
    getValueType(field, condition) {
      if (field && field.field && field.field.settings) {
        let testField = field;
        let options2 = field.field.settings.options || [];
        if (field.field.supportsNested) {
          options2 = field.subfield.settings.options || [];
          testField = field.subfield;
        }
        if (options2.length && ["=", "!="].includes(condition)) {
          return "select";
        }
        if (testField.type === "verbb\\formie\\fields\\formfields\\Agree" && ["=", "!="].includes(condition)) {
          return "select";
        }
      }
      if (field && field.valueType) {
        if (["=", "!="].includes(condition)) {
          return field.valueType;
        }
      }
      return "text";
    },
    getValueOptions(field, condition) {
      if (field && field.field && field.field.settings) {
        let testField = field;
        let options2 = field.field.settings.options || [];
        if (field.field.supportsNested) {
          options2 = field.subfield.settings.options || [];
          testField = field.subfield;
        }
        options2 = this.clone(options2);
        if (testField.type === "verbb\\formie\\fields\\formfields\\Agree") {
          return [
            { label: "Checked", value: "1" },
            { label: "Unchecked", value: "0" }
          ];
        }
        if (testField.type === "verbb\\formie\\fields\\formfields\\Recipients") {
          for (let i = 0; i < options2.length; i++) {
            options2[i].value = `id:${i}`;
          }
        }
        options2 = options2.filter((option3) => {
          return !option3.isOptgroup;
        });
        return options2;
      }
      if (field && field.valueOptions) {
        return this.clone(field.valueOptions);
      }
      return [];
    },
    changeDropdown(row) {
      const field = this.getField(row.field);
      row.valueType = this.getValueType(field, row.condition);
      row.valueOptions = this.getValueOptions(field, row.condition);
      if (row.valueType === "select" && row.valueOptions && row.valueOptions[0]) {
        row.value = row.valueOptions[0].value;
      } else {
        row.value = "";
      }
    },
    getField(handle) {
      let field = null;
      this.fieldOptions.forEach((optgroup) => {
        optgroup.options.forEach((f) => {
          if (f.value === handle) {
            field = f;
          }
        });
      });
      return field;
    },
    getFieldOptions() {
      const options2 = [];
      const allStatuses = this.$store.getters["formie/statuses"]();
      const statuses = allStatuses.map((status) => {
        return { label: status.name, value: status.handle };
      });
      options2.push({
        label: Craft.t("formie", "Submission"),
        options: [
          { label: Craft.t("formie", "Title"), value: "{submission:title}" },
          { label: Craft.t("formie", "ID"), value: "{submission:id}" },
          { label: Craft.t("formie", "Form Name"), value: "{submission:formName}" },
          {
            label: Craft.t("formie", "Status"),
            value: "{submission:status}",
            valueType: "select",
            valueOptions: [
              { label: Craft.t("formie", "Select an option"), value: "" },
              ...statuses
            ]
          }
        ]
      });
      const fields = this.$store.getters["form/fields"];
      const customFields = [];
      fields.forEach((field) => {
        if (!toBoolean(field.isNested)) {
          if (field.subfieldOptions && field.hasSubfields) {
            field.subfieldOptions.forEach((subfield) => {
              customFields.push({
                field,
                subfield,
                type: field.type,
                label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                value: `{${field.handle}.${subfield.handle}}`
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((subfield) => {
                customFields.push({
                  field,
                  subfield,
                  type: field.type,
                  label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                  value: `{${field.handle}.rows.new1.fields.${subfield.handle}}`
                });
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Date") {
            customFields.push({
              field,
              type: field.type,
              label: truncate(field.label, { length: 60 }),
              value: `{${field.handle}.date}`
            });
          } else {
            customFields.push({
              field,
              type: field.type,
              label: truncate(field.label, { length: 60 }),
              value: `{${field.handle}}`
            });
          }
        }
      });
      options2.push({
        label: Craft.t("formie", "Fields"),
        options: customFields
      });
      return options2;
    }
  }
};
const _hoisted_1$k = { class: "editable fullwidth" };
const _hoisted_2$g = {
  scope: "col",
  class: "singleline-cell textual"
};
const _hoisted_3$c = {
  scope: "col",
  class: "select-cell thin"
};
const _hoisted_4$a = {
  scope: "col",
  class: "select-cell thin"
};
const _hoisted_5$8 = {
  scope: "col",
  class: "singleline-cell textual"
};
const _hoisted_6$6 = /* @__PURE__ */ createBaseVNode("th", { colspan: "2" }, null, -1);
const _hoisted_7$5 = { class: "" };
const _hoisted_8$5 = { class: "singleline-cell textual" };
const _hoisted_9$5 = ["onUpdate:modelValue"];
const _hoisted_10$5 = { class: "select-cell thin" };
const _hoisted_11$5 = { class: "select small" };
const _hoisted_12$4 = ["onUpdate:modelValue", "onChange"];
const _hoisted_13$4 = { value: "" };
const _hoisted_14$4 = ["label"];
const _hoisted_15$4 = ["value"];
const _hoisted_16$4 = { class: "select-cell thin" };
const _hoisted_17$4 = { class: "select small" };
const _hoisted_18$4 = ["onUpdate:modelValue", "onChange"];
const _hoisted_19$4 = ["value"];
const _hoisted_20$4 = {
  key: 0,
  class: "singleline-cell textual"
};
const _hoisted_21$4 = ["onUpdate:modelValue"];
const _hoisted_22$4 = {
  key: 1,
  class: "select-cell",
  style: { "text-align": "left" }
};
const _hoisted_23$4 = { class: "select small" };
const _hoisted_24$4 = ["onUpdate:modelValue"];
const _hoisted_25$4 = ["value"];
const _hoisted_26$4 = { class: "thin action" };
const _hoisted_27$4 = ["onClick"];
const _hoisted_28$4 = { class: "hidden" };
const _hoisted_29$4 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment$1, null, [
    createBaseVNode("table", _hoisted_1$k, [
      createBaseVNode("thead", null, [
        createBaseVNode("tr", null, [
          createBaseVNode("th", _hoisted_2$g, toDisplayString(_ctx.t("formie", "Email")), 1),
          createBaseVNode("th", _hoisted_3$c, toDisplayString(_ctx.t("formie", "Field")), 1),
          createBaseVNode("th", _hoisted_4$a, toDisplayString(_ctx.t("formie", "Condition")), 1),
          createBaseVNode("th", _hoisted_5$8, toDisplayString(_ctx.t("formie", "Value")), 1),
          _hoisted_6$6
        ])
      ]),
      createBaseVNode("tbody", _hoisted_7$5, [
        (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.settings.toRecipients, (row, index2) => {
          return openBlock(), createElementBlock("tr", {
            key: row.id
          }, [
            createBaseVNode("td", _hoisted_8$5, [
              withDirectives(createBaseVNode("textarea", {
                "onUpdate:modelValue": ($event) => row.email = $event,
                rows: "1",
                style: { "min-height": "36px" }
              }, null, 8, _hoisted_9$5), [
                [vModelText, row.email]
              ])
            ]),
            createBaseVNode("td", _hoisted_10$5, [
              createBaseVNode("div", _hoisted_11$5, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.field = $event,
                  onChange: ($event) => $options.changeDropdown(row)
                }, [
                  createBaseVNode("option", _hoisted_13$4, toDisplayString(_ctx.t("formie", "Select an option")), 1),
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.fieldOptions, (optgroup, i) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: i,
                      label: optgroup.label
                    }, [
                      (openBlock(true), createElementBlock(Fragment$1, null, renderList(optgroup.options, (option3, j2) => {
                        return openBlock(), createElementBlock("option", {
                          key: j2,
                          value: option3.value
                        }, toDisplayString(option3.label), 9, _hoisted_15$4);
                      }), 128))
                    ], 8, _hoisted_14$4);
                  }), 128))
                ], 40, _hoisted_12$4), [
                  [vModelSelect, row.field]
                ])
              ])
            ]),
            createBaseVNode("td", _hoisted_16$4, [
              createBaseVNode("div", _hoisted_17$4, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.condition = $event,
                  onChange: ($event) => $options.changeDropdown(row)
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.conditions, (condition, i) => {
                    return openBlock(), createElementBlock("option", {
                      key: i,
                      value: condition.value
                    }, toDisplayString(condition.label), 9, _hoisted_19$4);
                  }), 128))
                ], 40, _hoisted_18$4), [
                  [vModelSelect, row.condition]
                ])
              ])
            ]),
            row.valueType === "text" ? (openBlock(), createElementBlock("td", _hoisted_20$4, [
              withDirectives(createBaseVNode("textarea", {
                "onUpdate:modelValue": ($event) => row.value = $event,
                rows: "1",
                style: { "min-height": "36px" }
              }, null, 8, _hoisted_21$4), [
                [vModelText, row.value]
              ])
            ])) : createCommentVNode("v-if", true),
            row.valueType === "select" ? (openBlock(), createElementBlock("td", _hoisted_22$4, [
              createBaseVNode("div", _hoisted_23$4, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.value = $event
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(row.valueOptions, (option3, i) => {
                    return openBlock(), createElementBlock("option", {
                      key: i,
                      value: option3.value
                    }, toDisplayString(option3.label), 9, _hoisted_25$4);
                  }), 128))
                ], 8, _hoisted_24$4), [
                  [vModelSelect, row.value]
                ])
              ])
            ])) : createCommentVNode("v-if", true),
            createBaseVNode("td", _hoisted_26$4, [
              createBaseVNode("a", {
                class: "delete icon",
                title: "Delete",
                onClick: withModifiers(($event) => $options.removeRow(index2), ["prevent"])
              }, null, 8, _hoisted_27$4)
            ])
          ]);
        }), 128))
      ])
    ]),
    createBaseVNode("div", {
      class: "btn add icon",
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.addRow && $options.addRow(...args), ["prevent"]))
    }, toDisplayString(_ctx.t("formie", "Add rule")), 1),
    createBaseVNode("div", _hoisted_28$4, [
      _hoisted_29$4,
      withDirectives(createBaseVNode("textarea", {
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $props.context._value = $event),
        class: "input text fullwidth"
      }, null, 512), [
        [vModelText, $props.context._value]
      ])
    ])
  ], 64);
}
var NotificationRecipientsInput = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/NotificationRecipientsInput.vue"]]);
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  prepend: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size)
      return this;
    return new OrderedMap(map3.content.concat(this.subtract(map3).content));
  },
  append: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size)
      return this;
    return new OrderedMap(this.subtract(map3).content.concat(map3.content));
  },
  subtract: function(map3) {
    var result = this;
    map3 = OrderedMap.from(map3);
    for (var i = 0; i < map3.content.length; i += 2)
      result = result.remove(map3.content[i]);
    return result;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop2 in value)
      content.push(prop2, value[prop2]);
  return new OrderedMap(content);
};
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner2 = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner2 != null)
        return inner2;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner2 = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner2)
        return inner2;
    }
    posA -= size2;
    posB -= size2;
  }
}
class Fragment {
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end3 = pos + child.nodeSize;
      if (end3 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end3;
    }
  }
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  textBetween(from2, to, blockSeparator, leafText) {
    let text3 = "", separated = true;
    this.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        text3 += node.text.slice(Math.max(from2, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node.isLeaf) {
        if (leafText) {
          text3 += typeof leafText === "function" ? leafText(node) : leafText;
        } else if (node.type.spec.leafText) {
          text3 += node.type.spec.leafText(node);
        }
        separated = !blockSeparator;
      } else if (!separated && node.isBlock) {
        text3 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text3;
  }
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last2 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last2.isText && last2.sameMarkup(first2)) {
      content[content.length - 1] = last2.withText(last2.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size2 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end3 = pos + child.nodeSize;
        if (end3 > from2) {
          if (pos < from2 || end3 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size2 += child.nodeSize;
        }
        pos = end3;
      }
    return new Fragment(result, size2);
  }
  cutByIndex(from2, to) {
    if (from2 == to)
      return Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from2, to));
  }
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new Fragment(copy2, size2);
  }
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  forEach(f) {
    for (let i = 0, p2 = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p2, i);
      p2 += child.nodeSize;
    }
  }
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end3 = curPos + cur.nodeSize;
      if (end3 >= pos) {
        if (end3 == pos || round2 > 0)
          return retIndex(i + 1, end3);
        return retIndex(i, curPos);
      }
      curPos = end3;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size2 = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size2 += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array, size2);
  }
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset2) {
  found.index = index2;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p2 in a)
      if (!(p2 in b) || !compareDeep(a[p2], b[p2]))
        return false;
    for (let p2 in b)
      if (!(p2 in a))
        return false;
  }
  return true;
}
class Mark$1 {
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  addToSet(set3) {
    let copy2, placed = false;
    for (let i = 0; i < set3.length; i++) {
      let other = set3[i];
      if (this.eq(other))
        return set3;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set3.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set3;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set3.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set3.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  removeFromSet(set3) {
    for (let i = 0; i < set3.length; i++)
      if (this.eq(set3[i]))
        return set3.slice(0, i).concat(set3.slice(i + 1));
    return set3;
  }
  isInSet(set3) {
    for (let i = 0; i < set3.length; i++)
      if (this.eq(set3[i]))
        return true;
    return false;
  }
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark$1.none;
    if (marks instanceof Mark$1)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
}
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(pos, fragment2) {
    let content = insertInto(this.content, pos + this.openStart, fragment2);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  removeBetween(from2, to) {
    return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  static maxOpen(fragment2, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment2.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment2.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment2, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner2 = insertInto(child.content, dist - offset2 - 1, insert);
  return inner2 && content.replaceChild(index2, child.copy(inner2));
}
function replace$1($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner2 = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner2));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end3 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start2, end3, $to, depth));
  }
}
function checkJoin(main2, sub2) {
  if (!sub2.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub2.type.name + " onto " + main2.type.name);
}
function joinable$1($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target2) {
  let last2 = target2.length - 1;
  if (last2 >= 0 && child.isText && child.sameMarkup(target2[last2]))
    target2[last2] = child.withText(target2[last2].text + child.text);
  else
    target2.push(child);
}
function addRange($start, $end, depth, target2) {
  let node = ($end || $start).node(depth);
  let startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target2);
      startIndex2++;
    }
  }
  for (let i = startIndex2; i < endIndex2; i++)
    addNode(node.child(i), target2);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target2);
}
function close(node, content) {
  if (!node.type.validContent(content))
    throw new ReplaceError("Invalid content for node " + node.type.name);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
class ResolvedPos {
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  get parent() {
    return this.node(this.depth);
  }
  get doc() {
    return this.node(0);
  }
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main2 = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--)
      if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2))))
        return new NodeRange(this, other, d2);
    return null;
  }
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node = doc2; ; ) {
      let { index: index2, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index2, start2 + offset2);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset2 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  static resolveCached(doc2, pos) {
    for (let i = 0; i < resolveCache.length; i++) {
      let cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc2)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
}
let resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
class NodeRange {
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  get start() {
    return this.$from.before(this.depth + 1);
  }
  get end() {
    return this.$to.after(this.depth + 1);
  }
  get parent() {
    return this.$from.node(this.depth);
  }
  get startIndex() {
    return this.$from.index(this.depth);
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
class Node$2 {
  constructor(type, attrs, content, marks = Mark$1.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  get childCount() {
    return this.content.childCount;
  }
  child(index2) {
    return this.content.child(index2);
  }
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  forEach(f) {
    this.content.forEach(f);
  }
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  get firstChild() {
    return this.content.firstChild;
  }
  get lastChild() {
    return this.content.lastChild;
  }
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  }
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node$2(this.type, this.attrs, content, this.marks);
  }
  mark(marks) {
    return marks == this.marks ? this : new Node$2(this.type, this.attrs, this.content, marks);
  }
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  replace(from2, to, slice2) {
    return replace$1(this.resolve(from2), this.resolve(to), slice2);
  }
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  childAfter(pos) {
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset2 };
  }
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset2 };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset2 - node.nodeSize };
  }
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  get isBlock() {
    return this.type.isBlock;
  }
  get isTextblock() {
    return this.type.isTextblock;
  }
  get inlineContent() {
    return this.type.inlineContent;
  }
  get isInline() {
    return this.type.isInline;
  }
  get isText() {
    return this.type.isText;
  }
  get isLeaf() {
    return this.type.isLeaf;
  }
  get isAtom() {
    return this.type.isAtom;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  contentMatchAt(index2) {
    let match2 = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match2)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match2;
  }
  canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end3 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end3);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end3; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end3 = start2 && start2.matchFragment(this.content, to);
    return end3 ? end3.validEnd : false;
  }
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  check() {
    if (!this.type.validContent(this.content))
      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`);
    let copy2 = Mark$1.none;
    for (let i = 0; i < this.marks.length; i++)
      copy2 = this.marks[i].addToSet(copy2);
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks);
  }
}
Node$2.prototype.text = void 0;
class TextNode extends Node$2 {
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text3) {
    if (text3 == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text3, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match2 = dfa(nfa(expr));
    checkForDeadEnds(match2, stream);
    return match2;
  }
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  matchFragment(frag, start2 = 0, end3 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end3; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  get inlineContent() {
    return this.next.length && this.next[0].type.isInline;
  }
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j2 = 0; j2 < other.next.length; j2++)
        if (this.next[i].type == other.next[j2].type)
          return true;
    return false;
  }
  fillBefore(after, toEnd = false, startIndex2 = 0) {
    let seen2 = [this];
    function search2(match2, types) {
      let finished = match2.matchFragment(after, startIndex2);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match2.next.length; i++) {
        let { type, next } = match2.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen2.indexOf(next) == -1) {
          seen2.push(next);
          let found2 = search2(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search2(this, []);
  }
  findWrapping(target2) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target2)
        return this.wrapCache[i + 1];
    let computed2 = this.computeWrapping(target2);
    this.wrapCache.push(target2, computed2);
    return computed2;
  }
  computeWrapping(target2) {
    let seen2 = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match2 = current.match;
      if (match2.matchType(target2)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match2.next.length; i++) {
        let { type, next } = match2.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen2) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen2[type.name] = true;
        }
      }
    }
    return null;
  }
  get edgeCount() {
    return this.next.length;
  }
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  toString() {
    let seen2 = [];
    function scan(m) {
      seen2.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen2.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen2.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen2.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min3 = parseNum(stream), max3 = min3;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max3 = parseNum(stream);
    else
      max3 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min3, max: max3, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile2(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile2(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile2(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile2(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile2(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile2(expr2.expr, from2), loop);
      connect(compile2(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile2(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile2(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile2(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile2(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set3;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set3 = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set3)
            out.push([term, set3 = []]);
          if (set3.indexOf(node2) == -1)
            set3.push(node2);
        });
      });
    });
    let state2 = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state2.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state2;
  }
}
function checkForDeadEnds(match2, stream) {
  for (let i = 0, work = [match2]; i < work.length; i++) {
    let state2 = work[i], dead = !state2.validEnd, nodes = [];
    for (let j2 = 0; j2 < state2.next.length; j2++) {
      let { type, next } = state2.next[j2];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
class NodeType$1 {
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  get isInline() {
    return !this.isBlock;
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$2(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
  }
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    if (!this.validContent(content))
      throw new RangeError("Invalid content for node " + this.name);
    return new Node$2(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
  }
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$2(this, attrs, content.append(after), Mark$1.setFrom(marks));
  }
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  }
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType$1(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _2 in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
}
class Attribute {
  constructor(options2) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
    this.default = options2.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
  }
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, computeAttrs(this.attrs, attrs));
  }
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  removeFromSet(set3) {
    for (var i = 0; i < set3.length; i++)
      if (set3[i].type == this) {
        set3 = set3.slice(0, i).concat(set3.slice(i + 1));
        i--;
      }
    return set3;
  }
  isInSet(set3) {
    for (let i = 0; i < set3.length; i++)
      if (set3[i].type == this)
        return set3[i];
  }
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema {
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    this.spec = {
      nodes: OrderedMap.from(spec.nodes),
      marks: OrderedMap.from(spec.marks || {}),
      topNode: spec.topNode
    };
    this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop2 in this.nodes) {
      if (prop2 in this.marks)
        throw new RangeError(prop2 + " can not be both a node and a mark");
      let type = this.nodes[prop2], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop2 in this.marks) {
      let type = this.marks[prop2], excl2 = type.spec.excludes;
      type.excluded = excl2 == null ? [type] : excl2 == "" ? [] : gatherMarks(this, excl2.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  text(text3, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text3, Mark$1.setFrom(marks));
  }
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  nodeFromJSON(json) {
    return Node$2.fromJSON(this, json);
  }
  markFromJSON(json) {
    return Mark$1.fromJSON(this, json);
  }
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop2 in schema.marks) {
        let mark2 = schema.marks[prop2];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
class DOMParser {
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (rule.tag)
        this.tags.push(rule);
      else if (rule.style)
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  parse(dom2, options2 = {}) {
    let context = new ParseContext(this, options2, false);
    context.addAll(dom2, options2.from, options2.to);
    return context.finish();
  }
  parseSlice(dom2, options2 = {}) {
    let context = new ParseContext(this, options2, true);
    context.addAll(dom2, options2.from, options2.to);
    return Slice.maxOpen(context.finish());
  }
  matchTag(dom2, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches$1(dom2, rule.tag) && (rule.namespace === void 0 || dom2.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom2);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  matchStyle(prop2, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop2) != 0 || rule.context && !context.matchesContext(rule.context) || style2.length > prop2.length && (style2.charCodeAt(prop2.length) != 61 || style2.slice(prop2.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          rule.node = name;
        });
    }
    return result;
  }
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
  }
}
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type, attrs, marks, pendingMarks, solid, match2, options2) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options2;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.stashMarks = [];
    this.match = match2 || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last2 = this.content[this.content.length - 1], m;
      if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
        let text3 = last2;
        if (last2.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text3.withText(text3.text.slice(0, text3.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  popFromStashMark(mark) {
    for (let i = this.stashMarks.length - 1; i >= 0; i--)
      if (mark.eq(this.stashMarks[i]))
        return this.stashMarks.splice(i, 1)[0];
  }
  applyPending(nextType) {
    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      let mark = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options2, isOpen) {
    this.parser = parser;
    this.options = options2;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options2.topNode, topContext;
    let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options2.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  addDOM(dom2) {
    if (dom2.nodeType == 3) {
      this.addTextNode(dom2);
    } else if (dom2.nodeType == 1) {
      let style2 = dom2.getAttribute("style");
      let marks = style2 ? this.readStyles(parseStyles(style2)) : null, top2 = this.top;
      if (marks != null)
        for (let i = 0; i < marks.length; i++)
          this.addPendingMark(marks[i]);
      this.addElement(dom2);
      if (marks != null)
        for (let i = 0; i < marks.length; i++)
          this.removePendingMark(marks[i], top2);
    }
  }
  addTextNode(dom2) {
    let value = dom2.nodeValue;
    let top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom2) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom2.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom2);
    } else {
      this.findInside(dom2);
    }
  }
  addElement(dom2, matchAfter) {
    let name = dom2.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom2);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom2) || (ruleID = this.parser.matchTag(dom2, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom2);
      this.ignoreFallback(dom2);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom2 = rule.skip;
      let sync, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom2.firstChild) {
        this.leafFallback(dom2);
        return;
      }
      this.addAll(dom2);
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.addElementByRule(dom2, rule, rule.consuming === false ? ruleID : void 0);
    }
  }
  leafFallback(dom2) {
    if (dom2.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom2.ownerDocument.createTextNode("\n"));
  }
  ignoreFallback(dom2) {
    if (dom2.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  readStyles(styles2) {
    let marks = Mark$1.none;
    style:
      for (let i = 0; i < styles2.length; i += 2) {
        for (let after = void 0; ; ) {
          let rule = this.parser.matchStyle(styles2[i], styles2[i + 1], this, after);
          if (!rule)
            continue style;
          if (rule.ignore)
            return null;
          marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
          if (rule.consuming === false)
            after = rule;
          else
            break;
        }
      }
    return marks;
  }
  addElementByRule(dom2, rule, continueAfter) {
    let sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom2);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom2);
    } else if (continueAfter) {
      this.addElement(dom2, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom2);
      rule.getContent(dom2, this.parser.schema).forEach((node) => this.insertNode(node));
    } else {
      let contentDOM = dom2;
      if (typeof rule.contentElement == "string")
        contentDOM = dom2.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom2);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom2, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  addAll(parent, startIndex2, endIndex2) {
    let index2 = startIndex2 || 0;
    for (let dom2 = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end3 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom2 != end3; dom2 = dom2.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom2);
    }
    this.findAtPoint(parent, index2);
  }
  findPlace(node) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true;
  }
  insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block3 = this.textblockFromContext();
      if (block3)
        this.enterInner(block3);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      let top2 = this.top;
      top2.applyPending(node.type);
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let marks = top2.activeMarks;
      for (let i = 0; i < node.marks.length; i++)
        if (!top2.type || top2.type.allowsMarkType(node.marks[i].type))
          marks = node.marks[i].addToSet(marks);
      top2.content.push(node.mark(marks));
      return true;
    }
    return false;
  }
  enter(type, attrs, preserveWS) {
    let ok = this.findPlace(type.create(attrs));
    if (ok)
      this.enterInner(type, attrs, true, preserveWS);
    return ok;
  }
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type);
    let options2 = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options2 |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options2));
    this.open++;
  }
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--)
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j2 = content.length - 1; j2 >= 0; j2--)
        pos += content[j2].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option3 = this.options.context;
    let useRoot = !this.isOpen && (!option3 || option3.parent.type == this.nodes[0].type);
    let minDepth = -(option3 ? option3.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match2 = (i, depth) => {
      for (; i >= 0; i--) {
        let part2 = parts[i];
        if (part2 == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match2(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option3 && depth >= minDepth ? option3.node(depth - minDepth).type : null;
          if (!next || next.name != part2 && next.groups.indexOf(part2) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match2(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d2 = $context.depth; d2 >= 0; d2--) {
        let deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
}
function normalizeList(dom2) {
  for (let child = dom2.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches$1(dom2, selector) {
  return (dom2.matches || dom2.msMatchesSelector || dom2.webkitMatchesSelector || dom2.mozMatchesSelector).call(dom2, selector);
}
function parseStyles(style2) {
  let re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re2.exec(style2))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop2 in obj)
    copy2[prop2] = obj[prop2];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen2 = [], scan = (match2) => {
      seen2.push(match2);
      for (let i = 0; i < match2.edgeCount; i++) {
        let { type, next } = match2.edge(i);
        if (type == nodeType)
          return true;
        if (seen2.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set3) {
  for (let i = 0; i < set3.length; i++) {
    if (mark.eq(set3[i]))
      return set3[i];
  }
}
class DOMSerializer {
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  serializeFragment(fragment2, options2 = {}, target2) {
    if (!target2)
      target2 = doc$1(options2).createDocumentFragment();
    let top2 = target2, active = [];
    fragment2.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add3 = node.marks[rendered++];
          let markDOM = this.serializeMark(add3, node.isInline, options2);
          if (markDOM) {
            active.push([add3, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options2));
    });
    return target2;
  }
  serializeNodeInner(node, options2) {
    let { dom: dom2, contentDOM } = DOMSerializer.renderSpec(doc$1(options2), this.nodes[node.type.name](node));
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options2, contentDOM);
    }
    return dom2;
  }
  serializeNode(node, options2 = {}) {
    let dom2 = this.serializeNodeInner(node, options2);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options2);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom2);
        dom2 = wrap2.dom;
      }
    }
    return dom2;
  }
  serializeMark(mark, inline3, options2 = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && DOMSerializer.renderSpec(doc$1(options2), toDOM(mark, inline3));
  }
  static renderSpec(doc2, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc2.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    let contentDOM;
    let dom2 = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    let attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space2 = name.indexOf(" ");
          if (space2 > 0)
            dom2.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
          else
            dom2.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start2; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: dom2, contentDOM: dom2 };
      } else {
        let { dom: inner2, contentDOM: innerContent } = DOMSerializer.renderSpec(doc2, child, xmlNS);
        dom2.appendChild(inner2);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom: dom2, contentDOM };
  }
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$1(options2) {
  return options2.document || window.document;
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset2) {
  return index2 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex2], newSize = this.ranges[i + newIndex2], end3 = start2 + oldSize;
      if (pos <= end3) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end3 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end3) ? null : makeRecover(i / 3, pos - start2);
        let del2 = pos == start2 ? DEL_AFTER : pos == end3 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end3)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex2], end3 = start2 + oldSize;
      if (pos <= end3 && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex2] - oldSize;
    }
    return false;
  }
  forEach(f) {
    let oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex2], newSize = this.ranges[i + newIndex2];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  slice(from2 = 0, to = this.maps.length) {
    return new Mapping(this.maps, this.mirror, from2, to);
  }
  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  appendMap(map3, mirrors) {
    this.to = this.maps.push(map3);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map3 = this.maps[i], result = map3.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  getMap() {
    return StepMap.empty;
  }
  merge(other) {
    return null;
  }
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  static fail(message2) {
    return new StepResult(null, message2);
  }
  static fromReplace(doc2, from2, to, slice2) {
    try {
      return StepResult.ok(doc2.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment2, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment2.childCount; i++) {
    let child = fragment2.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class ReplaceStep extends Step {
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap2 = doc2.slice(this.gapFrom, this.gapTo);
    if (gap2.openStart || gap2.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap2.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap2 = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap2, this.from + this.insert, this.from + this.insert + gap2, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from2, to) {
  let $from = doc2.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end3 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end3;
          else
            removed.push(removing = new RemoveMarkStep(start2, end3, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end3;
      else
        added.push(adding = new AddMarkStep(start2, end3, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from2, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set3 = node.marks, found2;
      while (found2 = mark.isInSet(set3)) {
        (toRemove || (toRemove = [])).push(found2);
        set3 = found2.removeFromSet(set3);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end3 = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m = matched[j2];
          if (m.step == step - 1 && style2.eq(matched[j2].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end3;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end3, step });
        }
      }
    }
  });
  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match2 = parentType.contentMatch) {
  let node = tr.doc.nodeAt(pos);
  let delSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end3 = cur + child.nodeSize;
    let allowed = match2.matchType(child.type);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end3, Slice.empty));
    } else {
      match2 = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr.step(new RemoveMarkStep(cur, end3, child.marks[j2]));
    }
    cur = end3;
  }
  if (!match2.validEnd) {
    let fill = match2.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = delSteps.length - 1; i >= 0; i--)
    tr.step(delSteps[i]);
}
function canCut(node, start2, end3) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end3 == node.childCount || node.canReplace(0, end3));
}
function liftTarget(range2) {
  let parent = range2.parent;
  let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (let depth = range2.depth; ; --depth) {
    let node = range2.$from.node(depth);
    let index2 = range2.$from.index(depth), endIndex2 = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node.canReplace(index2, endIndex2, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex2))
      break;
  }
  return null;
}
function lift$2(tr, range2, target2) {
  let { $from, $to, depth } = range2;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end3 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d2 = depth, splitting = false; d2 > target2; d2--)
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d2).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d2 = depth, splitting = false; d2 > target2; d2--)
    if (splitting || $to.after(d2 + 1) < $to.end(d2)) {
      splitting = true;
      after = Fragment.from($to.node(d2).copy(after));
      openEnd++;
    } else {
      end3++;
    }
  tr.step(new ReplaceAroundStep(start2, end3, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range2, nodeType, attrs = null, innerRange = range2) {
  let around = findWrappingOutside(range2, nodeType);
  let inner2 = around && findWrappingInside(innerRange, nodeType);
  if (!inner2)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner2.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range2, type) {
  let { parent, startIndex: startIndex2, endIndex: endIndex2 } = range2;
  let around = parent.contentMatchAt(startIndex2).findWrapping(type);
  if (!around)
    return null;
  let outer2 = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex2, endIndex2, outer2) ? around : null;
}
function findWrappingInside(range2, type) {
  let { parent, startIndex: startIndex2, endIndex: endIndex2 } = range2;
  let inner2 = parent.child(startIndex2);
  let inside = type.contentMatch.findWrapping(inner2.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex2; innerMatch && i < endIndex2; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range2, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match2 = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match2 || !match2.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range2.start, end3 = range2.end;
  tr.step(new ReplaceAroundStep(start2, end3, start2, end3, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr, pos, type, attrs, marks) {
  let node = tr.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d2 = $pos.depth - 1, i = depth - 2; d2 > base2; d2--, i--) {
    let node = $pos.node(d2), index3 = $pos.index(d2);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let after = typesAfter && typesAfter[i] || node;
    if (after != node)
      rest = rest.replaceChild(0, after.type.create(after.attrs));
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d2 = $pos.depth, e = $pos.depth - depth, i = depth - 1; d2 > e; d2--, i--) {
    before = Fragment.from($pos.node(d2).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d2).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function joinable(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function join(tr, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr.step(step);
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index2 = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d2 + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index2 = $pos.indexAfter(d2);
      if ($pos.node(d2).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d2 + 1);
      if (index2 < $pos.node(d2).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice2) {
  let $pos = doc2.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d2 = $pos.depth; d2 >= 0; d2--) {
      let bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc2.resolve(from2), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  findFittable() {
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment2, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment2 = parent.content;
        } else {
          fragment2 = this.unplaced.content;
        }
        let first2 = fragment2.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match: match2 } = this.frontier[frontierDepth], wrap2, inject2 = null;
          if (pass == 1 && (first2 ? match2.matchType(first2.type) || (inject2 = match2.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject: inject2 };
          else if (pass == 2 && first2 && (wrap2 = match2.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match2.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner2 = contentAt(content, openStart);
    if (!inner2.childCount || inner2.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner2.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner2 = contentAt(content, openStart);
    if (inner2.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner2.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  placeNodes({ sliceDepth, frontierDepth, parent, inject: inject2, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment2 = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add3 = [];
    let { match: match2, type } = this.frontier[frontierDepth];
    if (inject2) {
      for (let i = 0; i < inject2.childCount; i++)
        add3.push(inject2.child(i));
      match2 = match2.matchFragment(inject2);
    }
    let openEndCount = fragment2.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment2.childCount) {
      let next = fragment2.child(taken), matches3 = match2.matchType(next.type);
      if (!matches3)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match2 = matches3;
        add3.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment2.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment2.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add3));
    this.frontier[frontierDepth].match = match2;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment2; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match: match2, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match2, dropInner);
        if (!fit)
          continue;
        for (let d2 = i - 1; d2 >= 0; d2--) {
          let { match: match3, type: type2 } = this.frontier[d2];
          let matches3 = contentAfterFits($to, d2, type2, match3, true);
          if (!matches3 || matches3.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d2 = close2.depth + 1; d2 <= $to.depth; d2++) {
      let node = $to.node(d2), add3 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d2));
      this.openFrontierNode(node.type, node.attrs, add3);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add3 = open.match.fillBefore(Fragment.empty, true);
    if (add3.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add3);
  }
}
function dropFromFragment(fragment2, depth, count2) {
  if (depth == 0)
    return fragment2.cutByIndex(count2, fragment2.childCount);
  return fragment2.replaceChild(0, fragment2.firstChild.copy(dropFromFragment(fragment2.firstChild.content, depth - 1, count2)));
}
function addToFragment(fragment2, depth, content) {
  if (depth == 0)
    return fragment2.append(content);
  return fragment2.replaceChild(fragment2.childCount - 1, fragment2.lastChild.copy(addToFragment(fragment2.lastChild.content, depth - 1, content)));
}
function contentAt(fragment2, depth) {
  for (let i = 0; i < depth; i++)
    fragment2 = fragment2.firstChild.content;
  return fragment2;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match2, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match2.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type, node.content, index2) ? fit : null;
}
function invalidMarks(type, fragment2, start2) {
  for (let i = start2; i < fragment2.childCount; i++)
    if (!type.allowsMarks(fragment2.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from2, to, slice2) {
  if (!slice2.size)
    return tr.deleteRange(from2, to);
  let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    let spec = $from.node(d2).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d2) > -1)
      preferredTarget = d2;
    else if ($from.before(d2) == pos)
      targetDepths.splice(1, 0, -d2);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d2 = preferredDepth - 1; d2 >= 0; d2--) {
    let type = leftNodes[d2].type, def2 = definesContent(type);
    if (def2 && $from.node(preferredTargetIndex).type != type)
      preferredDepth = d2;
    else if (def2 || !type.isTextblock)
      break;
  }
  for (let j2 = slice2.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from2, to, slice2);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment2, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment2.firstChild;
    fragment2 = fragment2.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match2 = parent.contentMatchAt(0);
    let start2 = match2.fillBefore(fragment2).append(fragment2);
    fragment2 = start2.append(match2.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment2;
}
function replaceRangeWith(tr, from2, to, node) {
  if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$1(tr, from2, to) {
  let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last2 = i == covered.length - 1;
    if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from2 - $from.start(d2) == $from.depth - d2 && to > $from.end(d2) && $to.end(d2) - to != $to.depth - d2)
      return tr.delete($from.before(d2), to);
  }
  tr.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d2 = minDepth; d2 >= 0; d2--) {
    let start2 = $from.start(d2);
    if (start2 < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating)
      break;
    if (start2 == $to.start(d2) || d2 == $from.depth && d2 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d2 && $to.start(d2 - 1) == start2 - 1)
      result.push(d2);
  }
  return result;
}
let TransformError = class extends Error {
};
TransformError = function TransformError2(message2) {
  let err = Error.call(this, message2);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  get docChanged() {
    return this.steps.length > 0;
  }
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  deleteRange(from2, to) {
    deleteRange$1(this, from2, to);
    return this;
  }
  lift(range2, target2) {
    lift$2(this, range2, target2);
    return this;
  }
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  wrap(range2, wrappers) {
    wrap(this, range2, wrappers);
    return this;
  }
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType$1(this, from2, to, type, attrs);
    return this;
  }
  setNodeMarkup(pos, type, attrs = null, marks = []) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  clearIncompatible(pos, parentType, match2) {
    clearIncompatible(this, pos, parentType, match2);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from2, to);
      } else {
        tr.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd$1(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  static findFrom($pos, dir, textOnly = false) {
    let inner2 = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner2)
      return inner2;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  static create(doc2, from2) {
    return new NodeSelection(doc2.resolve(from2));
  }
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index2, dir, text3 = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner2 = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text3);
      if (inner2)
        return inner2;
    } else if (!text3 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  let last2 = tr.steps.length - 1;
  if (last2 < startLen)
    return;
  let step = tr.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map3 = tr.mapping.maps[last2], end3;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end3 == null)
      end3 = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end3), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  constructor(state2) {
    super(state2.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state2.selection;
    this.storedMarks = state2.storedMarks;
  }
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  ensureMarks(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  setTime(time2) {
    this.time = time2;
    return this;
  }
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node);
    return this;
  }
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  insertText(text3, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text3)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text3), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text3)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text3, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  get isGeneric() {
    for (let _2 in this.meta)
      return false;
    return true;
  }
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config2) {
      return config2.doc || config2.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config2, instance) {
      return config2.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config2) {
      return config2.storedMarks || null;
    },
    apply(tr, _marks, _old, state2) {
      return state2.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins2) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins2)
      plugins2.forEach((plugin2) => {
        if (this.pluginsByKey[plugin2.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin2.key + ")");
        this.plugins.push(plugin2);
        this.pluginsByKey[plugin2.key] = plugin2;
        if (plugin2.spec.state)
          this.fields.push(new FieldDesc(plugin2.key, plugin2.spec.state, plugin2));
      });
  }
}
class EditorState {
  constructor(config2) {
    this.config = config2;
  }
  get schema() {
    return this.config.schema;
  }
  get plugins() {
    return this.config.plugins;
  }
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  filterTransaction(tr, ignore2 = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore2) {
        let plugin2 = this.config.plugins[i];
        if (plugin2.spec.filterTransaction && !plugin2.spec.filterTransaction.call(plugin2, tr, this))
          return false;
      }
    return true;
  }
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen2 = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin2 = this.config.plugins[i];
        if (plugin2.spec.appendTransaction) {
          let n = seen2 ? seen2[i].n : 0, oldState = seen2 ? seen2[i].state : this;
          let tr = n < trs.length && plugin2.spec.appendTransaction.call(plugin2, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen2) {
              seen2 = [];
              for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                seen2.push(j2 < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen2)
            seen2[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  get tr() {
    return new Transaction(this);
  }
  static create(config2) {
    let $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config2, instance);
    return instance;
  }
  reconfigure(config2) {
    let $config = new Configuration(this.schema, config2.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config2, instance);
    }
    return instance;
  }
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop2 in pluginFields) {
        if (prop2 == "doc" || prop2 == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin2 = pluginFields[prop2], state2 = plugin2.spec.state;
        if (state2 && state2.toJSON)
          result[prop2] = state2.toJSON.call(plugin2, this[plugin2.key]);
      }
    return result;
  }
  static fromJSON(config2, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config2.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config2.schema, config2.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$2.fromJSON(config2.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop2 in pluginFields) {
            let plugin2 = pluginFields[prop2], state2 = plugin2.spec.state;
            if (plugin2.key == field.name && state2 && state2.fromJSON && Object.prototype.hasOwnProperty.call(json, prop2)) {
              instance[field.name] = state2.fromJSON.call(plugin2, config2, json[prop2], instance);
              return;
            }
          }
        instance[field.name] = field.init(config2, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target2) {
  for (let prop2 in obj) {
    let val = obj[prop2];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop2 == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target2[prop2] = val;
  }
  return target2;
}
class Plugin {
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  getState(state2) {
    return state2[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  constructor(name = "key") {
    this.key = createKey(name);
  }
  get(state2) {
    return state2.config.pluginsByKey[this.key];
  }
  getState(state2) {
    return state2[this.key];
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko$1 = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko$1 && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome$1 = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari$1 = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari$1 && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
const domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from2, to) {
  let range2 = reusedRange || (reusedRange = document.createRange());
  range2.setEnd(node, to == null ? node.nodeValue.length : to);
  range2.setStart(node, from2 || 0);
  return range2;
};
const isEquivalentPosition = function(node, off2, targetNode, targetOff) {
  return targetNode && (scanFor(node, off2, targetNode, targetOff, -1) || scanFor(node, off2, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off2 = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off2 = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom2) {
  let desc;
  for (let cur = dom2; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom2 || desc.contentDOM == dom2);
}
const selectionCollapsed = function(domSel) {
  let collapsed = domSel.isCollapsed;
  if (collapsed && chrome$1 && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    collapsed = false;
  return collapsed;
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect2 = node.getBoundingClientRect();
  let scaleX = rect2.width / node.offsetWidth || 1;
  let scaleY = rect2.height / node.offsetHeight || 1;
  return {
    left: rect2.left,
    right: rect2.left + node.clientWidth * scaleX,
    top: rect2.top,
    bottom: rect2.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect2, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect2.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect2.top + getSide(scrollMargin, "top"));
    else if (rect2.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect2.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect2.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect2.left + getSide(scrollMargin, "left"));
    else if (rect2.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect2.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect2 = { left: rect2.left - dX, top: rect2.top - dY, right: rect2.right - dX, bottom: rect2.bottom - dY };
      }
    }
    if (atTop)
      break;
  }
}
function storeScrollPos(view) {
  let rect2 = view.dom.getBoundingClientRect(), startY = Math.max(0, rect2.top);
  let refDOM, refTop;
  for (let x = (rect2.left + rect2.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect2.bottom); y += 5) {
    let dom2 = view.root.elementFromPoint(x, y);
    if (!dom2 || dom2 == view.dom || !view.dom.contains(dom2))
      continue;
    let localRect = dom2.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom2;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom2) {
  let stack2 = [], doc2 = dom2.ownerDocument;
  for (let cur = dom2; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom2 == doc2)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom: dom2, top: top2, left: left2 } = stack2[i];
    if (dom2.scrollTop != top2 + dTop)
      dom2.scrollTop = top2 + dTop;
    if (dom2.scrollLeft != left2)
      dom2.scrollLeft = left2;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom2) {
  if (dom2.setActive)
    return dom2.setActive();
  if (preventScrollSupported)
    return dom2.focus(preventScrollSupported);
  let stored = scrollStack(dom2);
  dom2.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest2, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect2 = rects[i];
      if (rect2.top <= rowBot && rect2.bottom >= rowTop) {
        rowBot = Math.max(rect2.bottom, rowBot);
        rowTop = Math.min(rect2.top, rowTop);
        let dx = rect2.left > coords.left ? rect2.left - coords.left : rect2.right < coords.left ? coords.left - rect2.right : 0;
        if (dx < dxClosest) {
          closest2 = child;
          dxClosest = dx;
          coordsClosest = dx && closest2.nodeType == 3 ? {
            left: rect2.right < coords.left ? rect2.right : rect2.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect2.left + rect2.right) / 2 ? 1 : 0);
          continue;
        }
      }
      if (!closest2 && (coords.left >= rect2.right && coords.top >= rect2.top || coords.left >= rect2.left && coords.top >= rect2.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (closest2 && closest2.nodeType == 3)
    return findOffsetInText(closest2, coordsClosest);
  if (!closest2 || dxClosest && closest2.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest2, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range2 = document.createRange();
  for (let i = 0; i < len; i++) {
    range2.setEnd(node, i + 1);
    range2.setStart(node, i);
    let rect2 = singleRect(range2, 1);
    if (rect2.top == rect2.bottom)
      continue;
    if (inRect(coords, rect2))
      return { node, offset: i + (coords.left >= (rect2.left + rect2.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect2) {
  return coords.left >= rect2.left - 1 && coords.left <= rect2.right + 1 && coords.top >= rect2.top - 1 && coords.top <= rect2.bottom + 1;
}
function targetKludge(dom2, coords) {
  let parent = dom2.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom2.getBoundingClientRect().left)
    return parent;
  return dom2;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect2 = node.getBoundingClientRect();
    bias = rect2.left != rect2.right && coords.left > (rect2.left + rect2.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outside = -1;
  for (let cur = node; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.node.isBlock && desc.parent) {
      let rect2 = desc.dom.getBoundingClientRect();
      if (rect2.left > coords.left || rect2.top > coords.top)
        outside = desc.posBefore;
      else if (rect2.right < coords.left || rect2.bottom < coords.top)
        outside = desc.posAfter;
      else
        break;
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node, offset2, 1);
}
function elementFromPoint(element, coords, box2) {
  let len = element.childNodes.length;
  if (len && box2.top < box2.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box2.top) / (box2.bottom - box2.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j2 = 0; j2 < rects.length; j2++) {
          let rect2 = rects[j2];
          if (inRect(coords, rect2))
            return elementFromPoint(child, coords, rect2);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset2 = 0;
  if (doc2.caretPositionFromPoint) {
    try {
      let pos2 = doc2.caretPositionFromPoint(coords.left, coords.top);
      if (pos2)
        ({ offsetNode: node, offset: offset2 } = pos2);
    } catch (_2) {
    }
  }
  if (!node && doc2.caretRangeFromPoint) {
    let range2 = doc2.caretRangeFromPoint(coords.left, coords.top);
    if (range2)
      ({ startContainer: node, startOffset: offset2 } = range2);
  }
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top + 1);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box2 = view.dom.getBoundingClientRect();
    if (!inRect(coords, box2))
      return null;
    elt = elementFromPoint(view.dom, coords, box2);
    if (!elt)
      return null;
  }
  if (safari$1) {
    for (let p2 = elt; node && p2; p2 = parentNode(p2))
      if (p2.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko$1 && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box2;
        if (next.nodeName == "IMG" && (box2 = next.getBoundingClientRect()).right <= coords.left && box2.bottom > coords.top)
          offset2++;
      }
    }
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(target2, bias) {
  let rects = target2.getClientRects();
  return !rects.length ? target2.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko$1;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect2 = singleRect(textRange(node, offset2, offset2), side);
      if (gecko$1 && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect2.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect2.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect2;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target2 = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target2)
      return flattenV(singleRect(target2, 1), false);
  }
  if (offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target2 = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target2)
      return flattenV(singleRect(target2, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect2, left2) {
  if (rect2.width == 0)
    return rect2;
  let x = left2 ? rect2.left : rect2.right;
  return { top: rect2.top, bottom: rect2.bottom, left: x, right: x };
}
function flattenH(rect2, top2) {
  if (rect2.height == 0)
    return rect2;
  let y = top2 ? rect2.top : rect2.bottom;
  return { top: y, bottom: y, left: rect2.left, right: rect2.right };
}
function withFlushedState(view, state2, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state2)
    view.updateState(state2);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state2)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state2, dir) {
  let sel = state2.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state2, () => {
    let { node: dom2 } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom2, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom2 = nearest.dom;
        break;
      }
      dom2 = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom2.firstChild; child; child = child.nextSibling) {
      let boxes2;
      if (child.nodeType == 1)
        boxes2 = child.getClientRects();
      else if (child.nodeType == 3)
        boxes2 = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes2.length; i++) {
        let box2 = boxes2[i];
        if (box2.bottom > box2.top + 1 && (dir == "up" ? coords.top - box2.top > (box2.bottom - coords.top) * 2 : box2.bottom - coords.bottom > (coords.bottom - box2.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state2, dir) {
  let { $head } = state2.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state2, () => {
    let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state2, dir) {
  if (cachedState == state2 && cachedDir == dir)
    return cachedResult;
  cachedState = state2;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state2, dir) : endOfTextblockHorizontal(view, state2, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom2, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom2;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom2.pmViewDesc = this;
  }
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  parseRule() {
    return null;
  }
  stopEvent(event) {
    return false;
  }
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom2, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom2.nodeType == 1 ? dom2 : dom2.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom2 == this.contentDOM) {
          domBefore = dom2.childNodes[offset2 - 1];
        } else {
          while (dom2.parentNode != this.contentDOM)
            dom2 = dom2.parentNode;
          domBefore = dom2.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom2 == this.contentDOM) {
          domAfter = dom2.childNodes[offset2];
        } else {
          while (dom2.parentNode != this.contentDOM)
            dom2 = dom2.parentNode;
          domAfter = dom2.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom2 == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom2.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search2 = dom2; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = false;
            break;
          }
          if (search2.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom2.childNodes.length)
        for (let search2 = dom2; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (search2.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom2, onlyNodes = false) {
    for (let first2 = true, cur = dom2; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom2.nodeType == 1 ? dom2 : dom2.parentNode) : nodeDOM == dom2))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom2) {
    let desc = dom2.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom2, offset2, bias) {
    for (let scan = dom2; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom2, offset2, bias);
    }
    return -1;
  }
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end3 = offset2 + child.size;
      if (offset2 == pos && end3 != offset2) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end3)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end3;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end3 = curPos + child.size;
      if (end3 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end3;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end3 = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end3) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end3 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j2 = i; j2 > 0; j2--) {
          let prev = this.children[j2 - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end3 > to || i == this.children.length - 1)) {
        to = end3;
        for (let j2 = i + 1; j2 < this.children.length; j2++) {
          let next = this.children[j2];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end3;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  setSelection(anchor, head, root2, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end3 = offset2 + child.size;
      if (from2 > offset2 && to < end3)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root2, force);
      offset2 = end3;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root2.getSelection();
    let brKludge = false;
    if ((gecko$1 || safari$1) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko$1 && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari$1) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (err) {
        if (!(err instanceof DOMException))
          throw err;
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range2 = document.createRange();
      range2.setEnd(headDOM.node, headDOM.offset);
      range2.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range2);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end3 = offset2 + child.size;
      if (offset2 == end3 ? from2 <= end3 && to >= offset2 : from2 < end3 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end3 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end3 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end3;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom2 = widget.type.toDOM;
    if (typeof dom2 == "function")
      dom2 = dom2(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom2.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom2);
        dom2 = wrap2;
      }
      dom2.contentEditable = "false";
      dom2.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom2, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop2 = this.widget.spec.stopEvent;
    return stop2 ? stop2(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom2, textDOM, text3) {
    super(parent, [], dom2, null);
    this.textDOM = textDOM;
    this.text = text3;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom2, offset2) {
    if (dom2 != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom2, contentDOM) {
    super(parent, [], dom2, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline3, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline3);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline3));
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom2, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom2, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
    if (contentDOM)
      this.updateChildren(view, pos);
  }
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom2 = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom2)
        dom2 = document.createTextNode(node.text);
      else if (dom2.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom2) {
      ({ dom: dom2, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
    }
    if (!contentDOM && !node.isText && dom2.nodeName != "BR") {
      if (!dom2.hasAttribute("contenteditable"))
        dom2.contentEditable = "false";
      if (node.type.spec.draggable)
        dom2.draggable = true;
    }
    let nodeDOM = dom2;
    dom2 = applyOuterDeco(dom2, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom2, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom2, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom2, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  updateChildren(view, pos) {
    let inline3 = this.node.inlineContent, off2 = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline3, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline3, view);
      updater.placeWidget(widget, view, off2);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline3, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off2);
      }
      off2 += child.nodeSize;
    });
    updater.syncToMarks([], inline3, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let sel = view.domSelection();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text3 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text3, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text: text3 }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text3);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text3.length, view, desc);
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom2, view) {
  applyOuterDeco(dom2, outerDeco, doc2);
  return new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom2, dom2, dom2, view, 0);
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom2, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom2, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom2, offset2, bias) {
    if (dom2 == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom2, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom2 = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom2, dom2, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom2, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom2, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : super.setSelection(anchor, head, root2, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom2 = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom2) {
        dom2 = rm(dom2);
        written = true;
      }
      dom2 = dom2.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom2);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom2 ? dom2.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom2 = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom2) {
    dom2 = rm(dom2);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom2, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom2.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom2.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom2.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom2.classList.add(curList[i]);
    if (dom2.classList.length == 0)
      dom2.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop2 = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop2.exec(prev.style))
        dom2.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom2.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom2, deco, node) {
  return patchOuterDeco(dom2, dom2, noDeco, computeOuterDeco(deco, node, dom2.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom2) {
  let next = dom2.nextSibling;
  dom2.parentNode.removeChild(dom2);
  return next;
}
class ViewTreeUpdater {
  constructor(top2, lock) {
    this.lock = lock;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  destroyBetween(start2, end3) {
    if (start2 == end3)
      return;
    for (let i = start2; i < end3; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end3 - start2);
    this.changed = true;
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  syncToMarks(marks, inline3, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        if (this.top.children[i].matchesMark(marks[depth])) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline3, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index = index2 + 1;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  updateNextNode(node, outerDeco, innerDeco, view, index2) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom;
        let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  addNode(node, outerDeco, innerDeco, view, pos) {
    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  addTextblockHacks() {
    let lastChild2 = this.top.children[this.index - 1], parent = this.top;
    while (lastChild2 instanceof MarkViewDesc) {
      parent = lastChild2;
      lastChild2 = parent.children[parent.children.length - 1];
    }
    if (!lastChild2 || !(lastChild2 instanceof TextViewDesc) || /\n$/.test(lastChild2.node.text)) {
      if ((safari$1 || chrome$1) && lastChild2 && lastChild2.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom2 = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom2.className = "ProseMirror-separator";
        dom2.alt = "";
      }
      if (nodeName == "BR")
        dom2.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom2, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches3 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches3.push(desc);
    }
  return { index: fI, matched, matches: matches3.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode2) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode2(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let widget = locals[decoIndex++], widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset2)
        (widgets || (widgets = [widget])).push(locals[decoIndex++]);
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end3 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end3;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end3) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end3 = cutAt;
        index2 = -1;
      }
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d2) => !d2.inline) : active.slice();
    onNode2(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end3;
  }
}
function iosHacks(dom2) {
  if (dom2.nodeName == "UL" || dom2.nodeName == "OL") {
    let oldCSS = dom2.style.cssText;
    dom2.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom2).listStyle;
    dom2.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
        return node.childNodes[offset2];
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      node = node.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text3, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      let found2 = childStart < to ? str.lastIndexOf(text3, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text3.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text3.length - childStart && str.slice(to - childStart, to - childStart + text3.length) == text3)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off2 = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off2, end3 = off2 += child.size;
    if (start2 >= to || end3 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end3 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome$1) {
    let domSel = view.domSelection(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari$1 || chrome$1 && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari$1 && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari$1 && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelection();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range2 = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range2.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range2.setEnd(node, 0);
  range2.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range2);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom)
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelection();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state2, dir) {
  let { $anchor, $head } = state2.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state2.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom2) {
  let desc = dom2.pmViewDesc;
  return desc && desc.size == 0 && (dom2.nextSibling || dom2.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  let sel = view.domSelection();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko$1 && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2]))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, sel, node, offset2);
  else if (moveNode)
    setSelFocus(view, sel, moveNode, moveOffset);
}
function skipIgnoredNodesRight(view) {
  let sel = view.domSelection();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, sel, moveNode, moveOffset);
}
function isBlockNode(dom2) {
  let desc = dom2.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node, offset2) {
  if (selectionCollapsed(sel)) {
    let range2 = document.createRange();
    range2.setEnd(node, offset2);
    range2.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range2);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state: state2 } = view;
  setTimeout(() => {
    if (view.state == state2)
      selectionToDOM(view);
  }, 50);
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state2) {
  view.domObserver.stop();
  node.contentEditable = state2;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari$1 || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelection();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || mac$2 && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code2 == 46 || mac$2 && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac$2 && code2 == 66 && mods == "c") {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 39 || mac$2 && code2 == 70 && mods == "c") {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code2 == 38 || mac$2 && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 40 || mac$2 && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (mac$2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper2 = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper2.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper2);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text3 = view.someProp("clipboardTextSerializer", (f) => f(slice2)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text: text3 };
}
function parseFromClipboard(view, text3, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom2, slice2;
  if (!html && !text3)
    return null;
  let asText = text3 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text3 = f(text3, inCode || plainText);
    });
    if (inCode)
      return text3 ? new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text3, $context, plainText));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom2 = document.createElement("div");
      text3.split(/(?:\r\n?|\n)+/).forEach((block3) => {
        let p2 = dom2.appendChild(document.createElement("p"));
        if (block3)
          p2.appendChild(serializer.serializeNode(schema.text(block3, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html);
    });
    dom2 = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom2);
  }
  let contextNode = dom2 && dom2.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0 && dom2.firstChild; i--)
      dom2 = dom2.firstChild;
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom2, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom3) {
        if (dom3.nodeName == "BR" && !dom3.nextSibling && dom3.parentNode && !inlineParents.test(dom3.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment2, $context) {
  if (fragment2.childCount < 2)
    return fragment2;
  for (let d2 = $context.depth; d2 >= 0; d2--) {
    let parent = $context.node(d2);
    let match2 = parent.contentMatchAt($context.index(d2));
    let lastWrap, result = [];
    fragment2.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match2.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match2 = match2.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment2;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner2 = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner2)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner2));
    let match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment2 = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment2.append(fill));
}
function closeRange(fragment2, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment2.firstChild : fragment2.lastChild, inner2 = node.content;
  if (depth < to - 1)
    inner2 = closeRange(inner2, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner2 = side < 0 ? node.contentMatchAt(0).fillBefore(inner2, fragment2.childCount > 1 || openEnd <= depth).append(inner2) : inner2.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment2.replaceChild(side < 0 ? 0 : fragment2.childCount - 1, node.copy(inner2));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom2) {
  let nodes = dom2.querySelectorAll(chrome$1 ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom2.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
let editHandlers = {};
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    });
  }
  if (safari$1)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent$1(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome$1 && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text3 = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text3)))
      view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target2 = flushed ? null : event.target;
    const targetDesc = target2 ? view.docView.nearestDesc(target2, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko$1 && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || safari$1 && this.mightDrag && !this.mightDrag.node.isAtom || chrome$1 && !(this.view.state.selection instanceof TextSelection) && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
}
handlers.touchdown = (view) => {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari$1 && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state: state2 } = view, $pos = state2.selection.$from;
    if (state2.selection.empty && (state2.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko$1 && state2.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelection();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom2) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom2);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range2 = document.createRange();
  range2.selectNodeContents(dom2);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range2);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom: dom2, text: text3 } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom2.innerHTML);
    data.setData("text/plain", text3);
  } else {
    captureCopy(view, dom2);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target2 = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target2.contentEditable = "true";
  target2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target2.focus();
  setTimeout(() => {
    view.focus();
    if (target2.parentNode)
      target2.parentNode.removeChild(target2);
    if (plainText)
      doPaste(view, target2.value, null, event);
    else
      doPaste(view, target2.textContent, target2.innerHTML, event);
  }, 50);
}
function doPaste(view, text3, html, event) {
  let slice2 = parseFromClipboard(view, text3, html, view.input.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice2, move) {
    this.slice = slice2;
    this.move = move;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
  }
  let slice2 = view.state.selection.content(), { dom: dom2, text: text3 } = serializeForClipboard(view, slice2);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom2.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text3);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier]);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_2, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse)
    return;
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2);
    });
  } else {
    slice2 = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move)
    tr.deleteSelection();
  let pos = tr.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode2)
    tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice2);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end3 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end3 = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end3)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelection()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome$1 && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop2 in editHandlers)
  handlers[prop2] = editHandlers[prop2];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p2 in a)
    if (a[p2] !== b[p2])
      return false;
  for (let p2 in b)
    if (!(p2 in a))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_2, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  copy(from2, to) {
    return new Decoration(from2, to, this.type);
  }
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  static inline(from2, to, attrs, spec) {
    return new Decoration(from2, to, new InlineType(attrs, spec));
  }
  static node(from2, to, attrs, spec) {
    return new Decoration(from2, to, new NodeType(attrs, spec));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof InlineType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  find(start2, end3, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end3 == null ? 1e9 : end3, result, 0, predicate);
    return result;
  }
  findInner(start2, end3, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end3 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end3 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end3 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  map(mapping, doc2, options2) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options2 || noSpec);
  }
  mapInner(mapping, node, offset2, oldOffset, options2) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options2.onRemove)
        options2.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options2);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j2 = 0, span; j2 < decorations.length; j2++)
        if (span = decorations[j2]) {
          if (span.from > from2 && span.to < to) {
            decorations[j2] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j2 = 0; j2 < local.length; j2++)
            if (local[j2].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j2--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end3 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end3 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end3, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j2 = 0; j2 < locals.length; j2++)
          result.push(locals[j2]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members);
    }
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options2) {
  let children = oldChildren.slice();
  let shift2 = (oldStart, oldEnd, newStart, newEnd) => {
    for (let i = 0; i < children.length; i += 3) {
      let end3 = children[i + 1], dSize;
      if (end3 < 0 || oldStart > end3 + oldOffset)
        continue;
      let start2 = children[i] + oldOffset;
      if (oldEnd >= start2) {
        children[i + 1] = oldStart <= start2 ? -2 : -1;
      } else if (newStart >= offset2 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };
  for (let i = 0; i < mapping.maps.length; i++)
    mapping.maps[i].forEach(shift2);
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options2);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options2);
    let built = buildTree(decorations, node, 0, options2);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j2 = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j2 < children.length && children[j2] < from2)
        j2 += 3;
      children.splice(j2, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options2) {
  function gather(set3, oldOffset2) {
    for (let i = 0; i < set3.local.length; i++) {
      let mapped = set3.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options2.onRemove)
        options2.onRemove(set3.local[i].spec);
    }
    for (let i = 0; i < set3.children.length; i += 3)
      gather(set3.children[i + 2], set3.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end3 = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end3) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset2, options2) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options2);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options2.onRemove)
        options2.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j2 = i + 1; j2 < working.length; j2++) {
        let next = working[j2];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j2] = next.copy(next.from, span.to);
            insertAhead(working, j2 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j2, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations2) => {
      for (let i = 0; i < mutations2.length; i++)
        this.queue.push(mutations2[i]);
      if (ie$1 && ie_version <= 11 && mutations2.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer)
      this.observer.observe(this.view.dom, observeOptions);
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelection();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelection());
  }
  ignoreSelectionChange(sel) {
    if (sel.rangeCount == 0)
      return true;
    let container = sel.getRangeAt(0).commonAncestorContainer;
    let desc = this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  flush() {
    if (!this.view.docView || this.flushingSoon > -1)
      return;
    let mutations2 = this.observer ? this.observer.takeRecords() : [];
    if (this.queue.length) {
      mutations2 = this.queue.concat(mutations2);
      this.queue.length = 0;
    }
    let sel = this.view.domSelection();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(this.view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (this.view.editable) {
      for (let i = 0; i < mutations2.length; i++) {
        let result = this.registerMutation(mutations2[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko$1 && added.length > 1) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    if (from2 > -1 || newSel) {
      if (from2 > -1) {
        this.view.docView.markDirty(from2, to);
        checkCSS(this.view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (this.view.docView && this.view.docView.dirty)
        this.view.updateState(this.view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(this.view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++)
        added.push(mut.addedNodes[i]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = false;
function checkCSS(view) {
  if (cssChecked)
    return;
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal")
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelection();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome$1 && view.input.lastKeyCode === 8) {
    for (let off2 = toOffset; off2 > fromOffset; off2--) {
      let node = parent.childNodes[off2 - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom2) {
  let desc = dom2.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom2.nodeName == "BR" && dom2.parentNode) {
    if (safari$1 && /^(ul|ol)$/i.test(dom2.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom2.parentNode.lastChild == dom2 || safari$1 && /^(tr|table)$/i.test(dom2.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom2.nodeName == "IMG" && dom2.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse2 = parseBetween(view, from2, to);
  if (chrome$1 && view.cursorWrapper && parse2.sel && parse2.sel.anchor == view.cursorWrapper.deco.from) {
    let text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    let size2 = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse2.sel = { anchor: parse2.sel.anchor + size2, head: parse2.sel.anchor + size2 };
  }
  let doc2 = view.state.doc, compare = doc2.slice(parse2.from, parse2.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P") && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse2.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse2.sel);
        if (sel2 && !sel2.eq(view.state.selection))
          view.dispatch(view.state.tr.setSelection(sel2));
      }
      return;
    }
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse2.doc.resolveNoCache(change.start - parse2.from);
  let $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse2.doc.content.size && (nextSel = Selection.findFrom(parse2.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome$1)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome$1 && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text3 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text3)))
        return;
      tr = view.state.tr.insertText(text3, chFrom, chTo);
    }
  }
  if (!tr)
    tr = view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
  if (parse2.sel) {
    let sel2 = resolveSelection(view, tr.doc, parse2.sel);
    if (sel2 && !(chrome$1 && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
      tr.setSelection(sel2);
  }
  if (storedMarks)
    tr.ensureMarks(storedMarks);
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update3;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update3 = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update3 = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update3(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeJoin(old, start2, end3, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end3 - start2 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end3 || skipClosingAndOpening($next, true, false) < end3)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end3 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end3++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end3++;
    }
  }
  return end3;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
class EditorView {
  constructor(place, props2) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.dragging = null;
    this._props = props2;
    this.state = props2.state;
    this.directPlugins = props2.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  get composing() {
    return this.input.composing;
  }
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  update(props2) {
    if (props2.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    this._props = props2;
    if (props2.plugins) {
      props2.plugins.forEach(checkStateComponent);
      this.directPlugins = props2.plugins;
    }
    this.updateStateInner(props2.state, true);
  }
  setProps(props2) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props2)
      updated[name] = props2[name];
    this.update(updated);
  }
  updateState(state2) {
    this.updateStateInner(state2, this.state.plugins != state2.plugins);
  }
  updateStateInner(state2, reconfigured) {
    let prev = this.state, redraw = false, updateSel = false;
    if (state2.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state2;
    if (reconfigured) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = reconfigured ? "reset" : state2.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state2.doc, outerDeco, innerDeco);
    if (updateDoc || !state2.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome$1) && !this.composing && !prev.selection.empty && !state2.selection.empty && selectionContextChanged(prev.selection, state2.selection);
      if (updateDoc) {
        let chromeKludge = chrome$1 ? this.trackWrites = this.domSelection().focusNode : null;
        if (redraw || !this.docView.update(state2.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state2.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelection()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state2.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      let startDOM = this.domSelection().focusNode;
      if (this.someProp("handleScrollToSelection", (f) => f(this)))
        ;
      else if (state2.selection instanceof NodeSelection) {
        let target2 = this.docView.domAfterPos(state2.selection.from);
        if (target2.nodeType == 1)
          scrollRectIntoView(this, target2.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(state2.selection.head, 1), startDOM);
      }
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin2 = this.directPlugins[i];
        if (plugin2.spec.view)
          this.pluginViews.push(plugin2.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin2 = this.state.plugins[i];
        if (plugin2.spec.view)
          this.pluginViews.push(plugin2.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  someProp(propName, f) {
    let prop2 = this._props && this._props[propName], value;
    if (prop2 != null && (value = f ? f(prop2) : prop2))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop3 = this.directPlugins[i].props[propName];
      if (prop3 != null && (value = f ? f(prop3) : prop3))
        return value;
    }
    let plugins2 = this.state.plugins;
    if (plugins2)
      for (let i = 0; i < plugins2.length; i++) {
        let prop3 = plugins2[i].props[propName];
        if (prop3 != null && (value = f ? f(prop3) : prop3))
          return value;
      }
  }
  hasFocus() {
    return this.root.activeElement == this.dom;
  }
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
          return this._root = search2;
        }
      }
    return cached || document;
  }
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  endOfTextblock(dir, state2) {
    return endOfTextblock(this, state2 || this.state, dir);
  }
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }
  get isDestroyed() {
    return this.docView == null;
  }
  dispatchEvent(event) {
    return dispatchEvent$1(this, event);
  }
  dispatch(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr);
    else
      this.updateState(this.state.apply(tr));
  }
  domSelection() {
    return this.root.getSelection();
  }
}
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        if (attr == "style") {
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom2 = document.createElement("img");
    dom2.className = "ProseMirror-separator";
    dom2.setAttribute("mark-placeholder", "true");
    dom2.setAttribute("alt", "");
    view.cursorWrapper = { dom: dom2, deco: Decoration.widget(view.state.selection.head, dom2, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add3(obj) {
    for (let prop2 in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop2))
        result[prop2] = obj[prop2];
  }
  view.someProp("nodeViews", add3);
  view.someProp("markViews", add3);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop2 in a) {
    if (a[prop2] != b[prop2])
      return true;
    nA++;
  }
  for (let _2 in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin2) {
  if (plugin2.spec.state || plugin2.spec.filterTransaction || plugin2.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac$1 || +chrome[1] < 57) || gecko && mac$1;
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code2 in base)
  if (!shift.hasOwnProperty(code2))
    shift[code2] = base[code2];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$1(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize3(map3) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop2 in map3)
    copy2[normalizeKeyName$1(prop2)] = map3[prop2];
  return copy2;
}
function modifiers(name, event, shift2) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 !== false && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map3 = normalize3(bindings);
  return function(view, event) {
    let name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    let direct = map3[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
      let fromCode = map3[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view))
        return true;
    } else if (isChar && event.shiftKey) {
      let withShift = map3[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view))
        return true;
    }
    return false;
  };
}
const deleteSelection$1 = (state2, dispatch2) => {
  if (state2.selection.empty)
    return false;
  if (dispatch2)
    dispatch2(state2.tr.deleteSelection().scrollIntoView());
  return true;
};
const joinBackward$1 = (state2, dispatch2, view) => {
  let { $cursor } = state2.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state2) : $cursor.parentOffset > 0))
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range2 = $cursor.blockRange(), target2 = range2 && liftTarget(range2);
    if (target2 == null)
      return false;
    if (dispatch2)
      dispatch2(state2.tr.lift(range2, target2).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state2, $cut, dispatch2))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state2.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        let tr = state2.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state2.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node, side, only2 = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only2 && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state2, dispatch2, view) => {
  let { $head, empty: empty2 } = state2.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state2) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state2.tr.setSelection(NodeSelection.create(state2.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
const joinForward$1 = (state2, dispatch2, view) => {
  let { $cursor } = state2.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state2) : $cursor.parentOffset < $cursor.parent.content.size))
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state2, $cut, dispatch2))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state2.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        let tr = state2.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state2.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state2, dispatch2, view) => {
  let { $head, empty: empty2 } = state2.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state2) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state2.tr.setSelection(NodeSelection.create(state2.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const lift$1 = (state2, dispatch2) => {
  let { $from, $to } = state2.selection;
  let range2 = $from.blockRange($to), target2 = range2 && liftTarget(range2);
  if (target2 == null)
    return false;
  if (dispatch2)
    dispatch2(state2.tr.lift(range2, target2).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state2, dispatch2) => {
  let { $head, $anchor } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch2)
    dispatch2(state2.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match2) {
  for (let i = 0; i < match2.edgeCount; i++) {
    let { type } = match2.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$1 = (state2, dispatch2) => {
  let { $head, $anchor } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch2) {
    let pos = $head.after(), tr = state2.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state2, dispatch2) => {
  let sel = state2.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch2) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state2.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state2, dispatch2) => {
  let { $cursor } = state2.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state2.doc, before)) {
      if (dispatch2)
        dispatch2(state2.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range2 = $cursor.blockRange(), target2 = range2 && liftTarget(range2);
  if (target2 == null)
    return false;
  if (dispatch2)
    dispatch2(state2.tr.lift(range2, target2).scrollIntoView());
  return true;
};
const splitBlock$1 = (state2, dispatch2) => {
  let { $from, $to } = state2.selection;
  if (state2.selection instanceof NodeSelection && state2.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state2.doc, $from.pos))
      return false;
    if (dispatch2)
      dispatch2(state2.tr.split($from.pos).scrollIntoView());
    return true;
  }
  if (!$from.parent.isBlock)
    return false;
  if (dispatch2) {
    let atEnd = $to.parentOffset == $to.parent.content.size;
    let tr = state2.tr;
    if (state2.selection instanceof TextSelection || state2.selection instanceof AllSelection)
      tr.deleteSelection();
    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [{ type: deflt }] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      if (deflt)
        types = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
        let first2 = tr.mapping.map($from.before()), $first = tr.doc.resolve(first2);
        if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
      }
    }
    dispatch2(tr.scrollIntoView());
  }
  return true;
};
const selectParentNode$1 = (state2, dispatch2) => {
  let { $from, to } = state2.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch2)
    dispatch2(state2.tr.setSelection(NodeSelection.create(state2.doc, pos)));
  return true;
};
const selectAll$1 = (state2, dispatch2) => {
  if (dispatch2)
    dispatch2(state2.tr.setSelection(new AllSelection(state2.doc)));
  return true;
};
function joinMaybeClear(state2, $pos, dispatch2) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch2)
      dispatch2(state2.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state2.doc, $pos.pos)))
    return false;
  if (dispatch2)
    dispatch2(state2.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state2, $cut, dispatch2) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match2;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state2, $cut, dispatch2))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match2 = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match2.matchType(conn[0] || after.type).validEnd) {
    if (dispatch2) {
      let end3 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr = state2.tr.step(new ReplaceAroundStep($cut.pos - 1, end3, $cut.pos, end3, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end3 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt))
        tr.join(joinAt);
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target2 = range2 && liftTarget(range2);
  if (target2 != null && target2 >= $cut.depth) {
    if (dispatch2)
      dispatch2(state2.tr.lift(range2, target2).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch2) {
        let end3 = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end3 = Fragment.from(wrap2[i].copy(end3));
        let tr = state2.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end3, wrap2.length, 0), 0, true));
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state2, dispatch2) {
    let sel = state2.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch2)
      dispatch2(state2.tr.setSelection(TextSelection.create(state2.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function wrapIn$1(nodeType, attrs = null) {
  return function(state2, dispatch2) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to), wrapping = range2 && findWrapping(range2, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch2)
      dispatch2(state2.tr.wrap(range2, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs = null) {
  return function(state2, dispatch2) {
    let { from: from2, to } = state2.selection;
    let applicable = false;
    state2.doc.nodesBetween(from2, to, (node, pos) => {
      if (applicable)
        return false;
      if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
        return;
      if (node.type == nodeType) {
        applicable = true;
      } else {
        let $pos = state2.doc.resolve(pos), index2 = $pos.index();
        applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
      }
    });
    if (!applicable)
      return false;
    if (dispatch2)
      dispatch2(state2.tr.setBlockType(from2, to, nodeType, attrs).scrollIntoView());
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state2, dispatch2, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state2, dispatch2, view))
        return true;
    return false;
  };
}
let backspace = chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
let del = chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
const pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock$1),
  "Mod-Enter": exitCode$1,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll$1
};
const macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart$1,
  "Ctrl-e": selectTextblockEnd$1
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$1(listType, attrs = null) {
  return function(state2, dispatch2) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to), doJoin = false, outerRange = range2;
    if (!range2)
      return false;
    if (range2.depth >= 2 && $from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
      if ($from.index(range2.depth - 1) == 0)
        return false;
      let $insert = state2.doc.resolve(range2.start - 2);
      outerRange = new NodeRange($insert, $insert, range2.depth);
      if (range2.endIndex < range2.parent.childCount)
        range2 = new NodeRange($from, state2.doc.resolve($to.end(range2.depth)), range2.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range2);
    if (!wrap2)
      return false;
    if (dispatch2)
      dispatch2(doWrapInList(state2.tr, range2, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr, range2, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr.step(new ReplaceAroundStep(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
  for (let i = range2.startIndex, e = range2.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr;
}
function liftListItem$1(itemType) {
  return function(state2, dispatch2) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range2)
      return false;
    if (!dispatch2)
      return true;
    if ($from.node(range2.depth - 1).type == itemType)
      return liftToOuterList(state2, dispatch2, itemType, range2);
    else
      return liftOutOfList(state2, dispatch2, range2);
  };
}
function liftToOuterList(state2, dispatch2, itemType, range2) {
  let tr = state2.tr, end3 = range2.end, endOfList = range2.$to.end(range2.depth);
  if (end3 < endOfList) {
    tr.step(new ReplaceAroundStep(end3 - 1, endOfList, end3, endOfList, new Slice(Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
    range2 = new NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfList), range2.depth);
  }
  dispatch2(tr.lift(range2, liftTarget(range2)).scrollIntoView());
  return true;
}
function liftOutOfList(state2, dispatch2, range2) {
  let tr = state2.tr, list3 = range2.parent;
  for (let pos = range2.end, i = range2.endIndex - 1, e = range2.startIndex; i > e; i--) {
    pos -= list3.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range2.start), item = $start.nodeAfter;
  if (tr.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range2.startIndex == 0, atEnd = range2.endIndex == list3.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list3))))
    return false;
  let start2 = $start.pos, end3 = start2 + item.nodeSize;
  tr.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end3 + (atEnd ? 1 : 0), start2 + 1, end3 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list3.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list3.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch2(tr.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state2, dispatch2) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range2)
      return false;
    let startIndex2 = range2.startIndex;
    if (startIndex2 == 0)
      return false;
    let parent = range2.parent, nodeBefore = parent.child(startIndex2 - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch2) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner2 = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner2)))), nestedBefore ? 3 : 1, 0);
      let before = range2.start, after = range2.end;
      dispatch2(state2.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
function createChainableState(config2) {
  const { state: state2, transaction } = config2;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return __spreadProps(__spreadValues({}, state2), {
    apply: state2.apply.bind(state2),
    applyTransaction: state2.applyTransaction.bind(state2),
    filterTransaction: state2.filterTransaction,
    plugins: state2.plugins,
    schema: state2.schema,
    reconfigure: state2.reconfigure.bind(state2),
    toJSON: state2.toJSON.bind(state2),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  });
}
class CommandManager {
  constructor(props2) {
    this.editor = props2.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props2.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state: state2 } = this;
    const { view } = editor;
    const { tr } = state2;
    const props2 = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props2);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state: state2 } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state2.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const chainedCommand = (...args) => {
        const props2 = this.buildProps(tr, shouldDispatch);
        const callback = command2(...args)(props2);
        callbacks.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    }))), {
      run: run2
    });
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state: state2 } = this;
    const dispatch2 = void 0;
    const tr = startTr || state2.tr;
    const props2 = this.buildProps(tr, dispatch2);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)(__spreadProps(__spreadValues({}, props2), { dispatch: dispatch2 }))];
    }));
    return __spreadProps(__spreadValues({}, formattedCommands), {
      chain: () => this.createChain(tr, dispatch2)
    });
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state: state2 } = this;
    const { view } = editor;
    if (state2.storedMarks) {
      tr.setStoredMarks(state2.storedMarks);
    }
    const props2 = {
      tr,
      editor,
      view,
      state: createChainableState({
        state: state2,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props2)];
        }));
      }
    };
    return props2;
  }
}
class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind(__spreadProps(__spreadValues({}, context), {
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    }));
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute2]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: __spreadValues(__spreadValues({}, defaultAttribute), attribute2)
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute2]) => {
      const mergedAttr = __spreadValues(__spreadValues({}, defaultAttribute), attribute2);
      if (attribute2.isRequired && attribute2.default === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = __spreadValues({}, items);
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        mergedAttributes[key] = [mergedAttributes[key], value].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute2) => mergeAttributes(attributes, attribute2), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props2) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props2);
    }
    return value(...props2);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule2, extensionAttributes) {
  if (parseRule2.style) {
    return parseRule2;
  }
  return __spreadProps(__spreadValues({}, parseRule2), {
    getAttrs: (node) => {
      const oldAttributes = parseRule2.getAttrs ? parseRule2.getAttrs(node) : parseRule2.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return __spreadProps(__spreadValues({}, items), {
          [item.name]: value
        });
      }, {});
      return __spreadValues(__spreadValues({}, oldAttributes), newAttributes);
    }
  });
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  }));
}
function getSchemaByResolvedExtensions(extensions2) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute2) => attribute2.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraNodeFields = extensions2.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return __spreadValues(__spreadValues({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});
    }, {});
    const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraNodeFields), {
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    }));
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute2) => attribute2.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraMarkFields = extensions2.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return __spreadValues(__spreadValues({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});
    }, {});
    const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraMarkFields), {
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    }));
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule2) => injectExtensionAttributesToParseRule(parseRule2, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  $from.parent.nodesBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, (node, pos, parent, index2) => {
    var _a, _b, _c;
    textBefore += ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index: index2
    })) || ((_c = $from.nodeBefore) === null || _c === void 0 ? void 0 : _c.text) || "%leaf%";
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
class InputRule {
  constructor(config2) {
    this.find = config2.find;
    this.handler = config2.handler;
  }
}
const inputRuleMatcherHandler = (text3, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text3);
  }
  const inputRuleMatch = find2(text3);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [];
  result.push(inputRuleMatch.text);
  result.index = inputRuleMatch.index;
  result.input = text3;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1$1(config2) {
  var _a;
  const { editor, from: from2, to, text: text3, rules, plugin: plugin2 } = config2;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text3;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match2 = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match2) {
      return;
    }
    const tr = view.state.tr;
    const state2 = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range2 = {
      from: from2 - (match2[0].length - text3.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state: state2
    });
    const handler = rule.handler({
      state: state2,
      range: range2,
      match: match2,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin2, {
      transform: tr,
      from: from2,
      to,
      text: text3
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props2) {
  const { editor, rules } = props2;
  const plugin2 = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev) {
        const stored = tr.getMeta(plugin2);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text3) {
        return run$1$1({
          editor,
          from: from2,
          to,
          text: text3,
          rules,
          plugin: plugin2
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin: plugin2
              });
            }
          });
          return false;
        }
      },
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin: plugin2
          });
        }
        return false;
      }
    },
    isInputRules: true
  });
  return plugin2;
}
function isNumber(value) {
  return typeof value === "number";
}
class PasteRule {
  constructor(config2) {
    this.find = config2.find;
    this.handler = config2.handler;
  }
}
const pasteRuleMatcherHandler = (text3, find2) => {
  if (isRegExp(find2)) {
    return [...text3.matchAll(find2)];
  }
  const matches3 = find2(text3);
  if (!matches3) {
    return [];
  }
  return matches3.map((pasteRuleMatch) => {
    const result = [];
    result.push(pasteRuleMatch.text);
    result.index = pasteRuleMatch.index;
    result.input = text3;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run$2(config2) {
  const { editor, state: state2, from: from2, to, rule } = config2;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state: state2
  });
  const handlers2 = [];
  state2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches3 = pasteRuleMatcherHandler(textToMatch, rule.find);
    matches3.forEach((match2) => {
      if (match2.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match2.index + 1;
      const end3 = start2 + match2[0].length;
      const range2 = {
        from: state2.tr.mapping.map(start2),
        to: state2.tr.mapping.map(end3)
      };
      const handler = rule.handler({
        state: state2,
        range: range2,
        match: match2,
        commands: commands2,
        chain,
        can
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
function pasteRulesPlugin(props2) {
  const { editor, rules } = props2;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  const plugins2 = rules.map((rule) => {
    return new Plugin({
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            return false;
          },
          paste: (view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state2) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from2 = oldState.doc.content.findDiffStart(state2.doc.content);
        const to = oldState.doc.content.findDiffEnd(state2.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        const tr = state2.tr;
        const chainableState = createChainableState({
          state: state2,
          transaction: tr
        });
        const handler = run$2({
          editor,
          state: chainableState,
          from: Math.max(from2 - 1, 0),
          to: to.b,
          rule
        });
        if (!handler || !tr.steps.length) {
          return;
        }
        return tr;
      }
    });
  });
  return plugins2;
}
function findDuplicates(items) {
  const filtered = items.filter((el2, index2) => items.indexOf(el2) !== index2);
  return [...new Set(filtered)];
}
class ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions);
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy2 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [
          extension,
          ...this.flatten(addExtensions())
        ];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return __spreadValues(__spreadValues({}, commands2), addCommands());
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins2 = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        const keyMapPlugin = keymap(bindings);
        plugins2.push(keyMapPlugin);
      }
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins2.push(...proseMirrorPlugins);
      }
      return plugins2;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute2) => attribute2.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          editor,
          node,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target2, source) {
  const output = __spreadValues({}, target2);
  if (isPlainObject(target2) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target2)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target2[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
class Extension {
  constructor(config2 = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = __spreadValues(__spreadValues({}, this.config), config2);
    this.name = this.config.name;
    if (config2.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config2 = {}) {
    return new Extension(config2);
  }
  configure(options2 = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options2);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range2, options2) {
  const { from: from2, to } = range2;
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  let text3 = "";
  let separated = true;
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text3 += blockSeparator;
        separated = true;
      }
      if (parent) {
        text3 += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range: range2
        });
      }
    } else if (node.isText) {
      text3 += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
      separated = false;
    } else if (node.isBlock && !separated) {
      text3 += blockSeparator;
      separated = true;
    }
  });
  return text3;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
const ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state: state2, schema } = editor;
            const { doc: doc2, selection } = state2;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range3) => range3.$from.pos));
            const to = Math.max(...ranges.map((range3) => range3.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range2 = { from: from2, to };
            return getTextBetween(doc2, range2, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
const clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
const clearNodes = () => ({ state: state2, tr, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state2.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const command = (fn2) => (props2) => {
  return fn2(props2);
};
const createParagraphNear = () => ({ state: state2, dispatch: dispatch2 }) => {
  return createParagraphNear$1(state2, dispatch2);
};
const deleteNode = (typeOrName) => ({ tr, state: state2, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteRange = (range2) => ({ tr, dispatch: dispatch2 }) => {
  const { from: from2, to } = range2;
  if (dispatch2) {
    tr.delete(from2, to);
  }
  return true;
};
const deleteSelection = () => ({ state: state2, dispatch: dispatch2 }) => {
  return deleteSelection$1(state2, dispatch2);
};
const enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
const exitCode = () => ({ state: state2, dispatch: dispatch2 }) => {
  return exitCode$1(state2, dispatch2);
};
function objectIncludes(object1, object2, options2 = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options2.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange$1($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) {
    return;
  }
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex2 = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex2 = startIndex2 + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type, attributes);
  while (startIndex2 > 0 && mark.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
    startIndex2 -= 1;
    startPos -= $pos.parent.child(startIndex2).nodeSize;
  }
  while (endIndex2 < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex2).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex2).nodeSize;
    endIndex2 += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
const extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch: dispatch2 }) => {
  const type = getMarkType(typeOrName, state2.schema);
  const { doc: doc2, selection } = tr;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range2 = getMarkRange$1($from, type, attributes);
    if (range2 && range2.from <= from2 && range2.to >= to) {
      const newSelection = TextSelection.create(doc2, range2.from, range2.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
const first = (commands2) => (props2) => {
  const items = typeof commands2 === "function" ? commands2(props2) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props2)) {
      return true;
    }
  }
  return false;
};
function isClass(value) {
  var _a;
  if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== "class") {
    return false;
  }
  return true;
}
function isObject(value) {
  return value && typeof value === "object" && !Array.isArray(value) && !isClass(value);
}
function isTextSelection(value) {
  return isObject(value) && value instanceof TextSelection;
}
function minMax(value = 0, min3 = 0, max3 = 0) {
  return Math.min(Math.max(value, min3), max3);
}
function resolveFocusPosition(doc2, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const focus = (position = null, options2 = {}) => ({ editor, view, tr, dispatch: dispatch2 }) => {
  options2 = __spreadValues({
    scrollIntoView: true
  }, options2);
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options2 === null || options2 === void 0 ? void 0 : options2.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
const forEach = (items, fn2) => (props2) => {
  return items.every((item, index2) => fn2(item, __spreadProps(__spreadValues({}, props2), { index: index2 })));
};
const insertContent = (value, options2) => ({ tr, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options2);
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function createNodeFromContent(content, schema, options2) {
  options2 = __spreadValues({
    slice: true,
    parseOptions: {}
  }, options2);
  if (typeof content === "object" && content !== null) {
    try {
      if (Array.isArray(content)) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content);
    } catch (error2) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error2);
      return createNodeFromContent("", schema, options2);
    }
  }
  if (typeof content === "string") {
    const parser = DOMParser.fromSchema(schema);
    return options2.slice ? parser.parseSlice(elementFromString(content), options2.parseOptions).content : parser.parse(elementFromString(content), options2.parseOptions);
  }
  return createNodeFromContent("", schema, options2);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last2 = tr.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map3 = tr.mapping.maps[last2];
  let end3 = 0;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end3 === 0) {
      end3 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end3), bias));
}
const isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
const insertContentAt = (position, value, options2) => ({ tr, dispatch: dispatch2, editor }) => {
  if (dispatch2) {
    options2 = __spreadValues({
      parseOptions: {},
      updateSelection: true
    }, options2);
    const content = createNodeFromContent(value, editor.schema, {
      parseOptions: __spreadValues({
        preserveWhitespace: "full"
      }, options2.parseOptions)
    });
    if (content.toString() === "<>") {
      return true;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      tr.insertText(value, from2, to);
    } else {
      tr.replaceWith(from2, to, content);
    }
    if (options2.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
  }
  return true;
};
const joinBackward = () => ({ state: state2, dispatch: dispatch2 }) => {
  return joinBackward$1(state2, dispatch2);
};
const joinForward = () => ({ state: state2, dispatch: dispatch2 }) => {
  return joinForward$1(state2, dispatch2);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
const keyboardShortcut = (name) => ({ editor, view, tr, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr.mapping);
    if (newStep && dispatch2) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state2, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state2.selection;
  const type = typeOrName ? getNodeType(typeOrName, state2.schema) : null;
  const nodeRanges = [];
  state2.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range2 = matchedNodeRanges.reduce((sum2, nodeRange) => sum2 + nodeRange.to - nodeRange.from, 0);
  return range2 >= selectionRange;
}
const lift = (typeOrName, attributes = {}) => ({ state: state2, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  const isActive2 = isNodeActive(state2, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$1(state2, dispatch2);
};
const liftEmptyBlock = () => ({ state: state2, dispatch: dispatch2 }) => {
  return liftEmptyBlock$1(state2, dispatch2);
};
const liftListItem = (typeOrName) => ({ state: state2, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  return liftListItem$1(type)(state2, dispatch2);
};
const newlineInCode = () => ({ state: state2, dispatch: dispatch2 }) => {
  return newlineInCode$1(state2, dispatch2);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props2 = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop2) => {
    if (!props2.includes(prop2)) {
      newObj[prop2] = obj[prop2];
    }
    return newObj;
  }, {});
}
const resetAttributes = (typeOrName, attributes) => ({ tr, state: state2, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state2.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state2.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state2.schema);
  }
  if (dispatch2) {
    tr.selection.ranges.forEach((range2) => {
      state2.doc.nodesBetween(range2.$from.pos, range2.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
const scrollIntoView = () => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr.scrollIntoView();
  }
  return true;
};
const selectAll = () => ({ tr, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr.doc.content.size
  });
};
const selectNodeBackward = () => ({ state: state2, dispatch: dispatch2 }) => {
  return selectNodeBackward$1(state2, dispatch2);
};
const selectNodeForward = () => ({ state: state2, dispatch: dispatch2 }) => {
  return selectNodeForward$1(state2, dispatch2);
};
const selectParentNode = () => ({ state: state2, dispatch: dispatch2 }) => {
  return selectParentNode$1(state2, dispatch2);
};
const selectTextblockEnd = () => ({ state: state2, dispatch: dispatch2 }) => {
  return selectTextblockEnd$1(state2, dispatch2);
};
const selectTextblockStart = () => ({ state: state2, dispatch: dispatch2 }) => {
  return selectTextblockStart$1(state2, dispatch2);
};
function createDocument(content, schema, parseOptions = {}) {
  return createNodeFromContent(content, schema, { slice: false, parseOptions });
}
const setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch: dispatch2 }) => {
  const { doc: doc2 } = tr;
  const document2 = createDocument(content, editor.schema, parseOptions);
  if (dispatch2) {
    tr.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
function getMarkAttributes(state2, typeOrName) {
  const type = getMarkType(typeOrName, state2.schema);
  const { from: from2, to, empty: empty2 } = state2.selection;
  const marks = [];
  if (empty2) {
    if (state2.storedMarks) {
      marks.push(...state2.storedMarks);
    }
    marks.push(...state2.selection.$head.marks());
  } else {
    state2.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return __spreadValues({}, mark.attrs);
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state2.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state2, type);
      tr.addStoredMark(type.create(__spreadValues(__spreadValues({}, oldAttributes), attributes)));
    } else {
      ranges.forEach((range2) => {
        const from2 = range2.$from.pos;
        const to = range2.$to.pos;
        state2.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(trimmedFrom, trimmedTo, type.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return true;
};
const setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
const setNode = (typeOrName, attributes = {}) => ({ state: state2, dispatch: dispatch2, chain }) => {
  const type = getNodeType(typeOrName, state2.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, attributes)(state2);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, attributes)(updatedState, dispatch2);
  }).run();
};
const setNodeSelection = (position) => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr;
    const minPos = Selection.atStart(doc2).from;
    const maxPos = Selection.atEnd(doc2).to;
    const resolvedPos = minMax(position, minPos, maxPos);
    const selection = NodeSelection.create(doc2, resolvedPos);
    tr.setSelection(selection);
  }
  return true;
};
const setTextSelection = (position) => ({ tr, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
const sinkListItem = (typeOrName) => ({ state: state2, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  return sinkListItem$1(type)(state2, dispatch2);
};
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function defaultBlockAt$1(match2) {
  for (let i = 0; i < match2.edgeCount; i += 1) {
    const { type } = match2.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function ensureMarks(state2, splittableMarks) {
  const marks = state2.storedMarks || state2.selection.$to.parentOffset && state2.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state2.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr, state: state2, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state2, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [{
      type: deflt,
      attrs: newAttributes
    }] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [{
        type: deflt,
        attrs: newAttributes
      }] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state2, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return true;
};
const splitListItem = (typeOrName) => ({ tr, state: state2, dispatch: dispatch2, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state2.schema);
  const { $from, $to } = state2.selection;
  const node = state2.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d2 = $from.depth - depthBefore; d2 >= $from.depth - 3; d2 -= 1) {
        wrap2 = Fragment.from($from.node(d2).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start2, tr.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    tr.split($from.pos, 2, types).scrollIntoView();
  }
  return true;
};
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group2 = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group2 !== "string") {
    return false;
  }
  return group2.split(" ").includes("list");
}
const joinListBackwards = (tr, listType) => {
  const list3 = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list3) {
    return true;
  }
  const before = tr.doc.resolve(Math.max(0, list3.pos - 1)).before(list3.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before);
  const canJoinBackwards = list3.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list3.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list3.pos);
  return true;
};
const joinListForwards = (tr, listType) => {
  const list3 = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list3) {
    return true;
  }
  const after = tr.doc.resolve(list3.start).after(list3.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after);
  const canJoinForwards = list3.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after);
  return true;
};
const toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state: state2, dispatch: dispatch2, chain, commands: commands2, can }) => {
  const { extensions: extensions2 } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state2.schema);
  const itemType = getNodeType(itemTypeOrName, state2.schema);
  const { selection } = state2;
  const { $from, $to } = selection;
  const range2 = $from.blockRange($to);
  if (!range2) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
  if (range2.depth >= 1 && parentList && range2.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
function isMarkActive(state2, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state2.selection;
  const type = typeOrName ? getMarkType(typeOrName, state2.schema) : null;
  if (empty2) {
    return !!(state2.storedMarks || state2.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state2.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range3 = relativeTo - relativeFrom;
      selectionRange += range3;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum2, markRange) => sum2 + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum2, markRange) => sum2 + markRange.to - markRange.from, 0);
  const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range2 >= selectionRange;
}
const toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state: state2, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options2;
  const type = getMarkType(typeOrName, state2.schema);
  const isActive2 = isMarkActive(state2, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state: state2, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  const toggleType = getNodeType(toggleTypeOrName, state2.schema);
  const isActive2 = isNodeActive(state2, type, attributes);
  if (isActive2) {
    return commands2.setNode(toggleType);
  }
  return commands2.setNode(type, attributes);
};
const toggleWrap = (typeOrName, attributes = {}) => ({ state: state2, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  const isActive2 = isNodeActive(state2, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
const undoInputRule = () => ({ state: state2, dispatch: dispatch2 }) => {
  const plugins2 = state2.plugins;
  for (let i = 0; i < plugins2.length; i += 1) {
    const plugin2 = plugins2[i];
    let undoable;
    if (plugin2.spec.isInputRules && (undoable = plugin2.getState(state2))) {
      if (dispatch2) {
        const tr = state2.tr;
        const toUndo = undoable.transform;
        for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
          tr.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state2.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
const unsetAllMarks = () => ({ tr, dispatch: dispatch2 }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos);
    });
  }
  return true;
};
const unsetMark = (typeOrName, options2 = {}) => ({ tr, state: state2, dispatch: dispatch2 }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options2;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state2.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range2 = getMarkRange$1($from, type, attrs);
    if (range2) {
      from2 = range2.from;
      to = range2.to;
    }
    tr.removeMark(from2, to, type);
  } else {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
const updateAttributes = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state2.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state2.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state2.schema);
  }
  if (dispatch2) {
    tr.selection.ranges.forEach((range2) => {
      const from2 = range2.$from.pos;
      const to = range2.$to.pos;
      state2.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, node.attrs), attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
const wrapIn = (typeOrName, attributes = {}) => ({ state: state2, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  return wrapIn$1(type, attributes)(state2, dispatch2);
};
const wrapInList = (typeOrName, attributes = {}) => ({ state: state2, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state2.schema);
  return wrapInList$1(type, attributes)(state2, dispatch2);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear,
  deleteNode,
  deleteRange,
  deleteSelection,
  enter,
  exitCode,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinBackward,
  joinForward,
  keyboardShortcut,
  lift,
  liftEmptyBlock,
  liftListItem,
  newlineInCode,
  resetAttributes,
  scrollIntoView,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectParentNode,
  selectTextblockEnd,
  selectTextblockStart,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem,
  splitBlock,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn,
  wrapInList
});
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return __spreadValues({}, commands);
  }
});
const Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
const FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
const Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      () => commands2.command(({ tr }) => {
        const { selection, doc: doc2 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const isAtStart = Selection.atStart(doc2).from === pos;
        if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = __spreadValues({}, baseKeymap);
    const macKeymap = __spreadProps(__spreadValues({}, baseKeymap), {
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    });
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          const isEmpty3 = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (empty2 || !allWasSelected || !isEmpty3) {
            return;
          }
          const tr = newState.tr;
          const state2 = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state: state2
          });
          commands2.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
const Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
function getNodeAttributes(state2, typeOrName) {
  const type = getNodeType(typeOrName, state2.schema);
  const { from: from2, to } = state2.selection;
  const nodes = [];
  state2.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return __spreadValues({}, node.attrs);
}
function getAttributes(state2, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state2.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state2, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state2, typeOrName);
  }
  return {};
}
function getHTMLFromFragment(fragment2, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment2);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText(node, options2) {
  const range2 = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range2, options2);
}
function isActive(state2, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state2, null, attributes) || isMarkActive(state2, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state2.schema);
  if (schemaType === "node") {
    return isNodeActive(state2, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state2, name, attributes);
  }
  return false;
}
function isNodeEmpty(node) {
  var _a;
  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce) {
  const tipTapStyleTag = document.querySelector("style[data-tiptap-style]");
  if (tipTapStyleTag !== null) {
    return tipTapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute("data-tiptap-style", "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
class Editor$1 extends EventEmitter {
  constructor(options2 = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options2);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  setOptions(options2 = {}) {
    this.options = __spreadValues(__spreadValues({}, this.options), options2);
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  setEditable(editable) {
    this.setOptions({ editable });
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(plugin2, handlePlugins) {
    const plugins2 = isFunction(handlePlugins) ? handlePlugins(plugin2, [...this.state.plugins]) : [...this.state.plugins, plugin2];
    const state2 = this.state.reconfigure({ plugins: plugins2 });
    this.view.updateState(state2);
  }
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state2 = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin2) => !plugin2.key.startsWith(name))
    });
    this.view.updateState(state2);
  }
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    const doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, __spreadProps(__spreadValues({}, this.options.editorProps), {
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc2,
        selection: selection || void 0
      })
    }));
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    const dom2 = this.view.dom;
    dom2.editor = this;
  }
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  dispatchTransaction(transaction) {
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state2 = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state2.selection);
    this.view.updateState(state2);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  getText(options2) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: __spreadValues(__spreadValues({}, textSerializers), getTextSerializersFromSchema(this.schema))
    });
  }
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform2 = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform2.step(step);
    });
  });
  return transform2;
}
function findChildrenInRange(node, range2, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range2.from, range2.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen2 = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen2, key) ? false : seen2[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_2, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform2) {
  const { mapping, steps } = transform2;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc2) {
  const marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach((mark) => {
      const $pos = doc2.resolve(from2 - 1);
      const range2 = getMarkRange$1($pos, mark.type);
      if (!range2) {
        return;
      }
      marks.push(__spreadValues({
        mark
      }, range2));
    });
  } else {
    doc2.nodesBetween(from2, to, (node, pos) => {
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function isNodeSelection(value) {
  return isObject(value) && value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end3 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end3.top);
  const bottom2 = Math.max(start2.bottom, end3.bottom);
  const left2 = Math.min(start2.left, end3.left);
  const right2 = Math.max(start2.right, end3.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return __spreadProps(__spreadValues({}, data), {
    toJSON: () => data
  });
}
function markInputRule(config2) {
  return new InputRule({
    find: config2.find,
    handler: ({ state: state2, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config2.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state2;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range2.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range2.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range2.from, range2.to, state2.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config2.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range2.to) {
          tr.delete(textEnd, range2.to);
        }
        if (textStart > range2.from) {
          tr.delete(range2.from + startSpaces, textStart);
        }
        markEnd = range2.from + startSpaces + captureGroup.length;
        tr.addMark(range2.from + startSpaces, markEnd, config2.type.create(attributes || {}));
        tr.removeStoredMark(config2.type);
      }
    }
  });
}
function nodeInputRule(config2) {
  return new InputRule({
    find: config2.find,
    handler: ({ state: state2, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config2.getAttributes, void 0, match2) || {};
      const { tr } = state2;
      const start2 = range2.from;
      let end3 = range2.to;
      if (match2[1]) {
        const offset2 = match2[0].lastIndexOf(match2[1]);
        let matchStart = start2 + offset2;
        if (matchStart > end3) {
          matchStart = end3;
        } else {
          end3 = matchStart + match2[1].length;
        }
        const lastChar = match2[0][match2[0].length - 1];
        tr.insertText(lastChar, start2 + match2[0].length - 1);
        tr.replaceWith(matchStart, end3, config2.type.create(attributes));
      } else if (match2[0]) {
        tr.replaceWith(start2, end3, config2.type.create(attributes));
      }
    }
  });
}
function textblockTypeInputRule(config2) {
  return new InputRule({
    find: config2.find,
    handler: ({ state: state2, range: range2, match: match2 }) => {
      const $start = state2.doc.resolve(range2.from);
      const attributes = callOrReturn(config2.getAttributes, void 0, match2) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config2.type)) {
        return null;
      }
      state2.tr.delete(range2.from, range2.to).setBlockType(range2.from, range2.from, config2.type, attributes);
    }
  });
}
function wrappingInputRule(config2) {
  return new InputRule({
    find: config2.find,
    handler: ({ state: state2, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config2.getAttributes, void 0, match2) || {};
      const tr = state2.tr.delete(range2.from, range2.to);
      const $start = tr.doc.resolve(range2.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config2.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange, wrapping);
      const before = tr.doc.resolve(range2.from - 1).nodeBefore;
      if (before && before.type === config2.type && canJoin(tr.doc, range2.from - 1) && (!config2.joinPredicate || config2.joinPredicate(match2, before))) {
        tr.join(range2.from - 1);
      }
    }
  });
}
class Mark {
  constructor(config2 = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = __spreadValues(__spreadValues({}, this.config), config2);
    this.name = this.config.name;
    if (config2.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config2 = {}) {
    return new Mark(config2);
  }
  configure(options2 = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options2);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
class Node$1 {
  constructor(config2 = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = __spreadValues(__spreadValues({}, this.config), config2);
    this.name = this.config.name;
    if (config2.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config2 = {}) {
    return new Node$1(config2);
  }
  configure(options2 = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options2);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node$1(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
class NodeView {
  constructor(component, props2, options2) {
    this.isDragging = false;
    this.component = component;
    this.editor = props2.editor;
    this.options = __spreadValues({
      stopEvent: null,
      ignoreMutation: null
    }, options2);
    this.extension = props2.extension;
    this.node = props2.node;
    this.decorations = props2.decorations;
    this.getPos = props2.getPos;
    this.mount();
  }
  mount() {
    return;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(event) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { view } = this.editor;
    const target2 = event.target;
    const dragHandle = target2.nodeType === 3 ? (_a = target2.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target2.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target2)) || !dragHandle) {
      return;
    }
    let x = 0;
    let y = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y = handleBox.y - domBox.y + offsetY;
    }
    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
    const selection = NodeSelection.create(view.state.doc, this.getPos());
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
  stopEvent(event) {
    var _a;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    const target2 = event.target;
    const isInElement = this.dom.contains(target2) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target2));
    if (!isInElement) {
      return false;
    }
    const isDropEvent = event.type === "drop";
    const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target2.tagName) || target2.isContentEditable;
    if (isInput && !isDropEvent) {
      return true;
    }
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    const isDragEvent = event.type.startsWith("drag");
    if (!isDraggable && isSelectable && isDragEvent) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target2.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener("dragend", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("mouseup", () => {
          this.isDragging = false;
        }, { once: true });
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && isiOS() && this.editor.isFocused) {
      const changedNodes = [
        ...Array.from(mutation.addedNodes),
        ...Array.from(mutation.removedNodes)
      ];
      if (changedNodes.every((node) => node.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr }) => {
      const pos = this.getPos();
      tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, this.node.attrs), attributes));
      return true;
    });
  }
  deleteNode() {
    const from2 = this.getPos();
    const to = from2 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from2, to });
  }
}
function markPasteRule(config2) {
  return new PasteRule({
    find: config2.find,
    handler: ({ state: state2, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config2.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state2;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range2.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range2.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range2.from, range2.to, state2.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config2.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range2.to) {
          tr.delete(textEnd, range2.to);
        }
        if (textStart > range2.from) {
          tr.delete(range2.from + startSpaces, textStart);
        }
        markEnd = range2.from + startSpaces + captureGroup.length;
        tr.addMark(range2.from + startSpaces, markEnd, config2.type.create(attributes || {}));
        tr.removeStoredMark(config2.type);
      }
    }
  });
}
class BubbleMenuView {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state: state2, from: from2, to }) => {
      const { doc: doc2, selection } = state2;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc2.textBetween(from2, to).length && isTextSelection(state2.selection);
      if (!view2.hasFocus() || empty2 || isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy$1(editorElement, __spreadValues({
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle"
    }, this.tippyOptions));
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a, _b, _c;
    const { state: state2, composing } = view;
    const { doc: doc2, selection } = state2;
    const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (composing || isSame) {
      return;
    }
    this.createTooltip();
    const { ranges } = selection;
    const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
    const to = Math.max(...ranges.map((range2) => range2.$to.pos));
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state: state2,
      oldState,
      from: from2,
      to
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
        if (isNodeSelection(state2.selection)) {
          const node = view.nodeDOM(from2);
          if (node) {
            return node.getBoundingClientRect();
          }
        }
        return posToDOMRect(view, from2, to);
      })
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const BubbleMenuPlugin = (options2) => {
  return new Plugin({
    key: typeof options2.pluginKey === "string" ? new PluginKey(options2.pluginKey) : options2.pluginKey,
    view: (view) => new BubbleMenuView(__spreadValues({ view }, options2))
  });
};
Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
class FloatingMenuView {
  constructor({ editor, element, view, tippyOptions = {}, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state: state2 }) => {
      const { selection } = state2;
      const { $anchor, empty: empty2 } = selection;
      const isRootDepth = $anchor.depth === 1;
      const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;
      if (!view2.hasFocus() || !empty2 || !isRootDepth || !isEmptyTextBlock) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy$1(editorElement, __spreadValues({
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle"
    }, this.tippyOptions));
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", (event) => {
        this.blurHandler({ event });
      });
    }
  }
  update(view, oldState) {
    var _a, _b, _c;
    const { state: state2 } = view;
    const { doc: doc2, selection } = state2;
    const { from: from2, to } = selection;
    const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
    if (isSame) {
      return;
    }
    this.createTooltip();
    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
      editor: this.editor,
      view,
      state: state2,
      oldState
    });
    if (!shouldShow) {
      this.hide();
      return;
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => posToDOMRect(view, from2, to))
    });
    this.show();
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const FloatingMenuPlugin = (options2) => {
  return new Plugin({
    key: typeof options2.pluginKey === "string" ? new PluginKey(options2.pluginKey) : options2.pluginKey,
    view: (view) => new FloatingMenuView(__spreadValues({ view }, options2))
  });
};
Extension.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      FloatingMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
defineComponent({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: null,
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: true
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(props2, { slots }) {
    const root2 = ref(null);
    onMounted(() => {
      const { pluginKey, editor, tippyOptions, shouldShow } = props2;
      editor.registerPlugin(BubbleMenuPlugin({
        pluginKey,
        editor,
        element: root2.value,
        tippyOptions,
        shouldShow
      }));
    });
    onBeforeUnmount(() => {
      const { pluginKey, editor } = props2;
      editor.unregisterPlugin(pluginKey);
    });
    return () => {
      var _a;
      return h("div", { ref: root2 }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
    };
  }
});
function useDebouncedRef(value) {
  return customRef((track2, trigger2) => {
    return {
      get() {
        track2();
        return value;
      },
      set(newValue) {
        value = newValue;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            trigger2();
          });
        });
      }
    };
  });
}
class Editor extends Editor$1 {
  constructor(options2 = {}) {
    super(options2);
    this.vueRenderers = reactive(/* @__PURE__ */ new Map());
    this.contentComponent = null;
    this.reactiveState = useDebouncedRef(this.view.state);
    this.reactiveExtensionStorage = useDebouncedRef(this.extensionStorage);
    this.on("transaction", () => {
      this.reactiveState.value = this.view.state;
      this.reactiveExtensionStorage.value = this.extensionStorage;
    });
    return markRaw(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  registerPlugin(plugin2, handlePlugins) {
    super.registerPlugin(plugin2, handlePlugins);
    this.reactiveState.value = this.view.state;
  }
  unregisterPlugin(nameOrPluginKey) {
    super.unregisterPlugin(nameOrPluginKey);
    this.reactiveState.value = this.view.state;
  }
}
const EditorContent = defineComponent({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(props2) {
    const rootEl2 = ref();
    const instance = getCurrentInstance();
    watchEffect(() => {
      const editor = props2.editor;
      if (editor && editor.options.element && rootEl2.value) {
        nextTick(() => {
          if (!rootEl2.value || !editor.options.element.firstChild) {
            return;
          }
          const element = unref(rootEl2.value);
          rootEl2.value.append(...editor.options.element.childNodes);
          editor.contentComponent = instance.ctx._;
          editor.setOptions({
            element
          });
          editor.createNodeViews();
        });
      }
    });
    onBeforeUnmount(() => {
      const editor = props2.editor;
      if (!editor) {
        return;
      }
      if (!editor.isDestroyed) {
        editor.view.setProps({
          nodeViews: {}
        });
      }
      editor.contentComponent = null;
      if (!editor.options.element.firstChild) {
        return;
      }
      const newElement = document.createElement("div");
      newElement.append(...editor.options.element.childNodes);
      editor.setOptions({
        element: newElement
      });
    });
    return { rootEl: rootEl2 };
  },
  render() {
    const vueRenderers = [];
    if (this.editor) {
      this.editor.vueRenderers.forEach((vueRenderer) => {
        const node = h(Teleport, {
          to: vueRenderer.teleportElement,
          key: vueRenderer.id
        }, h(vueRenderer.component, __spreadValues({
          ref: vueRenderer.id
        }, vueRenderer.props)));
        vueRenderers.push(node);
      });
    }
    return h("div", {
      ref: (el2) => {
        this.rootEl = el2;
      }
    }, ...vueRenderers);
  }
});
defineComponent({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: true
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(props2, { slots }) {
    const root2 = ref(null);
    onMounted(() => {
      const { pluginKey, editor, tippyOptions, shouldShow } = props2;
      editor.registerPlugin(FloatingMenuPlugin({
        pluginKey,
        editor,
        element: root2.value,
        tippyOptions,
        shouldShow
      }));
    });
    onBeforeUnmount(() => {
      const { pluginKey, editor } = props2;
      editor.unregisterPlugin(pluginKey);
    });
    return () => {
      var _a;
      return h("div", { ref: root2 }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
    };
  }
});
defineComponent({
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return h(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
const NodeViewWrapper = defineComponent({
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var _a, _b;
    return h(this.as, {
      class: this.decorationClasses.value,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      onDragstart: this.onDragStart
    }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));
  }
});
class VueRenderer {
  constructor(component, { props: props2 = {}, editor }) {
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.editor = editor;
    this.component = markRaw(component);
    this.teleportElement = document.createElement("div");
    this.element = this.teleportElement;
    this.props = reactive(props2);
    this.editor.vueRenderers.set(this.id, this);
    if (this.editor.contentComponent) {
      this.editor.contentComponent.update();
      if (this.teleportElement.children.length !== 1) {
        throw Error("VueRenderer doesn\u2019t support multiple child elements.");
      }
      this.element = this.teleportElement.firstElementChild;
    }
  }
  get ref() {
    var _a;
    return (_a = this.editor.contentComponent) === null || _a === void 0 ? void 0 : _a.refs[this.id];
  }
  updateProps(props2 = {}) {
    Object.entries(props2).forEach(([key, value]) => {
      this.props[key] = value;
    });
  }
  destroy() {
    this.editor.vueRenderers.delete(this.id);
  }
}
class VueNodeView extends NodeView {
  mount() {
    const props2 = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    const onDragStart = this.onDragStart.bind(this);
    this.decorationClasses = ref(this.getDecorationClasses());
    const extendedComponent = defineComponent({
      extends: __spreadValues({}, this.component),
      props: Object.keys(props2),
      template: this.component.template,
      setup: (reactiveProps) => {
        var _a, _b;
        provide("onDragStart", onDragStart);
        provide("decorationClasses", this.decorationClasses);
        return (_b = (_a = this.component).setup) === null || _b === void 0 ? void 0 : _b.call(_a, reactiveProps, {
          expose: () => void 0
        });
      },
      __scopeId: this.component.__scopeId,
      __cssModules: this.component.__cssModules
    });
    this.renderer = new VueRenderer(extendedComponent, {
      editor: this.editor,
      props: props2
    });
  }
  get dom() {
    if (!this.renderer.element.hasAttribute("data-node-view-wrapper")) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    const contentElement = this.dom.querySelector("[data-node-view-content]");
    return contentElement || this.dom;
  }
  update(node, decorations) {
    const updateProps2 = (props2) => {
      this.decorationClasses.value = this.getDecorationClasses();
      this.renderer.updateProps(props2);
    };
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        updateProps: () => updateProps2({ node, decorations })
      });
    }
    if (node.type !== this.node.type) {
      return false;
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    updateProps2({ node, decorations });
    return true;
  }
  selectNode() {
    this.renderer.updateProps({
      selected: true
    });
  }
  deselectNode() {
    this.renderer.updateProps({
      selected: false
    });
  }
  getDecorationClasses() {
    return this.decorations.map((item) => item.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy();
  }
}
function VueNodeViewRenderer(component, options2) {
  return (props2) => {
    if (!props2.editor.contentComponent) {
      return {};
    }
    return new VueNodeView(component, props2, options2);
  };
}
const starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
const underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
const Bold = Mark.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
const inputRegex$5 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
const pasteRegex$2 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
const Code = Mark.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$2,
        type: this.type
      })
    ];
  }
});
const inputRegex$4 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/;
const pasteRegex$1 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
const Highlight = Mark.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })
    ];
  }
});
const starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
const starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
const underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
const underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
const Italic = Mark.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
const inputRegex$3 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
const pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
const Strike = Mark.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-x": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
const Subscript = Mark.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "sub") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSubscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSubscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});
const Superscript = Mark.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "super") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSuperscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSuperscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});
const Underline = Mark.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const inputRegex$2 = /^\s*>\s$/;
const Blockquote = Node$1.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$2,
        type: this.type
      })
    ];
  }
});
const inputRegex$1 = /^\s*([-+*])\s$/;
const BulletList = Node$1.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2 }) => {
        return commands2.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$1,
        type: this.type
      })
    ];
  }
});
const backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
const tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
const CodeBlock = Node$1.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state: state2 } = editor;
        const { selection } = state2;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr }) => {
          tr.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state: state2 } = editor;
        const { selection, doc: doc2 } = state2;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after);
        if (nodeAfter) {
          return false;
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match2) => ({
          language: match2[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match2) => ({
          language: match2[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text3 = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text3 || !language) {
              return false;
            }
            const { tr } = view.state;
            tr.replaceSelectionWith(this.type.create({ language }));
            tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
            tr.insertText(text3.replace(/\r\n?/g, "\n"));
            tr.setMeta("paste", true);
            view.dispatch(tr);
            return true;
          }
        }
      })
    ];
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state: state2, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state2;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch2 }) => {
              if (dispatch2 && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
const Heading = Node$1.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => __spreadValues(__spreadValues({}, items), {
      [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
const HorizontalRule = Node$1.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [
      { tag: "hr" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain }) => {
        return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch2 }) => {
          var _a;
          if (dispatch2) {
            const { $to } = tr.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              tr.setSelection(TextSelection.create(tr.doc, $to.pos));
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr.insert(posAfter, node);
                tr.setSelection(TextSelection.create(tr.doc, posAfter));
              }
            }
            tr.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
const ListItem = Node$1.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const inputRegex = /^(\d+)\.\s$/;
const OrderedList = Node$1.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const _a = HTMLAttributes, { start: start2 } = _a, attributesWithoutStart = __objRest(_a, ["start"]);
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2 }) => {
        return commands2.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match2) => ({ start: +match2[1] }),
        joinPredicate: (match2, node) => node.childCount + node.attrs.start === +match2[1]
      })
    ];
  }
});
const Paragraph = Node$1.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const Text$1 = Node$1.create({
  name: "text",
  group: "inline"
});
function dropCursor(options2 = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options2);
    }
  });
}
class DropCursorView {
  constructor(editorView, options2) {
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = options2.width || 1;
    this.color = options2.color || "black";
    this.class = options2.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos), rect2;
    if (!$pos.parent.inlineContent) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0)).getBoundingClientRect();
        let top2 = before ? nodeRect.bottom : nodeRect.top;
        if (before && after)
          top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
        rect2 = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
      }
    }
    if (!rect2) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect2 = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
    }
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect3 = parent.getBoundingClientRect();
      parentLeft = rect3.left - parent.scrollLeft;
      parentTop = rect3.top - parent.scrollTop;
    }
    this.element.style.left = rect2.left - parentLeft + "px";
    this.element.style.top = rect2.top - parentTop + "px";
    this.element.style.width = rect2.right - rect2.left + "px";
    this.element.style.height = rect2.bottom - rect2.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled2 = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos) : disableDropCursor;
    if (pos && !disabled2) {
      let target2 = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        target2 = dropPoint(this.editorView.state.doc, target2, this.editorView.dragging.slice);
        if (target2 == null)
          return this.setCursor(null);
      }
      this.setCursor(target2);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
const Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});
const FocusClasses = Extension.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("focus"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const { isEditable, isFocused } = this.editor;
            const { anchor } = selection;
            const decorations = [];
            if (!isEditable || !isFocused) {
              return DecorationSet.create(doc2, []);
            }
            let maxLevels = 0;
            if (this.options.mode === "deepest") {
              doc2.descendants((node, pos) => {
                if (node.isText) {
                  return;
                }
                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                if (!isCurrent) {
                  return false;
                }
                maxLevels += 1;
              });
            }
            let currentLevel = 0;
            doc2.descendants((node, pos) => {
              if (node.isText) {
                return false;
              }
              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
              if (!isCurrent) {
                return false;
              }
              currentLevel += 1;
              const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
              if (outOfScope) {
                return this.options.mode === "deepest";
              }
              decorations.push(Decoration.node(pos, pos + node.nodeSize, {
                class: this.options.className
              }));
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
class GapCursor extends Selection {
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d2 = $pos.depth; ; d2--) {
          let parent = $pos.node(d2);
          if (dir > 0 ? $pos.indexAfter(d2) < parent.childCount : $pos.index(d2) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d2) : $pos.index(d2) - 1);
            break;
          } else if (d2 == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function closedBefore($pos) {
  for (let d2 = $pos.depth; d2 >= 0; d2--) {
    let index2 = $pos.index(d2), parent = $pos.node(d2);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d2 = $pos.depth; d2 >= 0; d2--) {
    let index2 = $pos.indexAfter(d2), parent = $pos.node(d2);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state2, dispatch2, view) {
    let sel = state2.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state2.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch2)
      dispatch2(state2.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state2) {
  if (!(state2.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state2.doc, [Decoration.widget(state2.selection.head, node, { key: "gapcursor" })]);
}
const Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get3(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors2 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors2.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors2.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors2);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner2 = this.right.leafAppend(other);
    if (inner2) {
      return new Append2(this.left, inner2);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner2 = this.left.leafPrepend(other);
    if (inner2) {
      return new Append2(inner2, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var ropeSequence = RopeSequence;
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  popEvent(state2, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end3 = this.items.length;
    for (; ; end3--) {
      let next = this.items.get(end3 - 1);
      if (next.selection) {
        --end3;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end3, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform2 = state2.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end3, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map3;
        if (step && transform2.maybeStep(step).doc) {
          map3 = transform2.mapping.maps[transform2.mapping.maps.length - 1];
          addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
      } else {
        transform2.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end3).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform: transform2, selection };
  }
  addTransform(transform2, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform2.steps.length; i++) {
      let step = transform2.steps[i].invert(transform2.docs[i]);
      let item = new Item(transform2.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map3) => new Item(map3))), this.eventCount);
  }
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map3 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map3, step, selection));
      } else {
        rebasedItems.push(new Item(map3));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count2 = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count2++;
    });
    return count2;
  }
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events2 = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events2++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map3 = step && step.getMap();
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events2++;
          let newItem = new Item(map3.invert(), step, selection), merged, last2 = items.length - 1;
          if (merged = items.length && items[last2].merge(newItem))
            items[last2] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(ropeSequence.from(items.reverse()), events2);
  }
}
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map3, step, selection, mirrorOffset) {
    this.map = map3;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state2, tr, options2) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options2, mustPreserveItems(state2)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options2, mustPreserveItems(state2)), null, history2.prevTime);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state2.selection.getBookmark() : void 0, options2, mustPreserveItems(state2)), Branch.empty, prevRanges, tr.time);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  }
}
function isAdjacentTo(transform2, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform2.docChanged)
    return true;
  let adjacent = false;
  transform2.mapping.maps[0].forEach((start2, end3) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end3 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map3) {
  let result = [];
  map3.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state2, dispatch2, redo2) {
  let preserveItems = mustPreserveItems(state2);
  let histOptions = historyKey.get(state2).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state2, preserveItems);
  if (!pop)
    return;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state2.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch2(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state2) {
  let plugins2 = state2.plugins;
  if (cachedPreserveItemsPlugins != plugins2) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins2;
    for (let i = 0; i < plugins2.length; i++)
      if (plugins2[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config2 = {}) {
  config2 = {
    depth: config2.depth || 100,
    newGroupDelay: config2.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply(tr, hist, state2) {
        return applyTransaction(hist, state2, tr, config2);
      }
    },
    config: config2,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
const undo = (state2, dispatch2) => {
  let hist = historyKey.getState(state2);
  if (!hist || hist.done.eventCount == 0)
    return false;
  if (dispatch2)
    histTransaction(hist, state2, dispatch2, false);
  return true;
};
const redo = (state2, dispatch2) => {
  let hist = historyKey.getState(state2);
  if (!hist || hist.undone.eventCount == 0)
    return false;
  if (dispatch2)
    histTransaction(hist, state2, dispatch2, true);
  return true;
};
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: state2, dispatch: dispatch2 }) => {
        return undo(state2, dispatch2);
      },
      redo: () => ({ state: state2, dispatch: dispatch2 }) => {
        return redo(state2, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});
const TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element) => element.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
function State(token2) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token2;
}
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  tt: function tt(input2, tokenOrState) {
    if (tokenOrState && tokenOrState.j) {
      this.j[input2] = tokenOrState;
      return tokenOrState;
    }
    var token2 = tokenOrState;
    var nextState = this.j[input2];
    if (nextState) {
      if (token2) {
        nextState.t = token2;
      }
      return nextState;
    }
    nextState = makeState();
    var templateState = takeT(this, input2);
    if (templateState) {
      Object.assign(nextState.j, templateState.j);
      nextState.jr.append(templateState.jr);
      nextState.jr = templateState.jd;
      nextState.t = token2 || templateState.t;
    } else {
      nextState.t = token2;
    }
    this.j[input2] = nextState;
    return nextState;
  }
};
var makeState = function makeState2() {
  return new State();
};
var makeAcceptingState = function makeAcceptingState2(token2) {
  return new State(token2);
};
var makeT = function makeT2(startState, input2, nextState) {
  if (!startState.j[input2]) {
    startState.j[input2] = nextState;
  }
};
var makeRegexT = function makeRegexT2(startState, regex2, nextState) {
  startState.jr.push([regex2, nextState]);
};
var takeT = function takeT2(state2, input2) {
  var nextState = state2.j[input2];
  if (nextState) {
    return nextState;
  }
  for (var i = 0; i < state2.jr.length; i++) {
    var regex2 = state2.jr[i][0];
    var _nextState = state2.jr[i][1];
    if (regex2.test(input2)) {
      return _nextState;
    }
  }
  return state2.jd;
};
var makeMultiT = function makeMultiT2(startState, chars, nextState) {
  for (var i = 0; i < chars.length; i++) {
    makeT(startState, chars[i], nextState);
  }
};
var makeBatchT = function makeBatchT2(startState, transitions) {
  for (var i = 0; i < transitions.length; i++) {
    var input2 = transitions[i][0];
    var nextState = transitions[i][1];
    makeT(startState, input2, nextState);
  }
};
var makeChainT = function makeChainT2(state2, str, endState, defaultStateFactory) {
  var i = 0, len = str.length, nextState;
  while (i < len && (nextState = state2.j[str[i]])) {
    state2 = nextState;
    i++;
  }
  if (i >= len) {
    return [];
  }
  while (i < len - 1) {
    nextState = defaultStateFactory();
    makeT(state2, str[i], nextState);
    state2 = nextState;
    i++;
  }
  makeT(state2, str[len - 1], endState);
};
var DOMAIN = "DOMAIN";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var NUM = "NUM";
var PROTOCOL = "PROTOCOL";
var MAILTO = "MAILTO";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var SYM = "SYM";
var text$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DOMAIN,
  LOCALHOST,
  TLD,
  NUM,
  PROTOCOL,
  MAILTO,
  WS,
  NL,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  SYM
});
var tlds2 = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw verm\xF6gensberater-ctb verm\xF6gensberatung-pwb \u03B5\u03BB \u03B5\u03C5 \u0431\u0433 \u0431\u0435\u043B \u0434\u0435\u0442\u0438 \u0435\u044E \u043A\u0430\u0442\u043E\u043B\u0438\u043A \u043A\u043E\u043C \u049B\u0430\u0437 \u043C\u043A\u0434 \u043C\u043E\u043D \u043C\u043E\u0441\u043A\u0432\u0430 \u043E\u043D\u043B\u0430\u0439\u043D \u043E\u0440\u0433 \u0440\u0443\u0441 \u0440\u0444 \u0441\u0430\u0439\u0442 \u0441\u0440\u0431 \u0443\u043A\u0440 \u10D2\u10D4 \u0570\u0561\u0575 \u05D9\u05E9\u05E8\u05D0\u05DC \u05E7\u05D5\u05DD \u0627\u0628\u0648\u0638\u0628\u064A \u0627\u062A\u0635\u0627\u0644\u0627\u062A \u0627\u0631\u0627\u0645\u0643\u0648 \u0627\u0644\u0627\u0631\u062F\u0646 \u0627\u0644\u0628\u062D\u0631\u064A\u0646 \u0627\u0644\u062C\u0632\u0627\u0626\u0631 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629 \u0627\u0644\u0639\u0644\u064A\u0627\u0646 \u0627\u0644\u0645\u063A\u0631\u0628 \u0627\u0645\u0627\u0631\u0627\u062A \u0627\u06CC\u0631\u0627\u0646 \u0628\u0627\u0631\u062A \u0628\u0627\u0632\u0627\u0631 \u0628\u06BE\u0627\u0631\u062A \u0628\u064A\u062A\u0643 \u067E\u0627\u06A9\u0633\u062A\u0627\u0646 \u0680\u0627\u0631\u062A \u062A\u0648\u0646\u0633 \u0633\u0648\u062F\u0627\u0646 \u0633\u0648\u0631\u064A\u0629 \u0634\u0628\u0643\u0629 \u0639\u0631\u0627\u0642 \u0639\u0631\u0628 \u0639\u0645\u0627\u0646 \u0641\u0644\u0633\u0637\u064A\u0646 \u0642\u0637\u0631 \u0643\u0627\u062B\u0648\u0644\u064A\u0643 \u0643\u0648\u0645 \u0645\u0635\u0631 \u0645\u0644\u064A\u0633\u064A\u0627 \u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627 \u0645\u0648\u0642\u0639 \u0647\u0645\u0631\u0627\u0647 \u0915\u0949\u092E \u0928\u0947\u091F \u092D\u093E\u0930\u0924 \u092D\u093E\u0930\u0924\u092E\u094D \u092D\u093E\u0930\u094B\u0924 \u0938\u0902\u0917\u0920\u0928 \u09AC\u09BE\u0982\u09B2\u09BE \u09AD\u09BE\u09B0\u09A4 \u09AD\u09BE\u09F0\u09A4 \u0A2D\u0A3E\u0A30\u0A24 \u0AAD\u0ABE\u0AB0\u0AA4 \u0B2D\u0B3E\u0B30\u0B24 \u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE \u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8 \u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD \u0C2D\u0C3E\u0C30\u0C24\u0C4D \u0CAD\u0CBE\u0CB0\u0CA4 \u0D2D\u0D3E\u0D30\u0D24\u0D02 \u0DBD\u0D82\u0D9A\u0DCF \u0E04\u0E2D\u0E21 \u0E44\u0E17\u0E22 \u0EA5\u0EB2\u0EA7 \uB2F7\uB137 \uB2F7\uCEF4 \uC0BC\uC131 \uD55C\uAD6D \u30A2\u30DE\u30BE\u30F3 \u30B0\u30FC\u30B0\u30EB \u30AF\u30E9\u30A6\u30C9 \u30B3\u30E0 \u30B9\u30C8\u30A2 \u30BB\u30FC\u30EB \u30D5\u30A1\u30C3\u30B7\u30E7\u30F3 \u30DD\u30A4\u30F3\u30C8 \u307F\u3093\u306A \u4E16\u754C \u4E2D\u4FE1 \u4E2D\u56FD \u4E2D\u570B \u4E2D\u6587\u7F51 \u4E9A\u9A6C\u900A \u4F01\u4E1A \u4F5B\u5C71 \u4FE1\u606F \u5065\u5EB7 \u516B\u5366 \u516C\u53F8 \u516C\u76CA \u53F0\u6E7E \u53F0\u7063 \u5546\u57CE \u5546\u5E97 \u5546\u6807 \u5609\u91CC \u5609\u91CC\u5927\u9152\u5E97 \u5728\u7EBF \u5927\u4F17\u6C7D\u8F66 \u5927\u62FF \u5929\u4E3B\u6559 \u5A31\u4E50 \u5BB6\u96FB \u5E7F\u4E1C \u5FAE\u535A \u6148\u5584 \u6211\u7231\u4F60 \u624B\u673A \u62DB\u8058 \u653F\u52A1 \u653F\u5E9C \u65B0\u52A0\u5761 \u65B0\u95FB \u65F6\u5C1A \u66F8\u7C4D \u673A\u6784 \u6DE1\u9A6C\u9521 \u6E38\u620F \u6FB3\u9580 \u70B9\u770B \u79FB\u52A8 \u7EC4\u7EC7\u673A\u6784 \u7F51\u5740 \u7F51\u5E97 \u7F51\u7AD9 \u7F51\u7EDC \u8054\u901A \u8BFA\u57FA\u4E9A \u8C37\u6B4C \u8D2D\u7269 \u901A\u8CA9 \u96C6\u56E2 \u96FB\u8A0A\u76C8\u79D1 \u98DE\u5229\u6D66 \u98DF\u54C1 \u9910\u5385 \u9999\u683C\u91CC\u62C9 \u9999\u6E2F".split(" ");
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
var EMOJI_VARIATION = /\uFE0F/;
var DIGIT = /\d/;
var SPACE = /\s/;
function init$2() {
  var customProtocols = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var S_START = makeState();
  var S_NUM = makeAcceptingState(NUM);
  var S_DOMAIN = makeAcceptingState(DOMAIN);
  var S_DOMAIN_HYPHEN = makeState();
  var S_WS = makeAcceptingState(WS);
  var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]];
  var makeDomainState = function makeDomainState2() {
    var state2 = makeAcceptingState(DOMAIN);
    state2.j = {
      "-": S_DOMAIN_HYPHEN
    };
    state2.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
    return state2;
  };
  var makeNearDomainState = function makeNearDomainState2(token2) {
    var state2 = makeDomainState();
    state2.t = token2;
    return state2;
  };
  makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ["{", makeAcceptingState(OPENBRACE)], ["[", makeAcceptingState(OPENBRACKET)], ["<", makeAcceptingState(OPENANGLEBRACKET)], ["(", makeAcceptingState(OPENPAREN)], ["}", makeAcceptingState(CLOSEBRACE)], ["]", makeAcceptingState(CLOSEBRACKET)], [">", makeAcceptingState(CLOSEANGLEBRACKET)], [")", makeAcceptingState(CLOSEPAREN)], ["&", makeAcceptingState(AMPERSAND)], ["*", makeAcceptingState(ASTERISK)], ["@", makeAcceptingState(AT)], ["`", makeAcceptingState(BACKTICK)], ["^", makeAcceptingState(CARET)], [":", makeAcceptingState(COLON)], [",", makeAcceptingState(COMMA)], ["$", makeAcceptingState(DOLLAR)], [".", makeAcceptingState(DOT)], ["=", makeAcceptingState(EQUALS)], ["!", makeAcceptingState(EXCLAMATION)], ["-", makeAcceptingState(HYPHEN)], ["%", makeAcceptingState(PERCENT)], ["|", makeAcceptingState(PIPE)], ["+", makeAcceptingState(PLUS)], ["#", makeAcceptingState(POUND)], ["?", makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ["/", makeAcceptingState(SLASH)], [";", makeAcceptingState(SEMI)], ["~", makeAcceptingState(TILDE)], ["_", makeAcceptingState(UNDERSCORE)], ["\\", makeAcceptingState(BACKSLASH)]]);
  makeT(S_START, "\n", makeAcceptingState(NL));
  makeRegexT(S_START, SPACE, S_WS);
  makeT(S_WS, "\n", makeState());
  makeRegexT(S_WS, SPACE, S_WS);
  for (var i = 0; i < tlds2.length; i++) {
    makeChainT(S_START, tlds2[i], makeNearDomainState(TLD), makeDomainState);
  }
  var S_PROTOCOL_FILE = makeDomainState();
  var S_PROTOCOL_FTP = makeDomainState();
  var S_PROTOCOL_HTTP = makeDomainState();
  var S_MAILTO = makeDomainState();
  makeChainT(S_START, "file", S_PROTOCOL_FILE, makeDomainState);
  makeChainT(S_START, "ftp", S_PROTOCOL_FTP, makeDomainState);
  makeChainT(S_START, "http", S_PROTOCOL_HTTP, makeDomainState);
  makeChainT(S_START, "mailto", S_MAILTO, makeDomainState);
  var S_PROTOCOL_SECURE = makeDomainState();
  var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL);
  var S_FULL_MAILTO = makeAcceptingState(MAILTO);
  makeT(S_PROTOCOL_FTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_FTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_HTTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_HTTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_FILE, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_SECURE, ":", S_FULL_PROTOCOL);
  makeT(S_MAILTO, ":", S_FULL_MAILTO);
  var S_CUSTOM_PROTOCOL = makeDomainState();
  for (var _i = 0; _i < customProtocols.length; _i++) {
    makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
  }
  makeT(S_CUSTOM_PROTOCOL, ":", S_FULL_PROTOCOL);
  makeChainT(S_START, "localhost", makeNearDomainState(LOCALHOST), makeDomainState);
  makeRegexT(S_START, DIGIT, S_NUM);
  makeRegexT(S_START, LETTER, S_DOMAIN);
  makeRegexT(S_START, EMOJI, S_DOMAIN);
  makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_NUM, DIGIT, S_NUM);
  makeRegexT(S_NUM, LETTER, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN);
  makeT(S_NUM, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN_HYPHEN, "-", S_DOMAIN_HYPHEN);
  makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN);
  S_START.jd = makeAcceptingState(SYM);
  return S_START;
}
function run$1(start2, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c) {
    return c.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state2 = start2;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = takeT(state2, iterable[charCursor]))) {
      state2 = nextState;
      if (state2.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state2;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      v: str.substr(cursor - tokenLength, tokenLength),
      s: cursor - tokenLength,
      e: cursor
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index2 = 0;
  while (index2 < len) {
    var first2 = str.charCodeAt(index2);
    var second = void 0;
    var char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
var defaults$1 = {
  defaultProtocol: "http",
  events: null,
  format: noop$3,
  formatHref: noop$3,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: 0,
  className: null,
  attributes: null,
  ignoreTags: []
};
function noop$3(val) {
  return val;
}
function inherits(parent, child) {
  var props2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var extended = Object.create(parent.prototype);
  for (var p2 in props2) {
    extended[p2] = props2[p2];
  }
  extended.constructor = child;
  child.prototype = extended;
  return child;
}
function MultiToken() {
}
MultiToken.prototype = {
  t: "token",
  isLink: false,
  toString: function toString2() {
    return this.v;
  },
  toHref: function toHref() {
    return this.toString();
  },
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject: function toObject() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults$1.defaultProtocol;
    return {
      type: this.t,
      value: this.v,
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  }
};
function createTokenClass(type, props2) {
  function Token2(value, tokens) {
    this.t = type;
    this.v = value;
    this.tk = tokens;
  }
  inherits(MultiToken, Token2, props2);
  return Token2;
}
var MailtoEmail = createTokenClass("email", {
  isLink: true
});
var Email = createTokenClass("email", {
  isLink: true,
  toHref: function toHref2() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  toHref: function toHref3() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults$1.defaultProtocol;
    var tokens = this.tk;
    var hasProtocol2 = false;
    var hasSlashSlash = false;
    var result = [];
    var i = 0;
    while (tokens[i].t === PROTOCOL) {
      hasProtocol2 = true;
      result.push(tokens[i].v);
      i++;
    }
    while (tokens[i].t === SLASH) {
      hasSlashSlash = true;
      result.push(tokens[i].v);
      i++;
    }
    for (; i < tokens.length; i++) {
      result.push(tokens[i].v);
    }
    result = result.join("");
    if (!(hasProtocol2 || hasSlashSlash)) {
      result = "".concat(protocol, "://").concat(result);
    }
    return result;
  },
  hasProtocol: function hasProtocol() {
    return this.tk[0].t === PROTOCOL;
  }
});
var multi = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  MailtoEmail,
  Email,
  Text,
  Nl,
  Url
});
function init$1() {
  var S_START = makeState();
  var S_PROTOCOL = makeState();
  var S_MAILTO = makeState();
  var S_PROTOCOL_SLASH = makeState();
  var S_PROTOCOL_SLASH_SLASH = makeState();
  var S_DOMAIN = makeState();
  var S_DOMAIN_DOT = makeState();
  var S_TLD = makeAcceptingState(Url);
  var S_TLD_COLON = makeState();
  var S_TLD_PORT = makeAcceptingState(Url);
  var S_URL = makeAcceptingState(Url);
  var S_URL_NON_ACCEPTING = makeState();
  var S_URL_OPENBRACE = makeState();
  var S_URL_OPENBRACKET = makeState();
  var S_URL_OPENANGLEBRACKET = makeState();
  var S_URL_OPENPAREN = makeState();
  var S_URL_OPENBRACE_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENPAREN_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACE_SYMS = makeState();
  var S_URL_OPENBRACKET_SYMS = makeState();
  var S_URL_OPENANGLEBRACKET_SYMS = makeState();
  var S_URL_OPENPAREN_SYMS = makeState();
  var S_EMAIL_DOMAIN = makeState();
  var S_EMAIL_DOMAIN_DOT = makeState();
  var S_EMAIL = makeAcceptingState(Email);
  var S_EMAIL_COLON = makeState();
  var S_EMAIL_PORT = makeAcceptingState(Email);
  var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail);
  var S_MAILTO_EMAIL_NON_ACCEPTING = makeState();
  var S_LOCALPART = makeState();
  var S_LOCALPART_AT = makeState();
  var S_LOCALPART_DOT = makeState();
  var S_NL = makeAcceptingState(Nl);
  makeT(S_START, NL, S_NL);
  makeT(S_START, PROTOCOL, S_PROTOCOL);
  makeT(S_START, MAILTO, S_MAILTO);
  makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
  makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH);
  makeT(S_START, TLD, S_DOMAIN);
  makeT(S_START, DOMAIN, S_DOMAIN);
  makeT(S_START, LOCALHOST, S_TLD);
  makeT(S_START, NUM, S_DOMAIN);
  makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL);
  makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_DOMAIN_DOT, TLD, S_TLD);
  makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
  makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
  makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
  makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN);
  makeT(S_TLD, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_TLD, COLON, S_TLD_COLON);
  makeT(S_TLD, SLASH, S_URL);
  makeT(S_TLD_COLON, NUM, S_TLD_PORT);
  makeT(S_TLD_PORT, SLASH, S_URL);
  makeT(S_EMAIL, COLON, S_EMAIL_COLON);
  makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT);
  var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL);
  makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL, qsAccepting, S_URL);
  makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
  makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
  makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
  makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
  makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
  makeT(S_DOMAIN, AT, S_LOCALPART_AT);
  makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
  makeT(S_TLD, AT, S_LOCALPART_AT);
  makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART);
  makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART, AT, S_LOCALPART_AT);
  makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
  makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL);
  return S_START;
}
function run(start2, input2, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];
  while (cursor < len) {
    var state2 = start2;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor < len && !(secondState = takeT(state2, tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || takeT(state2, tokens[cursor].t))) {
      secondState = null;
      state2 = nextState;
      if (state2.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state2;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      for (var i = cursor - multiLength; i < cursor; i++) {
        textTokens.push(tokens[i]);
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(parserCreateMultiToken(Text, input2, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(parserCreateMultiToken(Multi, input2, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(parserCreateMultiToken(Text, input2, textTokens));
  }
  return multis;
}
function parserCreateMultiToken(Multi, input2, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input2.substr(startIdx, endIdx - startIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || function() {
};
var INIT = {
  scanner: null,
  parser: null,
  pluginQueue: [],
  customProtocols: [],
  initialized: false
};
function registerCustomProtocol(protocol) {
  if (INIT.initialized) {
    warn('linkifyjs: already initialized - will not register custom protocol "'.concat(protocol, '" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.'));
  }
  if (!/^[a-z-]+$/.test(protocol)) {
    throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");
  }
  INIT.customProtocols.push(protocol);
}
function init() {
  INIT.scanner = {
    start: init$2(INIT.customProtocols),
    tokens: text$1
  };
  INIT.parser = {
    start: init$1(),
    tokens: multi
  };
  var utils2 = {
    createTokenClass
  };
  for (var i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser,
      utils: utils2
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find$1(str) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  var filtered = [];
  for (var i = 0; i < tokens.length; i++) {
    var token2 = tokens[i];
    if (token2.isLink && (!type || token2.t === type)) {
      filtered.push(token2.toObject());
    }
  }
  return filtered;
}
function test2(str) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
}
function autolink2(options2) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr } = newState;
      const transform2 = combineTransactionSteps(oldState.doc, [...transactions]);
      const { mapping } = transform2;
      const changes = getChangedRanges(transform2);
      changes.forEach(({ oldRange, newRange }) => {
        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter((item) => item.mark.type === options2.type).forEach((oldMark) => {
          const newFrom = mapping.map(oldMark.from);
          const newTo = mapping.map(oldMark.to);
          const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter((item) => item.mark.type === options2.type);
          if (!newMarks.length) {
            return;
          }
          const newMark = newMarks[0];
          const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, void 0, " ");
          const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, void 0, " ");
          const wasLink = test2(oldLinkText);
          const isLink = test2(newLinkText);
          if (wasLink && !isLink) {
            tr.removeMark(newMark.from, newMark.to, options2.type);
          }
        });
        findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock).forEach((textBlock) => {
          const text3 = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
          find$1(text3).filter((link3) => link3.isLink).filter((link3) => {
            if (options2.validate) {
              return options2.validate(link3.value);
            }
            return true;
          }).map((link3) => __spreadProps(__spreadValues({}, link3), {
            from: textBlock.pos + link3.start + 1,
            to: textBlock.pos + link3.end + 1
          })).filter((link3) => {
            const fromIsInRange = newRange.from >= link3.from && newRange.from <= link3.to;
            const toIsInRange = newRange.to >= link3.from && newRange.to <= link3.to;
            return fromIsInRange || toIsInRange;
          }).forEach((link3) => {
            tr.addMark(link3.from, link3.to, options2.type.create({
              href: link3.href
            }));
          });
        });
      });
      if (!tr.steps.length) {
        return;
      }
      return tr;
    }
  });
}
function clickHandler(options2) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a;
        const attrs = getAttributes(view.state, options2.type.name);
        const link3 = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest("a");
        if (link3 && attrs.href) {
          window.open(attrs.href, attrs.target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options2) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state: state2 } = view;
        const { selection } = state2;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link3 = find$1(textContent).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link3) {
          return false;
        }
        options2.editor.commands.setMark(options2.type, {
          href: link3.href
        });
        return true;
      }
    }
  });
}
const Link$1 = Mark.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  onCreate() {
    this.options.protocols.forEach(registerCustomProtocol);
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      { tag: 'a[href]:not([href *= "javascript:" i])' }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return [
      "a",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text3) => find$1(text3).filter((link3) => {
          if (this.options.validate) {
            return this.options.validate(link3.value);
          }
          return true;
        }).filter((link3) => link3.isLink).map((link3) => ({
          text: link3.value,
          index: link3.start,
          data: link3
        })),
        type: this.type,
        getAttributes: (match2) => {
          var _a;
          return {
            href: (_a = match2.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins2 = [];
    if (this.options.autolink) {
      plugins2.push(autolink2({
        type: this.type,
        validate: this.options.validate
      }));
    }
    if (this.options.openOnClick) {
      plugins2.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins2.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins2;
  }
});
var Link = Link$1.extend({
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("handleClick"),
        props: {
          handleClick: (view, pos, event) => {
            const attrs = this.editor.getAttributes("link");
            if (attrs.href && event.target instanceof HTMLAnchorElement) {
              setTimeout(() => {
                this.editor.emit("fui:link-clicked");
              }, 50);
              return true;
            }
          }
        }
      })
    ];
  }
});
var VariableTag_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => `.fui-tag-wrap[data-v-0ca78c5c] {
  display: inline-flex;
  margin: 0 1px;
  cursor: default;
}
.fui-tag[data-v-0ca78c5c] {
  position: relative;
  background-color: #5C6BC0;
  color: #fff;
  border-radius: 2px;
  display: inline-flex;
  padding: 0 5px;
  margin: 0;
  font-size: 12px;
  padding-right: 20px;
  white-space: nowrap;
}
.fui-tag.is-active[data-v-0ca78c5c] {
  outline: none;
  box-shadow: 0 0 0 3px rgba(123, 140, 232, 0.5);
}
.fui-tag .fui-tag-delete[data-v-0ca78c5c] {
  position: absolute;
  top: 50%;
  right: 3px;
  width: 12px;
  height: 12px;
  background-size: contain;
  transform: translateY(-50%);
  background-position: center center;
  background-repeat: no-repeat;
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%23fff' d='M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z'/%3E%3C/svg%3E");
}`)();
const _sfc_main$m = {
  name: "VariableTag",
  components: {
    NodeViewWrapper
  },
  props: {
    editor: {
      type: Object,
      default: () => {
      }
    },
    node: {
      type: Object,
      default: () => {
      }
    },
    decorations: {
      type: Array,
      default: () => {
        return [];
      }
    },
    selected: {
      type: Boolean,
      default: false
    },
    extension: {
      type: Object,
      default: () => {
      }
    },
    getPos: {
      type: Function,
      default: () => {
      }
    },
    updateAttributes: {
      type: Function,
      default: () => {
      }
    }
  },
  computed: {
    label() {
      return this.node.attrs.label;
    },
    value() {
      return this.node.attrs.value;
    }
  },
  methods: {
    destroy() {
      const pos = this.getPos();
      const range2 = { from: pos, to: pos + (this.node.nodeSize - 1) };
      this.editor.chain().focus().deleteRange(range2).run();
    }
  }
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_node_view_wrapper = resolveComponent("node-view-wrapper");
  return openBlock(), createBlock(_component_node_view_wrapper, {
    as: "span",
    class: normalizeClass(["fui-tag-wrap", { "active": $props.selected }]),
    contenteditable: "false",
    "data-drag-handle": ""
  }, {
    default: withCtx(() => [
      createBaseVNode("span", {
        class: normalizeClass(["fui-tag", { "is-active": $props.selected }]),
        contenteditable: "false"
      }, [
        createTextVNode(toDisplayString($options.label) + " ", 1),
        createBaseVNode("span", {
          class: "fui-tag-delete",
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.destroy && $options.destroy(...args), ["prevent"]))
        })
      ], 2)
    ]),
    _: 1
  }, 8, ["class"]);
}
var VariableTagView = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l], ["__scopeId", "data-v-0ca78c5c"], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/variable-tag/VariableTag.vue"]]);
var VariableTag = Node$1.create({
  name: "variableTag",
  group: "inline",
  inline: true,
  selectable: true,
  draggable: true,
  atom: true,
  addAttributes() {
    return {
      label: { default: null },
      value: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "variable-tag",
        getAttrs: (dom2) => {
          return JSON.parse(dom2.innerHTML);
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["variable-tag", JSON.stringify(HTMLAttributes)];
  },
  addCommands() {
    return {
      setVariableTag: (options2) => {
        return ({
          tr,
          dispatch: dispatch2,
          view,
          state: state2
        }) => {
          const { selection } = state2;
          const position = selection.$cursor ? selection.$cursor.pos : selection.$to.pos;
          const node = this.type.create(options2);
          const transaction = state2.tr.insert(position, node);
          dispatch2(transaction);
        };
      }
    };
  },
  addNodeView() {
    return VueNodeViewRenderer(VariableTagView);
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          handleKeyDown: (view, event) => {
            view.state.typing = true;
          },
          handlePaste: (view, event, slice2) => {
            view.state.pasting = true;
          }
        },
        filterTransaction: (transaction, state2) => {
          let result = true;
          if (state2.typing || state2.pasting) {
            transaction.mapping.maps.forEach((map3) => {
              map3.forEach((oldStart, oldEnd, newStart, newEnd) => {
                state2.doc.nodesBetween(oldStart, oldEnd, (node, number3, pos, parent, index2) => {
                  if (node.type.name === "variableTag") {
                    result = false;
                  }
                });
              });
            });
          }
          return result;
        }
      })
    ];
  }
});
var lightBorder = /* @__PURE__ */ (() => '.tippy-box[data-theme~=light-border]{background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,8,16,.15);color:#333;box-shadow:0 4px 14px -2px rgba(0,8,16,.08)}.tippy-box[data-theme~=light-border]>.tippy-backdrop{background-color:#fff}.tippy-box[data-theme~=light-border]>.tippy-arrow:after,.tippy-box[data-theme~=light-border]>.tippy-svg-arrow:after{content:"";position:absolute;z-index:-1}.tippy-box[data-theme~=light-border]>.tippy-arrow:after{border-color:transparent;border-style:solid}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-arrow:before{border-top-color:#fff}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-arrow:after{border-top-color:rgba(0,8,16,.2);border-width:7px 7px 0;top:17px;left:1px}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-svg-arrow>svg{top:16px}.tippy-box[data-theme~=light-border][data-placement^=top]>.tippy-svg-arrow:after{top:17px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:#fff;bottom:16px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-arrow:after{border-bottom-color:rgba(0,8,16,.2);border-width:0 7px 7px;bottom:17px;left:1px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-svg-arrow>svg{bottom:16px}.tippy-box[data-theme~=light-border][data-placement^=bottom]>.tippy-svg-arrow:after{bottom:17px}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-arrow:before{border-left-color:#fff}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-arrow:after{border-left-color:rgba(0,8,16,.2);border-width:7px 0 7px 7px;left:17px;top:1px}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-svg-arrow>svg{left:11px}.tippy-box[data-theme~=light-border][data-placement^=left]>.tippy-svg-arrow:after{left:12px}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-arrow:before{border-right-color:#fff;right:16px}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-arrow:after{border-width:7px 7px 7px 0;right:17px;top:1px;border-right-color:rgba(0,8,16,.2)}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-svg-arrow>svg{right:11px}.tippy-box[data-theme~=light-border][data-placement^=right]>.tippy-svg-arrow:after{right:12px}.tippy-box[data-theme~=light-border]>.tippy-svg-arrow{fill:#fff}.tippy-box[data-theme~=light-border]>.tippy-svg-arrow:after{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHoiIGZpbGw9InJnYmEoMCwgOCwgMTYsIDAuMikiLz48L3N2Zz4=);background-size:16px 6px;width:16px;height:6px}')();
/*!
 * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$1(target2, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target2;
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target2, props2) {
  for (var i = 0; i < props2.length; i++) {
    var descriptor = props2[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target2, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var noop = function noop2() {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== "undefined")
    _WINDOW = window;
  if (typeof document !== "undefined")
    _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined")
    _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined")
    _PERFORMANCE = performance;
} catch (e) {
}
var _ref = _WINDOW.navigator || {}, _ref$userAgent = _ref.userAgent, userAgent$1 = _ref$userAgent === void 0 ? "" : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
var IS_IE = ~userAgent$1.indexOf("MSIE") || ~userAgent$1.indexOf("Trident/");
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_FAMILY_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
var DATA_PREFIX = "data-prefix";
var DATA_ICON = "data-icon";
var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
var MUTATION_APPROACH_ASYNC = "async";
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var PRODUCTION$1 = function() {
  try {
    return false;
  } catch (e) {
    return false;
  }
}();
var PREFIX_TO_STYLE = {
  "fas": "solid",
  "fa-solid": "solid",
  "far": "regular",
  "fa-regular": "regular",
  "fal": "light",
  "fa-light": "light",
  "fat": "thin",
  "fa-thin": "thin",
  "fad": "duotone",
  "fa-duotone": "duotone",
  "fab": "brands",
  "fa-brands": "brands",
  "fak": "kit",
  "fa-kit": "kit",
  "fa": "solid"
};
var STYLE_TO_PREFIX = {
  "solid": "fas",
  "regular": "far",
  "light": "fal",
  "thin": "fat",
  "duotone": "fad",
  "brands": "fab",
  "kit": "fak"
};
var PREFIX_TO_LONG_STYLE = {
  "fab": "fa-brands",
  "fad": "fa-duotone",
  "fak": "fa-kit",
  "fal": "fa-light",
  "far": "fa-regular",
  "fas": "fa-solid",
  "fat": "fa-thin"
};
var LONG_STYLE_TO_PREFIX = {
  "fa-brands": "fab",
  "fa-duotone": "fad",
  "fa-kit": "fak",
  "fa-light": "fal",
  "fa-regular": "far",
  "fa-solid": "fas",
  "fa-thin": "fat"
};
var ICON_SELECTION_SYNTAX_PATTERN = /fa[srltdbk\-\ ]/;
var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
var FONT_FAMILY_PATTERN = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Kit)?.*/i;
var FONT_WEIGHT_TO_PREFIX = {
  "900": "fas",
  "400": "far",
  "normal": "far",
  "300": "fal",
  "100": "fat"
};
var oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var DUOTONE_CLASSES = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var RESERVED_CLASSES = [].concat(_toConsumableArray$1(Object.keys(STYLE_TO_PREFIX)), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", DUOTONE_CLASSES.GROUP, DUOTONE_CLASSES.SWAP_OPACITY, DUOTONE_CLASSES.PRIMARY, DUOTONE_CLASSES.SECONDARY]).concat(oneToTen.map(function(n) {
  return "".concat(n, "x");
})).concat(oneToTwenty.map(function(n) {
  return "w-".concat(n);
}));
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "")
    return true;
  if (val === "false")
    return false;
  if (val === "true")
    return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  var attrs = [["data-family-prefix", "familyPrefix"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach(function(_ref2) {
    var _ref22 = _slicedToArray(_ref2, 2), attr = _ref22[0], key = _ref22[1];
    var val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  styleDefault: "solid",
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
var _config = _objectSpread2$1(_objectSpread2$1({}, _default), initial);
if (!_config.autoReplaceSvg)
  _config.observeMutations = false;
var config = {};
Object.keys(_config).forEach(function(key) {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function set3(val) {
      _config[key] = val;
      _onChangeCb.forEach(function(cb) {
        return cb(config);
      });
    },
    get: function get4() {
      return _config[key];
    }
  });
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return function() {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  var style2 = DOCUMENT.createElement("style");
  style2.setAttribute("type", "text/css");
  style2.innerHTML = css2;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;
  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style2, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  var size2 = 12;
  var id = "";
  while (size2-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function toArray(obj) {
  var array = [];
  for (var i = (obj || []).length >>> 0; i--; ) {
    array[i] = obj[i];
  }
  return array;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute("class") || "").split(" ").filter(function(i) {
      return i;
    });
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function(acc, attributeName) {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform2) {
  return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
}
function transformForSvg(_ref2) {
  var transform2 = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
  var outer2 = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
  var innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
  var inner2 = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer: outer2,
    inner: inner2,
    path
  };
}
function transformForCss(_ref2) {
  var transform2 = _ref2.transform, _ref2$width = _ref2.width, width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height, _ref2$startCentered = _ref2.startCentered, startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform2.x / d - width / 2, "em, ").concat(transform2.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform2.x / d, "em), calc(-50% + ").concat(transform2.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform2.x / d, "em, ").concat(transform2.y / d, "em) ");
  }
  val += "scale(".concat(transform2.size / d * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / d * (transform2.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform2.rotate, "deg) ");
  return val;
}
var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0);\n          animation-delay: var(--fa-animation-delay, 0);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
function css$1() {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc = config.replacementClass;
  var s = baseStyles;
  if (fp !== dfp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), "g");
    var customPropPatt = new RegExp("\\--".concat(dfp, "\\-"), "g");
    var rPatt = new RegExp("\\.".concat(drc), "g");
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s;
}
var _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css$1());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout: function mixout() {
    return {
      dom: {
        css: css$1,
        insertCss: ensureCss
      }
    };
  },
  hooks: function hooks() {
    return {
      beforeDOMElementCreation: function beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg: function beforeI2svg() {
        ensureCss();
      }
    };
  }
};
var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER])
  w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles)
  w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks)
  w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims)
  w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function listener2() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener2);
  loaded = 1;
  functions.map(function(fn2) {
    return fn2();
  });
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded)
    DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
function domready(fn2) {
  if (!IS_DOM)
    return;
  loaded ? setTimeout(fn2, 0) : functions.push(fn2);
}
function toHtml(abstractNodes) {
  var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix2, iconName) {
  if (mapping && mapping[prefix2] && mapping[prefix2][iconName]) {
    return {
      prefix: prefix2,
      iconName,
      icon: mapping[prefix2][iconName]
    };
  }
}
var bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a, b, c, d2) {
    return func.call(thisContext, a, b, c, d2);
  };
};
var reduce = function fastReduceObject(subject, fn2, initialValue2, thisContext) {
  var keys2 = Object.keys(subject), length3 = keys2.length, iterator = thisContext !== void 0 ? bindInternal4(fn2, thisContext) : fn2, i, key, result;
  if (initialValue2 === void 0) {
    i = 1;
    result = subject[keys2[0]];
  } else {
    i = 0;
    result = initialValue2;
  }
  for (; i < length3; i++) {
    key = keys2[i];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};
function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length3 = string.length;
  while (counter < length3) {
    var value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length3) {
      var extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function toHex(unicode) {
  var decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index2) {
  var size2 = string.length;
  var first2 = string.charCodeAt(index2);
  var second;
  if (first2 >= 55296 && first2 <= 56319 && size2 > index2 + 1) {
    second = string.charCodeAt(index2 + 1);
    if (second >= 56320 && second <= 57343) {
      return (first2 - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first2;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce(function(acc, iconName) {
    var icon3 = icons[iconName];
    var expanded = !!icon3.icon;
    if (expanded) {
      acc[icon3.iconName] = icon3.icon;
    } else {
      acc[iconName] = icon3;
    }
    return acc;
  }, {});
}
function defineIcons(prefix2, icons) {
  var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix2, normalizeIcons(icons));
  } else {
    namespace.styles[prefix2] = _objectSpread2$1(_objectSpread2$1({}, namespace.styles[prefix2] || {}), normalized);
  }
  if (prefix2 === "fas") {
    defineIcons("fa", icons);
  }
}
var styles = namespace.styles, shims = namespace.shims;
var LONG_STYLE = Object.values(PREFIX_TO_LONG_STYLE);
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
var PREFIXES = Object.keys(PREFIX_TO_STYLE);
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(familyPrefix, cls) {
  var parts = cls.split("-");
  var prefix2 = parts[0];
  var iconName = parts.slice(1).join("-");
  if (prefix2 === familyPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = function build2() {
  var lookup = function lookup2(reducer) {
    return reduce(styles, function(o, style2, prefix2) {
      o[prefix2] = reduce(style2, reducer, {});
      return o;
    }, {});
  };
  _byUnicode = lookup(function(acc, icon3, iconName) {
    if (icon3[3]) {
      acc[icon3[3]] = iconName;
    }
    if (icon3[2]) {
      var aliases = icon3[2].filter(function(a) {
        return typeof a === "number";
      });
      aliases.forEach(function(alias) {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup(function(acc, icon3, iconName) {
    acc[iconName] = iconName;
    if (icon3[2]) {
      var aliases = icon3[2].filter(function(a) {
        return typeof a === "string";
      });
      aliases.forEach(function(alias) {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup(function(acc, icon3, iconName) {
    var aliases = icon3[2];
    acc[iconName] = iconName;
    aliases.forEach(function(alias) {
      acc[alias] = iconName;
    });
    return acc;
  });
  var hasRegular = "far" in styles || config.autoFetchSvg;
  var shimLookups = reduce(shims, function(acc, shim) {
    var maybeNameMaybeUnicode = shim[0];
    var prefix2 = shim[1];
    var iconName = shim[2];
    if (prefix2 === "far" && !hasRegular) {
      prefix2 = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix: prefix2,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix: prefix2,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault);
};
onChange(function(c) {
  _defaultUsablePrefix = getCanonicalPrefix(c.styleDefault);
});
build();
function byUnicode(prefix2, unicode) {
  return (_byUnicode[prefix2] || {})[unicode];
}
function byLigature(prefix2, ligature) {
  return (_byLigature[prefix2] || {})[ligature];
}
function byAlias(prefix2, alias) {
  return (_byAlias[prefix2] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  var oldUnicode = _byOldUnicode[unicode];
  var newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = function emptyCanonicalIcon2() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  var style2 = PREFIX_TO_STYLE[styleOrPrefix];
  var prefix2 = STYLE_TO_PREFIX[styleOrPrefix] || STYLE_TO_PREFIX[style2];
  var defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  return prefix2 || defined || null;
}
function getCanonicalIcon(values) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$skipLookups = params.skipLookups, skipLookups = _params$skipLookups === void 0 ? false : _params$skipLookups;
  var givenPrefix = null;
  var canonical = values.reduce(function(acc, cls) {
    var iconName = getIconName(config.familyPrefix, cls);
    if (styles[cls]) {
      cls = LONG_STYLE.includes(cls) ? LONG_STYLE_TO_PREFIX[cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES.indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls);
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass) {
      acc.rest.push(cls);
    }
    if (!skipLookups && acc.prefix && acc.iconName) {
      var shim = givenPrefix === "fa" ? byOldName(acc.iconName) : {};
      var aliasIconName = byAlias(acc.prefix, acc.iconName);
      if (shim.prefix) {
        givenPrefix = null;
      }
      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;
      if (acc.prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
        acc.prefix = "fas";
      }
    }
    return acc;
  }, emptyCanonicalIcon());
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
var Library = /* @__PURE__ */ function() {
  function Library2() {
    _classCallCheck(this, Library2);
    this.definitions = {};
  }
  _createClass(Library2, [{
    key: "add",
    value: function add3() {
      var _this = this;
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function(key) {
        _this.definitions[key] = _objectSpread2$1(_objectSpread2$1({}, _this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]);
        var longPrefix = PREFIX_TO_LONG_STYLE[key];
        if (longPrefix)
          defineIcons(longPrefix, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset2() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function(key) {
        var _normalized$key = normalized[key], prefix2 = _normalized$key.prefix, iconName = _normalized$key.iconName, icon3 = _normalized$key.icon;
        var aliases = icon3[2];
        if (!additions[prefix2])
          additions[prefix2] = {};
        if (aliases.length > 0) {
          aliases.forEach(function(alias) {
            if (typeof alias === "string") {
              additions[prefix2][alias] = icon3;
            }
          });
        }
        additions[prefix2][iconName] = icon3;
      });
      return additions;
    }
  }]);
  return Library2;
}();
var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref2) {
  var obj = _ref2.mixoutsTo;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach(function(k2) {
    if (defaultProviderKeys.indexOf(k2) === -1) {
      delete providers[k2];
    }
  });
  _plugins.forEach(function(plugin2) {
    var mixout8 = plugin2.mixout ? plugin2.mixout() : {};
    Object.keys(mixout8).forEach(function(tk) {
      if (typeof mixout8[tk] === "function") {
        obj[tk] = mixout8[tk];
      }
      if (_typeof$2(mixout8[tk]) === "object") {
        Object.keys(mixout8[tk]).forEach(function(sk) {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout8[tk][sk];
        });
      }
    });
    if (plugin2.hooks) {
      var hooks8 = plugin2.hooks();
      Object.keys(hooks8).forEach(function(hook) {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks8[hook]);
      });
    }
    if (plugin2.provides) {
      plugin2.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function(hookFn) {
    accumulator = hookFn.apply(null, [accumulator].concat(args));
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function(hookFn) {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  var hook = arguments[0];
  var args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  var iconName = iconLookup.iconName;
  var prefix2 = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName)
    return;
  iconName = byAlias(prefix2, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix2, iconName) || iconFromMapping(namespace.styles, prefix2, iconName);
}
var library = new Library();
var noAuto = function noAuto2() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks("noAuto");
};
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject("Operation requires a DOM of some kind.");
    }
  },
  watch: function watch2() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(function() {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks("watch", params);
    });
  }
};
var parse$1 = {
  icon: function icon(_icon) {
    if (_icon === null) {
      return null;
    }
    if (_typeof$2(_icon) === "object" && _icon.prefix && _icon.iconName) {
      return {
        prefix: _icon.prefix,
        iconName: byAlias(_icon.prefix, _icon.iconName) || _icon.iconName
      };
    }
    if (Array.isArray(_icon) && _icon.length === 2) {
      var iconName = _icon[1].indexOf("fa-") === 0 ? _icon[1].slice(3) : _icon[1];
      var prefix2 = getCanonicalPrefix(_icon[0]);
      return {
        prefix: prefix2,
        iconName: byAlias(prefix2, iconName) || iconName
      };
    }
    if (typeof _icon === "string" && (_icon.indexOf("".concat(config.familyPrefix, "-")) > -1 || _icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      var canonicalIcon = getCanonicalIcon(_icon.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof _icon === "string") {
      var _prefix = getDefaultUsablePrefix();
      return {
        prefix: _prefix,
        iconName: byAlias(_prefix, _icon) || _icon
      };
    }
  }
};
var api = {
  noAuto,
  config,
  dom,
  parse: parse$1,
  library,
  findIconDefinition,
  toHtml
};
var autoReplace = function autoReplace2() {
  var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot, autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg)
    api.dom.i2svg({
      node: autoReplaceSvgRoot
    });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function get4() {
      return val.abstract.map(function(a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, "node", {
    get: function get4() {
      if (!IS_DOM)
        return;
      var container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref2) {
  var children = _ref2.children, main2 = _ref2.main, mask = _ref2.mask, attributes = _ref2.attributes, styles2 = _ref2.styles, transform2 = _ref2.transform;
  if (transformIsMeaningful(transform2) && main2.found && !mask.found) {
    var width = main2.width, height = main2.height;
    var offset2 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread2$1(_objectSpread2$1({}, styles2), {}, {
      "transform-origin": "".concat(offset2.x + transform2.x / 16, "em ").concat(offset2.y + transform2.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref2) {
  var prefix2 = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes = _ref2.attributes, symbol = _ref2.symbol;
  var id = symbol === true ? "".concat(prefix2, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread2$1(_objectSpread2$1({}, attributes), {}, {
        id
      }),
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons, main2 = _params$icons.main, mask = _params$icons.mask, prefix2 = params.prefix, iconName = params.iconName, transform2 = params.transform, symbol = params.symbol, title = params.title, maskId = params.maskId, titleId = params.titleId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
  var _ref2 = mask.found ? mask : main2, width = _ref2.width, height = _ref2.height;
  var isUploadedIcon = prefix2 === "fak";
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : ""].filter(function(c) {
    return extra.classes.indexOf(c) === -1;
  }).filter(function(c) {
    return c !== "" || !!c;
  }).concat(extra.classes).join(" ");
  var content = {
    children: [],
    attributes: _objectSpread2$1(_objectSpread2$1({}, extra.attributes), {}, {
      "data-prefix": prefix2,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  var args = _objectSpread2$1(_objectSpread2$1({}, content), {}, {
    prefix: prefix2,
    iconName,
    main: main2,
    mask,
    maskId,
    transform: transform2,
    symbol,
    styles: _objectSpread2$1(_objectSpread2$1({}, uploadedIconWidthStyle), extra.styles)
  });
  var _ref22 = mask.found && main2.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  }, children = _ref22.children, attributes = _ref22.attributes;
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content, width = params.width, height = params.height, transform2 = params.transform, title = params.title, extra = params.extra, _params$watchable2 = params.watchable, watchable = _params$watchable2 === void 0 ? false : _params$watchable2;
  var attributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, extra.attributes), title ? {
    "title": title
  } : {}), {}, {
    "class": extra.classes.join(" ")
  });
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  var styles2 = _objectSpread2$1({}, extra.styles);
  if (transformIsMeaningful(transform2)) {
    styles2["transform"] = transformForCss({
      transform: transform2,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  var content = params.content, title = params.title, extra = params.extra;
  var attributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, extra.attributes), title ? {
    "title": title
  } : {}), {}, {
    "class": extra.classes.join(" ")
  });
  var styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
var styles$1 = namespace.styles;
function asFoundIcon(icon3) {
  var width = icon3[0];
  var height = icon3[1];
  var _icon$slice = icon3.slice(4), _icon$slice2 = _slicedToArray(_icon$slice, 1), vectorData = _icon$slice2[0];
  var element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix2) {
  if (!PRODUCTION$1 && !config.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix2, '" is missing.'));
  }
}
function findIcon(iconName, prefix2) {
  var givenPrefix = prefix2;
  if (prefix2 === "fa" && config.styleDefault !== null) {
    prefix2 = getDefaultUsablePrefix();
  }
  return new Promise(function(resolve2, reject) {
    ({
      found: false,
      width: 512,
      height: 512,
      icon: callProvided("missingIconAbstract") || {}
    });
    if (givenPrefix === "fa") {
      var shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix2 = shim.prefix || prefix2;
    }
    if (iconName && prefix2 && styles$1[prefix2] && styles$1[prefix2][iconName]) {
      var icon3 = styles$1[prefix2][iconName];
      return resolve2(asFoundIcon(icon3));
    }
    maybeNotifyMissing(iconName, prefix2);
    resolve2(_objectSpread2$1(_objectSpread2$1({}, missingIconResolutionMixin), {}, {
      icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    }));
  });
}
var noop$1 = function noop3() {
};
var p = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = 'FA "6.1.1"';
var begin = function begin2(name) {
  p.mark("".concat(preamble, " ").concat(name, " begins"));
  return function() {
    return end(name);
  };
};
var end = function end2(name) {
  p.mark("".concat(preamble, " ").concat(name, " ends"));
  p.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
var noop$2 = function noop4() {
};
function isWatched(node) {
  var i2svg2 = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg2 === "string";
}
function hasPrefixAndIcon(node) {
  var prefix2 = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  var icon3 = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix2 && icon3;
}
function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$ceFn = params.ceFn, ceFn = _params$ceFn === void 0 ? abstractObj.tag === "svg" ? createElementNS : createElement : _params$ceFn;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  var tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  var children = abstractObj.children || [];
  children.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node) {
  var comment2 = " ".concat(node.outerHTML, " ");
  comment2 = "".concat(comment2, "Font Awesome fontawesome.com ");
  return comment2;
}
var mutators = {
  replace: function replace2(mutation) {
    var node = mutation[0];
    if (node.parentNode) {
      mutation[1].forEach(function(abstract) {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });
      if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        var comment2 = DOCUMENT.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment2, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function nest(mutation) {
    var node = mutation[0];
    var abstract = mutation[1];
    if (~classArray(node).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    var forSvg = new RegExp("".concat(config.familyPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      var splitClasses = abstract[0].attributes.class.split(" ").reduce(function(acc, cls) {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node.removeAttribute("class");
      } else {
        node.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    var newInnerHTML = abstract.map(function(a) {
      return toHtml(a);
    }).join("\n");
    node.setAttribute(DATA_FA_I2SVG, "");
    node.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations2, callback) {
  var callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations2.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(function() {
      var mutator = getMutator();
      var mark = perf.begin("mutate");
      mutations2.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options2) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  var _options$treeCallback = options2.treeCallback, treeCallback = _options$treeCallback === void 0 ? noop$2 : _options$treeCallback, _options$nodeCallback = options2.nodeCallback, nodeCallback = _options$nodeCallback === void 0 ? noop$2 : _options$nodeCallback, _options$pseudoElemen = options2.pseudoElementsCallback, pseudoElementsCallback = _options$pseudoElemen === void 0 ? noop$2 : _options$pseudoElemen, _options$observeMutat = options2.observeMutationsRoot, observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function(objects) {
    if (disabled)
      return;
    var defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach(function(mutationRecord) {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)), prefix2 = _getCanonicalIcon.prefix, iconName = _getCanonicalIcon.iconName;
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix2 || defaultPrefix);
          if (iconName)
            mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM)
    return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo)
    return;
  mo.disconnect();
}
function styleParser(node) {
  var style2 = node.getAttribute("style");
  var val = [];
  if (style2) {
    val = style2.split(";").reduce(function(acc, style3) {
      var styles2 = style3.split(":");
      var prop2 = styles2[0];
      var value = styles2.slice(1);
      if (prop2 && value.length > 0) {
        acc[prop2] = value.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node) {
  var existingPrefix = node.getAttribute("data-prefix");
  var existingIconName = node.getAttribute("data-icon");
  var innerText = node.innerText !== void 0 ? node.innerText.trim() : "";
  var val = getCanonicalIcon(classArray(node));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }
  return val;
}
function attributesParser(node) {
  var extraAttributes = toArray(node.attributes).reduce(function(acc, attr) {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  var title = node.getAttribute("title");
  var titleId = node.getAttribute("data-fa-title-id");
  if (config.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  var parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  var _classParser = classParser(node), iconName = _classParser.iconName, prefix2 = _classParser.prefix, extraClasses = _classParser.rest;
  var extraAttributes = attributesParser(node);
  var pluginMeta = chainHooks("parseNodeAttributes", {}, node);
  var extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2$1({
    iconName,
    title: node.getAttribute("title"),
    titleId: node.getAttribute("data-fa-title-id"),
    prefix: prefix2,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}
var styles$2 = namespace.styles;
function generateMutation(node) {
  var nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node, nodeMeta);
  }
}
function onTree(root2) {
  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM)
    return Promise.resolve();
  var htmlClassList = DOCUMENT.documentElement.classList;
  var hclAdd = function hclAdd2(suffix2) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix2));
  };
  var hclRemove = function hclRemove2(suffix2) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix2));
  };
  var prefixes2 = config.autoFetchSvg ? Object.keys(PREFIX_TO_STYLE) : Object.keys(styles$2);
  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map(function(p2) {
    return ".".concat(p2, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  var candidates = [];
  try {
    candidates = toArray(root2.querySelectorAll(prefixesDomQuery));
  } catch (e) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  var mark = perf.begin("onTree");
  var mutations2 = candidates.reduce(function(acc, node) {
    try {
      var mutation = generateMutation(node);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e) {
      if (!PRODUCTION$1) {
        if (e.name === "MissingIcon") {
          console.error(e);
        }
      }
    }
    return acc;
  }, []);
  return new Promise(function(resolve2, reject) {
    Promise.all(mutations2).then(function(resolvedMutations) {
      perform(resolvedMutations, function() {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function")
          callback();
        mark();
        resolve2();
      });
    }).catch(function(e) {
      mark();
      reject(e);
    });
  });
}
function onNode(node) {
  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node).then(function(mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread2$1(_objectSpread2$1({}, params), {}, {
      mask
    }));
  };
}
var render = function render2(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform = params.transform, transform2 = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$titleId = params.titleId, titleId = _params$titleId === void 0 ? null : _params$titleId, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition)
    return;
  var prefix2 = iconDefinition.prefix, iconName = iconDefinition.iconName, icon3 = iconDefinition.icon;
  return domVariants(_objectSpread2$1({
    type: "icon"
  }, iconDefinition), function() {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon3),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix2,
      iconName,
      transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform2),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout: function mixout2() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks: function hooks2() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      var _params$node = params.node, node = _params$node === void 0 ? DOCUMENT : _params$node, _params$callback = params.callback, callback = _params$callback === void 0 ? function() {
      } : _params$callback;
      return onTree(node, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
      var iconName = nodeMeta.iconName, title = nodeMeta.title, titleId = nodeMeta.titleId, prefix2 = nodeMeta.prefix, transform2 = nodeMeta.transform, symbol = nodeMeta.symbol, mask = nodeMeta.mask, maskId = nodeMeta.maskId, extra = nodeMeta.extra;
      return new Promise(function(resolve2, reject) {
        Promise.all([findIcon(iconName, prefix2), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(_ref2) {
          var _ref22 = _slicedToArray(_ref2, 2), main2 = _ref22[0], mask2 = _ref22[1];
          resolve2([node, makeInlineSvgAbstract({
            icons: {
              main: main2,
              mask: mask2
            },
            prefix: prefix2,
            iconName,
            transform: transform2,
            symbol,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref3) {
      var children = _ref3.children, attributes = _ref3.attributes, main2 = _ref3.main, transform2 = _ref3.transform, styles2 = _ref3.styles;
      var styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes["style"] = styleString;
      }
      var nextChild;
      if (transformIsMeaningful(transform2)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main: main2,
          transform: transform2,
          containerWidth: main2.width,
          iconWidth: main2.width
        });
      }
      children.push(nextChild || main2.icon);
      return {
        children,
        attributes
      };
    };
  }
};
var Layers = {
  mixout: function mixout3() {
    return {
      layer: function layer(assembler) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes;
        return domVariants({
          type: "layer"
        }, function() {
          callHooks("beforeDOMElementCreation", {
            assembler,
            params
          });
          var children = [];
          assembler(function(args) {
            Array.isArray(args) ? args.map(function(a) {
              children = children.concat(a.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config.familyPrefix, "-layers")].concat(_toConsumableArray$1(classes)).join(" ")
            },
            children
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout: function mixout4() {
    return {
      counter: function counter(content) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: "counter",
          content
        }, function() {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.familyPrefix, "-layers-counter")].concat(_toConsumableArray$1(classes))
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout: function mixout5() {
    return {
      text: function text3(content) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$transform = params.transform, transform2 = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: "text",
          content
        }, function() {
          callHooks("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform2),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config.familyPrefix, "-layers-text")].concat(_toConsumableArray$1(classes))
            }
          });
        });
      }
    };
  },
  provides: function provides2(providers$$1) {
    providers$$1.generateLayersText = function(node, nodeMeta) {
      var title = nodeMeta.title, transform2 = nodeMeta.transform, extra = nodeMeta.extra;
      var width = null;
      var height = null;
      if (IS_IE) {
        var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        var boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config.autoA11y && !title) {
        extra.attributes["aria-hidden"] = "true";
      }
      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width,
        height,
        transform: transform2,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};
var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
function hexValueFromContent(content) {
  var cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  var codePoint = codePointAt(cleaned, 0);
  var isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  var isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function replaceForPosition(node, position) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
  return new Promise(function(resolve2, reject) {
    if (node.getAttribute(pendingAttribute) !== null) {
      return resolve2();
    }
    var children = toArray(node.children);
    var alreadyProcessedPseudoElement = children.filter(function(c) {
      return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
    })[0];
    var styles2 = WINDOW.getComputedStyle(node, position);
    var fontFamily = styles2.getPropertyValue("font-family").match(FONT_FAMILY_PATTERN);
    var fontWeight = styles2.getPropertyValue("font-weight");
    var content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamily) {
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve2();
    } else if (fontFamily && content !== "none" && content !== "") {
      var _content = styles2.getPropertyValue("content");
      var prefix2 = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(fontFamily[2]) ? STYLE_TO_PREFIX[fontFamily[2].toLowerCase()] : FONT_WEIGHT_TO_PREFIX[fontWeight];
      var _hexValueFromContent = hexValueFromContent(_content), hexValue = _hexValueFromContent.value, isSecondary = _hexValueFromContent.isSecondary;
      var isV4 = fontFamily[0].startsWith("FontAwesome");
      var iconName = byUnicode(prefix2, hexValue);
      var iconIdentifier = iconName;
      if (isV4) {
        var iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix2 = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix2 || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node.removeChild(alreadyProcessedPseudoElement);
        }
        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix2).then(function(main2) {
          var abstract = makeInlineSvgAbstract(_objectSpread2$1(_objectSpread2$1({}, meta), {}, {
            icons: {
              main: main2,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix2,
            iconName: iconIdentifier,
            extra,
            watchable: true
          }));
          var element = DOCUMENT.createElement("svg");
          if (position === "::before") {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }
          element.outerHTML = abstract.map(function(a) {
            return toHtml(a);
          }).join("\n");
          node.removeAttribute(pendingAttribute);
          resolve2();
        }).catch(reject);
      } else {
        resolve2();
      }
    } else {
      resolve2();
    }
  });
}
function replace3(node) {
  return Promise.all([replaceForPosition(node, "::before"), replaceForPosition(node, "::after")]);
}
function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
}
function searchPseudoElements(root2) {
  if (!IS_DOM)
    return;
  return new Promise(function(resolve2, reject) {
    var operations = toArray(root2.querySelectorAll("*")).filter(processable).map(replace3);
    var end3 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(function() {
      end3();
      enableObservation();
      resolve2();
    }).catch(function() {
      end3();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks: function hooks3() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides: function provides3(providers$$1) {
    providers$$1.pseudoElements2svg = function(params) {
      var _params$node = params.node, node = _params$node === void 0 ? DOCUMENT : _params$node;
      if (config.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};
var _unwatched = false;
var MutationObserver$1 = {
  mixout: function mixout6() {
    return {
      dom: {
        unwatch: function unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks: function hooks4() {
    return {
      bootstrap: function bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto: function noAuto3() {
        disconnect();
      },
      watch: function watch3(params) {
        var observeMutationsRoot = params.observeMutationsRoot;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
var parseTransformString = function parseTransformString2(transformString) {
  var transform2 = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce(function(acc, n) {
    var parts = n.toLowerCase().split("-");
    var first2 = parts[0];
    var rest = parts.slice(1).join("-");
    if (first2 && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first2 && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first2) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform2);
};
var PowerTransforms = {
  mixout: function mixout7() {
    return {
      parse: {
        transform: function transform2(transformString) {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks: function hooks5() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var transformString = node.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides: function provides4(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref2) {
      var main2 = _ref2.main, transform2 = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
      var outer2 = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      var innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
      var innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
      var innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
      var inner2 = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      var path = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      var operations = {
        outer: outer2,
        inner: inner2,
        path
      };
      return {
        tag: "g",
        attributes: _objectSpread2$1({}, operations.outer),
        children: [{
          tag: "g",
          attributes: _objectSpread2$1({}, operations.inner),
          children: [{
            tag: main2.icon.tag,
            children: main2.icon.children,
            attributes: _objectSpread2$1(_objectSpread2$1({}, main2.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks: function hooks6() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var maskData = node.getAttribute("data-fa-mask");
        var mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map(function(i) {
          return i.trim();
        }));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides: function provides5(providers2) {
    providers2.generateAbstractMask = function(_ref2) {
      var children = _ref2.children, attributes = _ref2.attributes, main2 = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform2 = _ref2.transform;
      var mainWidth = main2.width, mainPath = main2.icon;
      var maskWidth = mask.width, maskPath = mask.icon;
      var trans = transformForSvg({
        transform: transform2,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      var maskRect = {
        tag: "rect",
        attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
          fill: "white"
        })
      };
      var maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      var maskInnerGroup = {
        tag: "g",
        attributes: _objectSpread2$1({}, trans.inner),
        children: [fillBlack(_objectSpread2$1({
          tag: mainPath.tag,
          attributes: _objectSpread2$1(_objectSpread2$1({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      var maskOuterGroup = {
        tag: "g",
        attributes: _objectSpread2$1({}, trans.outer),
        children: [maskInnerGroup]
      };
      var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      var maskTag = {
        tag: "mask",
        attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [maskRect, maskOuterGroup]
      };
      var defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: "rect",
        attributes: _objectSpread2$1({
          fill: "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children,
        attributes
      };
    };
  }
};
var MissingIconIndicator = {
  provides: function provides6(providers2) {
    var reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      var gChildren = [];
      var FILL = {
        fill: "currentColor"
      };
      var ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var OPACITY_ANIMATE = _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
        attributeName: "opacity"
      });
      var dot2 = {
        tag: "circle",
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      if (!reduceMotion) {
        dot2.children.push({
          tag: "animate",
          attributes: _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
            values: "1;0;1;1;0;1;"
          })
        });
      }
      gChildren.push(dot2);
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          "class": "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks: function hooks7() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
        var symbolData = node.getAttribute("data-fa-symbol");
        var symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol;
        return accumulator;
      }
    };
  }
};
var plugins$1 = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins$1, {
  mixoutsTo: api
});
api.noAuto;
var config$1 = api.config;
var library$1 = api.library;
api.dom;
var parse$1$1 = api.parse;
api.findIconDefinition;
api.toHtml;
var icon2 = api.icon;
api.layer;
var text2 = api.text;
api.counter;
var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var humps = createCommonjsModule(function(module2) {
  (function(global2) {
    var _processKeys = function(convert2, obj, options2) {
      if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
        return obj;
      }
      var output, i = 0, l = 0;
      if (_isArray(obj)) {
        output = [];
        for (l = obj.length; i < l; i++) {
          output.push(_processKeys(convert2, obj[i], options2));
        }
      } else {
        output = {};
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            output[convert2(key, options2)] = _processKeys(convert2, obj[key], options2);
          }
        }
      }
      return output;
    };
    var separateWords = function(string, options2) {
      options2 = options2 || {};
      var separator = options2.separator || "_";
      var split2 = options2.split || /(?=[A-Z])/;
      return string.split(split2).join(separator);
    };
    var camelize2 = function(string) {
      if (_isNumerical(string)) {
        return string;
      }
      string = string.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
        return chr ? chr.toUpperCase() : "";
      });
      return string.substr(0, 1).toLowerCase() + string.substr(1);
    };
    var pascalize = function(string) {
      var camelized = camelize2(string);
      return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
    };
    var decamelize = function(string, options2) {
      return separateWords(string, options2).toLowerCase();
    };
    var toString3 = Object.prototype.toString;
    var _isFunction = function(obj) {
      return typeof obj === "function";
    };
    var _isObject = function(obj) {
      return obj === Object(obj);
    };
    var _isArray = function(obj) {
      return toString3.call(obj) == "[object Array]";
    };
    var _isDate = function(obj) {
      return toString3.call(obj) == "[object Date]";
    };
    var _isRegExp = function(obj) {
      return toString3.call(obj) == "[object RegExp]";
    };
    var _isBoolean = function(obj) {
      return toString3.call(obj) == "[object Boolean]";
    };
    var _isNumerical = function(obj) {
      obj = obj - 0;
      return obj === obj;
    };
    var _processor = function(convert2, options2) {
      var callback = options2 && "process" in options2 ? options2.process : options2;
      if (typeof callback !== "function") {
        return convert2;
      }
      return function(string, options3) {
        return callback(string, convert2, options3);
      };
    };
    var humps2 = {
      camelize: camelize2,
      decamelize,
      pascalize,
      depascalize: decamelize,
      camelizeKeys: function(object, options2) {
        return _processKeys(_processor(camelize2, options2), object);
      },
      decamelizeKeys: function(object, options2) {
        return _processKeys(_processor(decamelize, options2), object, options2);
      },
      pascalizeKeys: function(object, options2) {
        return _processKeys(_processor(pascalize, options2), object);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    if (module2.exports) {
      module2.exports = humps2;
    } else {
      global2.humps = humps2;
    }
  })(commonjsGlobal);
});
var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends$1 = Object.assign || function(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target2[key] = source[key];
      }
    }
  }
  return target2;
};
var objectWithoutProperties = function(obj, keys2) {
  var target2 = {};
  for (var i in obj) {
    if (keys2.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target2[i] = obj[i];
  }
  return target2;
};
var toConsumableArray = function(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  } else {
    return Array.from(arr);
  }
};
function styleToObject(style2) {
  return style2.split(";").map(function(s) {
    return s.trim();
  }).filter(function(s) {
    return s;
  }).reduce(function(output, pair) {
    var idx = pair.indexOf(":");
    var prop2 = humps.camelize(pair.slice(0, idx));
    var value = pair.slice(idx + 1).trim();
    output[prop2] = value;
    return output;
  }, {});
}
function classToObject(classes) {
  return classes.split(/\s+/).reduce(function(output, className) {
    output[className] = true;
    return output;
  }, {});
}
function convert(abstractElement) {
  var props2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof abstractElement === "string") {
    return abstractElement;
  }
  var children = (abstractElement.children || []).map(function(child) {
    return convert(child);
  });
  var mixins = Object.keys(abstractElement.attributes || {}).reduce(function(mixins2, key) {
    var value = abstractElement.attributes[key];
    switch (key) {
      case "class":
        mixins2.class = classToObject(value);
        break;
      case "style":
        mixins2.style = styleToObject(value);
        break;
      default:
        mixins2.attrs[key] = value;
    }
    return mixins2;
  }, {
    attrs: {},
    class: {},
    style: {}
  });
  attrs.class;
  var _attrs$style = attrs.style, aStyle = _attrs$style === void 0 ? {} : _attrs$style, otherAttrs = objectWithoutProperties(attrs, ["class", "style"]);
  return h(abstractElement.tag, _extends$1({}, props2, {
    class: mixins.class,
    style: _extends$1({}, mixins.style, aStyle)
  }, mixins.attrs, otherAttrs), children);
}
var PRODUCTION = false;
try {
  PRODUCTION = false;
} catch (e) {
}
function log() {
  if (!PRODUCTION && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? defineProperty({}, key, value) : {};
}
function classList(props2) {
  var _classes;
  var classes = (_classes = {
    "fa-spin": props2.spin,
    "fa-pulse": props2.pulse,
    "fa-fw": props2.fixedWidth,
    "fa-border": props2.border,
    "fa-li": props2.listItem,
    "fa-inverse": props2.inverse,
    "fa-flip-horizontal": props2.flip === "horizontal" || props2.flip === "both",
    "fa-flip-vertical": props2.flip === "vertical" || props2.flip === "both"
  }, defineProperty(_classes, "fa-" + props2.size, props2.size !== null), defineProperty(_classes, "fa-rotate-" + props2.rotation, props2.rotation !== null), defineProperty(_classes, "fa-pull-" + props2.pull, props2.pull !== null), defineProperty(_classes, "fa-swap-opacity", props2.swapOpacity), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function normalizeIconArgs(icon$$1) {
  if (icon$$1 === null) {
    return null;
  }
  if ((typeof icon$$1 === "undefined" ? "undefined" : _typeof$1(icon$$1)) === "object" && icon$$1.prefix && icon$$1.iconName) {
    return icon$$1;
  }
  if (Array.isArray(icon$$1) && icon$$1.length === 2) {
    return { prefix: icon$$1[0], iconName: icon$$1[1] };
  }
  if (typeof icon$$1 === "string") {
    return { prefix: "fas", iconName: icon$$1 };
  }
}
var FontAwesomeIcon = defineComponent({
  name: "FontAwesomeIcon",
  props: {
    border: {
      type: Boolean,
      default: false
    },
    fixedWidth: {
      type: Boolean,
      default: false
    },
    flip: {
      type: String,
      default: null,
      validator: function validator(value) {
        return ["horizontal", "vertical", "both"].indexOf(value) > -1;
      }
    },
    icon: {
      type: [Object, Array, String],
      required: true
    },
    mask: {
      type: [Object, Array, String],
      default: null
    },
    listItem: {
      type: Boolean,
      default: false
    },
    pull: {
      type: String,
      default: null,
      validator: function validator2(value) {
        return ["right", "left"].indexOf(value) > -1;
      }
    },
    pulse: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function validator3(value) {
        return [90, 180, 270].indexOf(Number.parseInt(value, 10)) > -1;
      }
    },
    swapOpacity: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: null,
      validator: function validator4(value) {
        return ["lg", "xs", "sm", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(value) > -1;
      }
    },
    spin: {
      type: Boolean,
      default: false
    },
    transform: {
      type: [String, Object],
      default: null
    },
    symbol: {
      type: [Boolean, String],
      default: false
    },
    title: {
      type: String,
      default: null
    },
    inverse: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup(props2, _ref2) {
    var attrs = _ref2.attrs;
    var icon$$1 = computed(function() {
      return normalizeIconArgs(props2.icon);
    });
    var classes = computed(function() {
      return objectWithKey("classes", classList(props2));
    });
    var transform2 = computed(function() {
      return objectWithKey("transform", typeof props2.transform === "string" ? parse$1$1.transform(props2.transform) : props2.transform);
    });
    var mask = computed(function() {
      return objectWithKey("mask", normalizeIconArgs(props2.mask));
    });
    var renderedIcon = computed(function() {
      return icon2(icon$$1.value, _extends$1({}, classes.value, transform2.value, mask.value, {
        symbol: props2.symbol,
        title: props2.title
      }));
    });
    watch$1(renderedIcon, function(value) {
      if (!value) {
        return log("Could not find one or more icon(s)", icon$$1.value, mask.value);
      }
    }, { immediate: true });
    var vnode = computed(function() {
      return renderedIcon.value ? convert(renderedIcon.value.abstract[0], {}, attrs) : null;
    });
    return function() {
      return vnode.value;
    };
  }
});
defineComponent({
  name: "FontAwesomeLayers",
  props: {
    fixedWidth: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup2(props2, _ref2) {
    var slots = _ref2.slots;
    var familyPrefix = config$1.familyPrefix;
    var className = computed(function() {
      return [familyPrefix + "-layers"].concat(toConsumableArray(props2.fixedWidth ? [familyPrefix + "-fw"] : []));
    });
    return function() {
      return h("div", { class: className.value }, slots.default ? slots.default() : []);
    };
  }
});
defineComponent({
  name: "FontAwesomeLayersText",
  props: {
    value: {
      type: [String, Number],
      default: ""
    },
    transform: {
      type: [String, Object],
      default: null
    },
    counter: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: null,
      validator: function validator5(value) {
        return ["bottom-left", "bottom-right", "top-left", "top-right"].indexOf(value) > -1;
      }
    }
  },
  setup: function setup3(props2, _ref2) {
    var attrs = _ref2.attrs;
    var familyPrefix = config$1.familyPrefix;
    var classes = computed(function() {
      return objectWithKey("classes", [].concat(toConsumableArray(props2.counter ? [familyPrefix + "-layers-counter"] : []), toConsumableArray(props2.position ? [familyPrefix + "-layers-" + props2.position] : [])));
    });
    var transform2 = computed(function() {
      return objectWithKey("transform", typeof props2.transform === "string" ? parse$1$1.transform(props2.transform) : props2.transform);
    });
    var abstractElement = computed(function() {
      var _text = text2(props2.value.toString(), _extends$1({}, transform2.value, classes.value)), abstract = _text.abstract;
      if (props2.counter) {
        abstract[0].attributes.class = abstract[0].attributes.class.replace("fa-layers-text", "");
      }
      return abstract[0];
    });
    var vnode = computed(function() {
      return convert(abstractElement.value, {}, attrs);
    });
    return function() {
      return vnode.value;
    };
  }
});
/*!
 * Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
var faAlignCenter = {
  prefix: "fas",
  iconName: "align-center",
  icon: [448, 512, [], "f037", "M320 96H128C110.3 96 96 81.67 96 64C96 46.33 110.3 32 128 32H320C337.7 32 352 46.33 352 64C352 81.67 337.7 96 320 96zM416 224H32C14.33 224 0 209.7 0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224zM0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480H32C14.33 480 0 465.7 0 448zM320 352H128C110.3 352 96 337.7 96 320C96 302.3 110.3 288 128 288H320C337.7 288 352 302.3 352 320C352 337.7 337.7 352 320 352z"]
};
var faAlignJustify = {
  prefix: "fas",
  iconName: "align-justify",
  icon: [448, 512, [], "f039", "M416 96H32C14.33 96 0 81.67 0 64C0 46.33 14.33 32 32 32H416C433.7 32 448 46.33 448 64C448 81.67 433.7 96 416 96zM416 352H32C14.33 352 0 337.7 0 320C0 302.3 14.33 288 32 288H416C433.7 288 448 302.3 448 320C448 337.7 433.7 352 416 352zM0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224H32C14.33 224 0 209.7 0 192zM416 480H32C14.33 480 0 465.7 0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480z"]
};
var faAlignLeft = {
  prefix: "fas",
  iconName: "align-left",
  icon: [448, 512, [], "f036", "M256 96H32C14.33 96 0 81.67 0 64C0 46.33 14.33 32 32 32H256C273.7 32 288 46.33 288 64C288 81.67 273.7 96 256 96zM256 352H32C14.33 352 0 337.7 0 320C0 302.3 14.33 288 32 288H256C273.7 288 288 302.3 288 320C288 337.7 273.7 352 256 352zM0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224H32C14.33 224 0 209.7 0 192zM416 480H32C14.33 480 0 465.7 0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480z"]
};
var faAlignRight = {
  prefix: "fas",
  iconName: "align-right",
  icon: [448, 512, [], "f038", "M416 96H192C174.3 96 160 81.67 160 64C160 46.33 174.3 32 192 32H416C433.7 32 448 46.33 448 64C448 81.67 433.7 96 416 96zM416 352H192C174.3 352 160 337.7 160 320C160 302.3 174.3 288 192 288H416C433.7 288 448 302.3 448 320C448 337.7 433.7 352 416 352zM0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224H32C14.33 224 0 209.7 0 192zM416 480H32C14.33 480 0 465.7 0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480z"]
};
var faHighlighter = {
  prefix: "fas",
  iconName: "highlighter",
  icon: [576, 512, [], "f591", "M143.1 320V248.3C143.1 233 151.2 218.7 163.5 209.6L436.6 8.398C444 2.943 452.1 0 462.2 0C473.6 0 484.5 4.539 492.6 12.62L547.4 67.38C555.5 75.46 559.1 86.42 559.1 97.84C559.1 107 557.1 115.1 551.6 123.4L350.4 396.5C341.3 408.8 326.1 416 311.7 416H239.1L214.6 441.4C202.1 453.9 181.9 453.9 169.4 441.4L118.6 390.6C106.1 378.1 106.1 357.9 118.6 345.4L143.1 320zM489.4 99.92L460.1 70.59L245 229L330.1 314.1L489.4 99.92zM23.03 466.3L86.06 403.3L156.7 473.9L125.7 504.1C121.2 509.5 115.1 512 108.7 512H40C26.75 512 16 501.3 16 488V483.3C16 476.1 18.53 470.8 23.03 466.3V466.3z"]
};
var faImage = {
  prefix: "fas",
  iconName: "image",
  icon: [512, 512, [], "f03e", "M447.1 32h-384C28.64 32-.0091 60.65-.0091 96v320c0 35.35 28.65 64 63.1 64h384c35.35 0 64-28.65 64-64V96C511.1 60.65 483.3 32 447.1 32zM111.1 96c26.51 0 48 21.49 48 48S138.5 192 111.1 192s-48-21.49-48-48S85.48 96 111.1 96zM446.1 407.6C443.3 412.8 437.9 416 432 416H82.01c-6.021 0-11.53-3.379-14.26-8.75c-2.73-5.367-2.215-11.81 1.334-16.68l70-96C142.1 290.4 146.9 288 152 288s9.916 2.441 12.93 6.574l32.46 44.51l93.3-139.1C293.7 194.7 298.7 192 304 192s10.35 2.672 13.31 7.125l128 192C448.6 396 448.9 402.3 446.1 407.6z"]
};
var faParagraph = {
  prefix: "fas",
  iconName: "paragraph",
  icon: [448, 512, [182], "f1dd", "M448 63.1C448 81.67 433.7 96 416 96H384v352c0 17.67-14.33 32-31.1 32S320 465.7 320 448V96h-32v352c0 17.67-14.33 32-31.1 32S224 465.7 224 448v-96H198.9c-83.57 0-158.2-61.11-166.1-144.3C23.66 112.3 98.44 32 191.1 32h224C433.7 32 448 46.33 448 63.1z"]
};
var SvgIcon_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => "\n.custom-svg svg {\n    display: block;\n    font-size: inherit;\n    height: 1em;\n    overflow: visible;\n    vertical-align: -0.125em;\n}\n\n")();
library$1.add(faParagraph, faHighlighter, faAlignLeft, faAlignRight, faAlignCenter, faAlignJustify, faImage);
const _sfc_main$l = {
  name: "SvgIcon",
  components: { FontAwesomeIcon },
  props: {
    content: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      defaultSvgs: {
        bold: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M333.49 238a122 122 0 0 0 27-65.21C367.87 96.49 308 32 233.42 32H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h31.87v288H34a16 16 0 0 0-16 16v48a16 16 0 0 0 16 16h209.32c70.8 0 134.14-51.75 141-122.4 4.74-48.45-16.39-92.06-50.83-119.6zM145.66 112h87.76a48 48 0 0 1 0 96h-87.76zm87.76 288h-87.76V288h87.76a56 56 0 0 1 0 112z"/></svg>',
        underline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M32 64h32v160c0 88.22 71.78 160 160 160s160-71.78 160-160V64h32a16 16 0 0 0 16-16V16a16 16 0 0 0-16-16H272a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h32v160a80 80 0 0 1-160 0V64h32a16 16 0 0 0 16-16V16a16 16 0 0 0-16-16H32a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16zm400 384H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"/></svg>',
        italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M320 48v32a16 16 0 0 1-16 16h-62.76l-80 320H208a16 16 0 0 1 16 16v32a16 16 0 0 1-16 16H16a16 16 0 0 1-16-16v-32a16 16 0 0 1 16-16h62.76l80-320H112a16 16 0 0 1-16-16V48a16 16 0 0 1 16-16h192a16 16 0 0 1 16 16z"/></svg>',
        strikethrough: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M496 224H293.9l-87.17-26.83A43.55 43.55 0 0 1 219.55 112h66.79A49.89 49.89 0 0 1 331 139.58a16 16 0 0 0 21.46 7.15l42.94-21.47a16 16 0 0 0 7.16-21.46l-.53-1A128 128 0 0 0 287.51 32h-68a123.68 123.68 0 0 0-123 135.64c2 20.89 10.1 39.83 21.78 56.36H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h480a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm-180.24 96A43 43 0 0 1 336 356.45 43.59 43.59 0 0 1 292.45 400h-66.79A49.89 49.89 0 0 1 181 372.42a16 16 0 0 0-21.46-7.15l-42.94 21.47a16 16 0 0 0-7.16 21.46l.53 1A128 128 0 0 0 224.49 480h68a123.68 123.68 0 0 0 123-135.64 114.25 114.25 0 0 0-5.34-24.36z"/></svg>',
        link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M314.222 197.78c51.091 51.091 54.377 132.287 9.75 187.16-6.242 7.73-2.784 3.865-84.94 86.02-54.696 54.696-143.266 54.745-197.99 0-54.711-54.69-54.734-143.255 0-197.99 32.773-32.773 51.835-51.899 63.409-63.457 7.463-7.452 20.331-2.354 20.486 8.192a173.31 173.31 0 0 0 4.746 37.828c.966 4.029-.272 8.269-3.202 11.198L80.632 312.57c-32.755 32.775-32.887 85.892 0 118.8 32.775 32.755 85.892 32.887 118.8 0l75.19-75.2c32.718-32.725 32.777-86.013 0-118.79a83.722 83.722 0 0 0-22.814-16.229c-4.623-2.233-7.182-7.25-6.561-12.346 1.356-11.122 6.296-21.885 14.815-30.405l4.375-4.375c3.625-3.626 9.177-4.594 13.76-2.294 12.999 6.524 25.187 15.211 36.025 26.049zM470.958 41.04c-54.724-54.745-143.294-54.696-197.99 0-82.156 82.156-78.698 78.29-84.94 86.02-44.627 54.873-41.341 136.069 9.75 187.16 10.838 10.838 23.026 19.525 36.025 26.049 4.582 2.3 10.134 1.331 13.76-2.294l4.375-4.375c8.52-8.519 13.459-19.283 14.815-30.405.621-5.096-1.938-10.113-6.561-12.346a83.706 83.706 0 0 1-22.814-16.229c-32.777-32.777-32.718-86.065 0-118.79l75.19-75.2c32.908-32.887 86.025-32.755 118.8 0 32.887 32.908 32.755 86.025 0 118.8l-45.848 45.84c-2.93 2.929-4.168 7.169-3.202 11.198a173.31 173.31 0 0 1 4.746 37.828c.155 10.546 13.023 15.644 20.486 8.192 11.574-11.558 30.636-30.684 63.409-63.457 54.733-54.735 54.71-143.3-.001-197.991z"></path></svg>',
        unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M304.083 388.936c4.686 4.686 4.686 12.284 0 16.971l-65.057 65.056c-54.709 54.711-143.27 54.721-197.989 0-54.713-54.713-54.719-143.27 0-197.989l65.056-65.057c4.686-4.686 12.284-4.686 16.971 0l22.627 22.627c4.686 4.686 4.686 12.284 0 16.971L81.386 311.82c-34.341 34.341-33.451 88.269.597 120.866 32.577 31.187 84.788 31.337 117.445-1.32l65.057-65.056c4.686-4.686 12.284-4.686 16.971 0l22.627 22.626zm-56.568-243.245l64.304-64.304c34.346-34.346 88.286-33.453 120.882.612 31.18 32.586 31.309 84.785-1.335 117.43l-65.056 65.057c-4.686 4.686-4.686 12.284 0 16.971l22.627 22.627c4.686 4.686 12.284 4.686 16.971 0l65.056-65.057c54.711-54.709 54.721-143.271 0-197.99-54.71-54.711-143.27-54.72-197.989 0l-65.057 65.057c-4.686 4.686-4.686 12.284 0 16.971l22.627 22.627c4.685 4.685 12.283 4.685 16.97-.001zm238.343 362.794l22.627-22.627c4.686-4.686 4.686-12.284 0-16.971L43.112 3.515c-4.686-4.686-12.284-4.686-16.971 0L3.515 26.142c-4.686 4.686-4.686 12.284 0 16.971l465.373 465.373c4.686 4.686 12.284 4.686 16.97-.001z"></path></svg>',
        "file-code": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M369.941 97.941l-83.882-83.882A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v416c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48V131.882a48 48 0 0 0-14.059-33.941zm-22.627 22.628a15.89 15.89 0 0 1 4.195 7.431H256V32.491a15.88 15.88 0 0 1 7.431 4.195l83.883 83.883zM336 480H48c-8.837 0-16-7.163-16-16V48c0-8.837 7.163-16 16-16h176v104c0 13.255 10.745 24 24 24h104v304c0 8.837-7.163 16-16 16zm-161.471-67.404l-25.928-7.527a5.1 5.1 0 0 1-3.476-6.32l58.027-199.869a5.1 5.1 0 0 1 6.32-3.476l25.927 7.527a5.1 5.1 0 0 1 3.476 6.32L180.849 409.12a5.1 5.1 0 0 1-6.32 3.476zm-48.446-47.674l18.492-19.724a5.101 5.101 0 0 0-.351-7.317L105.725 304l38.498-33.881a5.1 5.1 0 0 0 .351-7.317l-18.492-19.724a5.1 5.1 0 0 0-7.209-.233L57.61 300.279a5.1 5.1 0 0 0 0 7.441l61.263 57.434a5.1 5.1 0 0 0 7.21-.232zm139.043.232l61.262-57.434a5.1 5.1 0 0 0 0-7.441l-61.262-57.434a5.1 5.1 0 0 0-7.209.233l-18.492 19.724a5.101 5.101 0 0 0 .351 7.317L278.275 304l-38.499 33.881a5.1 5.1 0 0 0-.351 7.317l18.492 19.724a5.1 5.1 0 0 0 7.209.232z"></path></svg>',
        "page-break": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M144 48.06L304 48v112a16 16 0 0 0 16 16h112v40h48v-84a48.09 48.09 0 0 0-14.09-34L382 14.07A48.09 48.09 0 0 0 348 0L128 .08a32 32 0 0 0-32 32V216h48zM352 52l76.07 76H352zM240 264a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h96a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16zm192 200H144V360H96v120a32 32 0 0 0 32 32h320a32 32 0 0 0 32-32V360h-48zm128-200H432a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16zm-400 32v-16a16 16 0 0 0-16-16H16a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16z"></path></svg>',
        "remove-format": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M634 471L36 3.5A16 16 0 0 0 13.49 6l-10 12.5A16 16 0 0 0 6 41l598 467.5a16 16 0 0 0 22.5-2.5l10-12.5A16 16 0 0 0 634 471zM352 96l-24.76 74.27L378 210l38-114h144v32a16 16 0 0 0 16 16h16a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16H176a15.86 15.86 0 0 0-14.18 8.94L232.24 96zm-16 336h-32l25.68-77-50.77-39.7L240 432h-32a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16z"></path></svg>',
        "quote-right": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M464 32H336c-26.5 0-48 21.5-48 48v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48zm-288 0H48C21.5 32 0 53.5 0 80v128c0 26.5 21.5 48 48 48h80v64c0 35.3-28.7 64-64 64h-8c-13.3 0-24 10.7-24 24v48c0 13.3 10.7 24 24 24h8c88.4 0 160-71.6 160-160V80c0-26.5-21.5-48-48-48z"/></svg>',
        "list-ul": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M48 48a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm448 16H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"/></svg>',
        "list-ol": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M61.77 401l17.5-20.15a19.92 19.92 0 0 0 5.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h22.83a157.41 157.41 0 0 0-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.29 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 0 1-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.72 6.13-3.19 11.72 2.63 15.94 7.71 4.69 20.38 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM496 224H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM16 160h64a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H64V40a8 8 0 0 0-8-8H32a8 8 0 0 0-7.14 4.42l-8 16A8 8 0 0 0 24 64h8v64H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8zm-3.91 160H80a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H41.32c3.29-10.29 48.34-18.68 48.34-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.46 18.75-4.37 5.59-3 10.84 2.8 15.37l8.58 6.88c5.61 4.56 11 2.47 16.12-2.44a13.44 13.44 0 0 1 9.46-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.09 320z"/></svg>',
        "horizontal-rule": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M640 247.5v17a16 16 0 0 1-16 16H16a16 16 0 0 1-16-16v-17a16 16 0 0 1 16-16h608a16 16 0 0 1 16 16z"/></svg>',
        code: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M234.8 511.7L196 500.4c-4.2-1.2-6.7-5.7-5.5-9.9L331.3 5.8c1.2-4.2 5.7-6.7 9.9-5.5L380 11.6c4.2 1.2 6.7 5.7 5.5 9.9L244.7 506.2c-1.2 4.3-5.6 6.7-9.9 5.5zm-83.2-121.1l27.2-29c3.1-3.3 2.8-8.5-.5-11.5L72.2 256l106.1-94.1c3.4-3 3.6-8.2.5-11.5l-27.2-29c-3-3.2-8.1-3.4-11.3-.4L2.5 250.2c-3.4 3.2-3.4 8.5 0 11.7L140.3 391c3.2 3 8.2 2.8 11.3-.4zm284.1.4l137.7-129.1c3.4-3.2 3.4-8.5 0-11.7L435.7 121c-3.2-3-8.3-2.9-11.3.4l-27.2 29c-3.1 3.3-2.8 8.5.5 11.5L503.8 256l-106.1 94.1c-3.4 3-3.6 8.2-.5 11.5l27.2 29c3.1 3.2 8.1 3.4 11.3.4z"/></svg>',
        "brackets-curly": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M208 32h-88a56 56 0 0 0-56 56v77.49a40 40 0 0 1-11.72 28.29L7 239a24 24 0 0 0 0 34l45.24 45.24A40 40 0 0 1 64 346.52V424a56 56 0 0 0 56 56h88a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16h-88a8 8 0 0 1-8-8v-77.48a88.06 88.06 0 0 0-25.78-62.24L57.93 256l28.29-28.28A88.06 88.06 0 0 0 112 165.48V88a8 8 0 0 1 8-8h88a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm361 207l-45.25-45.24A40.07 40.07 0 0 1 512 165.48V88a56 56 0 0 0-56-56h-88a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h88a8 8 0 0 1 8 8v77.48a88 88 0 0 0 25.78 62.24L518.06 256l-28.28 28.28A88 88 0 0 0 464 346.52V424a8 8 0 0 1-8 8h-88a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h88a56 56 0 0 0 56-56v-77.49a40 40 0 0 1 11.72-28.29L569 273a24 24 0 0 0 0-34z"></path></svg>',
        undo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M212.333 224.333H12c-6.627 0-12-5.373-12-12V12C0 5.373 5.373 0 12 0h48c6.627 0 12 5.373 12 12v78.112C117.773 39.279 184.26 7.47 258.175 8.007c136.906.994 246.448 111.623 246.157 248.532C504.041 393.258 393.12 504 256.333 504c-64.089 0-122.496-24.313-166.51-64.215-5.099-4.622-5.334-12.554-.467-17.42l33.967-33.967c4.474-4.474 11.662-4.717 16.401-.525C170.76 415.336 211.58 432 256.333 432c97.268 0 176-78.716 176-176 0-97.267-78.716-176-176-176-58.496 0-110.28 28.476-142.274 72.333h98.274c6.627 0 12 5.373 12 12v48c0 6.627-5.373 12-12 12z"/></svg>',
        redo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M500.33 0h-47.41a12 12 0 0 0-12 12.57l4 82.76A247.42 247.42 0 0 0 256 8C119.34 8 7.9 119.53 8 256.19 8.1 393.07 119.1 504 256 504a247.1 247.1 0 0 0 166.18-63.91 12 12 0 0 0 .48-17.43l-34-34a12 12 0 0 0-16.38-.55A176 176 0 1 1 402.1 157.8l-101.53-4.87a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12h200.33a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12z"/></svg>',
        subscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M336 64h-52.28a16 16 0 0 0-13.31 7.12L176 212.73 81.59 71.12A16 16 0 0 0 68.28 64H16A16 16 0 0 0 0 80v16a16 16 0 0 0 16 16h35.16l96 144-96 144H16a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h52.28a16 16 0 0 0 13.31-7.12L176 299.27l94.41 141.61a16 16 0 0 0 13.31 7.12H336a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16h-35.16l-96-144 96-144H336a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm160 400h-24V304a16 16 0 0 0-16-16h-32a16 16 0 0 0-14.29 8.83l-16 32A16 16 0 0 0 408 352h16v112h-24a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h96a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16z"></path></svg>',
        superscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M336 64h-52.28a16 16 0 0 0-13.31 7.12L176 212.73 81.59 71.12A16 16 0 0 0 68.28 64H16A16 16 0 0 0 0 80v16a16 16 0 0 0 16 16h35.16l96 144-96 144H16a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h52.28a16 16 0 0 0 13.31-7.12L176 299.27l94.41 141.61a16 16 0 0 0 13.31 7.12H336a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16h-35.16l-96-144 96-144H336a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm160 112h-24V16a16 16 0 0 0-16-16h-32a16 16 0 0 0-14.29 8.83l-16 32A16 16 0 0 0 408 64h16v112h-24a16 16 0 0 0-16 16v16a16 16 0 0 0 16 16h96a16 16 0 0 0 16-16v-16a16 16 0 0 0-16-16z"></path></svg>',
        plusCircle: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M232 344V280H168C154.7 280 144 269.3 144 256C144 242.7 154.7 232 168 232H232V168C232 154.7 242.7 144 256 144C269.3 144 280 154.7 280 168V232H344C357.3 232 368 242.7 368 256C368 269.3 357.3 280 344 280H280V344C280 357.3 269.3 368 256 368C242.7 368 232 357.3 232 344zM512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256zM256 48C141.1 48 48 141.1 48 256C48 370.9 141.1 464 256 464C370.9 464 464 370.9 464 256C464 141.1 370.9 48 256 48z"/></svg>'
      }
    };
  },
  computed: {
    getSvg() {
      if (this.content.svg && this.defaultSvgs[this.content.svg]) {
        return this.defaultSvgs[this.content.svg];
      }
      return "";
    }
  }
};
const _hoisted_1$j = ["innerHTML"];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  return $props.content.icon ? (openBlock(), createBlock(_component_font_awesome_icon, {
    key: 0,
    icon: $props.content.icon
  }, null, 8, ["icon"])) : (openBlock(), createElementBlock("span", {
    key: 1,
    class: "custom-svg",
    innerHTML: $options.getSvg
  }, null, 8, _hoisted_1$j));
}
var SvgIcon = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/SvgIcon.vue"]]);
var MenuBarItem_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => '.fui-toolbar-btn {\n  background: transparent;\n  color: #1c2e36;\n  border-radius: 3px;\n  padding-left: 4px;\n  padding-right: 4px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 16px;\n  text-align: center;\n  height: 32px;\n  width: 32px;\n  margin: 0 2px;\n}\n.fui-toolbar-btn:focus, .fui-toolbar-btn:hover {\n  background-color: #edf3fa !important;\n}\n.fui-toolbar-btn.active {\n  background-color: rgba(96, 125, 159, 0.25) !important;\n}\n.fui-toolbar-dropdown {\n  display: block;\n  width: 100%;\n  padding: 10px;\n  margin: 0;\n  text-align: left;\n  text-decoration: none;\n  white-space: nowrap;\n  border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n  outline: 0;\n}\n.fui-toolbar-dropdown:hover {\n  cursor: pointer;\n  background: rgb(243, 245, 249);\n}\n.tippy-box[data-theme~=toolbar-dropdown] {\n  min-width: 250px;\n}\n.tippy-box[data-theme~=toolbar-dropdown] .tippy-content {\n  padding: 0;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-quote,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-quote {\n  color: rgba(0, 0, 0, 0.4);\n  font-style: italic;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-code,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-code {\n  font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;\n  font-size: 0.9em !important;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-h1,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-h1 {\n  font-size: 22px;\n  font-weight: 600;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-h2,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-h2 {\n  font-size: 20px;\n  font-weight: 600;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-h3,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-h3 {\n  font-size: 18px;\n  font-weight: 600;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-h4,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-h5,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n.fui-toolbar-dropdown-heading .fui-toolbar-dropdown-item-h6,\n.fui-toolbar-dropdown-formatting .fui-toolbar-dropdown-item-h6 {\n  font-size: 13.6px;\n  color: #7b8793;\n  font-weight: 600;\n}\n.fui-toolbar-dropdown-link .fui-toolbar-dropdown-item-unlink {\n  color: rgba(0, 0, 0, 0.4);\n}')();
const _sfc_main$k = {
  name: "MenuBarItem",
  components: {
    SvgIcon
  },
  props: {
    field: {
      type: Object,
      default: null
    },
    editor: {
      type: Object,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    svg: {
      type: String,
      default: null
    },
    name: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    action: {
      type: Function,
      default: () => {
      }
    },
    isActive: {
      type: Function,
      default: () => {
      }
    },
    options: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  data() {
    return {
      tippy: null
    };
  },
  computed: {
    active() {
      return this.isActive && this.isActive();
    }
  },
  mounted() {
    this.$nextTick(() => {
      if (this.hasDropdown) {
        const $template = this.$el.querySelector(`.fui-toolbar-dropdown-${this.name}`);
        const $button = this.$el;
        if ($template && $button) {
          $template.style.display = "block";
          this.tippy = tippy$1($button, {
            content: $template,
            trigger: "click",
            allowHTML: true,
            arrow: false,
            interactive: true,
            placement: "bottom-start",
            theme: "light-border toolbar-dropdown",
            zIndex: 1e3,
            hideOnClick: true,
            offset: [0, 1]
          });
        }
      }
    });
  },
  methods: {
    hasDropdown() {
      return this.options && this.options.length ? true : false;
    },
    runAction(action) {
      if (this.tippy) {
        this.tippy.hide();
      }
      if (action) {
        action();
      }
    },
    onMouseDown(e) {
      e.preventDefault();
    }
  }
};
const _hoisted_1$i = ["onClick"];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_svg_icon = resolveComponent("svg-icon");
  const _directive_tooltip = resolveDirective("tooltip");
  return withDirectives((openBlock(), createElementBlock("button", {
    class: normalizeClass(["btn fui-toolbar-btn", { "active": $options.active }]),
    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $options.runAction($props.action), ["prevent"])),
    onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onMouseDown && $options.onMouseDown(...args))
  }, [
    createVNode(_component_svg_icon, {
      content: { icon: $props.icon, svg: $props.svg }
    }, null, 8, ["content"]),
    $options.hasDropdown() ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["fui-toolbar-dropdown-container", "fui-toolbar-dropdown-" + $props.name]),
      style: { "display": "none" }
    }, [
      (openBlock(true), createElementBlock(Fragment$1, null, renderList($props.options, (option3, i) => {
        return openBlock(), createElementBlock("button", {
          key: i,
          class: normalizeClass(["fui-toolbar-dropdown", "fui-toolbar-dropdown-item-" + option3.name]),
          onClick: withModifiers(($event) => $options.runAction(option3.action), ["prevent"])
        }, toDisplayString(option3.title), 11, _hoisted_1$i);
      }), 128))
    ], 2)) : createCommentVNode("v-if", true)
  ], 34)), [
    [_directive_tooltip, { content: $props.title, theme: "fui-editor-tooltip" }]
  ]);
}
var MenuBarItem = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/MenuBarItem.vue"]]);
const getMarkRange = ($pos, type) => {
  if (!$pos || !type) {
    return;
  }
  const start2 = $pos.parent.childAfter($pos.parentOffset);
  if (!start2.node) {
    return;
  }
  const link3 = start2.node.marks.find((mark) => {
    return mark.type === type;
  });
  if (!link3) {
    return;
  }
  let startIndex2 = $pos.index();
  let startPos = $pos.start() + start2.offset;
  let endIndex2 = startIndex2 + 1;
  let endPos = startPos + start2.node.nodeSize;
  while (startIndex2 > 0 && link3.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
    startIndex2 -= 1;
    startPos -= $pos.parent.child(startIndex2).nodeSize;
  }
  while (endIndex2 < $pos.parent.childCount && link3.isInSet($pos.parent.child(endIndex2).marks)) {
    endPos += $pos.parent.child(endIndex2).nodeSize;
    endIndex2 += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
};
var MenuBarModal_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => `.fui-editor-modal-wrap,
.fui-editor-modal-overlay {
  position: fixed !important;
}
.fui-editor-modal-container {
  display: flex;
  justify-content: center;
  align-items: center;
}
.fui-editor-modal-content {
  width: 90vw;
  height: 90vh;
  max-width: 650px;
  max-height: 450px;
  display: flex;
  flex-direction: column;
  position: relative;
  border-radius: 5px;
  background-color: #fff;
  box-shadow: 0 25px 100px rgba(31, 41, 51, 0.5);
}
.fui-editor-modal-overlay {
  background-color: rgba(228, 237, 246, 0.65) !important;
}
.fui-editor-modal-header {
  display: flex;
  align-items: center;
  border-radius: 5px 5px 0 0;
  background-color: #f3f7fc;
  box-shadow: inset 0 -1px 0 rgba(51, 64, 77, 0.1);
  padding: 10px 24px;
  font-weight: 600;
  font-size: 15px;
  line-height: 30px;
}
.fui-editor-modal-close {
  width: 20px;
  height: 20px;
  margin-left: auto;
  cursor: pointer;
  background-size: 20px 20px;
  background-repeat: no-repeat;
  transition: all 0.3s ease;
  background-image: url("data:image/svg+xml,%3Csvg aria-hidden='true' role='img' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='currentColor' d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  opacity: 0.4;
}
.fui-editor-modal-body {
  height: 100%;
  overflow: auto;
  padding: 24px;
}
.fui-editor-modal-footer {
  width: 100%;
  margin: 0;
  background-color: #e4edf6;
  border-radius: 0 0 5px 5px;
  padding: 14px 24px;
  box-shadow: inset 0 1px 0 rgba(51, 64, 77, 0.1);
}`)();
const _sfc_main$j = {
  name: "MenuBarModal",
  inheritAttrs: false,
  props: {
    cancelButton: {
      type: String,
      default: "Cancel"
    },
    confirmButton: {
      type: String,
      default: "Confirm"
    }
  },
  emits: ["update:modelValue", "confirm", "cancel"],
  methods: {
    opened() {
      setTimeout(() => {
        this.$nextTick().then(() => {
          const $firstText = this.$el.querySelector('input[type="text"]');
          if ($firstText) {
            $firstText.focus();
          }
        });
      }, 50);
    }
  }
};
const _hoisted_1$h = { class: "fui-editor-modal-header" };
const _hoisted_2$f = { class: "fui-editor-modal-body" };
const _hoisted_3$b = { class: "fui-editor-modal-footer footer" };
const _hoisted_4$9 = /* @__PURE__ */ createBaseVNode("div", { class: "spinner hidden" }, null, -1);
const _hoisted_5$7 = { class: "buttons right" };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_final_modal = resolveComponent("vue-final-modal");
  return openBlock(), createBlock(_component_vue_final_modal, mergeProps({
    ssr: false,
    class: "fui-editor-modal-wrap"
  }, _ctx.$attrs, {
    classes: "fui-editor-modal-container",
    "content-class": "fui-editor-modal-content",
    "overlay-class": "fui-editor-modal-overlay",
    "lock-scroll": false,
    onOpened: $options.opened
  }), {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$h, [
        renderSlot(_ctx.$slots, "title"),
        createBaseVNode("div", {
          class: "fui-editor-modal-close",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$emit("update:modelValue", false), ["prevent"]))
        })
      ]),
      createBaseVNode("div", _hoisted_2$f, [
        renderSlot(_ctx.$slots, "default")
      ]),
      createBaseVNode("div", _hoisted_3$b, [
        _hoisted_4$9,
        createBaseVNode("div", _hoisted_5$7, [
          createBaseVNode("div", {
            role: "button",
            class: "btn",
            tabindex: "0",
            onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.$emit("cancel"), ["prevent"]))
          }, toDisplayString(_ctx.t("formie", $props.cancelButton)), 1),
          createBaseVNode("div", {
            role: "button",
            class: "btn submit",
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("confirm"), ["prevent"]))
          }, toDisplayString(_ctx.t("formie", $props.confirmButton)), 1)
        ])
      ])
    ]),
    _: 3
  }, 16, ["onOpened"]);
}
var MenuBarModal = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/MenuBarModal.vue"]]);
const _sfc_main$i = {
  name: "LinkMenuModal",
  components: {
    MenuBarModal
  },
  props: {
    field: {
      type: Object,
      default: null
    },
    editor: {
      type: Object,
      default: null
    },
    show: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Object,
      default: () => {
        return globalThis.proxyValue;
      }
    }
  },
  emits: ["update:modelValue", "close"],
  data() {
    return {
      targetId: `target-${Craft.randomString(10)}`,
      proxyShow: false,
      proxyValue: {
        url: null,
        text: null,
        target: null
      },
      errors: []
    };
  },
  computed: {
    elementSiteId() {
      return this.field.elementSiteId;
    },
    newWindow: {
      get() {
        return this.modelValue.target === "_blank";
      },
      set(value) {
        this.modelValue.target = value ? "_blank" : "";
      }
    }
  },
  watch: {
    show(newValue) {
      this.proxyShow = newValue;
    },
    proxyShow(newValue) {
      if (newValue === false) {
        this.$emit("close");
      }
    },
    proxyValue(newValue) {
      this.$emit("update:modelValue", newValue);
    }
  },
  methods: {
    cancelModal() {
      this.proxyShow = false;
    },
    confirmModal() {
      this.errors = [];
      if (!this.modelValue.url) {
        this.errors.push("url");
        return;
      }
      const data = { href: this.modelValue.url, target: this.modelValue.target ? "_blank" : "" };
      const { selection } = this.editor.state.tr;
      const cursorPos = selection.$cursor ? selection.$cursor.pos : selection.from;
      this.editor.chain().focus().command(({
        commands: commands2,
        tr,
        state: state2,
        dispatch: dispatch2
      }) => {
        let range2 = getMarkRange(state2.doc.resolve(tr.selection.anchor), state2.schema.marks.link);
        if (!range2) {
          range2 = { from: tr.selection.from, to: tr.selection.to };
        }
        if (this.modelValue.text) {
          const text3 = this.modelValue.text.toString();
          tr.insertText(text3, range2.from, range2.to);
          const $start = tr.doc.resolve(range2.from);
          const $end = tr.doc.resolve(range2.from + text3.length);
          tr.setSelection(new TextSelection($start, $end));
        }
      }).setLink(data).command(({
        commands: commands2,
        tr,
        state: state2,
        dispatch: dispatch2
      }) => {
        if (cursorPos) {
          tr.setSelection(TextSelection.create(tr.doc, cursorPos));
        }
      }).run();
      this.proxyShow = false;
    }
  }
};
const _hoisted_1$g = { class: "heading" };
const _hoisted_2$e = {
  id: "url-label",
  class: "required",
  for: "url"
};
const _hoisted_3$a = {
  key: 0,
  class: "errors"
};
const _hoisted_4$8 = {
  id: "text-field",
  class: "field"
};
const _hoisted_5$6 = { class: "heading" };
const _hoisted_6$5 = {
  id: "text-label",
  for: "text"
};
const _hoisted_7$4 = { class: "input ltr" };
const _hoisted_8$4 = {
  id: "target-field",
  class: "checkboxfield field"
};
const _hoisted_9$4 = { class: "input ltr" };
const _hoisted_10$4 = ["id"];
const _hoisted_11$4 = ["for"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_menu_bar_modal = resolveComponent("menu-bar-modal");
  return openBlock(), createBlock(_component_menu_bar_modal, {
    modelValue: $data.proxyShow,
    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.proxyShow = $event),
    attach: "body",
    "esc-to-close": true,
    "focus-trap": true,
    "confirm-button": _ctx.$attrs["confirm-button"],
    onConfirm: $options.confirmModal,
    onCancel: $options.cancelModal
  }, {
    title: withCtx(() => [
      createTextVNode(toDisplayString(_ctx.t("formie", _ctx.$attrs["modal-title"])), 1)
    ]),
    default: withCtx(() => [
      createBaseVNode("div", {
        id: "url-field",
        class: normalizeClass(["field", { "has-errors": $data.errors.includes("url") }])
      }, [
        createBaseVNode("div", _hoisted_1$g, [
          createBaseVNode("label", _hoisted_2$e, toDisplayString(_ctx.t("formie", "URL")), 1)
        ]),
        createBaseVNode("div", {
          class: normalizeClass(["input ltr", { "errors": $data.errors.includes("url") }])
        }, [
          withDirectives(createBaseVNode("input", {
            id: "url",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.modelValue.url = $event),
            type: "text",
            class: "text fullwidth",
            autofocus: "",
            autocomplete: "off",
            required: ""
          }, null, 512), [
            [vModelText, $props.modelValue.url]
          ])
        ], 2),
        $data.errors.includes("url") ? (openBlock(), createElementBlock("ul", _hoisted_3$a, [
          createBaseVNode("li", null, toDisplayString(_ctx.t("formie", "URL cannot be blank.")), 1)
        ])) : createCommentVNode("v-if", true)
      ], 2),
      createBaseVNode("div", _hoisted_4$8, [
        createBaseVNode("div", _hoisted_5$6, [
          createBaseVNode("label", _hoisted_6$5, toDisplayString(_ctx.t("formie", "Text")), 1)
        ]),
        createBaseVNode("div", _hoisted_7$4, [
          withDirectives(createBaseVNode("input", {
            id: "text",
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $props.modelValue.text = $event),
            type: "text",
            class: "text fullwidth",
            autofocus: "",
            autocomplete: "off"
          }, null, 512), [
            [vModelText, $props.modelValue.text]
          ])
        ])
      ]),
      createBaseVNode("div", _hoisted_8$4, [
        createBaseVNode("div", _hoisted_9$4, [
          withDirectives(createBaseVNode("input", {
            id: $data.targetId,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.newWindow = $event),
            type: "checkbox",
            class: "checkbox"
          }, null, 8, _hoisted_10$4), [
            [vModelCheckbox, $options.newWindow]
          ]),
          createBaseVNode("label", { for: $data.targetId }, toDisplayString(_ctx.t("formie", "Open link in new tab")), 9, _hoisted_11$4)
        ])
      ])
    ]),
    _: 1
  }, 8, ["modelValue", "confirm-button", "onConfirm", "onCancel"]);
}
var LinkMenuModal = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/link/LinkMenuModal.vue"]]);
var LinkMenuBubble_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => '.tippy-box[data-theme~=fui-menu-bubble] {\n  background-color: #1c2e36;\n  border-radius: 3px;\n}\n.tippy-box[data-theme~=fui-menu-bubble] .tippy-arrow {\n  z-index: 1;\n  pointer-events: none;\n}\n.tippy-box[data-theme~=fui-menu-bubble] .tippy-content {\n  padding: 6px 12px 8px;\n  box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2);\n}\n.tippy-box[data-theme~=fui-menu-bubble] a {\n  font-size: 12px;\n  color: #fff;\n  text-decoration: none;\n  display: inline-block;\n  padding: 0 0 0 7px;\n}\n.tippy-box[data-theme~=fui-menu-bubble] a:hover {\n  color: #ddd;\n}\n.tippy-box[data-theme~=fui-menu-bubble] a:before {\n  content: "";\n  padding-left: 10px;\n  border-left: 1px solid rgba(255, 255, 255, 0.3);\n}\n.tippy-box[data-theme~=fui-menu-bubble] a:first-child {\n  padding-left: 0;\n}\n.tippy-box[data-theme~=fui-menu-bubble] a:first-child:before {\n  padding-left: 0;\n  border-left: none;\n}')();
const _sfc_main$h = {
  name: "LinkMenuBubble",
  components: {
    LinkMenuModal
  },
  props: {
    field: {
      type: Object,
      default: null
    },
    editor: {
      type: Object,
      default: null
    }
  },
  data() {
    return {
      tippy: null,
      showEditModal: false,
      model: {
        url: null,
        text: null,
        target: null
      }
    };
  },
  watch: {
    editor: {
      immediate: true,
      handler(editor) {
        if (editor) {
          this.$nextTick(() => {
            editor.on("fui:link-clicked", this.renderBubble);
          });
        }
      }
    }
  },
  methods: {
    renderBubble() {
      const { doc: doc2, selection, schema } = this.editor.view.state;
      const range2 = getMarkRange(doc2.resolve(selection.anchor), schema.marks.link);
      if (range2) {
        const $node = this.editor.view.docView.domFromPos(range2.from).node;
        if ($node) {
          this.$el.style.display = "block";
          const attrs = this.editor.getAttributes("link");
          this.model.text = $node.textContent;
          this.model.url = attrs.href;
          this.model.target = attrs.target;
          this.tippy = tippy$1($node.parentNode, {
            content: this.$el,
            showOnCreate: true,
            trigger: "manual",
            allowHTML: true,
            arrow: true,
            interactive: true,
            placement: "top",
            theme: "fui-menu-bubble",
            hideOnClick: true,
            zIndex: 1e3,
            appendTo: () => {
              return document.body;
            }
          });
        }
      }
    },
    destroyBubble() {
      if (this.tippy) {
        this.tippy.destroy();
        this.tippy = null;
      }
    },
    truncate(str, n) {
      return str && str.length > n ? `${str.substr(0, n - 1)}&hellip;` : str;
    },
    edit() {
      this.showEditModal = true;
      this.destroyBubble();
      this.editor.chain().blur().run();
    },
    closeModal() {
      this.showEditModal = false;
    },
    unlink() {
      this.editor.chain().focus().unsetLink().run();
      this.destroyBubble();
    }
  }
};
const _hoisted_1$f = {
  class: "fui-link-menu-bubble",
  style: { "display": "none" }
};
const _hoisted_2$d = ["href", "innerHTML"];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_link_menu_modal = resolveComponent("link-menu-modal");
  return openBlock(), createElementBlock("div", _hoisted_1$f, [
    createBaseVNode("a", {
      href: $data.model.url,
      target: "_blank",
      innerHTML: $options.truncate($data.model.url, 30)
    }, null, 8, _hoisted_2$d),
    createBaseVNode("a", {
      href: "#",
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.edit && $options.edit(...args), ["prevent"]))
    }, toDisplayString(_ctx.t("formie", "Edit")), 1),
    createBaseVNode("a", {
      href: "#",
      onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.unlink && $options.unlink(...args), ["prevent"]))
    }, toDisplayString(_ctx.t("formie", "Unlink")), 1),
    createVNode(_component_link_menu_modal, {
      modelValue: $data.model,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.model = $event),
      show: $data.showEditModal,
      editor: $props.editor,
      field: $props.field,
      "confirm-button": "Update",
      "modal-title": "Edit Link",
      onClose: $options.closeModal
    }, null, 8, ["modelValue", "show", "editor", "field", "onClose"])
  ]);
}
var LinkMenuBubble = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/link/LinkMenuBubble.vue"]]);
const _sfc_main$g = {
  name: "MenuBarItem",
  components: {
    SvgIcon,
    LinkMenuModal,
    LinkMenuBubble
  },
  props: {
    field: {
      type: Object,
      default: null
    },
    editor: {
      type: Object,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    svg: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    isActive: {
      type: Function,
      default: () => {
      }
    }
  },
  data() {
    return {
      tippy: null,
      showEditModal: false,
      model: {}
    };
  },
  computed: {
    active() {
      return this.isActive && this.isActive();
    },
    linkOptions() {
      return this.field.linkOptions;
    }
  },
  created() {
    this.resetModel();
  },
  mounted() {
    this.$nextTick(() => {
      const $template = this.$el.querySelector(".fui-toolbar-dropdown-link");
      const $button = this.$el;
      if ($template && $button) {
        $template.style.display = "block";
        this.tippy = tippy$1($button, {
          content: $template,
          trigger: "click",
          allowHTML: true,
          arrow: false,
          interactive: true,
          placement: "bottom-start",
          theme: "light-border toolbar-dropdown",
          zIndex: 1e3,
          hideOnClick: true,
          offset: [0, 1]
        });
      }
    });
  },
  methods: {
    resetModel() {
      this.model = {
        url: null,
        text: null,
        target: null
      };
    },
    openNewModal() {
      this.tippy.hide();
      this.resetModel();
      const selectedText = this.getSelectedText();
      if (selectedText) {
        this.model.text = selectedText;
      }
      this.showEditModal = true;
    },
    openEditModal() {
      this.tippy.hide();
      const { from: from2, to } = this.editor.view.state.selection;
      const $node = this.editor.view.docView.domFromPos(from2).node;
      const attrs = this.editor.getAttributes("link");
      this.model.text = $node.textContent;
      this.model.url = attrs.href;
      this.model.target = attrs.target;
      this.showEditModal = true;
    },
    closeModal() {
      this.showEditModal = false;
    },
    openElementModal(selectedElement) {
      this.tippy.hide();
      this.resetModel();
      Craft.createElementSelectorModal(selectedElement.elementType, {
        storageKey: `FormieInput.LinkTo.${selectedElement.elementType}`,
        sources: selectedElement.sources,
        criteria: selectedElement.criteria,
        defaultSiteId: this.elementSiteId,
        autoFocusSearchBox: false,
        onSelect: $.proxy((elements) => {
          if (elements.length) {
            const [element] = elements;
            this.model.url = `${element.url}#${selectedElement.refHandle}:${element.id}@${element.siteId}`, this.model.text = this.getSelectedText() || element.label;
            this.tippy.hide();
            this.showEditModal = true;
          }
        }, this),
        closeOtherModals: false
      });
    },
    getSelectedText() {
      const { from: from2, to } = this.editor.state.selection;
      const selectedText = this.editor.state.doc.textBetween(from2, to, " ");
      if (selectedText) {
        return selectedText;
      }
      return false;
    },
    unlinkAction() {
      this.tippy.hide();
      this.editor.chain().focus().unsetLink().run();
    },
    onMouseDown(e) {
      e.preventDefault();
    }
  }
};
const _hoisted_1$e = {
  class: "fui-toolbar-dropdown-container fui-toolbar-dropdown-link",
  style: { "display": "none" }
};
const _hoisted_2$c = { key: 0 };
const _hoisted_3$9 = ["onClick"];
const _hoisted_4$7 = { key: 1 };
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_svg_icon = resolveComponent("svg-icon");
  const _component_link_menu_bubble = resolveComponent("link-menu-bubble");
  const _component_link_menu_modal = resolveComponent("link-menu-modal");
  const _directive_tooltip = resolveDirective("tooltip");
  return openBlock(), createElementBlock("div", null, [
    withDirectives((openBlock(), createElementBlock("button", {
      class: normalizeClass(["btn fui-toolbar-btn", { "active": $options.active }]),
      onClick: _cache[0] || (_cache[0] = withModifiers(() => {
      }, ["prevent"])),
      onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onMouseDown && $options.onMouseDown(...args))
    }, [
      createVNode(_component_svg_icon, {
        content: { icon: $props.icon, svg: $props.svg }
      }, null, 8, ["content"])
    ], 34)), [
      [_directive_tooltip, { content: $props.title, theme: "fui-editor-tooltip" }]
    ]),
    createBaseVNode("div", _hoisted_1$e, [
      !$options.active ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
        (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.linkOptions, (option3, i) => {
          return openBlock(), createElementBlock("button", {
            key: i,
            class: normalizeClass(["fui-toolbar-dropdown", "fui-toolbar-dropdown-item-link-" + option3.refHandle]),
            onClick: withModifiers(($event) => $options.openElementModal(option3), ["prevent"])
          }, toDisplayString(option3.optionTitle), 11, _hoisted_3$9);
        }), 128)),
        createBaseVNode("button", {
          class: "fui-toolbar-dropdown fui-toolbar-dropdown-item-link",
          onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.openNewModal && $options.openNewModal(...args), ["prevent"]))
        }, toDisplayString(_ctx.t("formie", "Insert Link")), 1)
      ])) : (openBlock(), createElementBlock("div", _hoisted_4$7, [
        createBaseVNode("button", {
          class: "fui-toolbar-dropdown fui-toolbar-dropdown-item-link",
          onClick: _cache[3] || (_cache[3] = withModifiers((...args) => $options.openEditModal && $options.openEditModal(...args), ["prevent"]))
        }, toDisplayString(_ctx.t("formie", "Edit Link")), 1)
      ])),
      createBaseVNode("button", {
        class: "fui-toolbar-dropdown fui-toolbar-dropdown-item-unlink",
        onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $options.unlinkAction && $options.unlinkAction(...args), ["prevent"]))
      }, toDisplayString(_ctx.t("formie", "Unlink")), 1)
    ]),
    createVNode(_component_link_menu_bubble, {
      editor: $props.editor,
      field: $props.field
    }, null, 8, ["editor", "field"]),
    createVNode(_component_link_menu_modal, {
      modelValue: $data.model,
      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.model = $event),
      show: $data.showEditModal,
      editor: $props.editor,
      field: $props.field,
      "confirm-button": "Insert",
      "modal-title": "Insert Link",
      onClose: $options.closeModal
    }, null, 8, ["modelValue", "show", "editor", "field", "onClose"])
  ]);
}
var LinkMenuBarItem = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/link/LinkMenuBarItem.vue"]]);
var VariableList_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".fui-variable-list li[data-v-879158d4] {\n  cursor: pointer;\n  padding: 5px 14px;\n  color: #606d7b;\n  font-weight: 500;\n  cursor: pointer;\n}\n.fui-variable-list li[data-v-879158d4]:hover {\n  background-color: #edf3fa;\n}\n.fui-variable-list li[data-v-879158d4]:first-child {\n  margin-top: 0 !important;\n}\n.fui-variable-list li.fui-list-item-heading[data-v-879158d4] {\n  text-transform: uppercase;\n  font-size: 10px;\n  padding: 0 14px;\n  margin-top: 5px;\n  color: #aebdce;\n  border-bottom: 1px #dfe5ea solid;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}")();
const _sfc_main$f = {
  name: "VariableList",
  props: {
    isOpen: {
      type: Boolean,
      default: false
    },
    variables: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  emits: ["updated"],
  methods: {
    truncate(string, options2) {
      return truncate(string, options2);
    },
    addVariable(e) {
      this.$emit("updated", e);
    }
  }
};
const _hoisted_1$d = {
  tabindex: "-1",
  role: "listbox",
  class: "fui-variable-list"
};
const _hoisted_2$b = ["data-value", "data-label"];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", _hoisted_1$d, [
    (openBlock(true), createElementBlock(Fragment$1, null, renderList($props.variables, (variable, index2) => {
      return openBlock(), createElementBlock("li", {
        key: index2,
        role: "option",
        class: normalizeClass({ "fui-list-item-heading": variable.heading }),
        "data-value": variable.value,
        "data-label": $options.truncate(variable.label, { length: 60 }),
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.addVariable && $options.addVariable(...args), ["prevent"]))
      }, toDisplayString($options.truncate(variable.label, { length: 60 })), 11, _hoisted_2$b);
    }), 128))
  ]);
}
var VariableList = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e], ["__scopeId", "data-v-879158d4"], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/variable-tag/VariableList.vue"]]);
var VariableTagMenuBarItem_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".fui-toolbar-dropdown-variables[data-v-7af8a2e5] {\n  display: block;\n  max-height: 200px;\n  overflow-y: auto;\n  padding: 5px 0;\n}")();
const _sfc_main$e = {
  name: "VariableTagItem",
  components: {
    SvgIcon,
    VariableList
  },
  props: {
    field: {
      type: Object,
      default: null
    },
    editor: {
      type: Object,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    svg: {
      type: String,
      default: null
    },
    title: {
      type: String,
      default: null
    },
    isActive: {
      type: Function,
      default: () => {
      }
    }
  },
  data() {
    return {
      tippy: null,
      variables: this.field.variables
    };
  },
  computed: {
    active() {
      return this.isActive && this.isActive();
    }
  },
  mounted() {
    this.$nextTick(() => {
      const $template = this.$el.querySelector(".fui-toolbar-dropdown-variables");
      const $button = this.$el;
      if ($template && $button) {
        $template.style.display = "block";
        this.tippy = tippy$1($button, {
          content: $template,
          trigger: "click",
          allowHTML: true,
          arrow: false,
          interactive: true,
          placement: "bottom-start",
          theme: "light-border toolbar-dropdown",
          zIndex: 1e3,
          hideOnClick: true,
          offset: [0, 1]
        });
      }
    });
  },
  methods: {
    addVariable(e) {
      this.tippy.hide();
      this.editor.chain().focus().setVariableTag({
        label: e.target.getAttribute("data-label"),
        value: e.target.getAttribute("data-value")
      }).run();
    },
    truncate(string, options2) {
      return truncate(string, options2);
    },
    onMouseDown(e) {
      e.preventDefault();
    }
  }
};
const _hoisted_1$c = {
  class: "fui-toolbar-dropdown-container fui-toolbar-dropdown-variables",
  style: { "display": "none" }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_svg_icon = resolveComponent("svg-icon");
  const _component_variable_list = resolveComponent("variable-list");
  const _directive_tooltip = resolveDirective("tooltip");
  return openBlock(), createElementBlock("div", null, [
    withDirectives((openBlock(), createElementBlock("button", {
      class: normalizeClass(["btn fui-toolbar-btn", { "active": $options.active }]),
      onClick: _cache[0] || (_cache[0] = withModifiers(() => {
      }, ["prevent"])),
      onMousedown: _cache[1] || (_cache[1] = (...args) => $options.onMouseDown && $options.onMouseDown(...args))
    }, [
      createVNode(_component_svg_icon, {
        content: { icon: $props.icon, svg: $props.svg }
      }, null, 8, ["content"])
    ], 34)), [
      [_directive_tooltip, { content: $props.title, theme: "fui-editor-tooltip" }]
    ]),
    createBaseVNode("div", _hoisted_1$c, [
      createVNode(_component_variable_list, {
        variables: $data.variables,
        onUpdated: $options.addVariable
      }, null, 8, ["variables", "onUpdated"])
    ])
  ]);
}
var VariableTagMenuBarItem = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-7af8a2e5"], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/variable-tag/VariableTagMenuBarItem.vue"]]);
var MenuBar_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".fui-editor-toolbar {\n  position: relative;\n  background: #fff;\n  border-radius: 3px 3px 0 0;\n  padding: 4px 8px;\n  align-items: center;\n  flex-wrap: wrap;\n  display: flex;\n  z-index: 5;\n  border-bottom: 1px rgba(49, 49, 93, 0.15) solid;\n  box-shadow: 0 2px 3px 0 rgba(49, 49, 93, 0.075);\n}")();
const _sfc_main$d = {
  components: {
    MenuBarItem,
    LinkMenuBarItem,
    VariableTagMenuBarItem
  },
  props: {
    field: {
      type: Object,
      default: null
    },
    editor: {
      type: Object,
      default: null
    },
    buttons: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  data() {
    return {
      allButtons: [
        {
          name: "bold",
          svg: "bold",
          title: Craft.t("formie", "Bold"),
          action: () => {
            return this.editor.chain().focus().toggleBold().run();
          },
          isActive: () => {
            return this.editor.isActive("bold");
          }
        },
        {
          name: "italic",
          svg: "italic",
          title: Craft.t("formie", "Italic"),
          action: () => {
            return this.editor.chain().focus().toggleItalic().run();
          },
          isActive: () => {
            return this.editor.isActive("italic");
          }
        },
        {
          name: "strikethrough",
          svg: "strikethrough",
          title: Craft.t("formie", "Strike"),
          action: () => {
            return this.editor.chain().focus().toggleStrike().run();
          },
          isActive: () => {
            return this.editor.isActive("strike");
          }
        },
        {
          name: "subscript",
          svg: "subscript",
          title: Craft.t("formie", "Subscript"),
          action: () => {
            return this.editor.chain().focus().toggleSubscript().run();
          },
          isActive: () => {
            return this.editor.isActive("subscript");
          }
        },
        {
          name: "superscript",
          svg: "superscript",
          title: Craft.t("formie", "Superscript"),
          action: () => {
            return this.editor.chain().focus().toggleSuperscript().run();
          },
          isActive: () => {
            return this.editor.isActive("superscript");
          }
        },
        {
          name: "underline",
          svg: "underline",
          title: Craft.t("formie", "Underline"),
          action: () => {
            return this.editor.chain().focus().toggleUnderline().run();
          },
          isActive: () => {
            return this.editor.isActive("underline");
          }
        },
        {
          name: "code",
          svg: "brackets-curly",
          title: Craft.t("formie", "Inline Code"),
          action: () => {
            return this.editor.chain().focus().toggleCode().run();
          },
          isActive: () => {
            return this.editor.isActive("code");
          }
        },
        {
          name: "highlight",
          icon: "highlighter",
          title: Craft.t("formie", "Highlight"),
          action: () => {
            return this.editor.chain().focus().toggleHighlight().run();
          },
          isActive: () => {
            return this.editor.isActive("highlight");
          }
        },
        {
          name: "paragraph",
          icon: "paragraph",
          title: Craft.t("formie", "Paragraph"),
          action: () => {
            return this.editor.chain().focus().setParagraph().run();
          }
        },
        {
          name: "unordered-list",
          svg: "list-ul",
          title: Craft.t("formie", "Bullet List"),
          action: () => {
            return this.editor.chain().focus().toggleBulletList().run();
          },
          isActive: () => {
            return this.editor.isActive("bulletList");
          }
        },
        {
          name: "ordered-list",
          svg: "list-ol",
          title: Craft.t("formie", "Ordered List"),
          action: () => {
            return this.editor.chain().focus().toggleOrderedList().run();
          },
          isActive: () => {
            return this.editor.isActive("orderedList");
          }
        },
        {
          name: "code-block",
          svg: "code",
          title: Craft.t("formie", "Code Block"),
          action: () => {
            return this.editor.chain().focus().toggleCodeBlock().run();
          },
          isActive: () => {
            return this.editor.isActive("codeBlock");
          }
        },
        {
          name: "quote",
          icon: "quote-right",
          title: Craft.t("formie", "Blockquote"),
          action: () => {
            return this.editor.chain().focus().toggleBlockquote().run();
          },
          isActive: () => {
            return this.editor.isActive("blockquote");
          }
        },
        {
          name: "hr",
          svg: "horizontal-rule",
          title: Craft.t("formie", "Horizontal Rule"),
          action: () => {
            return this.editor.chain().focus().setHorizontalRule().run();
          }
        },
        {
          name: "line-break",
          svg: "page-break",
          title: Craft.t("formie", "Line Break"),
          action: () => {
            return this.editor.chain().focus().setHardBreak().run();
          }
        },
        {
          name: "clear-format",
          svg: "remove-format",
          title: Craft.t("formie", "Clear Format"),
          action: () => {
            return this.editor.chain().focus().clearNodes().unsetAllMarks().run();
          }
        },
        {
          name: "undo",
          svg: "undo",
          title: Craft.t("formie", "Undo"),
          action: () => {
            return this.editor.chain().focus().undo().run();
          }
        },
        {
          name: "redo",
          svg: "redo",
          title: Craft.t("formie", "Redo"),
          action: () => {
            return this.editor.chain().focus().redo().run();
          }
        },
        {
          name: "align-left",
          icon: "align-left",
          title: Craft.t("formie", "Align Left"),
          action: () => {
            return this.editor.chain().focus().setTextAlign("left").run();
          }
        },
        {
          name: "align-center",
          icon: "align-center",
          title: Craft.t("formie", "Align Center"),
          action: () => {
            return this.editor.chain().focus().setTextAlign("center").run();
          }
        },
        {
          name: "align-right",
          icon: "align-right",
          title: Craft.t("formie", "Align Right"),
          action: () => {
            return this.editor.chain().focus().setTextAlign("right").run();
          }
        },
        {
          name: "align-justify",
          icon: "align-justify",
          title: Craft.t("formie", "Align Justify"),
          action: () => {
            return this.editor.chain().focus().setTextAlign("justify").run();
          }
        },
        {
          name: "formatting",
          icon: "paragraph",
          title: Craft.t("formie", "Formatting"),
          options: [
            {
              name: "paragraph",
              title: Craft.t("formie", "Paragraph")
            },
            {
              name: "code-block",
              title: Craft.t("formie", "Code Block"),
              action: () => {
                return this.editor.chain().focus().toggleCodeBlock().run();
              }
            },
            {
              name: "blockquote",
              title: Craft.t("formie", "Blockquote"),
              action: () => {
                return this.editor.chain().focus().toggleBlockquote().run();
              }
            },
            {
              name: "h1",
              title: Craft.t("formie", "Heading 1"),
              action: () => {
                return this.editor.chain().focus().toggleHeading({ level: 1 }).run();
              }
            },
            {
              name: "h2",
              title: Craft.t("formie", "Heading 2"),
              action: () => {
                return this.editor.chain().focus().toggleHeading({ level: 2 }).run();
              }
            },
            {
              name: "h3",
              title: Craft.t("formie", "Heading 3"),
              action: () => {
                return this.editor.chain().focus().toggleHeading({ level: 3 }).run();
              }
            },
            {
              name: "h4",
              title: Craft.t("formie", "Heading 4"),
              action: () => {
                return this.editor.chain().focus().toggleHeading({ level: 4 }).run();
              }
            },
            {
              name: "h5",
              title: Craft.t("formie", "Heading 5"),
              action: () => {
                return this.editor.chain().focus().toggleHeading({ level: 5 }).run();
              }
            },
            {
              name: "h6",
              title: Craft.t("formie", "Heading 6"),
              action: () => {
                return this.editor.chain().focus().toggleHeading({ level: 6 }).run();
              }
            }
          ]
        },
        {
          name: "link",
          svg: "link",
          title: Craft.t("formie", "Link"),
          component: "LinkMenuBarItem",
          isActive: () => {
            return this.editor.isActive("link");
          }
        },
        {
          name: "variableTag",
          svg: "plusCircle",
          title: Craft.t("formie", "Variables"),
          component: "VariableTagMenuBarItem",
          isActive: () => {
            return this.editor.isActive("variableTag");
          }
        }
      ]
    };
  },
  computed: {
    availableButtons() {
      const buttons = [];
      this.buttons.forEach((buttonName) => {
        const button2 = this.allButtons.find((x) => {
          return x.name === buttonName;
        });
        if (button2) {
          if (button2.name === "formatting") {
            button2.options = this.getEnabledOptions(button2, this.field.getFormattingOptions());
          }
          buttons.push(button2);
        }
      });
      return buttons;
    }
  },
  methods: {
    getEnabledOptions(button2, collection) {
      const options2 = [];
      collection.forEach((optionName) => {
        const option3 = button2.options.find((x) => {
          return x.name === optionName;
        });
        if (option3) {
          options2.push(option3);
        }
      });
      return options2;
    }
  }
};
const _hoisted_1$b = { class: "fui-editor-toolbar" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.availableButtons, (item, index2) => {
      return openBlock(), createBlock(resolveDynamicComponent(item.component || "MenuBarItem"), mergeProps({ key: index2 }, item, {
        editor: $props.editor,
        field: $props.field
      }), null, 16, ["editor", "field"]);
    }), 128))
  ]);
}
var MenuBar = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/richtext/MenuBar.vue"]]);
var RichTextInput_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".fui-rich-text {\n  position: relative;\n  border-radius: 3px;\n  border: 1px solid rgba(96, 125, 159, 0.25);\n  z-index: 2;\n}\n.fui-rich-text.has-focus {\n  box-shadow: 0 0 0 1px #127fbf, 0 0 0 3px rgba(18, 127, 191, 0.5);\n}\n.fui-rich-text .ProseMirror {\n  outline: none;\n  word-wrap: normal;\n  padding: 16px;\n  min-height: 10rem;\n  background-color: #fbfcfe;\n  background-clip: padding-box;\n}\n[data-is-showing-errors=true] .fui-rich-text .ProseMirror {\n  border-color: #CF1124;\n}\n.fui-rich-text .ProseMirror:focus {\n  box-shadow: none;\n}\n.fui-editor, .fui-editor * {\n  box-sizing: border-box;\n}\n.fui-editor .ProseMirror > ul,\n.fui-editor .ProseMirror > ol {\n  padding-left: 0 !important;\n  margin-left: 24px;\n}\n.fui-editor .ProseMirror > ul ul, .fui-editor .ProseMirror > ul ol,\n.fui-editor .ProseMirror > ol ul,\n.fui-editor .ProseMirror > ol ol {\n  padding-left: 0 !important;\n  margin-left: 24px;\n}\n.fui-editor .ProseMirror > ul p,\n.fui-editor .ProseMirror > ol p {\n  margin: 0;\n}\n.fui-editor .ProseMirror > ul {\n  list-style-type: disc;\n}\n.fui-editor .ProseMirror > ul ul {\n  list-style-type: disc;\n}\n.fui-editor .ProseMirror > blockquote {\n  border-left: 5px solid #edf2fc;\n  border-radius: 2px;\n  color: #606266;\n  margin: 10px 0;\n  padding-left: 1em;\n}\n.fui-editor .ProseMirror > pre {\n  background: #0d0d0d;\n  color: #fff;\n  font-family: JetBrainsMono, monospace;\n  padding: 0.75rem 1rem;\n  border-radius: 0.5rem;\n}\n.fui-editor .ProseMirror > p > a {\n  color: #3397ff;\n  text-decoration: underline;\n}\n.fui-rich-text-rows-1 .ProseMirror {\n  min-height: 1rem;\n}\n.fui-rich-text-rows-2 .ProseMirror {\n  min-height: 2rem;\n}\n.fui-rich-text-rows-3 .ProseMirror {\n  min-height: 3rem;\n}\n.fui-rich-text-rows-4 .ProseMirror {\n  min-height: 4rem;\n}\n.fui-rich-text-rows-5 .ProseMirror {\n  min-height: 5rem;\n}\n.fui-rich-text-rows-6 .ProseMirror {\n  min-height: 6rem;\n}\n.fui-rich-text-rows-7 .ProseMirror {\n  min-height: 7rem;\n}\n.fui-rich-text-rows-8 .ProseMirror {\n  min-height: 8rem;\n}\n.fui-rich-text-rows-9 .ProseMirror {\n  min-height: 9rem;\n}")();
const _sfc_main$c = {
  name: "RichTextField",
  components: {
    EditorContent,
    MenuBar
  },
  props: {
    context: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      mounted: false,
      buttons: ["bold", "italic"],
      editor: null,
      json: null,
      html: null,
      variables: {}
    };
  },
  computed: {
    jsonContent() {
      return this.contentToValue(this.json);
    },
    emailVariables() {
      return this.$store.getters["form/emailFields"]();
    },
    numberVariables() {
      return this.$store.getters["form/numberFields"]();
    },
    plainTextVariables() {
      return this.$store.getters["form/allFields"](true);
    },
    calculationsVariables() {
      return this.$store.getters["form/plainTextFields"](false);
    },
    allowSource() {
      return get2(this.context.attrs, "allow-source", false);
    },
    rows() {
      return get2(this.context.attrs, "rows", 10);
    },
    linkOptions() {
      return get2(this.context.attrs, "linkOptions", []);
    }
  },
  watch: {
    jsonContent(newValue) {
      this.context.node.input(newValue);
    }
  },
  mounted() {
    this.editor = new Editor({
      extensions: this.getExtensions(),
      content: this.valueToContent(this.clone(this.context._value)),
      autofocus: false,
      onUpdate: () => {
        this.json = this.editor.getJSON().content;
        this.html = this.editor.getHTML();
      }
    });
    this.json = this.editor.getJSON().content;
    this.html = this.editor.getHTML();
    this.$nextTick(() => {
      this.mounted = true;
    });
  },
  created() {
    if (this.context.attrs.buttons) {
      this.buttons = this.context.attrs.buttons;
    }
    const variablesAttribute = this.context.attrs.variables || "";
    if (variablesAttribute && this[variablesAttribute]) {
      this.variables = this[variablesAttribute];
    }
  },
  beforeUnmount() {
    if (this.editor) {
      this.editor.destroy();
    }
  },
  methods: {
    getFormattingOptions() {
      let options2 = ["paragraph", "code-block", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6"];
      if (this.context.attrs.formatting && this.context.attrs.formatting.length) {
        options2 = this.context.attrs.formatting;
      }
      return options2;
    },
    getExtensions() {
      const extensions2 = [
        Document,
        Dropcursor,
        Gapcursor,
        HardBreak,
        Paragraph,
        Text$1,
        FocusClasses.configure({ className: "has-focus", mode: "deepest" }),
        Bold,
        Code,
        Highlight,
        Italic,
        Strike,
        Subscript,
        Superscript,
        Underline,
        Blockquote,
        BulletList,
        CodeBlock,
        Heading.configure({ levels: [1, 2, 3, 4, 5, 6] }),
        HorizontalRule,
        ListItem,
        OrderedList,
        History,
        TextAlign.configure({
          types: ["heading", "paragraph"],
          defaultAlignment: "start"
        }),
        Link.configure({ openOnClick: false }),
        VariableTag.configure({ field: this })
      ];
      return extensions2;
    },
    valueToContent(value) {
      if (!value) {
        return null;
      }
      if (!Array.isArray(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
          console.log(e);
          console.log(value);
        }
      }
      return value.length ? { type: "doc", content: value } : null;
    },
    contentToValue(content) {
      return JSON.stringify(content);
    },
    isFocused() {
      return this.editor.isFocused;
    }
  }
};
const _hoisted_1$a = {
  key: 1,
  class: "input text",
  style: { "margin-top": "20px" }
};
const _hoisted_2$a = ["name"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_menu_bar = resolveComponent("menu-bar");
  const _component_editor_content = resolveComponent("editor-content");
  return openBlock(), createElementBlock("div", null, [
    $data.editor ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["fui-rich-text", ["fui-rich-text-rows-" + $options.rows, { "has-focus": $options.isFocused() }]])
    }, [
      $data.buttons.length ? (openBlock(), createBlock(_component_menu_bar, {
        key: 0,
        ref: "toolbar",
        buttons: $data.buttons,
        editor: $data.editor,
        field: this
      }, null, 8, ["buttons", "editor"])) : createCommentVNode("v-if", true),
      createVNode(_component_editor_content, {
        class: "fui-editor",
        editor: $data.editor
      }, null, 8, ["editor"])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.$isDebug ? (openBlock(), createElementBlock("div", _hoisted_1$a, toDisplayString($options.jsonContent), 1)) : createCommentVNode("v-if", true),
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.context._value = $event),
      name: $props.context.node.name,
      type: "hidden"
    }, null, 8, _hoisted_2$a), [
      [vModelText, $props.context._value]
    ])
  ]);
}
var RichTextInput = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/RichTextInput.vue"]]);
const _sfc_main$b = {
  props: {
    context: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      proxyValue: {}
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    field() {
      if (this.editingField) {
        return this.editingField.field;
      }
      return [];
    },
    columns() {
      return get2(this.context.attrs, "columns", {});
    },
    rows() {
      return get2(this.context.attrs, "rows", {});
    }
  }),
  mounted() {
    if (isEmpty$1(this.context._value)) {
      this.context.node.input({});
      setTimeout(() => {
        this.proxyValue = this.context._value;
      }, 20);
    } else {
      this.proxyValue = this.context._value;
    }
  },
  methods: {
    fieldSelectOptions() {
      const options2 = [
        { label: this.t("formie", "Select an option"), value: "" }
      ];
      const allFields = this.$store.getters["form/fields"];
      const fieldTypes = this.context.attrs.fieldTypes || [];
      allFields.forEach((field) => {
        if (fieldTypes.length && !fieldTypes.includes(field.type)) {
          return;
        }
        if (this.field && this.field.handle === field.handle) {
          return;
        }
        if (field.isCosmetic) {
          return;
        }
        if (!toBoolean(field.isNested)) {
          options2.push({ label: truncate(field.label, { length: 60 }), value: `{${field.handle}}` });
          if (field.subfieldOptions && field.hasSubfields) {
            field.subfieldOptions.forEach((subfield) => {
              options2.push({
                label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                value: `{${field.handle}[${subfield.handle}]}`
              });
            });
          }
          if (toBoolean(field.supportsNested) && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((subfield) => {
                options2.push({
                  label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                  value: `{${field.handle}[${subfield.handle}]}`
                });
                if (subfield.subfieldOptions && subfield.hasSubfields) {
                  subfield.subfieldOptions.forEach((subsubfield) => {
                    options2.push({
                      label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}: ${truncate(subsubfield.label, { length: 60 })}`,
                      value: `{${field.handle}[${subfield.handle}[${subsubfield.handle}]]}`
                    });
                  });
                }
              });
            });
          }
        }
      });
      return options2;
    }
  }
};
const _hoisted_1$9 = {
  ref: "table",
  class: "editable fullwidth"
};
const _hoisted_2$9 = { class: "flex flex-nowrap" };
const _hoisted_3$8 = { class: "small select" };
const _hoisted_4$6 = ["onUpdate:modelValue", "name"];
const _hoisted_5$5 = ["value"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", _hoisted_1$9, [
    createBaseVNode("thead", null, [
      createBaseVNode("tr", null, [
        (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.columns, (col, key, index2) => {
          return openBlock(), createElementBlock("th", {
            key: index2,
            scope: "col",
            class: normalizeClass(col.class)
          }, toDisplayString(col.label ? col.label : "") + " " + toDisplayString(col.heading ? col.heading : ""), 3);
        }), 128))
      ])
    ]),
    createBaseVNode("tbody", null, [
      (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.rows, (row, rowKey, rowIndex) => {
        return openBlock(), createElementBlock("tr", { key: rowIndex }, [
          (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.columns, (col, colKey, colIndex) => {
            return openBlock(), createElementBlock(Fragment$1, null, [
              col.type === "heading" ? (openBlock(), createElementBlock("th", {
                key: colIndex,
                class: normalizeClass(col.class)
              }, toDisplayString(row[colKey]), 3)) : createCommentVNode("v-if", true),
              col.type === "fieldSelect" ? (openBlock(), createElementBlock("td", {
                key: colIndex,
                class: normalizeClass(col.class)
              }, [
                createBaseVNode("div", _hoisted_2$9, [
                  createBaseVNode("div", _hoisted_3$8, [
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => $data.proxyValue[rowKey] = $event,
                      name: colKey
                    }, [
                      (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.fieldSelectOptions(), (option3, j2) => {
                        return openBlock(), createElementBlock("option", {
                          key: j2,
                          value: option3.value
                        }, toDisplayString(option3.label), 9, _hoisted_5$5);
                      }), 128))
                    ], 8, _hoisted_4$6), [
                      [vModelSelect, $data.proxyValue[rowKey]]
                    ])
                  ])
                ])
              ], 2)) : createCommentVNode("v-if", true)
            ], 64);
          }), 256))
        ]);
      }), 128))
    ])
  ], 512);
}
var StaticTableInput = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/StaticTableInput.vue"]]);
var vuedraggable_umd = { exports: {} };
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_esmBundler);
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target2 = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target2[key] = source[key];
    }
  }
  return target2;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var version = "1.14.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el2, event, fn2) {
  el2.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off(el2, event, fn2) {
  el2.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches2(el2, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el2) {
    try {
      if (el2.matches) {
        return el2.matches(selector);
      } else if (el2.msMatchesSelector) {
        return el2.msMatchesSelector(selector);
      } else if (el2.webkitMatchesSelector) {
        return el2.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el2) {
  return el2.host && el2 !== document && el2.host.nodeType ? el2.host : el2.parentNode;
}
function closest(el2, selector, ctx, includeCTX) {
  if (el2) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el2.parentNode === ctx && matches2(el2, selector) : matches2(el2, selector)) || includeCTX && el2 === ctx) {
        return el2;
      }
      if (el2 === ctx)
        break;
    } while (el2 = getParentOrHost(el2));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el2, name, state2) {
  if (el2 && name) {
    if (el2.classList) {
      el2.classList[state2 ? "add" : "remove"](name);
    } else {
      var className = (" " + el2.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el2.className = (className + (state2 ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el2, prop2, val) {
  var style2 = el2 && el2.style;
  if (style2) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el2, "");
      } else if (el2.currentStyle) {
        val = el2.currentStyle;
      }
      return prop2 === void 0 ? val : val[prop2];
    } else {
      if (!(prop2 in style2) && prop2.indexOf("webkit") === -1) {
        prop2 = "-webkit-" + prop2;
      }
      style2[prop2] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el2, selfOnly) {
  var appliedTransforms = "";
  if (typeof el2 === "string") {
    appliedTransforms = el2;
  } else {
    do {
      var transform2 = css(el2, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el2 = el2.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list3 = ctx.getElementsByTagName(tagName), i = 0, n = list3.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list3[i], i);
      }
    }
    return list3;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el2, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el2.getBoundingClientRect && el2 !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height, width;
  if (el2 !== window && el2.parentNode && el2 !== getWindowScrollingElement()) {
    elRect = el2.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el2 !== window) {
    container = container || el2.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el2 !== window) {
    var elMatrix = matrix(container || el2), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left2 /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom2 = top2 + height;
      right2 = left2 + width;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width,
    height
  };
}
function isScrolledPast(el2, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el2, true), elSideVal = getRect(el2)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild2(el2, childNum, options2, includeDragEl) {
  var currentChild = 0, i = 0, children = el2.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options2.draggable, el2, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el2, selector) {
  var last2 = el2.lastElementChild;
  while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches2(last2, selector))) {
    last2 = last2.previousElementSibling;
  }
  return last2 || null;
}
function index(el2, selector) {
  var index2 = 0;
  if (!el2 || !el2.parentNode) {
    return -1;
  }
  while (el2 = el2.previousElementSibling) {
    if (el2.nodeName.toUpperCase() !== "TEMPLATE" && el2 !== Sortable.clone && (!selector || matches2(el2, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el2) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el2) {
    do {
      var elMatrix = matrix(el2), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el2.scrollLeft * scaleX;
      offsetTop += el2.scrollTop * scaleY;
    } while (el2 !== winScroller && (el2 = el2.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el2, includeSelf) {
  if (!el2 || !el2.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el2;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el2, x, y) {
  el2.scrollLeft += x;
  el2.scrollTop += y;
}
function clone$1(el2) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el2).cloneNode(true);
  } else if ($2) {
    return $2(el2).clone(true)[0];
  } else {
    return el2.cloneNode(true);
  }
}
function setRect(el2, rect2) {
  css(el2, "position", "absolute");
  css(el2, "top", rect2.top);
  css(el2, "left", rect2.left);
  css(el2, "width", rect2.width);
  css(el2, "height", rect2.height);
}
function unsetRect(el2) {
  css(el2, "position", "");
  css(el2, "top", "");
  css(el2, "left", "");
  css(el2, "width", "");
  css(el2, "height", "");
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state2) {
      animationStates.push(state2);
    },
    removeAnimationState: function removeAnimationState(target2) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target2
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state2) {
        var time2 = 0, target2 = state2.target, fromRect = target2.fromRect, toRect = getRect(target2), prevFromRect = target2.prevFromRect, prevToRect = target2.prevToRect, animatingRect = state2.rect, targetMatrix = matrix(target2, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target2.toRect = toRect;
        if (target2.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time2 = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target2.prevFromRect = fromRect;
          target2.prevToRect = toRect;
          if (!time2) {
            time2 = _this.options.animation;
          }
          _this.animate(target2, animatingRect, toRect, time2);
        }
        if (time2) {
          animating = true;
          animationTime = Math.max(animationTime, time2);
          clearTimeout(target2.animationResetTimer);
          target2.animationResetTimer = setTimeout(function() {
            target2.animationTime = 0;
            target2.prevFromRect = null;
            target2.fromRect = null;
            target2.prevToRect = null;
            target2.thisAnimationDuration = null;
          }, time2);
          target2.thisAnimationDuration = time2;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target2, currentRect, toRect, duration) {
      if (duration) {
        css(target2, "transition", "");
        css(target2, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target2.animatingX = !!translateX;
        target2.animatingY = !!translateY;
        css(target2, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target2);
        css(target2, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target2, "transform", "translate3d(0,0,0)");
        typeof target2.animated === "number" && clearTimeout(target2.animated);
        target2.animated = setTimeout(function() {
          css(target2, "transition", "");
          css(target2, "transform", "");
          target2.animated = false;
          target2.animatingX = false;
          target2.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target2) {
  return target2.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options2) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options2.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin2) {
    for (var option3 in defaults) {
      if (defaults.hasOwnProperty(option3) && !(option3 in plugin2)) {
        plugin2[option3] = defaults[option3];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin2.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin2.pluginName, " more than once");
      }
    });
    plugins.push(plugin2);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (sortable[plugin2.pluginName][eventNameGlobal]) {
        sortable[plugin2.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin2.pluginName] && sortable[plugin2.pluginName][eventName]) {
        sortable[plugin2.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el2, defaults2, options2) {
    plugins.forEach(function(plugin2) {
      var pluginName = plugin2.pluginName;
      if (!sortable.options[pluginName] && !plugin2.initializeByDefault)
        return;
      var initialized = new plugin2(sortable, el2, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option3 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option3))
        continue;
      var modified = this.modifyOption(sortable, option3, sortable.options[option3]);
      if (typeof modified !== "undefined") {
        sortable.options[option3] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin2) {
      if (typeof plugin2.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin2.eventProperties.call(sortable[plugin2.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (plugin2.optionListeners && typeof plugin2.optionListeners[name] === "function") {
        modifiedValue = plugin2.optionListeners[name].call(sortable[plugin2.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref2) {
  var sortable = _ref2.sortable, rootEl2 = _ref2.rootEl, name = _ref2.name, targetEl = _ref2.targetEl, cloneEl2 = _ref2.cloneEl, toEl = _ref2.toEl, fromEl = _ref2.fromEl, oldIndex2 = _ref2.oldIndex, newIndex2 = _ref2.newIndex, oldDraggableIndex2 = _ref2.oldDraggableIndex, newDraggableIndex2 = _ref2.newDraggableIndex, originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, extraEventProperties = _ref2.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options2 = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option3 in allEventProperties) {
    evt[option3] = allEventProperties[option3];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options2[onName]) {
    options2[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref2.evt, data = _objectWithoutProperties(_ref2, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el2 = document.createElement("x");
  el2.style.cssText = "pointer-events:auto";
  return el2.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el2, options2) {
  var elCSS = css(el2), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild2(el2, 0, options2), child2 = getChild2(el2, 1, options2), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect2 = getRect(sortable), insideHorizontally = x >= rect2.left - threshold && x <= rect2.right + threshold, insideVertically = y >= rect2.top - threshold && y <= rect2.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options2) {
  function toFn(value, pull) {
    return function(to, from2, dragEl2, evt) {
      var sameGroup = to.options.group.name && from2.options.group.name && to.options.group.name === from2.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from2, dragEl2, evt), pull)(to, from2, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from2).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group2 = {};
  var originalGroup = options2.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group2.name = originalGroup.name;
  group2.checkPull = toFn(originalGroup.pull, true);
  group2.checkPut = toFn(originalGroup.put);
  group2.revertClone = originalGroup.revertClone;
  options2.group = group2;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el2, options2) {
  if (!(el2 && el2.nodeType && el2.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el2));
  }
  this.el = el2;
  this.options = options2 = _extends({}, options2);
  el2[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el2.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el2, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el2, defaults2);
  for (var name in defaults2) {
    !(name in options2) && (options2[name] = defaults2[name]);
  }
  _prepareGroup(options2);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options2.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options2.supportPointer) {
    on(el2, "pointerdown", this._onTapStart);
  } else {
    on(el2, "mousedown", this._onTapStart);
    on(el2, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el2, "dragover", this);
    on(el2, "dragenter", this);
  }
  sortables.push(this.el);
  options2.store && options2.store.get && this.sort(options2.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target2) {
    if (!this.el.contains(target2) && target2 !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target2) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target2, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el2 = this.el, options2 = this.options, preventOnFilter = options2.preventOnFilter, type = evt.type, touch2 = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target2 = (touch2 || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target2, filter2 = options2.filter;
    _saveInputCheckedState(el2);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options2.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target2 && target2.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target2 = closest(target2, options2.draggable, el2, false);
    if (target2 && target2.animated) {
      return;
    }
    if (lastDownEl === target2) {
      return;
    }
    oldIndex = index(target2);
    oldDraggableIndex = index(target2, options2.draggable);
    if (typeof filter2 === "function") {
      if (filter2.call(this, evt, target2, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target2,
          toEl: el2,
          fromEl: el2
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter2) {
      filter2 = filter2.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el2, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target2,
            fromEl: el2,
            toEl: el2
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter2) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options2.handle && !closest(originalTarget, options2.handle, el2, false)) {
      return;
    }
    this._prepareDragStart(evt, touch2, target2);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch2, target2) {
    var _this = this, el2 = _this.el, options2 = _this.options, ownerDocument = el2.ownerDocument, dragStartFn;
    if (target2 && !dragEl && target2.parentNode === el2) {
      var dragRect = getRect(target2);
      rootEl = el2;
      dragEl = target2;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target2;
      activeGroup = options2.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch2 || evt).clientX,
        clientY: (touch2 || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch2 || evt).clientX;
      this._lastY = (touch2 || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch2);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options2.chosenClass, true);
      };
      options2.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options2.delay && (!options2.delayOnTouchOnly || touch2) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options2.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options2.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch2 = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch2.clientX - this._lastX), Math.abs(touch2.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch2) {
    touch2 = touch2 || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch2) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch2) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options2 = this.options;
      !fallback && toggleClass(dragEl, options2.dragClass, false);
      toggleClass(dragEl, options2.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target2 = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target2;
      while (target2 && target2.shadowRoot) {
        target2 = target2.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target2 === parent)
          break;
        parent = target2;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target2);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target2,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target2 = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options2 = this.options, fallbackTolerance = options2.fallbackTolerance, fallbackOffset = options2.fallbackOffset, touch2 = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch2.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch2.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch2.clientX - this._lastX), Math.abs(touch2.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch2;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect2 = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options2 = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect2.top += ghostRelativeParent.scrollTop;
          rect2.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options2.ghostClass, false);
      toggleClass(ghostEl, options2.fallbackClass, true);
      toggleClass(ghostEl, options2.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect2.top);
      css(ghostEl, "left", rect2.left);
      css(ghostEl, "width", rect2.width);
      css(ghostEl, "height", rect2.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options2 = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone$1(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options2.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options2.setData && options2.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el2 = this.el, target2 = evt.target, dragRect, targetRect, revert, options2 = this.options, group2 = options2.group, activeSortable = Sortable.active, isOwner = activeGroup === group2, canSort = options2.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target: target2,
        completed,
        onMove: function onMove(target3, after2) {
          return _onMove(rootEl, el2, dragEl, dragRect, target3, getRect(target3), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options2.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target2;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target2 === dragEl && !dragEl.animated || target2 === el2 && !target2.animated) {
        lastTarget = null;
      }
      if (!options2.dragoverBubble && !evt.rootEl && target2 !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options2.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options2.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el2,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target2 = closest(target2, options2.draggable, el2, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target2.animated && target2.animatingX && target2.animatingY || _this._ignoreWhileAnimating === target2) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options2.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group2.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target2) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el2, options2.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el2 === evt.target) {
          target2 = elLastChild;
        }
        if (target2) {
          targetRect = getRect(target2);
        }
        if (_onMove(rootEl, el2, dragEl, dragRect, target2, targetRect, evt, !!target2) !== false) {
          capture();
          el2.appendChild(dragEl);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild2(el2, 0, options2, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target2 = firstChild;
        targetRect = getRect(target2);
        if (_onMove(rootEl, el2, dragEl, dragRect, target2, targetRect, evt, false) !== false) {
          capture();
          el2.insertBefore(dragEl, firstChild);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (target2.parentNode === el2) {
        targetRect = getRect(target2);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el2, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target2.animated && target2.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target2, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target2) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options2.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target2, targetRect, vertical, differentRowCol ? 1 : options2.swapThreshold, options2.invertedSwapThreshold == null ? options2.swapThreshold : options2.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target2);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target2) {
          return completed(false);
        }
        lastTarget = target2;
        lastDirection = direction;
        var nextSibling = target2.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el2, dragEl, dragRect, target2, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el2.appendChild(dragEl);
          } else {
            target2.parentNode.insertBefore(dragEl, after ? nextSibling : target2);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target2)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el2.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el2 = this.el, options2 = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options2.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options2.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el2, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options2.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el2) {
      el2.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order2 = [], el2, children = this.el.children, i = 0, n = children.length, options2 = this.options;
    for (; i < n; i++) {
      el2 = children[i];
      if (closest(el2, options2.draggable, this.el, false)) {
        order2.push(el2.getAttribute(options2.dataIdAttr) || _generateId(el2));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el2 = rootEl2.children[i];
      if (closest(el2, this.options.draggable, rootEl2, false)) {
        items[id] = el2;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store2 = this.options.store;
    store2 && store2.set && store2.set(this);
  },
  closest: function closest$1(el2, selector) {
    return closest(el2, selector || this.options.draggable, this.el, false);
  },
  option: function option2(name, value) {
    var options2 = this.options;
    if (value === void 0) {
      return options2[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options2[name] = modifiedValue;
      } else {
        options2[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options2);
      }
    }
  },
  destroy: function destroy2() {
    pluginEvent2("destroy", this);
    var el2 = this.el;
    el2[expando] = null;
    off(el2, "mousedown", this._onTapStart);
    off(el2, "touchstart", this._onTapStart);
    off(el2, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el2, "dragover", this);
      off(el2, "dragenter", this);
    }
    Array.prototype.forEach.call(el2.querySelectorAll("[draggable]"), function(el3) {
      el3.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el2 = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el2) {
  el2.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect2 = getRect(getChild2(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect2.left - spacer || evt.clientY < rect2.top && evt.clientX < rect2.right : evt.clientY < rect2.top - spacer || evt.clientY < rect2.bottom && evt.clientX < rect2.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect2 = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect2.right + spacer || evt.clientX <= rect2.right && evt.clientY > rect2.bottom && evt.clientX >= rect2.left : evt.clientX > rect2.right && evt.clientY > rect2.top || evt.clientX <= rect2.right && evt.clientY > rect2.bottom + spacer;
}
function _getSwapDirection(evt, target2, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target2);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target2) {
  if (index(dragEl) < index(target2)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el2) {
  var str = el2.tagName + el2.className + el2.src + el2.href + el2.textContent, i = str.length, sum2 = 0;
  while (i--) {
    sum2 += str.charCodeAt(i);
  }
  return sum2.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs2 = root2.getElementsByTagName("input");
  var idx = inputs2.length;
  while (idx--) {
    var el2 = inputs2[idx];
    el2.checked && savedInputChecked.push(el2);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is3(el2, selector) {
    return !!closest(el2, selector, el2, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone: clone$1,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild2
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin2) {
    if (!plugin2.prototype || !plugin2.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin2));
    }
    if (plugin2.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin2.utils);
    PluginManager.mount(plugin2);
  });
};
Sortable.create = function(el2, options2) {
  return new Sortable(el2, options2);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted2(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options2, rootEl2, isFallback) {
  if (!options2.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options2.scrollSensitivity, speed = options2.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options2.scroll;
    scrollCustomFn = options2.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el2 = currentParent, rect2 = getRect(el2), top2 = rect2.top, bottom2 = rect2.bottom, left2 = rect2.left, right2 = rect2.right, width = rect2.width, height = rect2.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el2.scrollWidth, scrollHeight = el2.scrollHeight, elCSS = css(el2), scrollPosX = el2.scrollLeft, scrollPosY = el2.scrollTop;
    if (el2 === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el2) {
      autoScrolls[layersOut].el = el2;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options2.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref2) {
  var originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, dragEl2 = _ref2.dragEl, activeSortable = _ref2.activeSortable, dispatchSortableEvent = _ref2.dispatchSortableEvent, hideGhostForTarget = _ref2.hideGhostForTarget, unhideGhostForTarget = _ref2.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch2 = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target2 = document.elementFromPoint(touch2.clientX, touch2.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target2)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild2(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: "sortable-swap-highlight"
    };
  }
  Swap.prototype = {
    dragStart: function dragStart2(_ref2) {
      var dragEl2 = _ref2.dragEl;
      lastSwapEl = dragEl2;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed, target2 = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
      if (!activeSortable.options.swap)
        return;
      var el2 = this.sortable.el, options2 = this.options;
      if (target2 && target2 !== el2) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target2) !== false) {
          toggleClass(target2, options2.swapClass, true);
          lastSwapEl = target2;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options2.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop3(_ref3) {
      var activeSortable = _ref3.activeSortable, putSortable2 = _ref3.putSortable, dragEl2 = _ref3.dragEl;
      var toSortable = putSortable2 || this.sortable;
      var options2 = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options2.swapClass, false);
      if (lastSwapEl && (options2.swap || putSortable2 && putSortable2.options.swap)) {
        if (dragEl2 !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable)
            activeSortable.captureAnimationState();
          swapNodes(dragEl2, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable)
            activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: "swap",
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1))
    return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}
var multiDragElements = [], multiDragClones = [], lastMultiDragSelect, multiDragSortable, initialFolding = false, folding = false, dragStarted = false, dragEl$1, clonesFromRect, clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
    if (sortable.options.supportPointer) {
      on(document, "pointerup", this._deselectMultiDrag);
    } else {
      on(document, "mouseup", this._deselectMultiDrag);
      on(document, "touchend", this._deselectMultiDrag);
    }
    on(document, "keydown", this._checkKeyDown);
    on(document, "keyup", this._checkKeyUp);
    this.defaults = {
      selectedClass: "sortable-selected",
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl2) {
        var data = "";
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function(multiDragElement, i) {
            data += (!i ? "" : ", ") + multiDragElement.textContent;
          });
        } else {
          data = dragEl2.textContent;
        }
        dataTransfer.setData("Text", data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref2) {
      var dragged = _ref2.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable, cancel = _ref2.cancel;
      if (!this.isMultiDrag)
        return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone$1(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style["will-change"] = "";
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone2(_ref3) {
      var sortable = _ref3.sortable, rootEl2 = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
      if (!this.isMultiDrag)
        return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl2);
          dispatchSortableEvent("clone");
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown, rootEl2 = _ref4.rootEl, cancel = _ref4.cancel;
      if (!this.isMultiDrag)
        return;
      insertMultiDragClones(false, rootEl2);
      multiDragClones.forEach(function(clone2) {
        css(clone2, "display", "");
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      _ref5.sortable;
      var cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
      if (!this.isMultiDrag)
        return;
      multiDragClones.forEach(function(clone2) {
        css(clone2, "display", "none");
        if (_this.options.removeCloneOnHide && clone2.parentNode) {
          clone2.parentNode.removeChild(clone2);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function(multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });
      multiDragElements = multiDragElements.sort(function(a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted2(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag)
        return;
      if (this.options.sort) {
        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            css(multiDragElement, "position", "absolute");
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function() {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function(multiDragElement) {
            unsetRect(multiDragElement);
          });
        }
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target2 = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target2)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable, rootEl2 = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        multiDragElements.forEach(function(multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl2);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl2 = _ref10.parentEl, putSortable2 = _ref10.putSortable;
      var options2 = this.options;
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        if (options2.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable2)) {
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function(multiDragElement) {
            if (multiDragElement === dragEl$1)
              return;
            setRect(multiDragElement, dragRectAbsolute);
            parentEl2.appendChild(multiDragElement);
          });
          folding = true;
        }
        if (!isOwner) {
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function(clone2) {
                activeSortable.addAnimationState({
                  target: clone2,
                  rect: clonesFromRect
                });
                clone2.fromRect = clonesFromRect;
                clone2.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function(multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop3(_ref12) {
      var evt = _ref12.originalEvent, rootEl2 = _ref12.rootEl, parentEl2 = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex2 = _ref12.oldIndex, putSortable2 = _ref12.putSortable;
      var toSortable = putSortable2 || this.sortable;
      if (!evt)
        return;
      var options2 = this.options, children = parentEl2.children;
      if (!dragStarted) {
        if (options2.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options2.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable,
            rootEl: rootEl2,
            name: "select",
            targetEl: dragEl$1,
            originalEvt: evt
          });
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              var n, i;
              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }
              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i]))
                  continue;
                toggleClass(children[i], options2.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable,
                  rootEl: rootEl2,
                  name: "select",
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable,
            rootEl: rootEl2,
            name: "deselect",
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      }
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        if ((parentEl2[expando].options.sort || parentEl2 !== rootEl2) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
          if (!initialFolding && options2.animation)
            dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options2.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function(multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect2 = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect2;
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect2
                  });
                }
              });
            }
            removeMultiDragElements();
            multiDragElements.forEach(function(multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl2.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl2.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });
            if (oldIndex2 === index(dragEl$1)) {
              var update3 = false;
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update3 = true;
                  return;
                }
              });
              if (update3) {
                dispatchSortableEvent("update");
              }
            }
          }
          multiDragElements.forEach(function(multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }
      if (rootEl2 === parentEl2 || putSortable2 && putSortable2.lastPutMode !== "clone") {
        multiDragClones.forEach(function(clone2) {
          clone2.parentNode && clone2.parentNode.removeChild(clone2);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, "pointerup", this._deselectMultiDrag);
      off(document, "mouseup", this._deselectMultiDrag);
      off(document, "touchend", this._deselectMultiDrag);
      off(document, "keydown", this._checkKeyDown);
      off(document, "keyup", this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted)
        return;
      if (multiDragSortable !== this.sortable)
        return;
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false))
        return;
      if (evt && evt.button !== 0)
        return;
      while (multiDragElements.length) {
        var el2 = multiDragElements[0];
        toggleClass(el2, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: "deselect",
          targetEl: el2,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    pluginName: "multiDrag",
    utils: {
      select: function select2(el2) {
        var sortable = el2.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el2))
          return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el2, sortable.options.selectedClass, true);
        multiDragElements.push(el2);
      },
      deselect: function deselect(el2) {
        var sortable = el2.parentNode[expando], index2 = multiDragElements.indexOf(el2);
        if (!sortable || !sortable.options.multiDrag || !~index2)
          return;
        toggleClass(el2, sortable.options.selectedClass, false);
        multiDragElements.splice(index2, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [], newIndicies = [];
      multiDragElements.forEach(function(multiDragElement) {
        oldIndicies.push({
          multiDragElement,
          index: multiDragElement.sortableIndex
        });
        var newIndex2;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex2 = -1;
        } else if (folding) {
          newIndex2 = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
        } else {
          newIndex2 = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement,
          index: newIndex2
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies,
        newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === "ctrl") {
          key = "Control";
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl2) {
  multiDragElements.forEach(function(multiDragElement, i) {
    var target2 = rootEl2.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target2) {
      rootEl2.insertBefore(multiDragElement, target2);
    } else {
      rootEl2.appendChild(multiDragElement);
    }
  });
}
function insertMultiDragClones(elementsInserted, rootEl2) {
  multiDragClones.forEach(function(clone2, i) {
    var target2 = rootEl2.children[clone2.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target2) {
      rootEl2.insertBefore(clone2, target2);
    } else {
      rootEl2.appendChild(clone2);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function(multiDragElement) {
    if (multiDragElement === dragEl$1)
      return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Sortable,
  MultiDrag: MultiDragPlugin,
  Sortable,
  Swap: SwapPlugin
}, Symbol.toStringTag, { value: "Module" }));
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(sortable_esm);
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module2.exports = factory(require$$0, require$$1);
  })(typeof self !== "undefined" ? self : commonjsGlobal$1, function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE_a352__) {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module3 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
        module3.l = true;
        return module3.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports3, name, getter) {
        if (!__webpack_require__.o(exports3, name)) {
          Object.defineProperty(exports3, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports3) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports3, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module3) {
        var getter = module3 && module3.__esModule ? function getDefault() {
          return module3["default"];
        } : function getModuleExports() {
          return module3;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property2) {
        return Object.prototype.hasOwnProperty.call(object, property2);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      "00ee": function(module3, exports3, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var test3 = {};
        test3[TO_STRING_TAG] = "z";
        module3.exports = String(test3) === "[object z]";
      },
      "0366": function(module3, exports3, __webpack_require__) {
        var aFunction = __webpack_require__("1c0b");
        module3.exports = function(fn2, that, length3) {
          aFunction(fn2);
          if (that === void 0)
            return fn2;
          switch (length3) {
            case 0:
              return function() {
                return fn2.call(that);
              };
            case 1:
              return function(a) {
                return fn2.call(that, a);
              };
            case 2:
              return function(a, b) {
                return fn2.call(that, a, b);
              };
            case 3:
              return function(a, b, c) {
                return fn2.call(that, a, b, c);
              };
          }
          return function() {
            return fn2.apply(that, arguments);
          };
        };
      },
      "057f": function(module3, exports3, __webpack_require__) {
        var toIndexedObject = __webpack_require__("fc6a");
        var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
        var toString3 = {}.toString;
        var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function(it2) {
          try {
            return nativeGetOwnPropertyNames(it2);
          } catch (error2) {
            return windowNames.slice();
          }
        };
        module3.exports.f = function getOwnPropertyNames(it2) {
          return windowNames && toString3.call(it2) == "[object Window]" ? getWindowNames(it2) : nativeGetOwnPropertyNames(toIndexedObject(it2));
        };
      },
      "06cf": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var propertyIsEnumerableModule = __webpack_require__("d1e7");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var toIndexedObject = __webpack_require__("fc6a");
        var toPrimitive = __webpack_require__("c04e");
        var has2 = __webpack_require__("5135");
        var IE8_DOM_DEFINE = __webpack_require__("0cfb");
        var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        exports3.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P2) {
          O = toIndexedObject(O);
          P2 = toPrimitive(P2, true);
          if (IE8_DOM_DEFINE)
            try {
              return nativeGetOwnPropertyDescriptor(O, P2);
            } catch (error2) {
            }
          if (has2(O, P2))
            return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P2), O[P2]);
        };
      },
      "0cfb": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var fails = __webpack_require__("d039");
        var createElement2 = __webpack_require__("cc12");
        module3.exports = !DESCRIPTORS && !fails(function() {
          return Object.defineProperty(createElement2("div"), "a", {
            get: function() {
              return 7;
            }
          }).a != 7;
        });
      },
      "13d5": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $reduce = __webpack_require__("d58f").left;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var STRICT_METHOD = arrayMethodIsStrict("reduce");
        var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
        $2({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
          reduce: function reduce2(callbackfn) {
            return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "14c3": function(module3, exports3, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        var regexpExec = __webpack_require__("9263");
        module3.exports = function(R2, S) {
          var exec = R2.exec;
          if (typeof exec === "function") {
            var result = exec.call(R2, S);
            if (typeof result !== "object") {
              throw TypeError("RegExp exec method returned something other than an Object or null");
            }
            return result;
          }
          if (classof(R2) !== "RegExp") {
            throw TypeError("RegExp#exec called on incompatible receiver");
          }
          return regexpExec.call(R2, S);
        };
      },
      "159b": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var DOMIterables = __webpack_require__("fdbc");
        var forEach3 = __webpack_require__("17c2");
        var createNonEnumerableProperty = __webpack_require__("9112");
        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global2[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach3)
            try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach3);
            } catch (error2) {
              CollectionPrototype.forEach = forEach3;
            }
        }
      },
      "17c2": function(module3, exports3, __webpack_require__) {
        var $forEach = __webpack_require__("b727").forEach;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var STRICT_METHOD = arrayMethodIsStrict("forEach");
        var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
        module3.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach3(callbackfn) {
          return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } : [].forEach;
      },
      "1be4": function(module3, exports3, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        module3.exports = getBuiltIn("document", "documentElement");
      },
      "1c0b": function(module3, exports3) {
        module3.exports = function(it2) {
          if (typeof it2 != "function") {
            throw TypeError(String(it2) + " is not a function");
          }
          return it2;
        };
      },
      "1c7e": function(module3, exports3, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var ITERATOR = wellKnownSymbol("iterator");
        var SAFE_CLOSING = false;
        try {
          var called = 0;
          var iteratorWithReturn = {
            next: function() {
              return { done: !!called++ };
            },
            "return": function() {
              SAFE_CLOSING = true;
            }
          };
          iteratorWithReturn[ITERATOR] = function() {
            return this;
          };
          Array.from(iteratorWithReturn, function() {
            throw 2;
          });
        } catch (error2) {
        }
        module3.exports = function(exec, SKIP_CLOSING) {
          if (!SKIP_CLOSING && !SAFE_CLOSING)
            return false;
          var ITERATION_SUPPORT = false;
          try {
            var object = {};
            object[ITERATOR] = function() {
              return {
                next: function() {
                  return { done: ITERATION_SUPPORT = true };
                }
              };
            };
            exec(object);
          } catch (error2) {
          }
          return ITERATION_SUPPORT;
        };
      },
      "1d80": function(module3, exports3) {
        module3.exports = function(it2) {
          if (it2 == void 0)
            throw TypeError("Can't call method on " + it2);
          return it2;
        };
      },
      "1dde": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var wellKnownSymbol = __webpack_require__("b622");
        var V8_VERSION = __webpack_require__("2d00");
        var SPECIES = wellKnownSymbol("species");
        module3.exports = function(METHOD_NAME) {
          return V8_VERSION >= 51 || !fails(function() {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES] = function() {
              return { foo: 1 };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
          });
        };
      },
      "23cb": function(module3, exports3, __webpack_require__) {
        var toInteger2 = __webpack_require__("a691");
        var max3 = Math.max;
        var min3 = Math.min;
        module3.exports = function(index2, length3) {
          var integer = toInteger2(index2);
          return integer < 0 ? max3(integer + length3, 0) : min3(integer, length3);
        };
      },
      "23e7": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var createNonEnumerableProperty = __webpack_require__("9112");
        var redefine = __webpack_require__("6eeb");
        var setGlobal = __webpack_require__("ce4e");
        var copyConstructorProperties = __webpack_require__("e893");
        var isForced = __webpack_require__("94ca");
        module3.exports = function(options2, source) {
          var TARGET = options2.target;
          var GLOBAL = options2.global;
          var STATIC = options2.stat;
          var FORCED, target2, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target2 = global2;
          } else if (STATIC) {
            target2 = global2[TARGET] || setGlobal(TARGET, {});
          } else {
            target2 = (global2[TARGET] || {}).prototype;
          }
          if (target2)
            for (key in source) {
              sourceProperty = source[key];
              if (options2.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target2, key);
                targetProperty = descriptor && descriptor.value;
              } else
                targetProperty = target2[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty === typeof targetProperty)
                  continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options2.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              redefine(target2, key, sourceProperty, options2);
            }
        };
      },
      "241c": function(module3, exports3, __webpack_require__) {
        var internalObjectKeys = __webpack_require__("ca84");
        var enumBugKeys = __webpack_require__("7839");
        var hiddenKeys = enumBugKeys.concat("length", "prototype");
        exports3.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
      },
      "25f0": function(module3, exports3, __webpack_require__) {
        var redefine = __webpack_require__("6eeb");
        var anObject = __webpack_require__("825a");
        var fails = __webpack_require__("d039");
        var flags = __webpack_require__("ad6d");
        var TO_STRING = "toString";
        var RegExpPrototype = RegExp.prototype;
        var nativeToString = RegExpPrototype[TO_STRING];
        var NOT_GENERIC = fails(function() {
          return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
        });
        var INCORRECT_NAME = nativeToString.name != TO_STRING;
        if (NOT_GENERIC || INCORRECT_NAME) {
          redefine(RegExp.prototype, TO_STRING, function toString3() {
            var R2 = anObject(this);
            var p2 = String(R2.source);
            var rf = R2.flags;
            var f = String(rf === void 0 && R2 instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R2) : rf);
            return "/" + p2 + "/" + f;
          }, { unsafe: true });
        }
      },
      "2ca0": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var toLength = __webpack_require__("50c4");
        var notARegExp = __webpack_require__("5a34");
        var requireObjectCoercible = __webpack_require__("1d80");
        var correctIsRegExpLogic = __webpack_require__("ab13");
        var IS_PURE = __webpack_require__("c430");
        var nativeStartsWith = "".startsWith;
        var min3 = Math.min;
        var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
        var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
          var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
          return descriptor && !descriptor.writable;
        }();
        $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
          startsWith: function startsWith2(searchString) {
            var that = String(requireObjectCoercible(this));
            notARegExp(searchString);
            var index2 = toLength(min3(arguments.length > 1 ? arguments[1] : void 0, that.length));
            var search2 = String(searchString);
            return nativeStartsWith ? nativeStartsWith.call(that, search2, index2) : that.slice(index2, index2 + search2.length) === search2;
          }
        });
      },
      "2d00": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var userAgent2 = __webpack_require__("342f");
        var process = global2.process;
        var versions = process && process.versions;
        var v8 = versions && versions.v8;
        var match2, version2;
        if (v8) {
          match2 = v8.split(".");
          version2 = match2[0] + match2[1];
        } else if (userAgent2) {
          match2 = userAgent2.match(/Edge\/(\d+)/);
          if (!match2 || match2[1] >= 74) {
            match2 = userAgent2.match(/Chrome\/(\d+)/);
            if (match2)
              version2 = match2[1];
          }
        }
        module3.exports = version2 && +version2;
      },
      "342f": function(module3, exports3, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        module3.exports = getBuiltIn("navigator", "userAgent") || "";
      },
      "35a1": function(module3, exports3, __webpack_require__) {
        var classof = __webpack_require__("f5df");
        var Iterators = __webpack_require__("3f8c");
        var wellKnownSymbol = __webpack_require__("b622");
        var ITERATOR = wellKnownSymbol("iterator");
        module3.exports = function(it2) {
          if (it2 != void 0)
            return it2[ITERATOR] || it2["@@iterator"] || Iterators[classof(it2)];
        };
      },
      "37e8": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var definePropertyModule = __webpack_require__("9bf2");
        var anObject = __webpack_require__("825a");
        var objectKeys = __webpack_require__("df75");
        module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys2 = objectKeys(Properties);
          var length3 = keys2.length;
          var index2 = 0;
          var key;
          while (length3 > index2)
            definePropertyModule.f(O, key = keys2[index2++], Properties[key]);
          return O;
        };
      },
      "3bbe": function(module3, exports3, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        module3.exports = function(it2) {
          if (!isObject2(it2) && it2 !== null) {
            throw TypeError("Can't set " + String(it2) + " as a prototype");
          }
          return it2;
        };
      },
      "3ca3": function(module3, exports3, __webpack_require__) {
        var charAt = __webpack_require__("6547").charAt;
        var InternalStateModule = __webpack_require__("69f3");
        var defineIterator = __webpack_require__("7dd0");
        var STRING_ITERATOR = "String Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
        defineIterator(String, "String", function(iterated) {
          setInternalState(this, {
            type: STRING_ITERATOR,
            string: String(iterated),
            index: 0
          });
        }, function next() {
          var state2 = getInternalState(this);
          var string = state2.string;
          var index2 = state2.index;
          var point;
          if (index2 >= string.length)
            return { value: void 0, done: true };
          point = charAt(string, index2);
          state2.index += point.length;
          return { value: point, done: false };
        });
      },
      "3f8c": function(module3, exports3) {
        module3.exports = {};
      },
      "4160": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var forEach3 = __webpack_require__("17c2");
        $2({ target: "Array", proto: true, forced: [].forEach != forEach3 }, {
          forEach: forEach3
        });
      },
      "428f": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        module3.exports = global2;
      },
      "44ad": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var classof = __webpack_require__("c6b6");
        var split2 = "".split;
        module3.exports = fails(function() {
          return !Object("z").propertyIsEnumerable(0);
        }) ? function(it2) {
          return classof(it2) == "String" ? split2.call(it2, "") : Object(it2);
        } : Object;
      },
      "44d2": function(module3, exports3, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var create = __webpack_require__("7c73");
        var definePropertyModule = __webpack_require__("9bf2");
        var UNSCOPABLES = wellKnownSymbol("unscopables");
        var ArrayPrototype = Array.prototype;
        if (ArrayPrototype[UNSCOPABLES] == void 0) {
          definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
            configurable: true,
            value: create(null)
          });
        }
        module3.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };
      },
      "44e7": function(module3, exports3, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var classof = __webpack_require__("c6b6");
        var wellKnownSymbol = __webpack_require__("b622");
        var MATCH = wellKnownSymbol("match");
        module3.exports = function(it2) {
          var isRegExp2;
          return isObject2(it2) && ((isRegExp2 = it2[MATCH]) !== void 0 ? !!isRegExp2 : classof(it2) == "RegExp");
        };
      },
      "4930": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
          return !String(Symbol());
        });
      },
      "4d64": function(module3, exports3, __webpack_require__) {
        var toIndexedObject = __webpack_require__("fc6a");
        var toLength = __webpack_require__("50c4");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var createMethod = function(IS_INCLUDES) {
          return function($this, el2, fromIndex) {
            var O = toIndexedObject($this);
            var length3 = toLength(O.length);
            var index2 = toAbsoluteIndex(fromIndex, length3);
            var value;
            if (IS_INCLUDES && el2 != el2)
              while (length3 > index2) {
                value = O[index2++];
                if (value != value)
                  return true;
              }
            else
              for (; length3 > index2; index2++) {
                if ((IS_INCLUDES || index2 in O) && O[index2] === el2)
                  return IS_INCLUDES || index2 || 0;
              }
            return !IS_INCLUDES && -1;
          };
        };
        module3.exports = {
          includes: createMethod(true),
          indexOf: createMethod(false)
        };
      },
      "4de4": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $filter = __webpack_require__("b727").filter;
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
        var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          filter: function filter2(callbackfn) {
            return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "4df4": function(module3, exports3, __webpack_require__) {
        var bind2 = __webpack_require__("0366");
        var toObject2 = __webpack_require__("7b0b");
        var callWithSafeIterationClosing = __webpack_require__("9bdd");
        var isArrayIteratorMethod = __webpack_require__("e95a");
        var toLength = __webpack_require__("50c4");
        var createProperty = __webpack_require__("8418");
        var getIteratorMethod = __webpack_require__("35a1");
        module3.exports = function from2(arrayLike) {
          var O = toObject2(arrayLike);
          var C2 = typeof this == "function" ? this : Array;
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          var iteratorMethod = getIteratorMethod(O);
          var index2 = 0;
          var length3, result, step, iterator, next, value;
          if (mapping)
            mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
          if (iteratorMethod != void 0 && !(C2 == Array && isArrayIteratorMethod(iteratorMethod))) {
            iterator = iteratorMethod.call(O);
            next = iterator.next;
            result = new C2();
            for (; !(step = next.call(iterator)).done; index2++) {
              value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
              createProperty(result, index2, value);
            }
          } else {
            length3 = toLength(O.length);
            result = new C2(length3);
            for (; length3 > index2; index2++) {
              value = mapping ? mapfn(O[index2], index2) : O[index2];
              createProperty(result, index2, value);
            }
          }
          result.length = index2;
          return result;
        };
      },
      "4fad": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $entries = __webpack_require__("6f53").entries;
        $2({ target: "Object", stat: true }, {
          entries: function entries(O) {
            return $entries(O);
          }
        });
      },
      "50c4": function(module3, exports3, __webpack_require__) {
        var toInteger2 = __webpack_require__("a691");
        var min3 = Math.min;
        module3.exports = function(argument) {
          return argument > 0 ? min3(toInteger2(argument), 9007199254740991) : 0;
        };
      },
      "5135": function(module3, exports3) {
        var hasOwnProperty2 = {}.hasOwnProperty;
        module3.exports = function(it2, key) {
          return hasOwnProperty2.call(it2, key);
        };
      },
      "5319": function(module3, exports3, __webpack_require__) {
        var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
        var anObject = __webpack_require__("825a");
        var toObject2 = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var toInteger2 = __webpack_require__("a691");
        var requireObjectCoercible = __webpack_require__("1d80");
        var advanceStringIndex = __webpack_require__("8aa5");
        var regExpExec = __webpack_require__("14c3");
        var max3 = Math.max;
        var min3 = Math.min;
        var floor2 = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
        var maybeToString = function(it2) {
          return it2 === void 0 ? it2 : String(it2);
        };
        fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
          var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
          var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
          return [
            function replace4(searchValue, replaceValue) {
              var O = requireObjectCoercible(this);
              var replacer2 = searchValue == void 0 ? void 0 : searchValue[REPLACE];
              return replacer2 !== void 0 ? replacer2.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
            },
            function(regexp, replaceValue) {
              if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                if (res.done)
                  return res.value;
              }
              var rx2 = anObject(regexp);
              var S = String(this);
              var functionalReplace = typeof replaceValue === "function";
              if (!functionalReplace)
                replaceValue = String(replaceValue);
              var global2 = rx2.global;
              if (global2) {
                var fullUnicode = rx2.unicode;
                rx2.lastIndex = 0;
              }
              var results = [];
              while (true) {
                var result = regExpExec(rx2, S);
                if (result === null)
                  break;
                results.push(result);
                if (!global2)
                  break;
                var matchStr = String(result[0]);
                if (matchStr === "")
                  rx2.lastIndex = advanceStringIndex(S, toLength(rx2.lastIndex), fullUnicode);
              }
              var accumulatedResult = "";
              var nextSourcePosition = 0;
              for (var i = 0; i < results.length; i++) {
                result = results[i];
                var matched = String(result[0]);
                var position = max3(min3(toInteger2(result.index), S.length), 0);
                var captures = [];
                for (var j2 = 1; j2 < result.length; j2++)
                  captures.push(maybeToString(result[j2]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                  var replacerArgs = [matched].concat(captures, position, S);
                  if (namedCaptures !== void 0)
                    replacerArgs.push(namedCaptures);
                  var replacement = String(replaceValue.apply(void 0, replacerArgs));
                } else {
                  replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                }
                if (position >= nextSourcePosition) {
                  accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                  nextSourcePosition = position + matched.length;
                }
              }
              return accumulatedResult + S.slice(nextSourcePosition);
            }
          ];
          function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
            if (namedCaptures !== void 0) {
              namedCaptures = toObject2(namedCaptures);
              symbols = SUBSTITUTION_SYMBOLS;
            }
            return nativeReplace.call(replacement, symbols, function(match2, ch) {
              var capture;
              switch (ch.charAt(0)) {
                case "$":
                  return "$";
                case "&":
                  return matched;
                case "`":
                  return str.slice(0, position);
                case "'":
                  return str.slice(tailPos);
                case "<":
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;
                default:
                  var n = +ch;
                  if (n === 0)
                    return match2;
                  if (n > m) {
                    var f = floor2(n / 10);
                    if (f === 0)
                      return match2;
                    if (f <= m)
                      return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match2;
                  }
                  capture = captures[n - 1];
              }
              return capture === void 0 ? "" : capture;
            });
          }
        });
      },
      "5692": function(module3, exports3, __webpack_require__) {
        var IS_PURE = __webpack_require__("c430");
        var store2 = __webpack_require__("c6cd");
        (module3.exports = function(key, value) {
          return store2[key] || (store2[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: "3.6.5",
          mode: IS_PURE ? "pure" : "global",
          copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
        });
      },
      "56ef": function(module3, exports3, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        var getOwnPropertyNamesModule = __webpack_require__("241c");
        var getOwnPropertySymbolsModule = __webpack_require__("7418");
        var anObject = __webpack_require__("825a");
        module3.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it2) {
          var keys2 = getOwnPropertyNamesModule.f(anObject(it2));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? keys2.concat(getOwnPropertySymbols(it2)) : keys2;
        };
      },
      "5a34": function(module3, exports3, __webpack_require__) {
        var isRegExp2 = __webpack_require__("44e7");
        module3.exports = function(it2) {
          if (isRegExp2(it2)) {
            throw TypeError("The method doesn't accept regular expressions");
          }
          return it2;
        };
      },
      "5c6c": function(module3, exports3) {
        module3.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      },
      "5db7": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var flattenIntoArray = __webpack_require__("a2bf");
        var toObject2 = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var aFunction = __webpack_require__("1c0b");
        var arraySpeciesCreate = __webpack_require__("65f0");
        $2({ target: "Array", proto: true }, {
          flatMap: function flatMap2(callbackfn) {
            var O = toObject2(this);
            var sourceLen = toLength(O.length);
            var A2;
            aFunction(callbackfn);
            A2 = arraySpeciesCreate(O, 0);
            A2.length = flattenIntoArray(A2, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            return A2;
          }
        });
      },
      "6547": function(module3, exports3, __webpack_require__) {
        var toInteger2 = __webpack_require__("a691");
        var requireObjectCoercible = __webpack_require__("1d80");
        var createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var S = String(requireObjectCoercible($this));
            var position = toInteger2(pos);
            var size2 = S.length;
            var first2, second;
            if (position < 0 || position >= size2)
              return CONVERT_TO_STRING ? "" : void 0;
            first2 = S.charCodeAt(position);
            return first2 < 55296 || first2 > 56319 || position + 1 === size2 || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first2 : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
          };
        };
        module3.exports = {
          codeAt: createMethod(false),
          charAt: createMethod(true)
        };
      },
      "65f0": function(module3, exports3, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var isArray2 = __webpack_require__("e8b5");
        var wellKnownSymbol = __webpack_require__("b622");
        var SPECIES = wellKnownSymbol("species");
        module3.exports = function(originalArray, length3) {
          var C2;
          if (isArray2(originalArray)) {
            C2 = originalArray.constructor;
            if (typeof C2 == "function" && (C2 === Array || isArray2(C2.prototype)))
              C2 = void 0;
            else if (isObject2(C2)) {
              C2 = C2[SPECIES];
              if (C2 === null)
                C2 = void 0;
            }
          }
          return new (C2 === void 0 ? Array : C2)(length3 === 0 ? 0 : length3);
        };
      },
      "69f3": function(module3, exports3, __webpack_require__) {
        var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
        var global2 = __webpack_require__("da84");
        var isObject2 = __webpack_require__("861d");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var objectHas = __webpack_require__("5135");
        var sharedKey = __webpack_require__("f772");
        var hiddenKeys = __webpack_require__("d012");
        var WeakMap2 = global2.WeakMap;
        var set3, get4, has2;
        var enforce = function(it2) {
          return has2(it2) ? get4(it2) : set3(it2, {});
        };
        var getterFor = function(TYPE) {
          return function(it2) {
            var state2;
            if (!isObject2(it2) || (state2 = get4(it2)).type !== TYPE) {
              throw TypeError("Incompatible receiver, " + TYPE + " required");
            }
            return state2;
          };
        };
        if (NATIVE_WEAK_MAP) {
          var store2 = new WeakMap2();
          var wmget = store2.get;
          var wmhas = store2.has;
          var wmset = store2.set;
          set3 = function(it2, metadata) {
            wmset.call(store2, it2, metadata);
            return metadata;
          };
          get4 = function(it2) {
            return wmget.call(store2, it2) || {};
          };
          has2 = function(it2) {
            return wmhas.call(store2, it2);
          };
        } else {
          var STATE = sharedKey("state");
          hiddenKeys[STATE] = true;
          set3 = function(it2, metadata) {
            createNonEnumerableProperty(it2, STATE, metadata);
            return metadata;
          };
          get4 = function(it2) {
            return objectHas(it2, STATE) ? it2[STATE] : {};
          };
          has2 = function(it2) {
            return objectHas(it2, STATE);
          };
        }
        module3.exports = {
          set: set3,
          get: get4,
          has: has2,
          enforce,
          getterFor
        };
      },
      "6eeb": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var has2 = __webpack_require__("5135");
        var setGlobal = __webpack_require__("ce4e");
        var inspectSource = __webpack_require__("8925");
        var InternalStateModule = __webpack_require__("69f3");
        var getInternalState = InternalStateModule.get;
        var enforceInternalState = InternalStateModule.enforce;
        var TEMPLATE = String(String).split("String");
        (module3.exports = function(O, key, value, options2) {
          var unsafe = options2 ? !!options2.unsafe : false;
          var simple = options2 ? !!options2.enumerable : false;
          var noTargetGet = options2 ? !!options2.noTargetGet : false;
          if (typeof value == "function") {
            if (typeof key == "string" && !has2(value, "name"))
              createNonEnumerableProperty(value, "name", key);
            enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
          }
          if (O === global2) {
            if (simple)
              O[key] = value;
            else
              setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O[key];
          } else if (!noTargetGet && O[key]) {
            simple = true;
          }
          if (simple)
            O[key] = value;
          else
            createNonEnumerableProperty(O, key, value);
        })(Function.prototype, "toString", function toString3() {
          return typeof this == "function" && getInternalState(this).source || inspectSource(this);
        });
      },
      "6f53": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var objectKeys = __webpack_require__("df75");
        var toIndexedObject = __webpack_require__("fc6a");
        var propertyIsEnumerable2 = __webpack_require__("d1e7").f;
        var createMethod = function(TO_ENTRIES) {
          return function(it2) {
            var O = toIndexedObject(it2);
            var keys2 = objectKeys(O);
            var length3 = keys2.length;
            var i = 0;
            var result = [];
            var key;
            while (length3 > i) {
              key = keys2[i++];
              if (!DESCRIPTORS || propertyIsEnumerable2.call(O, key)) {
                result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
              }
            }
            return result;
          };
        };
        module3.exports = {
          entries: createMethod(true),
          values: createMethod(false)
        };
      },
      "73d9": function(module3, exports3, __webpack_require__) {
        var addToUnscopables = __webpack_require__("44d2");
        addToUnscopables("flatMap");
      },
      "7418": function(module3, exports3) {
        exports3.f = Object.getOwnPropertySymbols;
      },
      "746f": function(module3, exports3, __webpack_require__) {
        var path = __webpack_require__("428f");
        var has2 = __webpack_require__("5135");
        var wrappedWellKnownSymbolModule = __webpack_require__("e538");
        var defineProperty2 = __webpack_require__("9bf2").f;
        module3.exports = function(NAME) {
          var Symbol2 = path.Symbol || (path.Symbol = {});
          if (!has2(Symbol2, NAME))
            defineProperty2(Symbol2, NAME, {
              value: wrappedWellKnownSymbolModule.f(NAME)
            });
        };
      },
      "7839": function(module3, exports3) {
        module3.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf"
        ];
      },
      "7b0b": function(module3, exports3, __webpack_require__) {
        var requireObjectCoercible = __webpack_require__("1d80");
        module3.exports = function(argument) {
          return Object(requireObjectCoercible(argument));
        };
      },
      "7c73": function(module3, exports3, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var defineProperties = __webpack_require__("37e8");
        var enumBugKeys = __webpack_require__("7839");
        var hiddenKeys = __webpack_require__("d012");
        var html = __webpack_require__("1be4");
        var documentCreateElement = __webpack_require__("cc12");
        var sharedKey = __webpack_require__("f772");
        var GT2 = ">";
        var LT2 = "<";
        var PROTOTYPE = "prototype";
        var SCRIPT = "script";
        var IE_PROTO = sharedKey("IE_PROTO");
        var EmptyConstructor = function() {
        };
        var scriptTag = function(content) {
          return LT2 + SCRIPT + GT2 + content + LT2 + "/" + SCRIPT + GT2;
        };
        var NullProtoObjectViaActiveX = function(activeXDocument2) {
          activeXDocument2.write(scriptTag(""));
          activeXDocument2.close();
          var temp = activeXDocument2.parentWindow.Object;
          activeXDocument2 = null;
          return temp;
        };
        var NullProtoObjectViaIFrame = function() {
          var iframe = documentCreateElement("iframe");
          var JS = "java" + SCRIPT + ":";
          var iframeDocument;
          iframe.style.display = "none";
          html.appendChild(iframe);
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag("document.F=Object"));
          iframeDocument.close();
          return iframeDocument.F;
        };
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            activeXDocument = document.domain && new ActiveXObject("htmlfile");
          } catch (error2) {
          }
          NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
          var length3 = enumBugKeys.length;
          while (length3--)
            delete NullProtoObject[PROTOTYPE][enumBugKeys[length3]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;
        module3.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = NullProtoObject();
          return Properties === void 0 ? result : defineProperties(result, Properties);
        };
      },
      "7dd0": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var createIteratorConstructor = __webpack_require__("9ed3");
        var getPrototypeOf = __webpack_require__("e163");
        var setPrototypeOf = __webpack_require__("d2bb");
        var setToStringTag = __webpack_require__("d44e");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var redefine = __webpack_require__("6eeb");
        var wellKnownSymbol = __webpack_require__("b622");
        var IS_PURE = __webpack_require__("c430");
        var Iterators = __webpack_require__("3f8c");
        var IteratorsCore = __webpack_require__("ae93");
        var IteratorPrototype = IteratorsCore.IteratorPrototype;
        var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
        var ITERATOR = wellKnownSymbol("iterator");
        var KEYS = "keys";
        var VALUES = "values";
        var ENTRIES = "entries";
        var returnThis = function() {
          return this;
        };
        module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
          createIteratorConstructor(IteratorConstructor, NAME, next);
          var getIterationMethod = function(KIND) {
            if (KIND === DEFAULT && defaultIterator)
              return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
              return IterablePrototype[KIND];
            switch (KIND) {
              case KEYS:
                return function keys2() {
                  return new IteratorConstructor(this, KIND);
                };
              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND);
                };
              case ENTRIES:
                return function entries() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function() {
              return new IteratorConstructor(this);
            };
          };
          var TO_STRING_TAG = NAME + " Iterator";
          var INCORRECT_VALUES_NAME = false;
          var IterablePrototype = Iterable.prototype;
          var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
          var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
          var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
          var CurrentIteratorPrototype, methods2, KEY;
          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
              if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) {
                  setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                  createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
              }
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
              if (IS_PURE)
                Iterators[TO_STRING_TAG] = returnThis;
            }
          }
          if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return nativeIterator.call(this);
            };
          }
          if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
            createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
          }
          Iterators[NAME] = defaultIterator;
          if (DEFAULT) {
            methods2 = {
              values: getIterationMethod(VALUES),
              keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
              entries: getIterationMethod(ENTRIES)
            };
            if (FORCED)
              for (KEY in methods2) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                  redefine(IterablePrototype, KEY, methods2[KEY]);
                }
              }
            else
              $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods2);
          }
          return methods2;
        };
      },
      "7f9a": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var inspectSource = __webpack_require__("8925");
        var WeakMap2 = global2.WeakMap;
        module3.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
      },
      "825a": function(module3, exports3, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        module3.exports = function(it2) {
          if (!isObject2(it2)) {
            throw TypeError(String(it2) + " is not an object");
          }
          return it2;
        };
      },
      "83ab": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module3.exports = !fails(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      },
      "8418": function(module3, exports3, __webpack_require__) {
        var toPrimitive = __webpack_require__("c04e");
        var definePropertyModule = __webpack_require__("9bf2");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module3.exports = function(object, key, value) {
          var propertyKey = toPrimitive(key);
          if (propertyKey in object)
            definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
          else
            object[propertyKey] = value;
        };
      },
      "861d": function(module3, exports3) {
        module3.exports = function(it2) {
          return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
        };
      },
      "8875": function(module3, exports3, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        (function(root2, factory) {
          {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports3, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        })(typeof self !== "undefined" ? self : this, function() {
          function getCurrentScript() {
            var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
            if (!descriptor && "currentScript" in document && document.currentScript) {
              return document.currentScript;
            }
            if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
              if (scriptLocation === currentLocation) {
                pageSource = document.documentElement.outerHTML;
                inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
              }
              for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].readyState === "interactive") {
                  return scripts[i];
                }
                if (scripts[i].src === scriptLocation) {
                  return scripts[i];
                }
                if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                  return scripts[i];
                }
              }
              return null;
            }
          }
          return getCurrentScript;
        });
      },
      "8925": function(module3, exports3, __webpack_require__) {
        var store2 = __webpack_require__("c6cd");
        var functionToString = Function.toString;
        if (typeof store2.inspectSource != "function") {
          store2.inspectSource = function(it2) {
            return functionToString.call(it2);
          };
        }
        module3.exports = store2.inspectSource;
      },
      "8aa5": function(module3, exports3, __webpack_require__) {
        var charAt = __webpack_require__("6547").charAt;
        module3.exports = function(S, index2, unicode) {
          return index2 + (unicode ? charAt(S, index2).length : 1);
        };
      },
      "8bbf": function(module3, exports3) {
        module3.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
      },
      "90e3": function(module3, exports3) {
        var id = 0;
        var postfix = Math.random();
        module3.exports = function(key) {
          return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
        };
      },
      "9112": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var definePropertyModule = __webpack_require__("9bf2");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module3.exports = DESCRIPTORS ? function(object, key, value) {
          return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      },
      "9263": function(module3, exports3, __webpack_require__) {
        var regexpFlags = __webpack_require__("ad6d");
        var stickyHelpers = __webpack_require__("9f7f");
        var nativeExec = RegExp.prototype.exec;
        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var UPDATES_LAST_INDEX_WRONG = function() {
          var re1 = /a/;
          var re2 = /b*/g;
          nativeExec.call(re1, "a");
          nativeExec.call(re2, "a");
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        }();
        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
        var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
        if (PATCH) {
          patchedExec = function exec(str) {
            var re2 = this;
            var lastIndex, reCopy, match2, i;
            var sticky = UNSUPPORTED_Y && re2.sticky;
            var flags = regexpFlags.call(re2);
            var source = re2.source;
            var charsAdded = 0;
            var strCopy = str;
            if (sticky) {
              flags = flags.replace("y", "");
              if (flags.indexOf("g") === -1) {
                flags += "g";
              }
              strCopy = String(str).slice(re2.lastIndex);
              if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && str[re2.lastIndex - 1] !== "\n")) {
                source = "(?: " + source + ")";
                strCopy = " " + strCopy;
                charsAdded++;
              }
              reCopy = new RegExp("^(?:" + source + ")", flags);
            }
            if (NPCG_INCLUDED) {
              reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
            }
            if (UPDATES_LAST_INDEX_WRONG)
              lastIndex = re2.lastIndex;
            match2 = nativeExec.call(sticky ? reCopy : re2, strCopy);
            if (sticky) {
              if (match2) {
                match2.input = match2.input.slice(charsAdded);
                match2[0] = match2[0].slice(charsAdded);
                match2.index = re2.lastIndex;
                re2.lastIndex += match2[0].length;
              } else
                re2.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match2) {
              re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match2 && match2.length > 1) {
              nativeReplace.call(match2[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === void 0)
                    match2[i] = void 0;
                }
              });
            }
            return match2;
          };
        }
        module3.exports = patchedExec;
      },
      "94ca": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var replacement = /#|\.prototype\./;
        var isForced = function(feature, detection) {
          var value = data[normalize4(feature)];
          return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
        };
        var normalize4 = isForced.normalize = function(string) {
          return String(string).replace(replacement, ".").toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = "N";
        var POLYFILL = isForced.POLYFILL = "P";
        module3.exports = isForced;
      },
      "99af": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var fails = __webpack_require__("d039");
        var isArray2 = __webpack_require__("e8b5");
        var isObject2 = __webpack_require__("861d");
        var toObject2 = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var createProperty = __webpack_require__("8418");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var wellKnownSymbol = __webpack_require__("b622");
        var V8_VERSION = __webpack_require__("2d00");
        var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
        var MAX_SAFE_INTEGER2 = 9007199254740991;
        var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
        var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
          var array = [];
          array[IS_CONCAT_SPREADABLE] = false;
          return array.concat()[0] !== array;
        });
        var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
        var isConcatSpreadable = function(O) {
          if (!isObject2(O))
            return false;
          var spreadable = O[IS_CONCAT_SPREADABLE];
          return spreadable !== void 0 ? !!spreadable : isArray2(O);
        };
        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
        $2({ target: "Array", proto: true, forced: FORCED }, {
          concat: function concat(arg) {
            var O = toObject2(this);
            var A2 = arraySpeciesCreate(O, 0);
            var n = 0;
            var i, k2, length3, len, E;
            for (i = -1, length3 = arguments.length; i < length3; i++) {
              E = i === -1 ? O : arguments[i];
              if (isConcatSpreadable(E)) {
                len = toLength(E.length);
                if (n + len > MAX_SAFE_INTEGER2)
                  throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for (k2 = 0; k2 < len; k2++, n++)
                  if (k2 in E)
                    createProperty(A2, n, E[k2]);
              } else {
                if (n >= MAX_SAFE_INTEGER2)
                  throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A2, n++, E);
              }
            }
            A2.length = n;
            return A2;
          }
        });
      },
      "9bdd": function(module3, exports3, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        module3.exports = function(iterator, fn2, value, ENTRIES) {
          try {
            return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
          } catch (error2) {
            var returnMethod = iterator["return"];
            if (returnMethod !== void 0)
              anObject(returnMethod.call(iterator));
            throw error2;
          }
        };
      },
      "9bf2": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var IE8_DOM_DEFINE = __webpack_require__("0cfb");
        var anObject = __webpack_require__("825a");
        var toPrimitive = __webpack_require__("c04e");
        var nativeDefineProperty = Object.defineProperty;
        exports3.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty2(O, P2, Attributes) {
          anObject(O);
          P2 = toPrimitive(P2, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return nativeDefineProperty(O, P2, Attributes);
            } catch (error2) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError("Accessors not supported");
          if ("value" in Attributes)
            O[P2] = Attributes.value;
          return O;
        };
      },
      "9ed3": function(module3, exports3, __webpack_require__) {
        var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
        var create = __webpack_require__("7c73");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var setToStringTag = __webpack_require__("d44e");
        var Iterators = __webpack_require__("3f8c");
        var returnThis = function() {
          return this;
        };
        module3.exports = function(IteratorConstructor, NAME, next) {
          var TO_STRING_TAG = NAME + " Iterator";
          IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
          setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
          Iterators[TO_STRING_TAG] = returnThis;
          return IteratorConstructor;
        };
      },
      "9f7f": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        function RE(s, f) {
          return RegExp(s, f);
        }
        exports3.UNSUPPORTED_Y = fails(function() {
          var re2 = RE("a", "y");
          re2.lastIndex = 2;
          return re2.exec("abcd") != null;
        });
        exports3.BROKEN_CARET = fails(function() {
          var re2 = RE("^r", "gy");
          re2.lastIndex = 2;
          return re2.exec("str") != null;
        });
      },
      "a2bf": function(module3, exports3, __webpack_require__) {
        var isArray2 = __webpack_require__("e8b5");
        var toLength = __webpack_require__("50c4");
        var bind2 = __webpack_require__("0366");
        var flattenIntoArray = function(target2, original, source, sourceLen, start2, depth, mapper, thisArg) {
          var targetIndex = start2;
          var sourceIndex = 0;
          var mapFn = mapper ? bind2(mapper, thisArg, 3) : false;
          var element;
          while (sourceIndex < sourceLen) {
            if (sourceIndex in source) {
              element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
              if (depth > 0 && isArray2(element)) {
                targetIndex = flattenIntoArray(target2, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
              } else {
                if (targetIndex >= 9007199254740991)
                  throw TypeError("Exceed the acceptable array length");
                target2[targetIndex] = element;
              }
              targetIndex++;
            }
            sourceIndex++;
          }
          return targetIndex;
        };
        module3.exports = flattenIntoArray;
      },
      "a352": function(module3, exports3) {
        module3.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
      },
      "a434": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var toInteger2 = __webpack_require__("a691");
        var toLength = __webpack_require__("50c4");
        var toObject2 = __webpack_require__("7b0b");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var createProperty = __webpack_require__("8418");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
        var USES_TO_LENGTH = arrayMethodUsesToLength("splice", { ACCESSORS: true, 0: 0, 1: 2 });
        var max3 = Math.max;
        var min3 = Math.min;
        var MAX_SAFE_INTEGER2 = 9007199254740991;
        var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          splice: function splice2(start2, deleteCount) {
            var O = toObject2(this);
            var len = toLength(O.length);
            var actualStart = toAbsoluteIndex(start2, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A2, k2, from2, to;
            if (argumentsLength === 0) {
              insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
              insertCount = 0;
              actualDeleteCount = len - actualStart;
            } else {
              insertCount = argumentsLength - 2;
              actualDeleteCount = min3(max3(toInteger2(deleteCount), 0), len - actualStart);
            }
            if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER2) {
              throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
            }
            A2 = arraySpeciesCreate(O, actualDeleteCount);
            for (k2 = 0; k2 < actualDeleteCount; k2++) {
              from2 = actualStart + k2;
              if (from2 in O)
                createProperty(A2, k2, O[from2]);
            }
            A2.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
              for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
                from2 = k2 + actualDeleteCount;
                to = k2 + insertCount;
                if (from2 in O)
                  O[to] = O[from2];
                else
                  delete O[to];
              }
              for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
                delete O[k2 - 1];
            } else if (insertCount > actualDeleteCount) {
              for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
                from2 = k2 + actualDeleteCount - 1;
                to = k2 + insertCount - 1;
                if (from2 in O)
                  O[to] = O[from2];
                else
                  delete O[to];
              }
            }
            for (k2 = 0; k2 < insertCount; k2++) {
              O[k2 + actualStart] = arguments[k2 + 2];
            }
            O.length = len - actualDeleteCount + insertCount;
            return A2;
          }
        });
      },
      "a4d3": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var global2 = __webpack_require__("da84");
        var getBuiltIn = __webpack_require__("d066");
        var IS_PURE = __webpack_require__("c430");
        var DESCRIPTORS = __webpack_require__("83ab");
        var NATIVE_SYMBOL = __webpack_require__("4930");
        var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
        var fails = __webpack_require__("d039");
        var has2 = __webpack_require__("5135");
        var isArray2 = __webpack_require__("e8b5");
        var isObject2 = __webpack_require__("861d");
        var anObject = __webpack_require__("825a");
        var toObject2 = __webpack_require__("7b0b");
        var toIndexedObject = __webpack_require__("fc6a");
        var toPrimitive = __webpack_require__("c04e");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var nativeObjectCreate = __webpack_require__("7c73");
        var objectKeys = __webpack_require__("df75");
        var getOwnPropertyNamesModule = __webpack_require__("241c");
        var getOwnPropertyNamesExternal = __webpack_require__("057f");
        var getOwnPropertySymbolsModule = __webpack_require__("7418");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var definePropertyModule = __webpack_require__("9bf2");
        var propertyIsEnumerableModule = __webpack_require__("d1e7");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var redefine = __webpack_require__("6eeb");
        var shared = __webpack_require__("5692");
        var sharedKey = __webpack_require__("f772");
        var hiddenKeys = __webpack_require__("d012");
        var uid2 = __webpack_require__("90e3");
        var wellKnownSymbol = __webpack_require__("b622");
        var wrappedWellKnownSymbolModule = __webpack_require__("e538");
        var defineWellKnownSymbol = __webpack_require__("746f");
        var setToStringTag = __webpack_require__("d44e");
        var InternalStateModule = __webpack_require__("69f3");
        var $forEach = __webpack_require__("b727").forEach;
        var HIDDEN = sharedKey("hidden");
        var SYMBOL = "Symbol";
        var PROTOTYPE = "prototype";
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(SYMBOL);
        var ObjectPrototype = Object[PROTOTYPE];
        var $Symbol = global2.Symbol;
        var $stringify = getBuiltIn("JSON", "stringify");
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
        var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
        var AllSymbols = shared("symbols");
        var ObjectPrototypeSymbols = shared("op-symbols");
        var StringToSymbolRegistry = shared("string-to-symbol-registry");
        var SymbolToStringRegistry = shared("symbol-to-string-registry");
        var WellKnownSymbolsStore = shared("wks");
        var QObject = global2.QObject;
        var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        var setSymbolDescriptor = DESCRIPTORS && fails(function() {
          return nativeObjectCreate(nativeDefineProperty({}, "a", {
            get: function() {
              return nativeDefineProperty(this, "a", { value: 7 }).a;
            }
          })).a != 7;
        }) ? function(O, P2, Attributes) {
          var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
          if (ObjectPrototypeDescriptor)
            delete ObjectPrototype[P2];
          nativeDefineProperty(O, P2, Attributes);
          if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
            nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
          }
        } : nativeDefineProperty;
        var wrap2 = function(tag, description) {
          var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
          setInternalState(symbol, {
            type: SYMBOL,
            tag,
            description
          });
          if (!DESCRIPTORS)
            symbol.description = description;
          return symbol;
        };
        var isSymbol2 = USE_SYMBOL_AS_UID ? function(it2) {
          return typeof it2 == "symbol";
        } : function(it2) {
          return Object(it2) instanceof $Symbol;
        };
        var $defineProperty = function defineProperty2(O, P2, Attributes) {
          if (O === ObjectPrototype)
            $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
          anObject(O);
          var key = toPrimitive(P2, true);
          anObject(Attributes);
          if (has2(AllSymbols, key)) {
            if (!Attributes.enumerable) {
              if (!has2(O, HIDDEN))
                nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
              O[HIDDEN][key] = true;
            } else {
              if (has2(O, HIDDEN) && O[HIDDEN][key])
                O[HIDDEN][key] = false;
              Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            }
            return setSymbolDescriptor(O, key, Attributes);
          }
          return nativeDefineProperty(O, key, Attributes);
        };
        var $defineProperties = function defineProperties(O, Properties) {
          anObject(O);
          var properties = toIndexedObject(Properties);
          var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
          $forEach(keys2, function(key) {
            if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))
              $defineProperty(O, key, properties[key]);
          });
          return O;
        };
        var $create = function create(O, Properties) {
          return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable2(V2) {
          var P2 = toPrimitive(V2, true);
          var enumerable = nativePropertyIsEnumerable.call(this, P2);
          if (this === ObjectPrototype && has2(AllSymbols, P2) && !has2(ObjectPrototypeSymbols, P2))
            return false;
          return enumerable || !has2(this, P2) || !has2(AllSymbols, P2) || has2(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P2) {
          var it2 = toIndexedObject(O);
          var key = toPrimitive(P2, true);
          if (it2 === ObjectPrototype && has2(AllSymbols, key) && !has2(ObjectPrototypeSymbols, key))
            return;
          var descriptor = nativeGetOwnPropertyDescriptor(it2, key);
          if (descriptor && has2(AllSymbols, key) && !(has2(it2, HIDDEN) && it2[HIDDEN][key])) {
            descriptor.enumerable = true;
          }
          return descriptor;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(O) {
          var names = nativeGetOwnPropertyNames(toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (!has2(AllSymbols, key) && !has2(hiddenKeys, key))
              result.push(key);
          });
          return result;
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
          var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
          var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (has2(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has2(ObjectPrototype, key))) {
              result.push(AllSymbols[key]);
            }
          });
          return result;
        };
        if (!NATIVE_SYMBOL) {
          $Symbol = function Symbol2() {
            if (this instanceof $Symbol)
              throw TypeError("Symbol is not a constructor");
            var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
            var tag = uid2(description);
            var setter = function(value) {
              if (this === ObjectPrototype)
                setter.call(ObjectPrototypeSymbols, value);
              if (has2(this, HIDDEN) && has2(this[HIDDEN], tag))
                this[HIDDEN][tag] = false;
              setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
            };
            if (DESCRIPTORS && USE_SETTER)
              setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
            return wrap2(tag, description);
          };
          redefine($Symbol[PROTOTYPE], "toString", function toString3() {
            return getInternalState(this).tag;
          });
          redefine($Symbol, "withoutSetter", function(description) {
            return wrap2(uid2(description), description);
          });
          propertyIsEnumerableModule.f = $propertyIsEnumerable;
          definePropertyModule.f = $defineProperty;
          getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
          getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
          getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
          wrappedWellKnownSymbolModule.f = function(name) {
            return wrap2(wellKnownSymbol(name), name);
          };
          if (DESCRIPTORS) {
            nativeDefineProperty($Symbol[PROTOTYPE], "description", {
              configurable: true,
              get: function description() {
                return getInternalState(this).description;
              }
            });
            if (!IS_PURE) {
              redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
            }
          }
        }
        $2({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
          Symbol: $Symbol
        });
        $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
          defineWellKnownSymbol(name);
        });
        $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
          "for": function(key) {
            var string = String(key);
            if (has2(StringToSymbolRegistry, string))
              return StringToSymbolRegistry[string];
            var symbol = $Symbol(string);
            StringToSymbolRegistry[string] = symbol;
            SymbolToStringRegistry[symbol] = string;
            return symbol;
          },
          keyFor: function keyFor(sym) {
            if (!isSymbol2(sym))
              throw TypeError(sym + " is not a symbol");
            if (has2(SymbolToStringRegistry, sym))
              return SymbolToStringRegistry[sym];
          },
          useSetter: function() {
            USE_SETTER = true;
          },
          useSimple: function() {
            USE_SETTER = false;
          }
        });
        $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
          create: $create,
          defineProperty: $defineProperty,
          defineProperties: $defineProperties,
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor
        });
        $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
          getOwnPropertyNames: $getOwnPropertyNames,
          getOwnPropertySymbols: $getOwnPropertySymbols
        });
        $2({ target: "Object", stat: true, forced: fails(function() {
          getOwnPropertySymbolsModule.f(1);
        }) }, {
          getOwnPropertySymbols: function getOwnPropertySymbols(it2) {
            return getOwnPropertySymbolsModule.f(toObject2(it2));
          }
        });
        if ($stringify) {
          var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
            var symbol = $Symbol();
            return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
          });
          $2({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
            stringify: function stringify(it2, replacer2, space) {
              var args = [it2];
              var index2 = 1;
              var $replacer;
              while (arguments.length > index2)
                args.push(arguments[index2++]);
              $replacer = replacer2;
              if (!isObject2(replacer2) && it2 === void 0 || isSymbol2(it2))
                return;
              if (!isArray2(replacer2))
                replacer2 = function(key, value) {
                  if (typeof $replacer == "function")
                    value = $replacer.call(this, key, value);
                  if (!isSymbol2(value))
                    return value;
                };
              args[1] = replacer2;
              return $stringify.apply(null, args);
            }
          });
        }
        if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
          createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
        }
        setToStringTag($Symbol, SYMBOL);
        hiddenKeys[HIDDEN] = true;
      },
      "a630": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var from2 = __webpack_require__("4df4");
        var checkCorrectnessOfIteration = __webpack_require__("1c7e");
        var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
          Array.from(iterable);
        });
        $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
          from: from2
        });
      },
      "a640": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module3.exports = function(METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return !!method && fails(function() {
            method.call(null, argument || function() {
              throw 1;
            }, 1);
          });
        };
      },
      "a691": function(module3, exports3) {
        var ceil = Math.ceil;
        var floor2 = Math.floor;
        module3.exports = function(argument) {
          return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor2 : ceil)(argument);
        };
      },
      "ab13": function(module3, exports3, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var MATCH = wellKnownSymbol("match");
        module3.exports = function(METHOD_NAME) {
          var regexp = /./;
          try {
            "/./"[METHOD_NAME](regexp);
          } catch (e) {
            try {
              regexp[MATCH] = false;
              return "/./"[METHOD_NAME](regexp);
            } catch (f) {
            }
          }
          return false;
        };
      },
      "ac1f": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var exec = __webpack_require__("9263");
        $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
          exec
        });
      },
      "ad6d": function(module3, exports3, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        module3.exports = function() {
          var that = anObject(this);
          var result = "";
          if (that.global)
            result += "g";
          if (that.ignoreCase)
            result += "i";
          if (that.multiline)
            result += "m";
          if (that.dotAll)
            result += "s";
          if (that.unicode)
            result += "u";
          if (that.sticky)
            result += "y";
          return result;
        };
      },
      "ae40": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var fails = __webpack_require__("d039");
        var has2 = __webpack_require__("5135");
        var defineProperty2 = Object.defineProperty;
        var cache = {};
        var thrower = function(it2) {
          throw it2;
        };
        module3.exports = function(METHOD_NAME, options2) {
          if (has2(cache, METHOD_NAME))
            return cache[METHOD_NAME];
          if (!options2)
            options2 = {};
          var method = [][METHOD_NAME];
          var ACCESSORS = has2(options2, "ACCESSORS") ? options2.ACCESSORS : false;
          var argument0 = has2(options2, 0) ? options2[0] : thrower;
          var argument1 = has2(options2, 1) ? options2[1] : void 0;
          return cache[METHOD_NAME] = !!method && !fails(function() {
            if (ACCESSORS && !DESCRIPTORS)
              return true;
            var O = { length: -1 };
            if (ACCESSORS)
              defineProperty2(O, 1, { enumerable: true, get: thrower });
            else
              O[1] = 1;
            method.call(O, argument0, argument1);
          });
        };
      },
      "ae93": function(module3, exports3, __webpack_require__) {
        var getPrototypeOf = __webpack_require__("e163");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var has2 = __webpack_require__("5135");
        var wellKnownSymbol = __webpack_require__("b622");
        var IS_PURE = __webpack_require__("c430");
        var ITERATOR = wellKnownSymbol("iterator");
        var BUGGY_SAFARI_ITERATORS = false;
        var returnThis = function() {
          return this;
        };
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
        if ([].keys) {
          arrayIterator = [].keys();
          if (!("next" in arrayIterator))
            BUGGY_SAFARI_ITERATORS = true;
          else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
              IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }
        if (IteratorPrototype == void 0)
          IteratorPrototype = {};
        if (!IS_PURE && !has2(IteratorPrototype, ITERATOR)) {
          createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
        }
        module3.exports = {
          IteratorPrototype,
          BUGGY_SAFARI_ITERATORS
        };
      },
      "b041": function(module3, exports3, __webpack_require__) {
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var classof = __webpack_require__("f5df");
        module3.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString3() {
          return "[object " + classof(this) + "]";
        };
      },
      "b0c0": function(module3, exports3, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var defineProperty2 = __webpack_require__("9bf2").f;
        var FunctionPrototype = Function.prototype;
        var FunctionPrototypeToString = FunctionPrototype.toString;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = "name";
        if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
          defineProperty2(FunctionPrototype, NAME, {
            configurable: true,
            get: function() {
              try {
                return FunctionPrototypeToString.call(this).match(nameRE)[1];
              } catch (error2) {
                return "";
              }
            }
          });
        }
      },
      "b622": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var shared = __webpack_require__("5692");
        var has2 = __webpack_require__("5135");
        var uid2 = __webpack_require__("90e3");
        var NATIVE_SYMBOL = __webpack_require__("4930");
        var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
        var WellKnownSymbolsStore = shared("wks");
        var Symbol2 = global2.Symbol;
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
        module3.exports = function(name) {
          if (!has2(WellKnownSymbolsStore, name)) {
            if (NATIVE_SYMBOL && has2(Symbol2, name))
              WellKnownSymbolsStore[name] = Symbol2[name];
            else
              WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
          }
          return WellKnownSymbolsStore[name];
        };
      },
      "b64b": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var toObject2 = __webpack_require__("7b0b");
        var nativeKeys2 = __webpack_require__("df75");
        var fails = __webpack_require__("d039");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeKeys2(1);
        });
        $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
          keys: function keys2(it2) {
            return nativeKeys2(toObject2(it2));
          }
        });
      },
      "b727": function(module3, exports3, __webpack_require__) {
        var bind2 = __webpack_require__("0366");
        var IndexedObject = __webpack_require__("44ad");
        var toObject2 = __webpack_require__("7b0b");
        var toLength = __webpack_require__("50c4");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var push = [].push;
        var createMethod = function(TYPE) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            var O = toObject2($this);
            var self2 = IndexedObject(O);
            var boundFunction = bind2(callbackfn, that, 3);
            var length3 = toLength(self2.length);
            var index2 = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target2 = IS_MAP ? create($this, length3) : IS_FILTER ? create($this, 0) : void 0;
            var value, result;
            for (; length3 > index2; index2++)
              if (NO_HOLES || index2 in self2) {
                value = self2[index2];
                result = boundFunction(value, index2, O);
                if (TYPE) {
                  if (IS_MAP)
                    target2[index2] = result;
                  else if (result)
                    switch (TYPE) {
                      case 3:
                        return true;
                      case 5:
                        return value;
                      case 6:
                        return index2;
                      case 2:
                        push.call(target2, value);
                    }
                  else if (IS_EVERY)
                    return false;
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target2;
          };
        };
        module3.exports = {
          forEach: createMethod(0),
          map: createMethod(1),
          filter: createMethod(2),
          some: createMethod(3),
          every: createMethod(4),
          find: createMethod(5),
          findIndex: createMethod(6)
        };
      },
      "c04e": function(module3, exports3, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        module3.exports = function(input2, PREFERRED_STRING) {
          if (!isObject2(input2))
            return input2;
          var fn2, val;
          if (PREFERRED_STRING && typeof (fn2 = input2.toString) == "function" && !isObject2(val = fn2.call(input2)))
            return val;
          if (typeof (fn2 = input2.valueOf) == "function" && !isObject2(val = fn2.call(input2)))
            return val;
          if (!PREFERRED_STRING && typeof (fn2 = input2.toString) == "function" && !isObject2(val = fn2.call(input2)))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      "c430": function(module3, exports3) {
        module3.exports = false;
      },
      "c6b6": function(module3, exports3) {
        var toString3 = {}.toString;
        module3.exports = function(it2) {
          return toString3.call(it2).slice(8, -1);
        };
      },
      "c6cd": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var setGlobal = __webpack_require__("ce4e");
        var SHARED = "__core-js_shared__";
        var store2 = global2[SHARED] || setGlobal(SHARED, {});
        module3.exports = store2;
      },
      "c740": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $findIndex = __webpack_require__("b727").findIndex;
        var addToUnscopables = __webpack_require__("44d2");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var FIND_INDEX = "findIndex";
        var SKIPS_HOLES = true;
        var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
        if (FIND_INDEX in [])
          Array(1)[FIND_INDEX](function() {
            SKIPS_HOLES = false;
          });
        $2({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
          findIndex: function findIndex2(callbackfn) {
            return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        addToUnscopables(FIND_INDEX);
      },
      "c8ba": function(module3, exports3) {
        var g;
        g = function() {
          return this;
        }();
        try {
          g = g || new Function("return this")();
        } catch (e) {
          if (typeof window === "object")
            g = window;
        }
        module3.exports = g;
      },
      "c975": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $indexOf = __webpack_require__("4d64").indexOf;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var nativeIndexOf = [].indexOf;
        var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict("indexOf");
        var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
        $2({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
          indexOf: function indexOf(searchElement) {
            return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "ca84": function(module3, exports3, __webpack_require__) {
        var has2 = __webpack_require__("5135");
        var toIndexedObject = __webpack_require__("fc6a");
        var indexOf = __webpack_require__("4d64").indexOf;
        var hiddenKeys = __webpack_require__("d012");
        module3.exports = function(object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O)
            !has2(hiddenKeys, key) && has2(O, key) && result.push(key);
          while (names.length > i)
            if (has2(O, key = names[i++])) {
              ~indexOf(result, key) || result.push(key);
            }
          return result;
        };
      },
      "caad": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $includes = __webpack_require__("4d64").includes;
        var addToUnscopables = __webpack_require__("44d2");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
        $2({ target: "Array", proto: true, forced: !USES_TO_LENGTH }, {
          includes: function includes2(el2) {
            return $includes(this, el2, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        addToUnscopables("includes");
      },
      "cc12": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var isObject2 = __webpack_require__("861d");
        var document2 = global2.document;
        var EXISTS = isObject2(document2) && isObject2(document2.createElement);
        module3.exports = function(it2) {
          return EXISTS ? document2.createElement(it2) : {};
        };
      },
      "ce4e": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var createNonEnumerableProperty = __webpack_require__("9112");
        module3.exports = function(key, value) {
          try {
            createNonEnumerableProperty(global2, key, value);
          } catch (error2) {
            global2[key] = value;
          }
          return value;
        };
      },
      "d012": function(module3, exports3) {
        module3.exports = {};
      },
      "d039": function(module3, exports3) {
        module3.exports = function(exec) {
          try {
            return !!exec();
          } catch (error2) {
            return true;
          }
        };
      },
      "d066": function(module3, exports3, __webpack_require__) {
        var path = __webpack_require__("428f");
        var global2 = __webpack_require__("da84");
        var aFunction = function(variable) {
          return typeof variable == "function" ? variable : void 0;
        };
        module3.exports = function(namespace2, method) {
          return arguments.length < 2 ? aFunction(path[namespace2]) || aFunction(global2[namespace2]) : path[namespace2] && path[namespace2][method] || global2[namespace2] && global2[namespace2][method];
        };
      },
      "d1e7": function(module3, exports3, __webpack_require__) {
        var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
        exports3.f = NASHORN_BUG ? function propertyIsEnumerable2(V2) {
          var descriptor = getOwnPropertyDescriptor(this, V2);
          return !!descriptor && descriptor.enumerable;
        } : nativePropertyIsEnumerable;
      },
      "d28b": function(module3, exports3, __webpack_require__) {
        var defineWellKnownSymbol = __webpack_require__("746f");
        defineWellKnownSymbol("iterator");
      },
      "d2bb": function(module3, exports3, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var aPossiblePrototype = __webpack_require__("3bbe");
        module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var CORRECT_SETTER = false;
          var test3 = {};
          var setter;
          try {
            setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
            setter.call(test3, []);
            CORRECT_SETTER = test3 instanceof Array;
          } catch (error2) {
          }
          return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER)
              setter.call(O, proto);
            else
              O.__proto__ = proto;
            return O;
          };
        }() : void 0);
      },
      "d3b7": function(module3, exports3, __webpack_require__) {
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var redefine = __webpack_require__("6eeb");
        var toString3 = __webpack_require__("b041");
        if (!TO_STRING_TAG_SUPPORT) {
          redefine(Object.prototype, "toString", toString3, { unsafe: true });
        }
      },
      "d44e": function(module3, exports3, __webpack_require__) {
        var defineProperty2 = __webpack_require__("9bf2").f;
        var has2 = __webpack_require__("5135");
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        module3.exports = function(it2, TAG, STATIC) {
          if (it2 && !has2(it2 = STATIC ? it2 : it2.prototype, TO_STRING_TAG)) {
            defineProperty2(it2, TO_STRING_TAG, { configurable: true, value: TAG });
          }
        };
      },
      "d58f": function(module3, exports3, __webpack_require__) {
        var aFunction = __webpack_require__("1c0b");
        var toObject2 = __webpack_require__("7b0b");
        var IndexedObject = __webpack_require__("44ad");
        var toLength = __webpack_require__("50c4");
        var createMethod = function(IS_RIGHT) {
          return function(that, callbackfn, argumentsLength, memo2) {
            aFunction(callbackfn);
            var O = toObject2(that);
            var self2 = IndexedObject(O);
            var length3 = toLength(O.length);
            var index2 = IS_RIGHT ? length3 - 1 : 0;
            var i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2)
              while (true) {
                if (index2 in self2) {
                  memo2 = self2[index2];
                  index2 += i;
                  break;
                }
                index2 += i;
                if (IS_RIGHT ? index2 < 0 : length3 <= index2) {
                  throw TypeError("Reduce of empty array with no initial value");
                }
              }
            for (; IS_RIGHT ? index2 >= 0 : length3 > index2; index2 += i)
              if (index2 in self2) {
                memo2 = callbackfn(memo2, self2[index2], index2, O);
              }
            return memo2;
          };
        };
        module3.exports = {
          left: createMethod(false),
          right: createMethod(true)
        };
      },
      "d784": function(module3, exports3, __webpack_require__) {
        __webpack_require__("ac1f");
        var redefine = __webpack_require__("6eeb");
        var fails = __webpack_require__("d039");
        var wellKnownSymbol = __webpack_require__("b622");
        var regexpExec = __webpack_require__("9263");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var SPECIES = wellKnownSymbol("species");
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          var re2 = /./;
          re2.exec = function() {
            var result = [];
            result.groups = { a: "7" };
            return result;
          };
          return "".replace(re2, "$<a>") !== "7";
        });
        var REPLACE_KEEPS_$0 = function() {
          return "a".replace(/./, "$0") === "$0";
        }();
        var REPLACE = wellKnownSymbol("replace");
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
          if (/./[REPLACE]) {
            return /./[REPLACE]("a", "$0") === "";
          }
          return false;
        }();
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          var re2 = /(?:)/;
          var originalExec = re2.exec;
          re2.exec = function() {
            return originalExec.apply(this, arguments);
          };
          var result = "ab".split(re2);
          return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
        });
        module3.exports = function(KEY, length3, exec, sham) {
          var SYMBOL = wellKnownSymbol(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function() {
            var O = {};
            O[SYMBOL] = function() {
              return 7;
            };
            return ""[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
            var execCalled = false;
            var re2 = /a/;
            if (KEY === "split") {
              re2 = {};
              re2.constructor = {};
              re2.constructor[SPECIES] = function() {
                return re2;
              };
              re2.flags = "";
              re2[SYMBOL] = /./[SYMBOL];
            }
            re2.exec = function() {
              execCalled = true;
              return null;
            };
            re2[SYMBOL]("");
            return !execCalled;
          });
          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
            var nativeRegExpMethod = /./[SYMBOL];
            var methods2 = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
              if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                }
                return { done: true, value: nativeMethod.call(str, regexp, arg2) };
              }
              return { done: false };
            }, {
              REPLACE_KEEPS_$0,
              REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
            });
            var stringMethod = methods2[0];
            var regexMethod = methods2[1];
            redefine(String.prototype, KEY, stringMethod);
            redefine(RegExp.prototype, SYMBOL, length3 == 2 ? function(string, arg) {
              return regexMethod.call(string, this, arg);
            } : function(string) {
              return regexMethod.call(string, this);
            });
          }
          if (sham)
            createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
        };
      },
      "d81d": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var $map = __webpack_require__("b727").map;
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
        var USES_TO_LENGTH = arrayMethodUsesToLength("map");
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          map: function map3(callbackfn) {
            return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "da84": function(module3, exports3, __webpack_require__) {
        (function(global2) {
          var check2 = function(it2) {
            return it2 && it2.Math == Math && it2;
          };
          module3.exports = check2(typeof globalThis == "object" && globalThis) || check2(typeof window == "object" && window) || check2(typeof self == "object" && self) || check2(typeof global2 == "object" && global2) || Function("return this")();
        }).call(this, __webpack_require__("c8ba"));
      },
      "dbb4": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var DESCRIPTORS = __webpack_require__("83ab");
        var ownKeys2 = __webpack_require__("56ef");
        var toIndexedObject = __webpack_require__("fc6a");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var createProperty = __webpack_require__("8418");
        $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
          getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
            var O = toIndexedObject(object);
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            var keys2 = ownKeys2(O);
            var result = {};
            var index2 = 0;
            var key, descriptor;
            while (keys2.length > index2) {
              descriptor = getOwnPropertyDescriptor(O, key = keys2[index2++]);
              if (descriptor !== void 0)
                createProperty(result, key, descriptor);
            }
            return result;
          }
        });
      },
      "dbf1": function(module3, __webpack_exports__, __webpack_require__) {
        (function(global2) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return console2;
          });
          function getConsole() {
            if (typeof window !== "undefined") {
              return window.console;
            }
            return global2.console;
          }
          var console2 = getConsole();
        }).call(this, __webpack_require__("c8ba"));
      },
      "ddb0": function(module3, exports3, __webpack_require__) {
        var global2 = __webpack_require__("da84");
        var DOMIterables = __webpack_require__("fdbc");
        var ArrayIteratorMethods = __webpack_require__("e260");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var wellKnownSymbol = __webpack_require__("b622");
        var ITERATOR = wellKnownSymbol("iterator");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var ArrayValues = ArrayIteratorMethods.values;
        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global2[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          if (CollectionPrototype) {
            if (CollectionPrototype[ITERATOR] !== ArrayValues)
              try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
              } catch (error2) {
                CollectionPrototype[ITERATOR] = ArrayValues;
              }
            if (!CollectionPrototype[TO_STRING_TAG]) {
              createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
            }
            if (DOMIterables[COLLECTION_NAME])
              for (var METHOD_NAME in ArrayIteratorMethods) {
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                  try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                  } catch (error2) {
                    CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                  }
              }
          }
        }
      },
      "df75": function(module3, exports3, __webpack_require__) {
        var internalObjectKeys = __webpack_require__("ca84");
        var enumBugKeys = __webpack_require__("7839");
        module3.exports = Object.keys || function keys2(O) {
          return internalObjectKeys(O, enumBugKeys);
        };
      },
      "e01a": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var DESCRIPTORS = __webpack_require__("83ab");
        var global2 = __webpack_require__("da84");
        var has2 = __webpack_require__("5135");
        var isObject2 = __webpack_require__("861d");
        var defineProperty2 = __webpack_require__("9bf2").f;
        var copyConstructorProperties = __webpack_require__("e893");
        var NativeSymbol = global2.Symbol;
        if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || NativeSymbol().description !== void 0)) {
          var EmptyStringDescriptionStore = {};
          var SymbolWrapper = function Symbol2() {
            var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
            var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
            if (description === "")
              EmptyStringDescriptionStore[result] = true;
            return result;
          };
          copyConstructorProperties(SymbolWrapper, NativeSymbol);
          var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
          symbolPrototype.constructor = SymbolWrapper;
          var symbolToString2 = symbolPrototype.toString;
          var native = String(NativeSymbol("test")) == "Symbol(test)";
          var regexp = /^Symbol\((.*)\)[^)]+$/;
          defineProperty2(symbolPrototype, "description", {
            configurable: true,
            get: function description() {
              var symbol = isObject2(this) ? this.valueOf() : this;
              var string = symbolToString2.call(symbol);
              if (has2(EmptyStringDescriptionStore, symbol))
                return "";
              var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
              return desc === "" ? void 0 : desc;
            }
          });
          $2({ global: true, forced: true }, {
            Symbol: SymbolWrapper
          });
        }
      },
      "e163": function(module3, exports3, __webpack_require__) {
        var has2 = __webpack_require__("5135");
        var toObject2 = __webpack_require__("7b0b");
        var sharedKey = __webpack_require__("f772");
        var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
        var IE_PROTO = sharedKey("IE_PROTO");
        var ObjectPrototype = Object.prototype;
        module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
          O = toObject2(O);
          if (has2(O, IE_PROTO))
            return O[IE_PROTO];
          if (typeof O.constructor == "function" && O instanceof O.constructor) {
            return O.constructor.prototype;
          }
          return O instanceof Object ? ObjectPrototype : null;
        };
      },
      "e177": function(module3, exports3, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module3.exports = !fails(function() {
          function F2() {
          }
          F2.prototype.constructor = null;
          return Object.getPrototypeOf(new F2()) !== F2.prototype;
        });
      },
      "e260": function(module3, exports3, __webpack_require__) {
        var toIndexedObject = __webpack_require__("fc6a");
        var addToUnscopables = __webpack_require__("44d2");
        var Iterators = __webpack_require__("3f8c");
        var InternalStateModule = __webpack_require__("69f3");
        var defineIterator = __webpack_require__("7dd0");
        var ARRAY_ITERATOR = "Array Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
        module3.exports = defineIterator(Array, "Array", function(iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            index: 0,
            kind
          });
        }, function() {
          var state2 = getInternalState(this);
          var target2 = state2.target;
          var kind = state2.kind;
          var index2 = state2.index++;
          if (!target2 || index2 >= target2.length) {
            state2.target = void 0;
            return { value: void 0, done: true };
          }
          if (kind == "keys")
            return { value: index2, done: false };
          if (kind == "values")
            return { value: target2[index2], done: false };
          return { value: [index2, target2[index2]], done: false };
        }, "values");
        Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
      },
      "e439": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var fails = __webpack_require__("d039");
        var toIndexedObject = __webpack_require__("fc6a");
        var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var DESCRIPTORS = __webpack_require__("83ab");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeGetOwnPropertyDescriptor(1);
        });
        var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
        $2({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it2, key) {
            return nativeGetOwnPropertyDescriptor(toIndexedObject(it2), key);
          }
        });
      },
      "e538": function(module3, exports3, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        exports3.f = wellKnownSymbol;
      },
      "e893": function(module3, exports3, __webpack_require__) {
        var has2 = __webpack_require__("5135");
        var ownKeys2 = __webpack_require__("56ef");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var definePropertyModule = __webpack_require__("9bf2");
        module3.exports = function(target2, source) {
          var keys2 = ownKeys2(source);
          var defineProperty2 = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if (!has2(target2, key))
              defineProperty2(target2, key, getOwnPropertyDescriptor(source, key));
          }
        };
      },
      "e8b5": function(module3, exports3, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        module3.exports = Array.isArray || function isArray2(arg) {
          return classof(arg) == "Array";
        };
      },
      "e95a": function(module3, exports3, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var Iterators = __webpack_require__("3f8c");
        var ITERATOR = wellKnownSymbol("iterator");
        var ArrayPrototype = Array.prototype;
        module3.exports = function(it2) {
          return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
        };
      },
      "f5df": function(module3, exports3, __webpack_require__) {
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var classofRaw = __webpack_require__("c6b6");
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var CORRECT_ARGUMENTS = classofRaw(function() {
          return arguments;
        }()) == "Arguments";
        var tryGet = function(it2, key) {
          try {
            return it2[key];
          } catch (error2) {
          }
        };
        module3.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
          var O, tag, result;
          return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O = Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
        };
      },
      "f772": function(module3, exports3, __webpack_require__) {
        var shared = __webpack_require__("5692");
        var uid2 = __webpack_require__("90e3");
        var keys2 = shared("keys");
        module3.exports = function(key) {
          return keys2[key] || (keys2[key] = uid2(key));
        };
      },
      "fb15": function(module3, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__);
        if (typeof window !== "undefined") {
          var currentScript = window.document.currentScript;
          {
            var getCurrentScript = __webpack_require__("8875");
            currentScript = getCurrentScript();
            if (!("currentScript" in document)) {
              Object.defineProperty(document, "currentScript", { get: getCurrentScript });
            }
          }
          var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          if (src) {
            __webpack_require__.p = src[1];
          }
        }
        __webpack_require__("99af");
        __webpack_require__("4de4");
        __webpack_require__("4160");
        __webpack_require__("c975");
        __webpack_require__("d81d");
        __webpack_require__("a434");
        __webpack_require__("159b");
        __webpack_require__("a4d3");
        __webpack_require__("e439");
        __webpack_require__("dbb4");
        __webpack_require__("b64b");
        function _defineProperty2(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function ownKeys2(object, enumerableOnly) {
          var keys2 = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys2.push.apply(keys2, symbols);
          }
          return keys2;
        }
        function _objectSpread22(target2) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys2(Object(source), true).forEach(function(key) {
                _defineProperty2(target2, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys2(Object(source)).forEach(function(key) {
                Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target2;
        }
        function _arrayWithHoles2(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        __webpack_require__("e01a");
        __webpack_require__("d28b");
        __webpack_require__("e260");
        __webpack_require__("d3b7");
        __webpack_require__("3ca3");
        __webpack_require__("ddb0");
        function _iterableToArrayLimit2(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        __webpack_require__("a630");
        __webpack_require__("fb6a");
        __webpack_require__("b0c0");
        __webpack_require__("25f0");
        function _arrayLikeToArray2(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _unsupportedIterableToArray2(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray2(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray2(o, minLen);
        }
        function _nonIterableRest2() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _slicedToArray2(arr, i) {
          return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
        }
        function _arrayWithoutHoles2(arr) {
          if (Array.isArray(arr))
            return _arrayLikeToArray2(arr);
        }
        function _iterableToArray2(iter) {
          if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
            return Array.from(iter);
        }
        function _nonIterableSpread2() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toConsumableArray2(arr) {
          return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
        }
        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
        var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);
        function removeNode(node) {
          if (node.parentElement !== null) {
            node.parentElement.removeChild(node);
          }
        }
        function insertNodeAt(fatherNode, node, position) {
          var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
          fatherNode.insertBefore(node, refNode);
        }
        var console2 = __webpack_require__("dbf1");
        __webpack_require__("13d5");
        __webpack_require__("4fad");
        __webpack_require__("ac1f");
        __webpack_require__("5319");
        function cached(fn2) {
          var cache = /* @__PURE__ */ Object.create(null);
          return function cachedFn(str) {
            var hit = cache[str];
            return hit || (cache[str] = fn2(str));
          };
        }
        var regex2 = /-(\w)/g;
        var camelize2 = cached(function(str) {
          return str.replace(regex2, function(_2, c) {
            return c.toUpperCase();
          });
        });
        __webpack_require__("5db7");
        __webpack_require__("73d9");
        var manageAndEmit = ["Start", "Add", "Remove", "Update", "End"];
        var emit2 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
        var manage = ["Move"];
        var eventHandlerNames = [manage, manageAndEmit, emit2].flatMap(function(events3) {
          return events3;
        }).map(function(evt) {
          return "on".concat(evt);
        });
        var events2 = {
          manage,
          manageAndEmit,
          emit: emit2
        };
        function isReadOnly(eventName) {
          return eventHandlerNames.indexOf(eventName) !== -1;
        }
        __webpack_require__("caad");
        __webpack_require__("2ca0");
        var tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
        function isHtmlTag(name) {
          return tags.includes(name);
        }
        function isTransition(name) {
          return ["transition-group", "TransitionGroup"].includes(name);
        }
        function isHtmlAttribute(value) {
          return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
        }
        function project(entries) {
          return entries.reduce(function(res, _ref2) {
            var _ref22 = _slicedToArray2(_ref2, 2), key = _ref22[0], value = _ref22[1];
            res[key] = value;
            return res;
          }, {});
        }
        function getComponentAttributes(_ref3) {
          var $attrs = _ref3.$attrs, _ref3$componentData = _ref3.componentData, componentData = _ref3$componentData === void 0 ? {} : _ref3$componentData;
          var attributes = project(Object.entries($attrs).filter(function(_ref4) {
            var _ref5 = _slicedToArray2(_ref4, 2), key = _ref5[0];
            _ref5[1];
            return isHtmlAttribute(key);
          }));
          return _objectSpread22(_objectSpread22({}, attributes), componentData);
        }
        function createSortableOption(_ref6) {
          var $attrs = _ref6.$attrs, callBackBuilder = _ref6.callBackBuilder;
          var options2 = project(getValidSortableEntries($attrs));
          Object.entries(callBackBuilder).forEach(function(_ref7) {
            var _ref8 = _slicedToArray2(_ref7, 2), eventType = _ref8[0], eventBuilder = _ref8[1];
            events2[eventType].forEach(function(event) {
              options2["on".concat(event)] = eventBuilder(event);
            });
          });
          var draggable = "[data-draggable]".concat(options2.draggable || "");
          return _objectSpread22(_objectSpread22({}, options2), {}, {
            draggable
          });
        }
        function getValidSortableEntries(value) {
          return Object.entries(value).filter(function(_ref9) {
            var _ref10 = _slicedToArray2(_ref9, 2), key = _ref10[0];
            _ref10[1];
            return !isHtmlAttribute(key);
          }).map(function(_ref11) {
            var _ref12 = _slicedToArray2(_ref11, 2), key = _ref12[0], value2 = _ref12[1];
            return [camelize2(key), value2];
          }).filter(function(_ref13) {
            var _ref14 = _slicedToArray2(_ref13, 2), key = _ref14[0];
            _ref14[1];
            return !isReadOnly(key);
          });
        }
        __webpack_require__("c740");
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target2, props3) {
          for (var i = 0; i < props3.length; i++) {
            var descriptor = props3[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target2, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var getHtmlElementFromNode = function getHtmlElementFromNode2(_ref2) {
          var el2 = _ref2.el;
          return el2;
        };
        var addContext2 = function addContext3(domElement, context) {
          return domElement.__draggable_context = context;
        };
        var getContext2 = function getContext3(domElement) {
          return domElement.__draggable_context;
        };
        var componentStructure_ComponentStructure = /* @__PURE__ */ function() {
          function ComponentStructure(_ref2) {
            var _ref2$nodes = _ref2.nodes, header = _ref2$nodes.header, defaultNodes = _ref2$nodes.default, footer = _ref2$nodes.footer, root2 = _ref2.root, realList = _ref2.realList;
            _classCallCheck2(this, ComponentStructure);
            this.defaultNodes = defaultNodes;
            this.children = [].concat(_toConsumableArray2(header), _toConsumableArray2(defaultNodes), _toConsumableArray2(footer));
            this.externalComponent = root2.externalComponent;
            this.rootTransition = root2.transition;
            this.tag = root2.tag;
            this.realList = realList;
          }
          _createClass2(ComponentStructure, [{
            key: "render",
            value: function render3(h2, attributes) {
              var tag = this.tag, children = this.children, _isRootComponent = this._isRootComponent;
              var option3 = !_isRootComponent ? children : {
                default: function _default2() {
                  return children;
                }
              };
              return h2(tag, attributes, option3);
            }
          }, {
            key: "updated",
            value: function updated() {
              var defaultNodes = this.defaultNodes, realList = this.realList;
              defaultNodes.forEach(function(node, index2) {
                addContext2(getHtmlElementFromNode(node), {
                  element: realList[index2],
                  index: index2
                });
              });
            }
          }, {
            key: "getUnderlyingVm",
            value: function getUnderlyingVm(domElement) {
              return getContext2(domElement);
            }
          }, {
            key: "getVmIndexFromDomIndex",
            value: function getVmIndexFromDomIndex(domIndex2, element) {
              var defaultNodes = this.defaultNodes;
              var length3 = defaultNodes.length;
              var domChildren = element.children;
              var domElement = domChildren.item(domIndex2);
              if (domElement === null) {
                return length3;
              }
              var context = getContext2(domElement);
              if (context) {
                return context.index;
              }
              if (length3 === 0) {
                return 0;
              }
              var firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
              var indexFirstDomListElement = _toConsumableArray2(domChildren).findIndex(function(element2) {
                return element2 === firstDomListElement;
              });
              return domIndex2 < indexFirstDomListElement ? 0 : length3;
            }
          }, {
            key: "_isRootComponent",
            get: function get4() {
              return this.externalComponent || this.rootTransition;
            }
          }]);
          return ComponentStructure;
        }();
        var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
        function getSlot(slots, key) {
          var slotValue = slots[key];
          return slotValue ? slotValue() : [];
        }
        function computeNodes(_ref2) {
          var $slots = _ref2.$slots, realList = _ref2.realList, getKey = _ref2.getKey;
          var normalizedList = realList || [];
          var _map = ["header", "footer"].map(function(name) {
            return getSlot($slots, name);
          }), _map2 = _slicedToArray2(_map, 2), header = _map2[0], footer = _map2[1];
          var item = $slots.item;
          if (!item) {
            throw new Error("draggable element must have an item slot");
          }
          var defaultNodes = normalizedList.flatMap(function(element, index2) {
            return item({
              element,
              index: index2
            }).map(function(node) {
              node.key = getKey(element);
              node.props = _objectSpread22(_objectSpread22({}, node.props || {}), {}, {
                "data-draggable": true
              });
              return node;
            });
          });
          if (defaultNodes.length !== normalizedList.length) {
            throw new Error("Item slot must have only one child");
          }
          return {
            header,
            footer,
            default: defaultNodes
          };
        }
        function getRootInformation(tag) {
          var transition = isTransition(tag);
          var externalComponent = !isHtmlTag(tag) && !transition;
          return {
            transition,
            externalComponent,
            tag: externalComponent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])(tag) : transition ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : tag
          };
        }
        function computeComponentStructure(_ref2) {
          var $slots = _ref2.$slots, tag = _ref2.tag, realList = _ref2.realList, getKey = _ref2.getKey;
          var nodes = computeNodes({
            $slots,
            realList,
            getKey
          });
          var root2 = getRootInformation(tag);
          return new componentStructure_ComponentStructure({
            nodes,
            root: root2,
            realList
          });
        }
        function _emit(evtName, evtData) {
          var _this = this;
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
            return _this.$emit(evtName.toLowerCase(), evtData);
          });
        }
        function _manage(evtName) {
          var _this2 = this;
          return function(evtData, originalElement) {
            if (_this2.realList !== null) {
              return _this2["onDrag".concat(evtName)](evtData, originalElement);
            }
          };
        }
        function _manageAndEmit(evtName) {
          var _this3 = this;
          var delegateCallBack = _manage.call(this, evtName);
          return function(evtData, originalElement) {
            delegateCallBack.call(_this3, evtData, originalElement);
            _emit.call(_this3, evtName, evtData);
          };
        }
        var draggingElement = null;
        var props2 = {
          list: {
            type: Array,
            required: false,
            default: null
          },
          modelValue: {
            type: Array,
            required: false,
            default: null
          },
          itemKey: {
            type: [String, Function],
            required: true
          },
          clone: {
            type: Function,
            default: function _default2(original) {
              return original;
            }
          },
          tag: {
            type: String,
            default: "div"
          },
          move: {
            type: Function,
            default: null
          },
          componentData: {
            type: Object,
            required: false,
            default: null
          }
        };
        var emits = ["update:modelValue", "change"].concat(_toConsumableArray2([].concat(_toConsumableArray2(events2.manageAndEmit), _toConsumableArray2(events2.emit)).map(function(evt) {
          return evt.toLowerCase();
        })));
        var draggableComponent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
          name: "draggable",
          inheritAttrs: false,
          props: props2,
          emits,
          data: function data() {
            return {
              error: false
            };
          },
          render: function render3() {
            try {
              this.error = false;
              var $slots = this.$slots, $attrs = this.$attrs, tag = this.tag, componentData = this.componentData, realList = this.realList, getKey = this.getKey;
              var componentStructure = computeComponentStructure({
                $slots,
                tag,
                realList,
                getKey
              });
              this.componentStructure = componentStructure;
              var attributes = getComponentAttributes({
                $attrs,
                componentData
              });
              return componentStructure.render(external_commonjs_vue_commonjs2_vue_root_Vue_["h"], attributes);
            } catch (err) {
              this.error = true;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("pre", {
                style: {
                  color: "red"
                }
              }, err.stack);
            }
          },
          created: function created() {
            if (this.list !== null && this.modelValue !== null) {
              console2["a"].error("modelValue and list props are mutually exclusive! Please set one or another.");
            }
          },
          mounted: function mounted() {
            var _this4 = this;
            if (this.error) {
              return;
            }
            var $attrs = this.$attrs, $el = this.$el, componentStructure = this.componentStructure;
            componentStructure.updated();
            var sortableOptions = createSortableOption({
              $attrs,
              callBackBuilder: {
                manageAndEmit: function manageAndEmit2(event) {
                  return _manageAndEmit.call(_this4, event);
                },
                emit: function emit3(event) {
                  return _emit.bind(_this4, event);
                },
                manage: function manage2(event) {
                  return _manage.call(_this4, event);
                }
              }
            });
            var targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
            this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(targetDomElement, sortableOptions);
            this.targetDomElement = targetDomElement;
            targetDomElement.__draggable_component__ = this;
          },
          updated: function updated() {
            this.componentStructure.updated();
          },
          beforeUnmount: function beforeUnmount() {
            if (this._sortable !== void 0)
              this._sortable.destroy();
          },
          computed: {
            realList: function realList() {
              var list3 = this.list;
              return list3 ? list3 : this.modelValue;
            },
            getKey: function getKey() {
              var itemKey = this.itemKey;
              if (typeof itemKey === "function") {
                return itemKey;
              }
              return function(element) {
                return element[itemKey];
              };
            }
          },
          watch: {
            $attrs: {
              handler: function handler(newOptionValue) {
                var _sortable = this._sortable;
                if (!_sortable)
                  return;
                getValidSortableEntries(newOptionValue).forEach(function(_ref2) {
                  var _ref22 = _slicedToArray2(_ref2, 2), key = _ref22[0], value = _ref22[1];
                  _sortable.option(key, value);
                });
              },
              deep: true
            }
          },
          methods: {
            getUnderlyingVm: function getUnderlyingVm(domElement) {
              return this.componentStructure.getUnderlyingVm(domElement) || null;
            },
            getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(htmElement) {
              return htmElement.__draggable_component__;
            },
            emitChanges: function emitChanges(evt) {
              var _this5 = this;
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                return _this5.$emit("change", evt);
              });
            },
            alterList: function alterList(onList) {
              if (this.list) {
                onList(this.list);
                return;
              }
              var newList = _toConsumableArray2(this.modelValue);
              onList(newList);
              this.$emit("update:modelValue", newList);
            },
            spliceList: function spliceList() {
              var _arguments = arguments;
              var spliceList2 = function spliceList3(list3) {
                return list3.splice.apply(list3, _toConsumableArray2(_arguments));
              };
              this.alterList(spliceList2);
            },
            updatePosition: function updatePosition(oldIndex2, newIndex2) {
              var updatePosition2 = function updatePosition3(list3) {
                return list3.splice(newIndex2, 0, list3.splice(oldIndex2, 1)[0]);
              };
              this.alterList(updatePosition2);
            },
            getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
              var to = _ref3.to, related = _ref3.related;
              var component = this.getUnderlyingPotencialDraggableComponent(to);
              if (!component) {
                return {
                  component
                };
              }
              var list3 = component.realList;
              var context = {
                list: list3,
                component
              };
              if (to !== related && list3) {
                var destination = component.getUnderlyingVm(related) || {};
                return _objectSpread22(_objectSpread22({}, destination), context);
              }
              return context;
            },
            getVmIndexFromDomIndex: function getVmIndexFromDomIndex(domIndex2) {
              return this.componentStructure.getVmIndexFromDomIndex(domIndex2, this.targetDomElement);
            },
            onDragStart: function onDragStart(evt) {
              this.context = this.getUnderlyingVm(evt.item);
              evt.item._underlying_vm_ = this.clone(this.context.element);
              draggingElement = evt.item;
            },
            onDragAdd: function onDragAdd(evt) {
              var element = evt.item._underlying_vm_;
              if (element === void 0) {
                return;
              }
              removeNode(evt.item);
              var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
              this.spliceList(newIndex2, 0, element);
              var added = {
                element,
                newIndex: newIndex2
              };
              this.emitChanges({
                added
              });
            },
            onDragRemove: function onDragRemove(evt) {
              insertNodeAt(this.$el, evt.item, evt.oldIndex);
              if (evt.pullMode === "clone") {
                removeNode(evt.clone);
                return;
              }
              var _this$context = this.context, oldIndex2 = _this$context.index, element = _this$context.element;
              this.spliceList(oldIndex2, 1);
              var removed = {
                element,
                oldIndex: oldIndex2
              };
              this.emitChanges({
                removed
              });
            },
            onDragUpdate: function onDragUpdate(evt) {
              removeNode(evt.item);
              insertNodeAt(evt.from, evt.item, evt.oldIndex);
              var oldIndex2 = this.context.index;
              var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
              this.updatePosition(oldIndex2, newIndex2);
              var moved2 = {
                element: this.context.element,
                oldIndex: oldIndex2,
                newIndex: newIndex2
              };
              this.emitChanges({
                moved: moved2
              });
            },
            computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
              if (!relatedContext.element) {
                return 0;
              }
              var domChildren = _toConsumableArray2(evt.to.children).filter(function(el2) {
                return el2.style["display"] !== "none";
              });
              var currentDomIndex = domChildren.indexOf(evt.related);
              var currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
              var draggedInList = domChildren.indexOf(draggingElement) !== -1;
              return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
            },
            onDragMove: function onDragMove(evt, originalEvent) {
              var move = this.move, realList = this.realList;
              if (!move || !realList) {
                return true;
              }
              var relatedContext = this.getRelatedContextFromMoveEvent(evt);
              var futureIndex = this.computeFutureIndex(relatedContext, evt);
              var draggedContext = _objectSpread22(_objectSpread22({}, this.context), {}, {
                futureIndex
              });
              var sendEvent = _objectSpread22(_objectSpread22({}, evt), {}, {
                relatedContext,
                draggedContext
              });
              return move(sendEvent, originalEvent);
            },
            onDragEnd: function onDragEnd() {
              draggingElement = null;
            }
          }
        });
        var vuedraggable = draggableComponent;
        __webpack_exports__["default"] = vuedraggable;
      },
      "fb6a": function(module3, exports3, __webpack_require__) {
        var $2 = __webpack_require__("23e7");
        var isObject2 = __webpack_require__("861d");
        var isArray2 = __webpack_require__("e8b5");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var toLength = __webpack_require__("50c4");
        var toIndexedObject = __webpack_require__("fc6a");
        var createProperty = __webpack_require__("8418");
        var wellKnownSymbol = __webpack_require__("b622");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var arrayMethodUsesToLength = __webpack_require__("ae40");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
        var USES_TO_LENGTH = arrayMethodUsesToLength("slice", { ACCESSORS: true, 0: 0, 1: 2 });
        var SPECIES = wellKnownSymbol("species");
        var nativeSlice = [].slice;
        var max3 = Math.max;
        $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
          slice: function slice2(start2, end3) {
            var O = toIndexedObject(this);
            var length3 = toLength(O.length);
            var k2 = toAbsoluteIndex(start2, length3);
            var fin = toAbsoluteIndex(end3 === void 0 ? length3 : end3, length3);
            var Constructor, result, n;
            if (isArray2(O)) {
              Constructor = O.constructor;
              if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                Constructor = void 0;
              } else if (isObject2(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null)
                  Constructor = void 0;
              }
              if (Constructor === Array || Constructor === void 0) {
                return nativeSlice.call(O, k2, fin);
              }
            }
            result = new (Constructor === void 0 ? Array : Constructor)(max3(fin - k2, 0));
            for (n = 0; k2 < fin; k2++, n++)
              if (k2 in O)
                createProperty(result, n, O[k2]);
            result.length = n;
            return result;
          }
        });
      },
      "fc6a": function(module3, exports3, __webpack_require__) {
        var IndexedObject = __webpack_require__("44ad");
        var requireObjectCoercible = __webpack_require__("1d80");
        module3.exports = function(it2) {
          return IndexedObject(requireObjectCoercible(it2));
        };
      },
      "fdbc": function(module3, exports3) {
        module3.exports = {
          CSSRuleList: 0,
          CSSStyleDeclaration: 0,
          CSSValueList: 0,
          ClientRectList: 0,
          DOMRectList: 0,
          DOMStringList: 0,
          DOMTokenList: 1,
          DataTransferItemList: 0,
          FileList: 0,
          HTMLAllCollection: 0,
          HTMLCollection: 0,
          HTMLFormElement: 0,
          HTMLSelectElement: 0,
          MediaList: 0,
          MimeTypeArray: 0,
          NamedNodeMap: 0,
          NodeList: 1,
          PaintRequestList: 0,
          Plugin: 0,
          PluginArray: 0,
          SVGLengthList: 0,
          SVGNumberList: 0,
          SVGPathSegList: 0,
          SVGPointList: 0,
          SVGStringList: 0,
          SVGTransformList: 0,
          SourceBufferList: 0,
          StyleSheetList: 0,
          TextTrackCueList: 0,
          TextTrackList: 0,
          TouchList: 0
        };
      },
      "fdbf": function(module3, exports3, __webpack_require__) {
        var NATIVE_SYMBOL = __webpack_require__("4930");
        module3.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
      }
    })["default"];
  });
})(vuedraggable_umd);
var Draggable = /* @__PURE__ */ getDefaultExportFromCjs(vuedraggable_umd.exports);
var Modal_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => `.vfm {
  position: fixed !important;
}
.fui-modal-overlay {
  background-color: rgba(123, 135, 147, 0.35) !important;
}
.fui-modal {
  display: flex;
  justify-content: center;
  align-items: center;
  position: fixed !important;
}
.fui-modal-wrap {
  position: relative;
  display: flex;
  flex-direction: column;
  margin: 1rem;
  max-height: 100%;
  border-radius: 5px;
  background-color: #fff;
  box-shadow: 0 25px 100px rgba(31, 41, 51, 0.5);
  z-index: 100;
  overflow: hidden;
  width: 66%;
  height: 66%;
  min-width: 600px;
  min-height: 400px;
}
.fui-modal-header {
  width: 100%;
  background-color: #f3f7fc;
  box-shadow: inset 0 -1px 0 rgba(51, 64, 77, 0.1);
  padding: 10px 24px;
  display: flex;
  align-items: center;
  border-top-left-radius: 5px;
  border-top-right-radius: 5px;
}
.fui-modal-title {
  margin: 0;
  padding: 0;
  font-weight: 600;
  font-size: 15px;
  line-height: 30px;
}
.fui-dialog-close {
  width: 20px;
  height: 20px;
  margin-left: auto;
  cursor: pointer;
  background-size: 20px 20px;
  background-repeat: no-repeat;
  transition: all 0.3s ease;
  background-image: url("data:image/svg+xml,%3Csvg aria-hidden='true' role='img' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 320 512'%3E%3Cpath fill='%233f4d5a' d='M207.6 256l107.72-107.72c6.23-6.23 6.23-16.34 0-22.58l-25.03-25.03c-6.23-6.23-16.34-6.23-22.58 0L160 208.4 52.28 100.68c-6.23-6.23-16.34-6.23-22.58 0L4.68 125.7c-6.23 6.23-6.23 16.34 0 22.58L112.4 256 4.68 363.72c-6.23 6.23-6.23 16.34 0 22.58l25.03 25.03c6.23 6.23 16.34 6.23 22.58 0L160 303.6l107.72 107.72c6.23 6.23 16.34 6.23 22.58 0l25.03-25.03c6.23-6.23 6.23-16.34 0-22.58L207.6 256z'%3E%3C/path%3E%3C/svg%3E");
  opacity: 0.6;
}
.fui-dialog-close:hover {
  opacity: 1;
}
.fui-modal-body {
  height: 100%;
  position: relative;
  overflow: auto;
}
.fui-modal-content {
  padding: 24px;
}
.fui-modal-footer {
  width: 100%;
  background-color: #e4edf6;
  box-shadow: inset 0 1px 0 rgba(51, 64, 77, 0.1);
  padding: 10px 24px;
  border-bottom-left-radius: 5px;
  border-bottom-right-radius: 5px;
}
.fui-modal-footer > .buttons {
  margin: 0;
}
.fui-modal-enter-active,
.fui-modal-leave-active {
  transition: opacity 0.2s ease;
}
.fui-modal-enter-from,
.fui-modal-leave-to {
  opacity: 0;
}`)();
const _sfc_main$a = {
  name: "Modal",
  components: {
    VueFinalModal: Ee
  },
  props: {
    modalClass: {
      type: [String, Array],
      default: ""
    },
    showHeader: {
      type: Boolean,
      default: true
    },
    showFooter: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      id: this.$id("modal")
    };
  },
  methods: {
    showModal() {
      setTimeout(() => {
        xe.show(this.id);
      }, 10);
    },
    close() {
      setTimeout(() => {
        xe.hide(this.id);
      }, 10);
    }
  }
};
const _hoisted_1$8 = {
  key: 0,
  id: "modalTitle",
  class: "fui-modal-header"
};
const _hoisted_2$8 = {
  id: "modalDescription",
  class: "fui-modal-body"
};
const _hoisted_3$7 = {
  key: 1,
  class: "fui-modal-footer"
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_final_modal = resolveComponent("vue-final-modal");
  return openBlock(), createBlock(_component_vue_final_modal, mergeProps({
    name: $data.id,
    ssr: false
  }, _ctx.$attrs, {
    "z-index-auto": true,
    "z-index-base": "100",
    "esc-to-close": true,
    attach: "body",
    classes: ["fui-modal", $props.modalClass],
    "content-class": "fui-modal-wrap",
    "overlay-class": "fui-modal-overlay",
    transition: "fui-modal",
    "overlay-transition": "fui-modal"
  }), {
    default: withCtx(() => [
      $props.showHeader ? (openBlock(), createElementBlock("header", _hoisted_1$8, [
        renderSlot(_ctx.$slots, "header")
      ])) : createCommentVNode("v-if", true),
      createBaseVNode("section", _hoisted_2$8, [
        renderSlot(_ctx.$slots, "body")
      ]),
      $props.showFooter ? (openBlock(), createElementBlock("footer", _hoisted_3$7, [
        renderSlot(_ctx.$slots, "footer")
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 16, ["name", "classes"]);
}
var Modal = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$9], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/components/Modal.vue"]]);
var TableBulkOptions_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".fui-table-bulk-preview {\n  border-radius: 4px;\n  width: 100%;\n  height: 210px;\n  padding: 5px !important;\n  font-size: 12px !important;\n  line-height: 1.4 !important;\n}")();
const _sfc_main$9 = {
  name: "TableBulkOptions",
  components: {
    Modal
  },
  props: {
    showModal: {
      type: Boolean,
      default: () => {
      }
    },
    predefinedOptions: {
      type: Array,
      default: () => {
        return [];
      }
    },
    tableField: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      success: false,
      error: false,
      errorMessage: "",
      loading: false,
      saveLoading: false,
      options: [],
      availableOptions: [],
      labelOptions: [],
      valueOptions: [],
      predefinedOption: null,
      labelOption: null,
      valueOption: null,
      preview: ""
    };
  },
  watch: {
    predefinedOption() {
      this.updatePreview();
    },
    labelOption() {
      this.updatePreview();
    },
    valueOption() {
      this.updatePreview();
    }
  },
  methods: {
    closeModal() {
      this.$refs.modal.close();
    },
    onCancelModal() {
      this.closeModal();
    },
    onSave() {
      this.saveLoading = true;
      setTimeout(() => {
        const values = this.preview.split("\n").map((line) => {
          const lineValues = line.split("|");
          return { label: lineValues[0], value: lineValues[1] || lineValues[0], isDefault: false };
        });
        this.tableField.setItems(values, false);
        this.closeModal();
        this.saveLoading = false;
      }, 100);
    },
    onPredefinedChange(e) {
      this.predefinedOption = e.target.value;
      this.fetchOptions({ option: this.predefinedOption });
    },
    onLabelChange(e) {
      this.labelOption = e.target.value;
    },
    onValueChange(e) {
      this.valueOption = e.target.value;
    },
    updatePreview() {
      if (this.availableOptions.length) {
        let options2 = [];
        options2 = this.availableOptions.map((option3) => {
          if (this.labelOption || this.valueOption) {
            if (this.labelOption === this.valueOption) {
              return option3[this.labelOption];
            }
            return `${option3[this.labelOption]}|${option3[this.valueOption]}`;
          }
          return option3;
        });
        this.preview = options2.join("\n");
      }
    },
    fetchOptions(data = {}) {
      this.success = false;
      this.error = false;
      this.errorMessage = "";
      this.loading = true;
      Craft.sendActionRequest("POST", "formie/fields/get-predefined-options", { data }).then((response) => {
        this.loading = false;
        if (response.data.error) {
          this.error = true;
          this.errorMessage = Craft.t("formie", "An error occurred.");
          if (response.data.error) {
            this.errorMessage += `<br><code>${response.data.error}</code>`;
          }
          return;
        }
        if (response.data) {
          this.availableOptions = response.data.data || [];
          this.labelOptions = response.data.labelOptions || [];
          this.valueOptions = response.data.valueOptions || [];
          this.labelOption = response.data.labelOption || null;
          this.valueOption = response.data.valueOption || null;
        }
        this.updatePreview();
        this.success = true;
      }).catch((error2) => {
        this.loading = false;
        this.error = true;
        this.errorMessage = error2;
        if (error2.response.data.error) {
          this.errorMessage += `<br><code>${error2.response.data.error}</code>`;
        }
      });
    }
  }
};
const _hoisted_1$7 = { class: "fui-modal-title" };
const _hoisted_2$7 = { class: "fui-modal-content" };
const _hoisted_3$6 = {
  class: "fui-field-instructions",
  style: { "margin": "-10px 0 15px" }
};
const _hoisted_4$5 = { class: "fui-row" };
const _hoisted_5$4 = { class: "fui-col-6" };
const _hoisted_6$4 = { class: "field" };
const _hoisted_7$3 = { class: "heading" };
const _hoisted_8$3 = { for: "predefined-options" };
const _hoisted_9$3 = {
  id: "help-predefined-options",
  class: "instructions"
};
const _hoisted_10$3 = { class: "select" };
const _hoisted_11$3 = ["value"];
const _hoisted_12$3 = {
  key: 0,
  class: "fui-loading-pane"
};
const _hoisted_13$3 = /* @__PURE__ */ createBaseVNode("div", { class: "fui-loading fui-loading-lg" }, null, -1);
const _hoisted_14$3 = [
  _hoisted_13$3
];
const _hoisted_15$3 = {
  key: 1,
  class: "fui-error-pane error"
};
const _hoisted_16$3 = { class: "fui-error-content" };
const _hoisted_17$3 = /* @__PURE__ */ createBaseVNode("span", { "data-icon": "alert" }, null, -1);
const _hoisted_18$3 = ["innerHTML"];
const _hoisted_19$3 = { key: 2 };
const _hoisted_20$3 = {
  key: 0,
  class: "field"
};
const _hoisted_21$3 = { class: "heading" };
const _hoisted_22$3 = { for: "label-options" };
const _hoisted_23$3 = {
  id: "help-label-options",
  class: "instructions"
};
const _hoisted_24$3 = { class: "select" };
const _hoisted_25$3 = ["value"];
const _hoisted_26$3 = {
  key: 1,
  class: "field"
};
const _hoisted_27$3 = { class: "heading" };
const _hoisted_28$3 = { for: "value-options" };
const _hoisted_29$3 = {
  id: "help-value-options",
  class: "instructions"
};
const _hoisted_30$3 = { class: "select" };
const _hoisted_31$3 = ["value"];
const _hoisted_32$3 = { class: "fui-col-6" };
const _hoisted_33$3 = { class: "buttons right" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_modal = resolveComponent("modal");
  return openBlock(), createBlock(_component_modal, {
    ref: "modal",
    modelValue: $props.showModal,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $props.showModal = $event),
    "modal-class": "fui-table-bulk-add-modal",
    onClickOutside: $options.onCancelModal
  }, {
    header: withCtx(() => [
      createBaseVNode("h3", _hoisted_1$7, toDisplayString(_ctx.t("formie", "Bulk Add Options")), 1),
      createBaseVNode("div", {
        class: "fui-dialog-close",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.onCancelModal && $options.onCancelModal(...args), ["prevent"]))
      })
    ]),
    body: withCtx(() => [
      createBaseVNode("div", _hoisted_2$7, [
        createBaseVNode("div", _hoisted_3$6, [
          createBaseVNode("p", null, toDisplayString(_ctx.t("formie", "Select from predefined options and customize or paste your own to bulk add options.")), 1)
        ]),
        createBaseVNode("div", _hoisted_4$5, [
          createBaseVNode("div", _hoisted_5$4, [
            createBaseVNode("div", _hoisted_6$4, [
              createBaseVNode("div", _hoisted_7$3, [
                createBaseVNode("label", _hoisted_8$3, toDisplayString(_ctx.t("formie", "Predefined Options")), 1),
                createBaseVNode("div", _hoisted_9$3, [
                  createBaseVNode("p", null, toDisplayString(_ctx.t("formie", "Select from the available predefined options.")), 1)
                ])
              ]),
              createBaseVNode("div", _hoisted_10$3, [
                createBaseVNode("select", {
                  id: "predefined-options",
                  class: "select",
                  "aria-describedby": "help-predefined-options",
                  onChange: _cache[1] || (_cache[1] = (...args) => $options.onPredefinedChange && $options.onPredefinedChange(...args))
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($props.predefinedOptions, (option3, index2) => {
                    return openBlock(), createElementBlock("option", {
                      key: index2,
                      value: option3.value
                    }, toDisplayString(option3.label), 9, _hoisted_11$3);
                  }), 128))
                ], 32)
              ])
            ]),
            $data.loading ? (openBlock(), createElementBlock("div", _hoisted_12$3, _hoisted_14$3)) : createCommentVNode("v-if", true),
            $data.error ? (openBlock(), createElementBlock("div", _hoisted_15$3, [
              createBaseVNode("div", _hoisted_16$3, [
                _hoisted_17$3,
                createBaseVNode("span", {
                  class: "error",
                  innerHTML: $data.errorMessage
                }, null, 8, _hoisted_18$3)
              ])
            ])) : createCommentVNode("v-if", true),
            !$data.loading ? (openBlock(), createElementBlock("div", _hoisted_19$3, [
              $data.labelOptions.length ? (openBlock(), createElementBlock("div", _hoisted_20$3, [
                createBaseVNode("div", _hoisted_21$3, [
                  createBaseVNode("label", _hoisted_22$3, toDisplayString(_ctx.t("formie", "Option Label")), 1),
                  createBaseVNode("div", _hoisted_23$3, [
                    createBaseVNode("p", null, toDisplayString(_ctx.t("formie", "Select the data to be used as the option label.")), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$3, [
                  withDirectives(createBaseVNode("select", {
                    id: "label-options",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.labelOption = $event),
                    class: "select",
                    "aria-describedby": "help-label-options",
                    onChange: _cache[3] || (_cache[3] = (...args) => $options.onLabelChange && $options.onLabelChange(...args))
                  }, [
                    (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.labelOptions, (option3, index2) => {
                      return openBlock(), createElementBlock("option", {
                        key: index2,
                        value: option3.value
                      }, toDisplayString(option3.label), 9, _hoisted_25$3);
                    }), 128))
                  ], 544), [
                    [vModelSelect, $data.labelOption]
                  ])
                ])
              ])) : createCommentVNode("v-if", true),
              $data.valueOptions.length ? (openBlock(), createElementBlock("div", _hoisted_26$3, [
                createBaseVNode("div", _hoisted_27$3, [
                  createBaseVNode("label", _hoisted_28$3, toDisplayString(_ctx.t("formie", "Option Value")), 1),
                  createBaseVNode("div", _hoisted_29$3, [
                    createBaseVNode("p", null, toDisplayString(_ctx.t("formie", "Select the data to be used as the option value.")), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_30$3, [
                  withDirectives(createBaseVNode("select", {
                    id: "value-options",
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.valueOption = $event),
                    class: "select",
                    "aria-describedby": "help-value-options",
                    onChange: _cache[5] || (_cache[5] = (...args) => $options.onValueChange && $options.onValueChange(...args))
                  }, [
                    (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.valueOptions, (option3, index2) => {
                      return openBlock(), createElementBlock("option", {
                        key: index2,
                        value: option3.value
                      }, toDisplayString(option3.label), 9, _hoisted_31$3);
                    }), 128))
                  ], 544), [
                    [vModelSelect, $data.valueOption]
                  ])
                ])
              ])) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true)
          ]),
          createBaseVNode("div", _hoisted_32$3, [
            withDirectives(createBaseVNode("textarea", {
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.preview = $event),
              class: "text fui-table-bulk-preview"
            }, null, 512), [
              [vModelText, $data.preview]
            ])
          ])
        ])
      ])
    ]),
    footer: withCtx(() => [
      createBaseVNode("div", _hoisted_33$3, [
        createBaseVNode("div", {
          class: "btn",
          role: "button",
          onClick: _cache[7] || (_cache[7] = withModifiers((...args) => $options.onCancelModal && $options.onCancelModal(...args), ["prevent"]))
        }, toDisplayString(_ctx.t("app", "Cancel")), 1),
        createBaseVNode("div", {
          class: normalizeClass(["btn submit", { "fui-loading fui-loading-sm": $data.saveLoading }]),
          role: "button",
          onClick: _cache[8] || (_cache[8] = withModifiers((...args) => $options.onSave && $options.onSave(...args), ["prevent"]))
        }, toDisplayString(_ctx.t("app", "Add Options")), 3)
      ])
    ]),
    _: 1
  }, 8, ["modelValue", "onClickOutside"]);
}
var TableBulkOptions = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/table/TableBulkOptions.vue"]]);
const parse = function(attribute2, obj) {
  if (typeof attribute2 !== "string") {
    return attribute2;
  }
  if (!obj) {
    return null;
  }
  let negative = false;
  let compare = "";
  if (attribute2.includes("||")) {
    const attributes = attribute2.split("||");
    const results = attributes.map((attr) => {
      return parse(attr, obj);
    });
    return results.includes(true);
  }
  if (attribute2.startsWith("!")) {
    attribute2 = attribute2.replace("!", "");
    negative = true;
  }
  if (attribute2.includes("=")) {
    [attribute2, compare] = attribute2.split("=");
  }
  if (attribute2) {
    if (compare) {
      if (negative) {
        return get2(obj, attribute2) !== compare;
      }
      return get2(obj, attribute2) === compare;
    }
    if (negative) {
      return !get2(obj, attribute2);
    }
    return get2(obj, attribute2);
  }
  return null;
};
var TableDropdown_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".fui-edit-table-modal .fui-modal-wrap {\n  width: 35%;\n  height: 65%;\n  min-height: 200px;\n  min-width: 200px;\n}\n.fui-edit-table-modal .fui-modal-content {\n  padding-bottom: 6rem;\n}")();
const _sfc_main$8 = {
  name: "TableDropdown",
  components: {
    Modal
  },
  props: {
    showModal: {
      type: Boolean,
      default: false
    },
    values: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      originalValues: null,
      formValues: this.values
    };
  },
  created() {
    this.originalValues = this.clone(this.values);
  },
  methods: {
    closeModal() {
      this.$refs.modal.close();
    },
    onCancelModal() {
      this.$parent.model.options = this.originalValues.options || [];
      this.closeModal();
    },
    onSave() {
      this.$refs.fieldForm.submit();
    },
    submitHandler() {
      this.closeModal();
    }
  }
};
const _hoisted_1$6 = { class: "fui-modal-content" };
const _hoisted_2$6 = { class: "buttons right" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FormKit = resolveComponent("FormKit");
  const _component_FormKitForm = resolveComponent("FormKitForm");
  const _component_modal = resolveComponent("modal");
  return openBlock(), createBlock(_component_modal, {
    ref: "modal",
    modelValue: $props.showModal,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $props.showModal = $event),
    "modal-class": "fui-edit-table-modal",
    "show-header": false
  }, {
    header: withCtx(() => []),
    body: withCtx(() => [
      createBaseVNode("div", _hoisted_1$6, [
        createVNode(_component_FormKitForm, {
          ref: "fieldForm",
          modelValue: $data.formValues,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.formValues = $event),
          name: "tableDropdownOptions",
          onSubmit: $options.submitHandler
        }, {
          default: withCtx(() => [
            createVNode(_component_FormKit, {
              type: "table",
              name: "options",
              label: _ctx.t("formie", "Dropdown Options"),
              help: _ctx.t("formie", "Define the available options."),
              validation: "+min:1|uniqueTableCellLabel|uniqueTableCellValue|requiredTableCellLabel|requiredTableCellValue",
              "new-row-defaults": {
                label: "",
                value: "",
                isOptgroup: false,
                isDefault: false
              },
              columns: [{
                type: "label",
                label: _ctx.t("formie", "Option Label"),
                class: "singleline-cell textual"
              }, {
                type: "value",
                label: _ctx.t("formie", "Value"),
                class: "code singleline-cell textual"
              }, {
                type: "default",
                name: "default",
                label: _ctx.t("formie", "Default"),
                class: "thin checkbox-cell"
              }]
            }, null, 8, ["label", "help", "columns"])
          ]),
          _: 1
        }, 8, ["modelValue", "onSubmit"])
      ])
    ]),
    footer: withCtx(() => [
      createBaseVNode("div", _hoisted_2$6, [
        createBaseVNode("div", {
          class: "btn submit",
          role: "button",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.onSave && $options.onSave(...args), ["prevent"]))
        }, toDisplayString(_ctx.t("app", "Done")), 1)
      ])
    ]),
    _: 1
  }, 8, ["modelValue"]);
}
var TableDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/table/TableDropdown.vue"]]);
var TableRow_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => "td .focus-visible {\n  z-index: 1;\n  position: relative;\n}")();
const _sfc_main$7 = {
  name: "TableRow",
  components: {
    TableDropdown
  },
  props: {
    context: {
      type: Object,
      default: () => {
      }
    },
    model: {
      type: Object,
      default: () => {
      }
    },
    index: {
      type: Number,
      default: 0
    }
  },
  emits: ["remove"],
  data() {
    return {
      showModal: false,
      labelBlur: false,
      valueBlur: false
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    columns() {
      const columns = get2(this.context.attrs, "columns", []);
      if (typeof columns === "string" && this.editingField) {
        return get2(this.editingField.field, columns);
      }
      return columns;
    },
    labelName() {
      return this._getName("label", "label");
    },
    valueName() {
      return this._getName("value", "value");
    },
    defaultName() {
      return this._getName("default", "isDefault");
    },
    allowMultipleDefault() {
      const attribute2 = get2(this.context.attrs, "allowMultipleDefault", true);
      return parse(attribute2, this.editingField ? this.editingField.field : null);
    },
    generateHandle() {
      return get2(this.context.attrs, "generateHandle", false);
    },
    generateValue() {
      return get2(this.context.attrs, "generateValue", true);
    },
    hasDefault() {
      let hasDefault = false;
      if (!this.allowMultipleDefault) {
        this.context.value.forEach((row, i) => {
          if (row[this.defaultName] && i !== this.index) {
            hasDefault = true;
          }
        });
      }
      return !hasDefault;
    },
    typeOptions() {
      return [
        {
          label: Craft.t("formie", "Checkbox"),
          value: "checkbox"
        },
        {
          label: Craft.t("formie", "Color"),
          value: "color"
        },
        {
          label: Craft.t("formie", "Date"),
          value: "date"
        },
        {
          label: Craft.t("formie", "Dropdown"),
          value: "select"
        },
        {
          label: Craft.t("formie", "Email"),
          value: "email"
        },
        {
          label: Craft.t("formie", "Heading"),
          value: "heading"
        },
        {
          label: Craft.t("formie", "Multi-line Text"),
          value: "multiline"
        },
        {
          label: Craft.t("formie", "Number"),
          value: "number"
        },
        {
          label: Craft.t("formie", "Time"),
          value: "time"
        },
        {
          label: Craft.t("formie", "Single-line Text"),
          value: "singleline"
        },
        {
          label: Craft.t("formie", "URL"),
          value: "url"
        }
      ];
    }
  }),
  watch: {
    model: {
      deep: true,
      handler(newVal) {
        const values = this.context.value;
        values[this.index] = newVal;
        this.context.node.input(values);
      }
    },
    allowMultipleDefault(newValue, oldValue) {
      this.$nextTick(() => {
        if (!newValue && oldValue) {
          let first2 = true;
          this.context.value.forEach((row) => {
            if (row[this.defaultName]) {
              if (!first2) {
                row[this.defaultName] = false;
              }
              first2 = false;
            }
          });
        }
      });
    }
  },
  methods: {
    onModalClosed() {
      this.showModal = false;
    },
    openModal() {
      this.showModal = true;
    },
    _getName(type, fallback) {
      const name = this.columns.find((o) => {
        return o.type === type;
      });
      if (name && name.name) {
        return name.name;
      }
      return fallback;
    },
    getError(field, value) {
      const labelsWithError = this.context.node.config.labelsWithError || [];
      this.context.node.config.valuesWithError || [];
      if (field === "label" && this.labelBlur) {
        return labelsWithError.includes(value);
      }
      if (field === "value" && this.valueBlur) {
        return labelsWithError.includes(value);
      }
      return false;
    },
    labelUpdate() {
      if (this.model.isOptgroup) {
        return;
      }
      if (!this.generateValue) {
        return;
      }
      if (this.model.__isNew) {
        if (this.generateHandle) {
          this.model[this.valueName] = generateHandle(this.model[this.labelName]);
        } else {
          this.model[this.valueName] = this.model[this.labelName];
        }
      }
    },
    valueUpdate() {
      if (this.model[this.valueName].trim() === "") {
        this.model.__isNew = true;
      }
    },
    removeItem() {
      this.$emit("remove", this.index);
    }
  }
};
const _hoisted_1$5 = { key: 0 };
const _hoisted_2$5 = { class: "checkbox-wrapper" };
const _hoisted_3$5 = ["id"];
const _hoisted_4$4 = ["for"];
const _hoisted_5$3 = ["disabled"];
const _hoisted_6$3 = { class: "checkbox-wrapper" };
const _hoisted_7$2 = ["id", "disabled"];
const _hoisted_8$2 = ["for"];
const _hoisted_9$2 = { class: "checkbox-wrapper" };
const _hoisted_10$2 = ["id"];
const _hoisted_11$2 = ["for"];
const _hoisted_12$2 = ["width"];
const _hoisted_13$2 = { class: "flex flex-nowrap" };
const _hoisted_14$2 = { class: "select small" };
const _hoisted_15$2 = ["value"];
const _hoisted_16$2 = ["width"];
const _hoisted_17$2 = { class: "checkbox-wrapper" };
const _hoisted_18$2 = ["id", "onUpdate:modelValue"];
const _hoisted_19$2 = ["for"];
const _hoisted_20$2 = ["width"];
const _hoisted_21$2 = { class: "flex color-container" };
const _hoisted_22$2 = /* @__PURE__ */ createBaseVNode("div", { class: "color small" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "color-preview" }, [
    /* @__PURE__ */ createBaseVNode("input", {
      type: "color",
      class: "color-preview-input"
    })
  ])
], -1);
const _hoisted_23$2 = ["onUpdate:modelValue"];
const _hoisted_24$2 = ["width"];
const _hoisted_25$2 = { class: "datewrapper" };
const _hoisted_26$2 = ["onUpdate:modelValue"];
const _hoisted_27$2 = /* @__PURE__ */ createBaseVNode("div", { "data-icon": "date" }, null, -1);
const _hoisted_28$2 = ["width"];
const _hoisted_29$2 = ["onUpdate:modelValue"];
const _hoisted_30$2 = ["width"];
const _hoisted_31$2 = ["onUpdate:modelValue"];
const _hoisted_32$2 = ["width"];
const _hoisted_33$2 = {
  class: "lightswitch small",
  tabindex: "0",
  role: "checkbox",
  "aria-checked": "false"
};
const _hoisted_34 = /* @__PURE__ */ createBaseVNode("div", { class: "lightswitch-container" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "handle" })
], -1);
const _hoisted_35 = ["onUpdate:modelValue"];
const _hoisted_36 = ["width"];
const _hoisted_37 = ["onUpdate:modelValue"];
const _hoisted_38 = ["width"];
const _hoisted_39 = ["onUpdate:modelValue"];
const _hoisted_40 = ["width"];
const _hoisted_41 = { class: "timewrapper" };
const _hoisted_42 = ["onUpdate:modelValue"];
const _hoisted_43 = /* @__PURE__ */ createBaseVNode("div", { "data-icon": "time" }, null, -1);
const _hoisted_44 = ["width"];
const _hoisted_45 = { class: "select small" };
const _hoisted_46 = ["onUpdate:modelValue"];
const _hoisted_47 = ["value"];
const _hoisted_48 = ["width"];
const _hoisted_49 = ["onUpdate:modelValue"];
const _hoisted_50 = ["width"];
const _hoisted_51 = ["onUpdate:modelValue"];
const _hoisted_52 = { class: "thin action" };
const _hoisted_53 = ["title"];
const _hoisted_54 = { class: "thin action" };
const _hoisted_55 = ["title"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_table_dropdown = resolveComponent("table-dropdown");
  return $options.columns.length ? (openBlock(), createElementBlock("tr", _hoisted_1$5, [
    (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.columns, (col, i) => {
      return openBlock(), createElementBlock(Fragment$1, null, [
        col.type === "optgroup" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass(col.class)
        }, [
          createBaseVNode("div", _hoisted_2$5, [
            withDirectives(createBaseVNode("input", {
              id: "isOptgroup-" + $props.index,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.model.isOptgroup = $event),
              type: "checkbox",
              class: "checkbox"
            }, null, 8, _hoisted_3$5), [
              [vModelCheckbox, $props.model.isOptgroup]
            ]),
            createBaseVNode("label", {
              for: "isOptgroup-" + $props.index
            }, null, 8, _hoisted_4$4)
          ])
        ], 2)) : createCommentVNode("v-if", true),
        col.type === "label" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass([col.class, { error: $options.getError("label", $props.model[$options.labelName]) }])
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $props.model[$options.labelName] = $event),
            type: "text",
            class: "text fullwidth",
            autocomplete: "off",
            onInput: _cache[2] || (_cache[2] = (...args) => $options.labelUpdate && $options.labelUpdate(...args)),
            onFocus: _cache[3] || (_cache[3] = ($event) => $data.labelBlur = false),
            onBlur: _cache[4] || (_cache[4] = ($event) => $data.labelBlur = true)
          }, null, 544), [
            [vModelText, $props.model[$options.labelName]]
          ])
        ], 2)) : createCommentVNode("v-if", true),
        col.type === "value" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass([col.class, { disabled: $props.model.isOptgroup, error: $options.getError("value", $props.model[$options.valueName]) }])
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $props.model[$options.valueName] = $event),
            type: "text",
            class: "text fullwidth",
            autocomplete: "off",
            disabled: $props.model.isOptgroup,
            onInput: _cache[6] || (_cache[6] = (...args) => $options.valueUpdate && $options.valueUpdate(...args)),
            onFocus: _cache[7] || (_cache[7] = ($event) => $data.valueBlur = false),
            onBlur: _cache[8] || (_cache[8] = ($event) => $data.valueBlur = true)
          }, null, 40, _hoisted_5$3), [
            [vModelText, $props.model[$options.valueName]]
          ])
        ], 2)) : createCommentVNode("v-if", true),
        col.type === "default" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass([col.class, { disabled: $props.model.isOptgroup }])
        }, [
          createBaseVNode("div", _hoisted_6$3, [
            withDirectives(createBaseVNode("input", {
              id: "isDefault-" + $props.index,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $props.model[$options.defaultName] = $event),
              type: "checkbox",
              class: "checkbox",
              disabled: $props.model.isOptgroup || !$options.hasDefault
            }, null, 8, _hoisted_7$2), [
              [vModelCheckbox, $props.model[$options.defaultName]]
            ]),
            createBaseVNode("label", {
              for: "isDefault-" + $props.index
            }, null, 8, _hoisted_8$2)
          ])
        ], 2)) : createCommentVNode("v-if", true),
        col.type === "disabled" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass(col.class)
        }, [
          createBaseVNode("div", _hoisted_9$2, [
            withDirectives(createBaseVNode("input", {
              id: "disabled-" + $props.index,
              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $props.model.disabled = $event),
              type: "checkbox",
              class: "checkbox"
            }, null, 8, _hoisted_10$2), [
              [vModelCheckbox, $props.model.disabled]
            ]),
            createBaseVNode("label", {
              for: "disabled-" + $props.index
            }, null, 8, _hoisted_11$2)
          ])
        ], 2)) : createCommentVNode("v-if", true),
        col.type === "width" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass(col.class),
          width: col.width
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $props.model.width = $event),
            type: "text",
            class: "text fullwidth",
            autocomplete: "off"
          }, null, 512), [
            [vModelText, $props.model.width]
          ])
        ], 10, _hoisted_12$2)) : createCommentVNode("v-if", true),
        col.type === "type" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: normalizeClass(col.class)
        }, [
          createBaseVNode("div", _hoisted_13$2, [
            createBaseVNode("div", _hoisted_14$2, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $props.model.type = $event)
              }, [
                (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.typeOptions, (option3, j2) => {
                  return openBlock(), createElementBlock("option", {
                    key: j2,
                    value: option3.value
                  }, toDisplayString(option3.label), 9, _hoisted_15$2);
                }), 128))
              ], 512), [
                [vModelSelect, $props.model.type]
              ])
            ]),
            createBaseVNode("a", {
              class: normalizeClass(["settings light", { "hidden": $props.model.type !== "select" }]),
              role: "button",
              "data-icon": "settings",
              onClick: _cache[13] || (_cache[13] = withModifiers((...args) => $options.openModal && $options.openModal(...args), ["prevent"]))
            }, null, 2),
            $data.showModal ? (openBlock(), createBlock(_component_table_dropdown, {
              key: 0,
              ref_for: true,
              ref: "editFieldModal",
              showModal: $data.showModal,
              "onUpdate:showModal": _cache[14] || (_cache[14] = ($event) => $data.showModal = $event),
              values: $props.model,
              "onUpdate:values": _cache[15] || (_cache[15] = ($event) => $props.model = $event),
              onClosed: $options.onModalClosed
            }, null, 8, ["showModal", "values", "onClosed"])) : createCommentVNode("v-if", true)
          ])
        ], 2)) : createCommentVNode("v-if", true),
        createCommentVNode(" //////////////////////// "),
        createCommentVNode(" Fieldtypes "),
        createCommentVNode(" //////////////////////// "),
        col.type === "checkbox" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "checkbox-cell",
          width: col.width
        }, [
          createBaseVNode("div", _hoisted_17$2, [
            withDirectives(createBaseVNode("input", {
              id: col.handle + "-" + $props.index,
              "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
              type: "checkbox",
              class: "checkbox"
            }, null, 8, _hoisted_18$2), [
              [vModelCheckbox, $props.model[col.id]]
            ]),
            createBaseVNode("label", {
              for: col.handle + "-" + $props.index
            }, null, 8, _hoisted_19$2)
          ])
        ], 8, _hoisted_16$2)) : createCommentVNode("v-if", true),
        col.type === "color" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "color-cell textual code",
          width: col.width
        }, [
          createBaseVNode("div", _hoisted_21$2, [
            _hoisted_22$2,
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
              type: "text",
              class: "text color-input",
              size: "10",
              autocomplete: "off"
            }, null, 8, _hoisted_23$2), [
              [vModelText, $props.model[col.id]]
            ])
          ])
        ], 8, _hoisted_20$2)) : createCommentVNode("v-if", true),
        col.type === "date" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "date-cell textual",
          width: col.width
        }, [
          createBaseVNode("div", _hoisted_25$2, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
              type: "text",
              class: "text hasDatepicker",
              size: "10",
              autocomplete: "off",
              placeholder: " "
            }, null, 8, _hoisted_26$2), [
              [vModelText, $props.model[col.id]]
            ]),
            _hoisted_27$2
          ])
        ], 8, _hoisted_24$2)) : createCommentVNode("v-if", true),
        col.type === "email" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "email-cell textual",
          width: col.width
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
            type: "email",
            class: "text fullwidth",
            autocomplete: "off"
          }, null, 8, _hoisted_29$2), [
            [vModelText, $props.model[col.id]]
          ])
        ], 8, _hoisted_28$2)) : createCommentVNode("v-if", true),
        col.type === "heading" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "",
          width: col.width
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
            type: "text",
            class: "text fullwidth",
            autocomplete: "off"
          }, null, 8, _hoisted_31$2), [
            [vModelText, $props.model[col.id]]
          ])
        ], 8, _hoisted_30$2)) : createCommentVNode("v-if", true),
        col.type === "lightswitch" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "lightswitch-cell",
          width: col.width
        }, [
          createBaseVNode("div", _hoisted_33$2, [
            _hoisted_34,
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
              type: "hidden"
            }, null, 8, _hoisted_35), [
              [vModelText, $props.model[col.id]]
            ])
          ])
        ], 8, _hoisted_32$2)) : createCommentVNode("v-if", true),
        col.type === "multiline" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "multiline-cell textual",
          width: col.width
        }, [
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
            rows: "1",
            style: { "min-height": "36px" }
          }, null, 8, _hoisted_37), [
            [vModelText, $props.model[col.id]]
          ])
        ], 8, _hoisted_36)) : createCommentVNode("v-if", true),
        col.type === "number" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "number-cell textual",
          width: col.width
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
            type: "number",
            class: "text fullwidth",
            autocomplete: "off"
          }, null, 8, _hoisted_39), [
            [vModelText, $props.model[col.id]]
          ])
        ], 8, _hoisted_38)) : createCommentVNode("v-if", true),
        col.type === "time" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "time-cell textual",
          width: col.width
        }, [
          createBaseVNode("div", _hoisted_41, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
              type: "text",
              class: "text ui-timepicker-input",
              size: "10",
              autocomplete: "off",
              placeholder: " "
            }, null, 8, _hoisted_42), [
              [vModelText, $props.model[col.id]]
            ]),
            _hoisted_43
          ])
        ], 8, _hoisted_40)) : createCommentVNode("v-if", true),
        col.type === "select" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "select-cell",
          width: col.width
        }, [
          createBaseVNode("div", _hoisted_45, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": ($event) => $props.model[col.id] = $event
            }, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(col.options, (option3, optIndex) => {
                return openBlock(), createElementBlock("option", {
                  key: optIndex,
                  value: option3.value
                }, toDisplayString(option3.label), 9, _hoisted_47);
              }), 128))
            ], 8, _hoisted_46), [
              [vModelSelect, $props.model[col.id]]
            ])
          ])
        ], 8, _hoisted_44)) : createCommentVNode("v-if", true),
        col.type === "singleline" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "singleline-cell textual",
          width: col.width
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
            type: "text",
            class: "text fullwidth",
            autocomplete: "off"
          }, null, 8, _hoisted_49), [
            [vModelText, $props.model[col.id]]
          ])
        ], 8, _hoisted_48)) : createCommentVNode("v-if", true),
        col.type === "url" ? (openBlock(), createElementBlock("td", {
          key: i,
          class: "url-cell textual",
          width: col.width
        }, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": ($event) => $props.model[col.id] = $event,
            type: "url",
            class: "text fullwidth",
            autocomplete: "off"
          }, null, 8, _hoisted_51), [
            [vModelText, $props.model[col.id]]
          ])
        ], 8, _hoisted_50)) : createCommentVNode("v-if", true)
      ], 64);
    }), 256)),
    createBaseVNode("td", _hoisted_52, [
      createBaseVNode("a", {
        class: "move icon",
        title: _ctx.t("app", "Reorder"),
        role: "button"
      }, null, 8, _hoisted_53)
    ]),
    createBaseVNode("td", _hoisted_54, [
      createBaseVNode("a", {
        class: "delete icon",
        title: _ctx.t("app", "Delete"),
        role: "button",
        onClick: _cache[16] || (_cache[16] = withModifiers((...args) => $options.removeItem && $options.removeItem(...args), ["prevent"]))
      }, null, 8, _hoisted_55)
    ])
  ])) : createCommentVNode("v-if", true);
}
var TableRow = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/table/TableRow.vue"]]);
var TableInput_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".fui-table-bulk-add-btn[data-v-e3e68e10] {\n  position: absolute;\n  top: -36px;\n  right: 0;\n  font-size: 12px;\n  border-radius: 3px;\n  padding: 5px 12px;\n  height: auto;\n}\n.fui-table-btn-disabled[data-v-e3e68e10] {\n  opacity: 0.2;\n  pointer-events: none;\n}")();
const _sfc_main$6 = {
  name: "TableInput",
  components: {
    Draggable,
    TableRow,
    TableBulkOptions
  },
  props: {
    context: {
      type: Object,
      required: true
    }
  },
  emits: ["remove"],
  data() {
    return {
      dragging: false,
      totalColumns: 0,
      showModal: false
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    totalItems() {
      return Array.isArray(this.context._value) ? this.context._value.length : this.context.minimum || 1;
    },
    canAddMore() {
      return this.repeatable && (this.context.limit ? this.totalItems < this.context.limit : true);
    },
    columns() {
      let columns = get2(this.context.attrs, "columns", []);
      if (typeof columns === "string") {
        if (this.editingField) {
          columns = get2(this.editingField.field, columns);
        }
      }
      if (columns !== void 0) {
        return columns;
      }
      return [];
    },
    repeatable() {
      return get2(this.context.attrs, "repeatable", true);
    },
    showHeader() {
      return get2(this.context.attrs, "showHeader", true);
    },
    confirmDelete() {
      return get2(this.context.attrs, "confirmDelete", false);
    },
    confirmMessage() {
      return get2(this.context.attrs, "confirmMessage", "");
    },
    newRowLabel() {
      return get2(this.context.attrs, "newRowLabel", "Add an option");
    },
    newRowDefaults() {
      return get2(this.context.attrs, "newRowDefaults", {});
    },
    useColumnIds() {
      return get2(this.context.attrs, "useColumnIds", false);
    },
    enableBulkOptions() {
      return get2(this.context.attrs, "enableBulkOptions", false);
    },
    predefinedOptions() {
      return get2(this.context.attrs, "predefinedOptions", false);
    },
    initialValue() {
      return get2(this.context.attrs, "initialValue", []);
    }
  }),
  created() {
    if (!Array.isArray(this.context._value)) {
      this.context.node.input([]);
    }
    if (isEmpty$1(this.context._value) && !isEmpty$1(this.initialValue)) {
      setTimeout(() => {
        this.context.node.input(this.initialValue);
      }, 20);
    }
    this.totalColumns = Math.max(Math.max.apply(Math, this.clone(this.context._value).map((o) => {
      if (o.id) {
        return o.id.toString().replace("col", "");
      }
    })), this.context._value.length) || 0;
  },
  methods: {
    setItems(items, replace4 = true) {
      if (replace4) {
        this.context.node.input([]);
      }
      items.forEach((item) => {
        this.addItem(null, item);
      });
    },
    addItem(e, item = {}) {
      let newRow = this.clone(this.newRowDefaults);
      if (!isEmpty$1(item)) {
        newRow = item;
      }
      if (typeof newRow === "function") {
        newRow = newRow();
      }
      Object.defineProperty(newRow, "__isNew", {
        enumerable: false,
        writable: true,
        value: Symbol(true)
      });
      if (this.useColumnIds) {
        newRow.id = `col${++this.totalColumns}`;
      }
      if (!Array.isArray(this.context._value)) {
        this.context.node.input([]);
      }
      this.context._value.push(setId(newRow));
      this.$nextTick().then(() => {
        const $rows = this.$refs.table.getElementsByTagName("tr");
        if ($rows.length) {
          const $lastRow = $rows[$rows.length - 1];
          if ($lastRow) {
            const $firstText = $lastRow.querySelector('input[type="text"]');
            if ($firstText) {
              $firstText.focus();
            }
          }
        }
      });
    },
    removeItem(index2) {
      if (this.confirmDelete) {
        let message2 = this.confirmMessage;
        const row = this.context._value[index2];
        if (typeof message2 === "function") {
          message2 = this.confirmMessage(row);
        }
        if (confirm(message2)) {
          this.deleteRow(index2);
        }
      } else {
        this.deleteRow(index2);
      }
    },
    deleteRow(index2) {
      this.context._value.splice(index2, 1);
    },
    openModal() {
      this.showModal = true;
    },
    onModalClosed() {
      this.showModal = false;
    }
  }
};
const _withScopeId$1 = (n) => (pushScopeId("data-v-e3e68e10"), n = n(), popScopeId(), n);
const _hoisted_1$4 = ["data-is-repeatable"];
const _hoisted_2$4 = {
  ref: "table",
  class: "editable fullwidth"
};
const _hoisted_3$4 = { key: 0 };
const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("th", { colspan: "2" }, null, -1));
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_table_bulk_options = resolveComponent("table-bulk-options");
  const _component_TableRow = resolveComponent("TableRow");
  const _component_draggable = resolveComponent("draggable");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($props.context.classes.element),
    "data-is-repeatable": $props.context.repeatable
  }, [
    $options.enableBulkOptions ? (openBlock(), createElementBlock("div", {
      key: 0,
      tabindex: "0",
      class: "btn add icon fui-table-bulk-add-btn",
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.openModal && $options.openModal(...args), ["prevent"]))
    }, toDisplayString(_ctx.t("formie", "Bulk add options")), 1)) : createCommentVNode("v-if", true),
    $options.enableBulkOptions && $data.showModal ? (openBlock(), createBlock(_component_table_bulk_options, {
      key: 1,
      ref: "bulkOptionsModal",
      showModal: $data.showModal,
      "onUpdate:showModal": _cache[1] || (_cache[1] = ($event) => $data.showModal = $event),
      "predefined-options": $options.predefinedOptions,
      "table-field": this,
      onClosed: $options.onModalClosed
    }, null, 8, ["showModal", "predefined-options", "onClosed"])) : createCommentVNode("v-if", true),
    withDirectives(createBaseVNode("table", _hoisted_2$4, [
      $options.showHeader ? (openBlock(), createElementBlock("thead", _hoisted_3$4, [
        createBaseVNode("tr", null, [
          (openBlock(true), createElementBlock(Fragment$1, null, renderList($options.columns, (col, index2) => {
            return openBlock(), createElementBlock("th", {
              key: index2,
              scope: "col",
              class: normalizeClass(col.class)
            }, toDisplayString(col.label ? col.label : "") + " " + toDisplayString(col.heading ? col.heading : ""), 3);
          }), 128)),
          _hoisted_4$3
        ])
      ])) : createCommentVNode("v-if", true),
      createVNode(_component_draggable, {
        list: $props.context._value,
        tag: "tbody",
        class: normalizeClass({ "is-dragging": $data.dragging }),
        handle: ".move.icon",
        animation: "150",
        "ghost-class": "vue-admin-table-drag",
        "item-key": "__id",
        onStart: _cache[2] || (_cache[2] = ($event) => $data.dragging = true),
        onEnd: _cache[3] || (_cache[3] = ($event) => $data.dragging = false)
      }, {
        item: withCtx(({ element, index: index2 }) => [
          createVNode(_component_TableRow, {
            index: index2,
            model: element,
            context: $props.context,
            onRemove: $options.removeItem
          }, null, 8, ["index", "model", "context", "onRemove"])
        ]),
        _: 1
      }, 8, ["list", "class"])
    ], 512), [
      [vShow, $options.columns.length]
    ]),
    $options.canAddMore ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(["btn add icon", { "fui-table-btn-disabled": !$options.columns.length }]),
      tabindex: "0",
      onClick: _cache[4] || (_cache[4] = withModifiers((...args) => $options.addItem && $options.addItem(...args), ["prevent"])),
      onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => $options.addItem && $options.addItem(...args), ["prevent"]), ["space"]))
    }, toDisplayString(_ctx.t("formie", $options.newRowLabel)), 35)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$4);
}
var TableInput = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5], ["__scopeId", "data-v-e3e68e10"], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/TableInput.vue"]]);
var VariableTextInput_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".fui-toolbar-dropdown-variables[data-v-5690dd55] {\n  display: block;\n  max-height: 200px;\n  overflow-y: auto;\n  padding: 5px 0;\n}\n.input-wrap[data-v-5690dd55] {\n  position: relative;\n}\n.fui-field-add-variable-icon[data-v-5690dd55] {\n  position: absolute;\n  display: flex;\n  align-items: center;\n  height: calc(100% - 2px);\n  top: 50%;\n  right: 1px;\n  padding: 8px 10px;\n  opacity: 1;\n  cursor: pointer;\n  color: #1c2e36;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  transform: translateY(-50%);\n  border-left: 1px solid transparent;\n  border-top: 1px solid transparent;\n  border-bottom: 1px solid transparent;\n  border-radius: 0 3px 3px 0;\n  background-clip: padding-box;\n  background-color: transparent;\n  z-index: 1;\n  transition: all 0.2s ease;\n}\n.fui-field-add-variable-icon svg[data-v-5690dd55] {\n  width: 16px;\n  height: 16px;\n  display: block;\n  color: #8d959b;\n  transition: color 0.2s ease;\n}\n.fui-field-add-variable-icon[data-v-5690dd55]:hover, .is-open .fui-field-add-variable-icon[data-v-5690dd55] {\n  background-color: #fff;\n  border-left-color: #d7dfe7;\n}\n.is-open .fui-field-add-variable-icon[data-v-5690dd55] {\n  border-bottom-color: #fff;\n  border-bottom-right-radius: 0;\n}\n.fui-field-add-variable-icon:hover svg[data-v-5690dd55], .is-open .fui-field-add-variable-icon svg[data-v-5690dd55] {\n  color: #1c2e36;\n}")();
var VariableTextInput_vue_vue_type_style_index_1_lang = /* @__PURE__ */ (() => ".fui-tags-list .ProseMirror {\n  outline: none;\n  overflow: hidden;\n  padding: 6px 45px 6px 9px;\n  border-radius: 3px;\n  border: 1px solid rgba(96, 125, 159, 0.25);\n  background-color: hsl(212deg, 50%, 99%);\n  background-clip: padding-box;\n}\n[data-is-showing-errors=true] .fui-tags-list .ProseMirror {\n  border-color: #CF1124;\n}\n.fui-tags-list .ProseMirror-focused {\n  border-color: #127FBF;\n  box-shadow: 0 0 0 2px rgba(18, 127, 191, 0.5);\n}")();
const OneLiner = Node$1.create({
  name: "oneLiner",
  topNode: true,
  content: "block"
});
const _sfc_main$5 = {
  name: "VariableTextInput",
  components: {
    EditorContent,
    VariableList
  },
  props: {
    context: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      tippy: null,
      isOpen: false,
      mounted: false,
      editor: null,
      json: null,
      html: null,
      variables: {}
    };
  },
  computed: {
    jsonContent() {
      return this.contentToValue(this.json);
    },
    emailVariables() {
      return this.$store.getters["form/emailFields"]();
    },
    plainTextVariables() {
      return this.$store.getters["form/plainTextFields"](true);
    },
    generalVariables() {
      return this.$store.getters["form/generalFields"];
    },
    userVariables() {
      return this.$store.getters["form/userFields"];
    },
    numberVariables() {
      return this.$store.getters["form/numberFields"]();
    }
  },
  watch: {
    jsonContent(newValue) {
      this.context.node.input(newValue);
    }
  },
  created() {
    const variablesAttribute = this.context.attrs.variables || "";
    if (variablesAttribute && this[variablesAttribute]) {
      this.variables = this[variablesAttribute];
    }
  },
  mounted() {
    this.editor = new Editor({
      extensions: this.getExtensions(),
      content: this.valueToContent(this.clone(this.context._value)),
      autofocus: false,
      onUpdate: () => {
        this.json = this.editor.getJSON().content;
        this.html = this.editor.getHTML();
      }
    });
    this.json = this.editor.getJSON().content;
    this.html = this.editor.getHTML();
    this.$nextTick(() => {
      this.mounted = true;
      const $template = this.$el.querySelector(".fui-toolbar-dropdown-variables");
      const $button = this.$el.querySelector(".fui-field-add-variable-icon");
      if ($template && $button) {
        $template.style.display = "block";
        const self2 = this;
        this.tippy = tippy$1($button, {
          content: $template,
          trigger: "click",
          allowHTML: true,
          arrow: false,
          interactive: true,
          placement: "bottom-end",
          theme: "light-border toolbar-dropdown",
          zIndex: 1e3,
          hideOnClick: true,
          offset: [0, 1],
          onShow(instance) {
            self2.isOpen = true;
          },
          onHide(instance) {
            self2.isOpen = false;
          }
        });
      }
    });
  },
  beforeUnmount() {
    if (this.editor) {
      this.editor.destroy();
    }
  },
  methods: {
    getExtensions() {
      const extensions2 = [
        OneLiner,
        Paragraph,
        Text$1,
        VariableTag.configure({ field: this })
      ];
      return extensions2;
    },
    valueToContent(value) {
      if (!value) {
        return "";
      }
      return value.split(/({.*?})/).map((param) => {
        if (param.includes("{")) {
          const variable = find$3(this.variables, { value: param });
          if (variable) {
            return `<variable-tag>${JSON.stringify(variable)}</variable-tag>`;
          }
        }
        return param;
      }).join("");
    },
    contentToValue(content) {
      if (!content) {
        return "";
      }
      let newContent = "";
      content.forEach((node) => {
        if (node.type === "paragraph" && node.content) {
          node.content.forEach((param) => {
            if (param.type === "text") {
              newContent += param.text;
            }
            if (param.type === "variableTag") {
              newContent += param.attrs.value;
            }
          });
        }
      });
      return newContent;
    },
    addVariable(e) {
      this.tippy.hide();
      this.editor.chain().focus().setVariableTag({
        label: e.target.getAttribute("data-label"),
        value: e.target.getAttribute("data-value")
      }).run();
    }
  }
};
const _withScopeId = (n) => (pushScopeId("data-v-5690dd55"), n = n(), popScopeId(), n);
const _hoisted_1$3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("svg", {
  "aria-hidden": "true",
  focusable: "false",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    fill: "currentColor",
    d: "M384 240v32c0 6.6-5.4 12-12 12h-88v88c0 6.6-5.4 12-12 12h-32c-6.6 0-12-5.4-12-12v-88h-88c-6.6 0-12-5.4-12-12v-32c0-6.6 5.4-12 12-12h88v-88c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v88h88c6.6 0 12 5.4 12 12zm120 16c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-48 0c0-110.5-89.5-200-200-200S56 145.5 56 256s89.5 200 200 200 200-89.5 200-200z"
  })
], -1));
const _hoisted_2$3 = [
  _hoisted_1$3
];
const _hoisted_3$3 = {
  class: "fui-toolbar-dropdown-container fui-toolbar-dropdown-variables",
  style: { "display": "none" }
};
const _hoisted_4$2 = { class: "hidden" };
const _hoisted_5$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_6$2 = ["name"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_editor_content = resolveComponent("editor-content");
  const _component_variable_list = resolveComponent("variable-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["input input-wrap", { errors: false }])
  }, [
    createVNode(_component_editor_content, {
      class: normalizeClass(["fui-tags-list", { errors: false }]),
      editor: $data.editor
    }, null, 8, ["editor"]),
    $data.variables.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["select-list-container", { "is-open": $data.isOpen }])
    }, [
      createBaseVNode("div", {
        class: "fui-field-add-variable-icon",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.selectVariable && _ctx.selectVariable(...args), ["prevent"]))
      }, _hoisted_2$3),
      createBaseVNode("div", _hoisted_3$3, [
        createVNode(_component_variable_list, {
          variables: $data.variables,
          onUpdated: $options.addVariable
        }, null, 8, ["variables", "onUpdated"])
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", _hoisted_4$2, [
      _hoisted_5$2,
      withDirectives(createBaseVNode("input", {
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $props.context._value = $event),
        name: $props.context.node.name,
        class: "input text fullwidth"
      }, null, 8, _hoisted_6$2), [
        [vModelText, $props.context._value]
      ])
    ])
  ]);
}
var VariableTextInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-5690dd55"], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/inputs/VariableTextInput.vue"]]);
const _sfc_main$4 = {
  props: {
    context: {
      type: Object,
      required: true
    }
  },
  methods: {
    toggleCollapse() {
      this.context.node.input(!this.context._value);
    }
  }
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(["fui-toggle", { "expanded": !$props.context._value, "collapsed": $props.context._value }]),
    onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.toggleCollapse && $options.toggleCollapse(...args), ["prevent"]))
  }, null, 2);
}
var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/Collapse.vue"]]);
const _sfc_main$3 = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      fieldOptions: [],
      conditions: [
        { label: Craft.t("formie", "Select an option"), value: "" },
        { label: Craft.t("formie", "is"), value: "=" },
        { label: Craft.t("formie", "is not"), value: "!=" },
        { label: Craft.t("formie", "greater than"), value: ">" },
        { label: Craft.t("formie", "less than"), value: "<" },
        { label: Craft.t("formie", "contains"), value: "contains" },
        { label: Craft.t("formie", "starts with"), value: "startsWith" },
        { label: Craft.t("formie", "ends with"), value: "endsWith" }
      ],
      settings: {},
      defaultSettings: {
        showRule: "show",
        conditionRule: "all",
        conditions: []
      }
    };
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    },
    pages: (state2) => {
      return state2.form.pages;
    }
  })), {
    field() {
      if (this.editingField) {
        return this.editingField.field;
      }
      return [];
    },
    descriptionText() {
      return this.context.attrs.descriptionText || "this field if";
    }
  }),
  watch: {
    settings: {
      deep: true,
      handler(newValue) {
        this.context.node.input(this.serializeContent(newValue));
      }
    }
  },
  created() {
    this.fieldOptions = this.getFieldOptions();
    this.settings = this.unserializeContent(this.clone(this.context._value));
  },
  methods: {
    unserializeContent(value) {
      let parsedValue = null;
      if (!value) {
        return this.defaultSettings;
      }
      if (!Array.isArray(value) && !isPlainObject$1(value)) {
        try {
          parsedValue = JSON.parse(value);
        } catch (e) {
          console.log(e);
          console.log(value);
        }
      } else {
        parsedValue = value;
      }
      if (parsedValue && parsedValue.conditions) {
        parsedValue.conditions.forEach((row) => {
          const field = this.getField(row.field);
          row.valueType = this.getValueType(field, row.condition);
          row.valueOptions = this.getValueOptions(field, row.condition);
        });
        return parsedValue;
      }
      return this.defaultSettings;
    },
    serializeContent(content) {
      const value = this.clone(content);
      value.conditions.forEach((row) => {
        delete row.valueType;
        delete row.valueOptions;
      });
      return JSON.stringify(value);
    },
    addRow() {
      this.settings.conditions.push({
        id: newId(),
        field: "",
        condition: "",
        value: "",
        valueType: "text",
        valueOptions: []
      });
    },
    removeRow(index2) {
      this.settings.conditions.splice(index2, 1);
    },
    getValueType(field, condition) {
      if (field && field.field && field.field.settings) {
        let testField = field;
        let options2 = field.field.settings.options || [];
        if (field.field.supportsNested) {
          options2 = field.subfield.settings.options || [];
          testField = field.subfield;
        }
        if (options2.length && ["=", "!="].includes(condition)) {
          return "select";
        }
        if (testField.type === "verbb\\formie\\fields\\formfields\\Agree" && ["=", "!="].includes(condition)) {
          return "select";
        }
      }
      if (field && field.valueType) {
        if (["=", "!="].includes(condition)) {
          return field.valueType;
        }
      }
      return "text";
    },
    getValueOptions(field, condition) {
      if (field && field.field && field.field.settings) {
        let testField = field;
        let options2 = field.field.settings.options || [];
        if (field.field.supportsNested) {
          options2 = field.subfield.settings.options || [];
          testField = field.subfield;
        }
        options2 = this.clone(options2);
        if (testField.type === "verbb\\formie\\fields\\formfields\\Agree") {
          return [
            { label: "Checked", value: "1" },
            { label: "Unchecked", value: "0" }
          ];
        }
        if (testField.type === "verbb\\formie\\fields\\formfields\\Recipients") {
          for (let i = 0; i < options2.length; i++) {
            options2[i].value = `id:${i}`;
          }
        }
        options2 = options2.filter((option3) => {
          return !option3.isOptgroup;
        });
        return options2;
      }
      if (field && field.valueOptions) {
        return this.clone(field.valueOptions);
      }
      return [];
    },
    changeDropdown(row) {
      const field = this.getField(row.field);
      row.valueType = this.getValueType(field, row.condition);
      row.valueOptions = this.getValueOptions(field, row.condition);
      if (row.valueType === "select" && row.valueOptions && row.valueOptions[0]) {
        row.value = row.valueOptions[0].value;
      } else {
        row.value = "";
      }
    },
    getField(handle) {
      let field = null;
      this.fieldOptions.forEach((optgroup) => {
        optgroup.options.forEach((f) => {
          if (f.value === handle) {
            field = f;
          }
        });
      });
      return field;
    },
    getFieldOptions() {
      const options2 = [];
      const customFields = [];
      const excludedFields = [];
      const fields = this.$store.getters["form/fields"];
      const allStatuses = this.$store.getters["formie/statuses"]();
      allStatuses.map((status) => {
        return { label: status.name, value: status.handle };
      });
      if (this.context.attrs.isPageModal) {
        const currentPageIndex = this.pages.indexOf(this.context.attrs.page);
        if (currentPageIndex > -1) {
          this.pages.forEach((page, index2) => {
            if (index2 > currentPageIndex) {
              if (page.rows && Array.isArray(page.rows)) {
                page.rows.forEach((row) => {
                  if (row.fields && Array.isArray(row.fields)) {
                    row.fields.forEach((field) => {
                      excludedFields.push(field.handle);
                    });
                  }
                });
              }
            }
          });
        }
      }
      fields.forEach((field) => {
        if (this.field.vid === field.vid) {
          return;
        }
        if (excludedFields.includes(field.handle)) {
          return;
        }
        if (!toBoolean(field.isNested)) {
          if (field.subfieldOptions && field.hasSubfields) {
            field.subfieldOptions.forEach((subfield) => {
              customFields.push({
                field,
                subfield,
                type: field.type,
                label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                value: `{${field.handle}.${subfield.handle}}`
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((subfield) => {
                customFields.push({
                  field,
                  subfield,
                  type: field.type,
                  label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                  value: `{${field.handle}.rows.new1.fields.${subfield.handle}}`
                });
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Date") {
            customFields.push({
              field,
              type: field.type,
              label: truncate(field.label, { length: 60 }),
              value: `{${field.handle}.date}`
            });
          } else {
            customFields.push({
              field,
              type: field.type,
              label: truncate(field.label, { length: 60 }),
              value: `{${field.handle}}`
            });
          }
        }
      });
      options2.push({
        label: Craft.t("formie", "Fields"),
        options: customFields
      });
      return options2;
    }
  }
};
const _hoisted_1$2 = { style: { "margin-bottom": "20px" } };
const _hoisted_2$2 = { class: "select small" };
const _hoisted_3$2 = { value: "show" };
const _hoisted_4$1 = { value: "hide" };
const _hoisted_5$1 = { class: "select small" };
const _hoisted_6$1 = { value: "all" };
const _hoisted_7$1 = { value: "any" };
const _hoisted_8$1 = { class: "editable fullwidth" };
const _hoisted_9$1 = {
  scope: "col",
  class: "select-cell thin"
};
const _hoisted_10$1 = {
  scope: "col",
  class: "select-cell thin"
};
const _hoisted_11$1 = {
  scope: "col",
  class: "singleline-cell textual"
};
const _hoisted_12$1 = /* @__PURE__ */ createBaseVNode("th", { colspan: "2" }, null, -1);
const _hoisted_13$1 = { class: "" };
const _hoisted_14$1 = { class: "select-cell thin" };
const _hoisted_15$1 = { class: "select small" };
const _hoisted_16$1 = ["onUpdate:modelValue", "onChange"];
const _hoisted_17$1 = { value: "" };
const _hoisted_18$1 = ["label"];
const _hoisted_19$1 = ["value"];
const _hoisted_20$1 = { class: "select-cell thin" };
const _hoisted_21$1 = { class: "select small" };
const _hoisted_22$1 = ["onUpdate:modelValue", "onChange"];
const _hoisted_23$1 = ["value"];
const _hoisted_24$1 = {
  key: 0,
  class: "singleline-cell textual"
};
const _hoisted_25$1 = ["onUpdate:modelValue"];
const _hoisted_26$1 = {
  key: 1,
  class: "select-cell",
  style: { "text-align": "left" }
};
const _hoisted_27$1 = { class: "select small" };
const _hoisted_28$1 = ["onUpdate:modelValue"];
const _hoisted_29$1 = ["value"];
const _hoisted_30$1 = { class: "thin action" };
const _hoisted_31$1 = ["onClick"];
const _hoisted_32$1 = { class: "hidden" };
const _hoisted_33$1 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment$1, null, [
    createBaseVNode("div", _hoisted_1$2, [
      createTextVNode(toDisplayString(_ctx.t("formie", "I want to")) + " ", 1),
      createBaseVNode("div", _hoisted_2$2, [
        withDirectives(createBaseVNode("select", {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.settings.showRule = $event)
        }, [
          createBaseVNode("option", _hoisted_3$2, toDisplayString(_ctx.t("formie", "Show")), 1),
          createBaseVNode("option", _hoisted_4$1, toDisplayString(_ctx.t("formie", "Hide")), 1)
        ], 512), [
          [vModelSelect, $data.settings.showRule]
        ])
      ]),
      createTextVNode(" " + toDisplayString(_ctx.t("formie", $options.descriptionText)) + " ", 1),
      createBaseVNode("div", _hoisted_5$1, [
        withDirectives(createBaseVNode("select", {
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.settings.conditionRule = $event)
        }, [
          createBaseVNode("option", _hoisted_6$1, toDisplayString(_ctx.t("formie", "All")), 1),
          createBaseVNode("option", _hoisted_7$1, toDisplayString(_ctx.t("formie", "Any")), 1)
        ], 512), [
          [vModelSelect, $data.settings.conditionRule]
        ])
      ]),
      createTextVNode(" " + toDisplayString(_ctx.t("formie", "of the following rules match.")), 1)
    ]),
    createBaseVNode("table", _hoisted_8$1, [
      createBaseVNode("thead", null, [
        createBaseVNode("tr", null, [
          createBaseVNode("th", _hoisted_9$1, toDisplayString(_ctx.t("formie", "Field")), 1),
          createBaseVNode("th", _hoisted_10$1, toDisplayString(_ctx.t("formie", "Condition")), 1),
          createBaseVNode("th", _hoisted_11$1, toDisplayString(_ctx.t("formie", "Value")), 1),
          _hoisted_12$1
        ])
      ]),
      createBaseVNode("tbody", _hoisted_13$1, [
        (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.settings.conditions, (row, index2) => {
          return openBlock(), createElementBlock("tr", {
            key: row.id
          }, [
            createBaseVNode("td", _hoisted_14$1, [
              createBaseVNode("div", _hoisted_15$1, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.field = $event,
                  onChange: ($event) => $options.changeDropdown(row)
                }, [
                  createBaseVNode("option", _hoisted_17$1, toDisplayString(_ctx.t("formie", "Select an option")), 1),
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.fieldOptions, (optgroup, i) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: i,
                      label: optgroup.label
                    }, [
                      (openBlock(true), createElementBlock(Fragment$1, null, renderList(optgroup.options, (option3, j2) => {
                        return openBlock(), createElementBlock("option", {
                          key: j2,
                          value: option3.value
                        }, toDisplayString(option3.label), 9, _hoisted_19$1);
                      }), 128))
                    ], 8, _hoisted_18$1);
                  }), 128))
                ], 40, _hoisted_16$1), [
                  [vModelSelect, row.field]
                ])
              ])
            ]),
            createBaseVNode("td", _hoisted_20$1, [
              createBaseVNode("div", _hoisted_21$1, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.condition = $event,
                  onChange: ($event) => $options.changeDropdown(row)
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.conditions, (condition, i) => {
                    return openBlock(), createElementBlock("option", {
                      key: i,
                      value: condition.value
                    }, toDisplayString(condition.label), 9, _hoisted_23$1);
                  }), 128))
                ], 40, _hoisted_22$1), [
                  [vModelSelect, row.condition]
                ])
              ])
            ]),
            row.valueType === "text" ? (openBlock(), createElementBlock("td", _hoisted_24$1, [
              withDirectives(createBaseVNode("textarea", {
                "onUpdate:modelValue": ($event) => row.value = $event,
                rows: "1",
                style: { "min-height": "36px" }
              }, null, 8, _hoisted_25$1), [
                [vModelText, row.value]
              ])
            ])) : createCommentVNode("v-if", true),
            row.valueType === "select" ? (openBlock(), createElementBlock("td", _hoisted_26$1, [
              createBaseVNode("div", _hoisted_27$1, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.value = $event
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(row.valueOptions, (option3, i) => {
                    return openBlock(), createElementBlock("option", {
                      key: i,
                      value: option3.value
                    }, toDisplayString(option3.label), 9, _hoisted_29$1);
                  }), 128))
                ], 8, _hoisted_28$1), [
                  [vModelSelect, row.value]
                ])
              ])
            ])) : createCommentVNode("v-if", true),
            createBaseVNode("td", _hoisted_30$1, [
              createBaseVNode("a", {
                class: "delete icon",
                title: "Delete",
                onClick: withModifiers(($event) => $options.removeRow(index2), ["prevent"])
              }, null, 8, _hoisted_31$1)
            ])
          ]);
        }), 128))
      ])
    ]),
    createBaseVNode("div", {
      class: "btn add icon",
      onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.addRow && $options.addRow(...args), ["prevent"]))
    }, toDisplayString(_ctx.t("formie", "Add rule")), 1),
    createBaseVNode("div", _hoisted_32$1, [
      _hoisted_33$1,
      withDirectives(createBaseVNode("textarea", {
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $props.context._value = $event),
        class: "input text fullwidth"
      }, null, 512), [
        [vModelText, $props.context._value]
      ])
    ])
  ], 64);
}
var FieldConditions = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/FieldConditions.vue"]]);
const _sfc_main$2 = {
  props: {
    context: {
      type: Object,
      default: () => {
      }
    }
  },
  data() {
    return {
      fieldOptions: [],
      conditions: [
        { label: Craft.t("formie", "Select an option"), value: "" },
        { label: Craft.t("formie", "is"), value: "=" },
        { label: Craft.t("formie", "is not"), value: "!=" },
        { label: Craft.t("formie", "greater than"), value: ">" },
        { label: Craft.t("formie", "less than"), value: "<" },
        { label: Craft.t("formie", "contains"), value: "contains" },
        { label: Craft.t("formie", "starts with"), value: "startsWith" },
        { label: Craft.t("formie", "ends with"), value: "endsWith" }
      ],
      settings: {},
      defaultSettings: {
        sendRule: "send",
        conditionRule: "all",
        conditions: []
      }
    };
  },
  watch: {
    settings: {
      deep: true,
      handler(newValue) {
        this.context.node.input(this.serializeContent(newValue));
      }
    }
  },
  created() {
    this.fieldOptions = this.getFieldOptions();
    this.settings = this.unserializeContent(this.clone(this.context._value));
  },
  methods: {
    unserializeContent(value) {
      let parsedValue = null;
      if (!value) {
        return this.defaultSettings;
      }
      if (!Array.isArray(value) && !isPlainObject$1(value)) {
        try {
          parsedValue = JSON.parse(value);
        } catch (e) {
          console.log(e);
          console.log(value);
        }
      } else {
        parsedValue = value;
      }
      if (parsedValue && parsedValue.conditions) {
        parsedValue.conditions.forEach((row) => {
          const field = this.getField(row.field);
          row.valueType = this.getValueType(field, row.condition);
          row.valueOptions = this.getValueOptions(field, row.condition);
        });
        return parsedValue;
      }
      return this.defaultSettings;
    },
    serializeContent(content) {
      const value = this.clone(content);
      value.conditions.forEach((row) => {
        delete row.valueType;
        delete row.valueOptions;
      });
      return JSON.stringify(value);
    },
    addRow() {
      this.settings.conditions.push({
        id: newId(),
        field: "",
        condition: "",
        value: "",
        valueType: "text",
        valueOptions: []
      });
    },
    removeRow(index2) {
      this.settings.conditions.splice(index2, 1);
    },
    getValueType(field, condition) {
      if (field && field.field && field.field.settings) {
        let testField = field;
        let options2 = field.field.settings.options || [];
        if (field.field.supportsNested) {
          options2 = field.subfield.settings.options || [];
          testField = field.subfield;
        }
        if (options2.length && ["=", "!="].includes(condition)) {
          return "select";
        }
        if (testField.type === "verbb\\formie\\fields\\formfields\\Agree" && ["=", "!="].includes(condition)) {
          return "select";
        }
      }
      if (field && field.valueType) {
        if (["=", "!="].includes(condition)) {
          return field.valueType;
        }
      }
      return "text";
    },
    getValueOptions(field, condition) {
      if (field && field.field && field.field.settings) {
        let testField = field;
        let options2 = field.field.settings.options || [];
        if (field.field.supportsNested) {
          options2 = field.subfield.settings.options || [];
          testField = field.subfield;
        }
        options2 = this.clone(options2);
        if (testField.type === "verbb\\formie\\fields\\formfields\\Agree") {
          return [
            { label: "Checked", value: "1" },
            { label: "Unchecked", value: "0" }
          ];
        }
        if (testField.type === "verbb\\formie\\fields\\formfields\\Recipients") {
          for (let i = 0; i < options2.length; i++) {
            options2[i].value = `id:${i}`;
          }
        }
        options2 = options2.filter((option3) => {
          return !option3.isOptgroup;
        });
        return options2;
      }
      if (field && field.valueOptions) {
        return this.clone(field.valueOptions);
      }
      return [];
    },
    changeDropdown(row) {
      const field = this.getField(row.field);
      row.valueType = this.getValueType(field, row.condition);
      row.valueOptions = this.getValueOptions(field, row.condition);
      if (row.valueType === "select" && row.valueOptions && row.valueOptions[0]) {
        row.value = row.valueOptions[0].value;
      } else {
        row.value = "";
      }
    },
    getField(handle) {
      let field = null;
      this.fieldOptions.forEach((optgroup) => {
        optgroup.options.forEach((f) => {
          if (f.value === handle) {
            field = f;
          }
        });
      });
      return field;
    },
    getFieldOptions() {
      const options2 = [];
      const allStatuses = this.$store.getters["formie/statuses"]();
      const statuses = allStatuses.map((status) => {
        return { label: status.name, value: status.handle };
      });
      options2.push({
        label: Craft.t("formie", "Submission"),
        options: [
          { label: Craft.t("formie", "Title"), value: "{submission:title}" },
          { label: Craft.t("formie", "ID"), value: "{submission:id}" },
          { label: Craft.t("formie", "Form Name"), value: "{submission:formName}" },
          {
            label: Craft.t("formie", "Status"),
            value: "{submission:status}",
            valueType: "select",
            valueOptions: [
              { label: Craft.t("formie", "Select an option"), value: "" },
              ...statuses
            ]
          }
        ]
      });
      const fields = this.$store.getters["form/fields"];
      const customFields = [];
      fields.forEach((field) => {
        if (!toBoolean(field.isNested)) {
          if (field.subfieldOptions && field.hasSubfields) {
            field.subfieldOptions.forEach((subfield) => {
              customFields.push({
                field,
                subfield,
                type: field.type,
                label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                value: `{${field.handle}.${subfield.handle}}`
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((subfield) => {
                customFields.push({
                  field,
                  subfield,
                  type: field.type,
                  label: `${truncate(field.label, { length: 60 })}: ${truncate(subfield.label, { length: 60 })}`,
                  value: `{${field.handle}.rows.new1.fields.${subfield.handle}}`
                });
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Date") {
            customFields.push({
              field,
              type: field.type,
              label: truncate(field.label, { length: 60 }),
              value: `{${field.handle}.date}`
            });
          } else {
            customFields.push({
              field,
              type: field.type,
              label: truncate(field.label, { length: 60 }),
              value: `{${field.handle}}`
            });
          }
        }
      });
      options2.push({
        label: Craft.t("formie", "Fields"),
        options: customFields
      });
      return options2;
    }
  }
};
const _hoisted_1$1 = { style: { "margin-bottom": "20px" } };
const _hoisted_2$1 = { class: "select small" };
const _hoisted_3$1 = { value: "send" };
const _hoisted_4 = { value: "notSend" };
const _hoisted_5 = { class: "select small" };
const _hoisted_6 = { value: "all" };
const _hoisted_7 = { value: "any" };
const _hoisted_8 = { class: "editable fullwidth" };
const _hoisted_9 = {
  scope: "col",
  class: "select-cell thin"
};
const _hoisted_10 = {
  scope: "col",
  class: "select-cell thin"
};
const _hoisted_11 = {
  scope: "col",
  class: "singleline-cell textual"
};
const _hoisted_12 = /* @__PURE__ */ createBaseVNode("th", { colspan: "2" }, null, -1);
const _hoisted_13 = { class: "" };
const _hoisted_14 = { class: "select-cell thin" };
const _hoisted_15 = { class: "select small" };
const _hoisted_16 = ["onUpdate:modelValue", "onChange"];
const _hoisted_17 = { value: "" };
const _hoisted_18 = ["label"];
const _hoisted_19 = ["value"];
const _hoisted_20 = { class: "select-cell thin" };
const _hoisted_21 = { class: "select small" };
const _hoisted_22 = ["onUpdate:modelValue", "onChange"];
const _hoisted_23 = ["value"];
const _hoisted_24 = {
  key: 0,
  class: "singleline-cell textual"
};
const _hoisted_25 = ["onUpdate:modelValue"];
const _hoisted_26 = {
  key: 1,
  class: "select-cell",
  style: { "text-align": "left" }
};
const _hoisted_27 = { class: "select small" };
const _hoisted_28 = ["onUpdate:modelValue"];
const _hoisted_29 = ["value"];
const _hoisted_30 = { class: "thin action" };
const _hoisted_31 = ["onClick"];
const _hoisted_32 = { class: "hidden" };
const _hoisted_33 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment$1, null, [
    createBaseVNode("div", _hoisted_1$1, [
      createTextVNode(toDisplayString(_ctx.t("formie", "I want to")) + " ", 1),
      createBaseVNode("div", _hoisted_2$1, [
        withDirectives(createBaseVNode("select", {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.settings.sendRule = $event)
        }, [
          createBaseVNode("option", _hoisted_3$1, toDisplayString(_ctx.t("formie", "Send")), 1),
          createBaseVNode("option", _hoisted_4, toDisplayString(_ctx.t("formie", "Not Send")), 1)
        ], 512), [
          [vModelSelect, $data.settings.sendRule]
        ])
      ]),
      createTextVNode(" " + toDisplayString(_ctx.t("formie", "this notification if")) + " ", 1),
      createBaseVNode("div", _hoisted_5, [
        withDirectives(createBaseVNode("select", {
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.settings.conditionRule = $event)
        }, [
          createBaseVNode("option", _hoisted_6, toDisplayString(_ctx.t("formie", "All")), 1),
          createBaseVNode("option", _hoisted_7, toDisplayString(_ctx.t("formie", "Any")), 1)
        ], 512), [
          [vModelSelect, $data.settings.conditionRule]
        ])
      ]),
      createTextVNode(" " + toDisplayString(_ctx.t("formie", "of the following rules match.")), 1)
    ]),
    createBaseVNode("table", _hoisted_8, [
      createBaseVNode("thead", null, [
        createBaseVNode("tr", null, [
          createBaseVNode("th", _hoisted_9, toDisplayString(_ctx.t("formie", "Field")), 1),
          createBaseVNode("th", _hoisted_10, toDisplayString(_ctx.t("formie", "Condition")), 1),
          createBaseVNode("th", _hoisted_11, toDisplayString(_ctx.t("formie", "Value")), 1),
          _hoisted_12
        ])
      ]),
      createBaseVNode("tbody", _hoisted_13, [
        (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.settings.conditions, (row, index2) => {
          return openBlock(), createElementBlock("tr", {
            key: row.id
          }, [
            createBaseVNode("td", _hoisted_14, [
              createBaseVNode("div", _hoisted_15, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.field = $event,
                  onChange: ($event) => $options.changeDropdown(row)
                }, [
                  createBaseVNode("option", _hoisted_17, toDisplayString(_ctx.t("formie", "Select an option")), 1),
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.fieldOptions, (optgroup, i) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: i,
                      label: optgroup.label
                    }, [
                      (openBlock(true), createElementBlock(Fragment$1, null, renderList(optgroup.options, (option3, j2) => {
                        return openBlock(), createElementBlock("option", {
                          key: j2,
                          value: option3.value
                        }, toDisplayString(option3.label), 9, _hoisted_19);
                      }), 128))
                    ], 8, _hoisted_18);
                  }), 128))
                ], 40, _hoisted_16), [
                  [vModelSelect, row.field]
                ])
              ])
            ]),
            createBaseVNode("td", _hoisted_20, [
              createBaseVNode("div", _hoisted_21, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.condition = $event,
                  onChange: ($event) => $options.changeDropdown(row)
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList($data.conditions, (condition, i) => {
                    return openBlock(), createElementBlock("option", {
                      key: i,
                      value: condition.value
                    }, toDisplayString(condition.label), 9, _hoisted_23);
                  }), 128))
                ], 40, _hoisted_22), [
                  [vModelSelect, row.condition]
                ])
              ])
            ]),
            row.valueType === "text" ? (openBlock(), createElementBlock("td", _hoisted_24, [
              withDirectives(createBaseVNode("textarea", {
                "onUpdate:modelValue": ($event) => row.value = $event,
                rows: "1",
                style: { "min-height": "36px" }
              }, null, 8, _hoisted_25), [
                [vModelText, row.value]
              ])
            ])) : createCommentVNode("v-if", true),
            row.valueType === "select" ? (openBlock(), createElementBlock("td", _hoisted_26, [
              createBaseVNode("div", _hoisted_27, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": ($event) => row.value = $event
                }, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(row.valueOptions, (option3, i) => {
                    return openBlock(), createElementBlock("option", {
                      key: i,
                      value: option3.value
                    }, toDisplayString(option3.label), 9, _hoisted_29);
                  }), 128))
                ], 8, _hoisted_28), [
                  [vModelSelect, row.value]
                ])
              ])
            ])) : createCommentVNode("v-if", true),
            createBaseVNode("td", _hoisted_30, [
              createBaseVNode("a", {
                class: "delete icon",
                title: "Delete",
                onClick: withModifiers(($event) => $options.removeRow(index2), ["prevent"])
              }, null, 8, _hoisted_31)
            ])
          ]);
        }), 128))
      ])
    ]),
    createBaseVNode("div", {
      class: "btn add icon",
      onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.addRow && $options.addRow(...args), ["prevent"]))
    }, toDisplayString(_ctx.t("formie", "Add rule")), 1),
    createBaseVNode("div", _hoisted_32, [
      _hoisted_33,
      withDirectives(createBaseVNode("textarea", {
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $props.context._value = $event),
        class: "input text fullwidth"
      }, null, 512), [
        [vModelText, $props.context._value]
      ])
    ])
  ], 64);
}
var NotificationConditions = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/NotificationConditions.vue"]]);
const _sfc_main$1 = {
  name: "SlideUpDown",
  props: {
    active: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number,
      default: 500
    },
    tag: {
      type: String,
      default: "div"
    },
    useHidden: {
      type: Boolean,
      default: true
    }
  },
  emits: ["open-start", "open-end", "close-start", "close-end"],
  data: () => {
    return {
      style: {},
      initial: false,
      hidden: false
    };
  },
  computed: {
    el() {
      return this.$refs.container;
    },
    attrs() {
      const attrs = {
        "aria-hidden": !this.active,
        "aria-expanded": this.active
      };
      if (this.useHidden) {
        attrs.hidden = this.hidden;
      }
      return attrs;
    }
  },
  watch: {
    active() {
      this.layout();
    }
  },
  mounted() {
    this.layout();
    this.initial = true;
  },
  created() {
    this.hidden = !this.active;
  },
  methods: {
    layout() {
      if (this.active) {
        this.hidden = false;
        this.$emit("open-start");
        if (this.initial) {
          this.setHeight("0px", () => {
            return `${this.el.scrollHeight}px`;
          });
        }
      } else {
        this.$emit("close-start");
        this.setHeight(`${this.el.scrollHeight}px`, () => {
          return "0px";
        });
      }
    },
    asap(callback) {
      if (!this.initial) {
        callback();
      } else {
        this.$nextTick(callback);
      }
    },
    setHeight(temp, afterRelayout) {
      this.style = { height: temp };
      this.asap(() => {
        this.__ = this.el.scrollHeight;
        this.style = {
          height: afterRelayout(),
          overflow: "hidden",
          "transition-property": "height",
          "transition-timing-function": "ease-out",
          "transition-duration": `${this.duration}ms`
        };
      });
    },
    onTransitionEnd(event) {
      if (event.target !== this.el) {
        return;
      }
      if (this.active) {
        this.style = {};
        this.$emit("open-end");
      } else {
        this.style = {
          height: "0",
          overflow: "hidden"
        };
        this.hidden = true;
        this.$emit("close-end");
      }
    }
  },
  render() {
    return h(this.tag, {
      style: this.style,
      attrs: this.attrs,
      ref: "container",
      on: { transitionend: this.onTransitionEnd }
    }, this.$slots.default());
  }
};
var SlideUpDown = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/components/SlideUpDown.vue"]]);
const _sfc_main = {
  name: "ToggleBlock",
  components: {
    SlideUpDown
  },
  props: {
    hasErrors: {
      type: Boolean,
      default: false
    }
  },
  computed: __spreadProps(__spreadValues({}, mapState({
    editingField: (state2) => {
      return state2.formie.editingField;
    }
  })), {
    enabledHandle() {
      return `${this.$attrs.blockHandle}Enabled`;
    },
    collapsedHandle() {
      return `${this.$attrs.blockHandle}Collapsed`;
    },
    isEnabled() {
      if (!this.showEnabled) {
        return true;
      }
      if (this.editingField && this.editingField.field) {
        return this.editingField.field.settings[this.enabledHandle];
      }
      return true;
    },
    isCollapsed() {
      if (!this.showToggle) {
        return false;
      }
      if (this.editingField && this.editingField.field) {
        return this.editingField.field.settings[this.collapsedHandle];
      }
      return false;
    },
    showToggle() {
      if (this.$attrs.showToggle !== void 0) {
        return this.$attrs.showToggle;
      }
      return true;
    },
    showEnabled() {
      if (this.$attrs.showEnabled !== void 0) {
        return this.$attrs.showEnabled;
      }
      return true;
    }
  }),
  watch: {
    isEnabled(newValue) {
      if (this.editingField && this.editingField.field) {
        this.editingField.field.settings[this.collapsedHandle] = !newValue;
      }
    }
  }
};
const _hoisted_1 = { class: "fui-tb-header" };
const _hoisted_2 = { class: "fui-tb-header-title" };
const _hoisted_3 = { class: "fui-tb-body" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FormKit = resolveComponent("FormKit");
  const _component_slide_up_down = resolveComponent("slide-up-down");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["fui-toggle-block", { "has-errors": $props.hasErrors }])
  }, [
    createBaseVNode("div", _hoisted_1, [
      $options.showEnabled ? (openBlock(), createBlock(_component_FormKit, {
        key: 0,
        id: $options.enabledHandle,
        type: "lightswitch",
        "extra-small": true,
        name: $options.enabledHandle
      }, null, 8, ["id", "name"])) : createCommentVNode("v-if", true),
      createBaseVNode("span", _hoisted_2, toDisplayString(_ctx.$attrs.blockLabel), 1),
      $options.showToggle ? (openBlock(), createBlock(_component_FormKit, {
        key: 1,
        id: $options.collapsedHandle,
        type: "collapse",
        name: $options.collapsedHandle
      }, null, 8, ["id", "name"])) : createCommentVNode("v-if", true)
    ]),
    createVNode(_component_slide_up_down, {
      active: !$options.isCollapsed,
      duration: 300
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_3, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _: 3
    }, 8, ["active"])
  ], 2);
}
var ToggleBlock = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "/Users/joshcrawford/public_html/craft4-plugins/formie/src/web/assets/forms/src/js/formkit/ToggleBlock.vue"]]);
const emailOrVariable = (node, address) => {
  const variableRegex = /({.*?})/;
  const emailRegex = /(^$|^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$)/;
  if (variableRegex.test(node.value)) {
    return true;
  }
  return emailRegex.test(node.value);
};
const minBlock = (node, address) => {
  const values = node.at("$root").value;
  if (has(values, "address1Enabled")) {
    return values.autocompleteEnabled || values.address1Enabled || values.address2Enabled || values.address3Enabled || values.cityEnabled || values.stateEnabled || values.zipEnabled || values.countryEnabled;
  }
  if (has(values, "prefixEnabled")) {
    return values.prefixEnabled || values.firstNameEnabled || values.middleNameEnabled || values.lastNameEnabled;
  }
  return true;
};
minBlock.skipEmpty = false;
const requiredIf = (node, address) => {
  var _a;
  const foreignValue = (_a = node.at(address)) == null ? void 0 : _a.value;
  return foreignValue ? !empty$2(node.value) : true;
};
requiredIf.skipEmpty = false;
const uniqueHandle = (node, args) => {
  const $store = node.config.rootConfig.formieConfig;
  if ($store) {
    const { editingField } = $store.state.formie;
    if (editingField) {
      return editingField.fieldHandles.indexOf(node.value) === -1;
    }
  }
  return true;
};
uniqueHandle.skipEmpty = false;
const checkDuplicates = function(options2, field) {
  const occurrences = options2.reduce((counter, item) => {
    counter[item[field]] = counter[item[field]] + 1 || 1;
    return counter;
  }, {});
  return Object.keys(occurrences).filter((item) => {
    return occurrences[item] > 1 ? item : false;
  });
};
const required2 = function(node, prop2) {
  var _a, _b;
  const options2 = (_a = node.at(`$root.${node.name}`)) == null ? void 0 : _a.value;
  const columns = (_b = node.context.attrs) == null ? void 0 : _b.columns;
  if (!Array.isArray(options2) || !Array.isArray(columns)) {
    return true;
  }
  const emptyFields = options2.filter((row) => {
    const valueKey = columns.find((o) => {
      return o.type === prop2;
    }).name || prop2;
    if (prop2 === "value" && row.isOptgroup) {
      return false;
    }
    if (empty$2(row[valueKey])) {
      if (prop2 === "value") {
        node.config.valuesWithError.push(row[valueKey]);
      } else if (prop2 === "label") {
        node.config.labelsWithError.push(row[valueKey]);
      }
    }
    return empty$2(row[valueKey]);
  });
  return !emptyFields.length;
};
const unique = function(node, prop2) {
  var _a, _b;
  let options2 = (_a = node.at(`$root.${node.name}`)) == null ? void 0 : _a.value;
  const columns = (_b = node.context.attrs) == null ? void 0 : _b.columns;
  if (prop2 === "label") {
    node.config.labelsWithError = [];
  } else if (prop2 === "value") {
    node.config.valuesWithError = [];
  }
  if (!Array.isArray(options2) || !Array.isArray(columns)) {
    return true;
  }
  const value = columns.find((o) => {
    return o.type === prop2;
  }).name || prop2;
  if (prop2 === "value") {
    options2 = options2.filter((option3) => {
      return !option3.isOptgroup;
    });
  }
  const duplicates = checkDuplicates(options2, value);
  duplicates.forEach((duplicate) => {
    if (prop2 === "value") {
      node.config.valuesWithError.push(duplicate);
    } else if (prop2 === "label") {
      node.config.labelsWithError.push(duplicate);
    }
  });
  return !duplicates.length;
};
const requiredTableCellLabel = (node) => {
  return required2(node, "label");
};
const requiredTableCellValue = (node) => {
  return required2(node, "value");
};
const uniqueTableCellLabel = (node) => {
  return unique(node, "label");
};
const uniqueTableCellValue = (node) => {
  return unique(node, "value");
};
var formkitConfig = defaultConfig({
  plugins: [moveLabelPlugin, addSelectWrapperPlugin],
  rules: {
    emailOrVariable,
    minBlock,
    requiredIf,
    requiredTableCellLabel,
    requiredTableCellValue,
    uniqueHandle,
    uniqueTableCellLabel,
    uniqueTableCellValue
  },
  messages: {
    en: {
      validation: {
        requiredIf({ name }) {
          return Craft.t("formie", "{name} is required.", { name });
        },
        requiredTableCellLabel(options2) {
          const column = options2.node.context.attrs.columns.find((item) => {
            return item.type === "label";
          });
          return Craft.t("formie", "{name} is required.", { name: column.label });
        },
        requiredTableCellValue(options2) {
          const column = options2.node.context.attrs.columns.find((item) => {
            return item.type === "value";
          });
          return Craft.t("formie", "{name} is required.", { name: column.label });
        },
        minBlock({ name }) {
          return Craft.t("formie", "At least one field is required.");
        },
        uniqueHandle({ name }) {
          return Craft.t("formie", "Handle must be unique.");
        },
        uniqueTableCellLabel(options2) {
          const column = options2.node.context.attrs.columns.find((item) => {
            return item.type === "label";
          });
          return Craft.t("formie", "All {name} must be unique.", { name: column.label });
        },
        uniqueTableCellValue(options2) {
          const column = options2.node.context.attrs.columns.find((item) => {
            return item.type === "value";
          });
          return Craft.t("formie", "All {name} must be unique.", { name: column.label });
        }
      }
    }
  },
  config: {
    classes: generateClasses({
      global: {
        outer: "$reset field",
        wrapper: "$reset field field-wrapper",
        inner: "$reset input",
        label: "$reset field-label",
        help: "$reset instructions",
        messages: "$reset errors",
        message: "$reset error",
        input: "$reset"
      },
      select: {
        input: "$reset select"
      }
    })
  },
  inputs: {
    checkboxSelect: createInput(CheckboxSelectInput),
    date: createInput(DateInput),
    elementSelect: createInput(ElementSelectInput),
    fieldSelect: createInput(FieldSelectInput),
    handle: createInput(HandleInput),
    lightswitch: createInput(LightswitchInput),
    multiSelect: createInput(MultiSelectInput),
    notificationRecipients: createInput(NotificationRecipientsInput),
    richText: createInput(RichTextInput),
    staticTable: createInput(StaticTableInput),
    table: createInput(TableInput, {
      config: {
        labelsWithError: [],
        valuesWithError: []
      }
    }),
    variableText: createInput(VariableTextInput),
    collapse: createInput(Collapse),
    fieldConditions: createInput(FieldConditions),
    fieldWrap: createInput({
      $el: "div",
      children: "$slots.default"
    }),
    notificationConditions: createInput(NotificationConditions),
    toggleBlocks: createInput({
      $el: "div",
      children: "$slots.default"
    }),
    toggleBlock: createInput(ToggleBlock)
  }
});
var md5 = { exports: {} };
(function(module2) {
  (function($2) {
    function safeAdd(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num2, cnt) {
      return num2 << cnt | num2 >>> 32 - cnt;
    }
    function md5cmn(q2, a, b, x, s, t2) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q2), safeAdd(x, t2)), s), b);
    }
    function md5ff(a, b, c, d2, x, s, t2) {
      return md5cmn(b & c | ~b & d2, a, b, x, s, t2);
    }
    function md5gg(a, b, c, d2, x, s, t2) {
      return md5cmn(b & d2 | c & ~d2, a, b, x, s, t2);
    }
    function md5hh(a, b, c, d2, x, s, t2) {
      return md5cmn(b ^ c ^ d2, a, b, x, s, t2);
    }
    function md5ii(a, b, c, d2, x, s, t2) {
      return md5cmn(c ^ (b | ~d2), a, b, x, s, t2);
    }
    function binlMD5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[(len + 64 >>> 9 << 4) + 14] = len;
      var i;
      var olda;
      var oldb;
      var oldc;
      var oldd;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d2 = 271733878;
      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d2;
        a = md5ff(a, b, c, d2, x[i], 7, -680876936);
        d2 = md5ff(d2, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d2, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d2, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d2, x[i + 4], 7, -176418897);
        d2 = md5ff(d2, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d2, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d2, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d2, x[i + 8], 7, 1770035416);
        d2 = md5ff(d2, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d2, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d2, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d2, x[i + 12], 7, 1804603682);
        d2 = md5ff(d2, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d2, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d2, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d2, x[i + 1], 5, -165796510);
        d2 = md5gg(d2, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d2, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d2, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d2, x[i + 5], 5, -701558691);
        d2 = md5gg(d2, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d2, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d2, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d2, x[i + 9], 5, 568446438);
        d2 = md5gg(d2, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d2, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d2, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d2, x[i + 13], 5, -1444681467);
        d2 = md5gg(d2, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d2, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d2, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d2, x[i + 5], 4, -378558);
        d2 = md5hh(d2, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d2, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d2, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d2, x[i + 1], 4, -1530992060);
        d2 = md5hh(d2, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d2, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d2, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d2, x[i + 13], 4, 681279174);
        d2 = md5hh(d2, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d2, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d2, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d2, x[i + 9], 4, -640364487);
        d2 = md5hh(d2, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d2, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d2, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d2, x[i], 6, -198630844);
        d2 = md5ii(d2, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d2, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d2, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d2, x[i + 12], 6, 1700485571);
        d2 = md5ii(d2, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d2, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d2, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d2, x[i + 8], 6, 1873313359);
        d2 = md5ii(d2, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d2, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d2, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d2, x[i + 4], 6, -145523070);
        d2 = md5ii(d2, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d2, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d2, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d2 = safeAdd(d2, oldd);
      }
      return [a, b, c, d2];
    }
    function binl2rstr(input2) {
      var i;
      var output = "";
      var length32 = input2.length * 32;
      for (i = 0; i < length32; i += 8) {
        output += String.fromCharCode(input2[i >> 5] >>> i % 32 & 255);
      }
      return output;
    }
    function rstr2binl(input2) {
      var i;
      var output = [];
      output[(input2.length >> 2) - 1] = void 0;
      for (i = 0; i < output.length; i += 1) {
        output[i] = 0;
      }
      var length8 = input2.length * 8;
      for (i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input2.charCodeAt(i / 8) & 255) << i % 32;
      }
      return output;
    }
    function rstrMD5(s) {
      return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
    }
    function rstrHMACMD5(key, data) {
      var i;
      var bkey = rstr2binl(key);
      var ipad = [];
      var opad = [];
      var hash2;
      ipad[15] = opad[15] = void 0;
      if (bkey.length > 16) {
        bkey = binlMD5(bkey, key.length * 8);
      }
      for (i = 0; i < 16; i += 1) {
        ipad[i] = bkey[i] ^ 909522486;
        opad[i] = bkey[i] ^ 1549556828;
      }
      hash2 = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
      return binl2rstr(binlMD5(opad.concat(hash2), 512 + 128));
    }
    function rstr2hex(input2) {
      var hexTab = "0123456789abcdef";
      var output = "";
      var x;
      var i;
      for (i = 0; i < input2.length; i += 1) {
        x = input2.charCodeAt(i);
        output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
      }
      return output;
    }
    function str2rstrUTF8(input2) {
      return unescape(encodeURIComponent(input2));
    }
    function rawMD5(s) {
      return rstrMD5(str2rstrUTF8(s));
    }
    function hexMD5(s) {
      return rstr2hex(rawMD5(s));
    }
    function rawHMACMD5(k2, d2) {
      return rstrHMACMD5(str2rstrUTF8(k2), str2rstrUTF8(d2));
    }
    function hexHMACMD5(k2, d2) {
      return rstr2hex(rawHMACMD5(k2, d2));
    }
    function md52(string, key, raw2) {
      if (!key) {
        if (!raw2) {
          return hexMD5(string);
        }
        return rawMD5(string);
      }
      if (!raw2) {
        return hexHMACMD5(key, string);
      }
      return rawHMACMD5(key, string);
    }
    if (module2.exports) {
      module2.exports = md52;
    } else {
      $2.md5 = md52;
    }
  })(commonjsGlobal$1);
})(md5);
var blueimpMd5 = md5.exports;
function md5Hex(data) {
  if (Array.isArray(data)) {
    data = data.join("");
  }
  return blueimpMd5(data);
}
const state$4 = {
  pages: []
};
const getRows = (payload) => {
  if (payload.fieldId) {
    const field = getters$4.field(state$4)(payload.fieldId);
    if (typeof field.rows === "undefined") {
      field.rows = [];
    }
    return ref(field.rows);
  }
  if (typeof state$4.pages[payload.pageIndex].rows === "undefined") {
    state$4.pages[payload.pageIndex].rows = [];
  }
  return ref(state$4.pages[payload.pageIndex].rows);
};
const mutations$4 = {
  SET_FORM_CONFIG(state2, config2) {
    if (config2.pages && Array.isArray(config2.pages)) {
      config2.pages.forEach((page) => {
        if (page.rows && Array.isArray(page.rows)) {
          page.rows.forEach((row) => {
            if (row.fields && Array.isArray(row.fields)) {
              row.fields.forEach((field) => {
                if (!field.vid) {
                  field.vid = newId();
                  if (field.rows && Array.isArray(field.rows)) {
                    field.rows.forEach((nestedRow) => {
                      if (nestedRow.fields && Array.isArray(nestedRow.fields)) {
                        nestedRow.fields.forEach((nestedField) => {
                          if (!nestedField.vid) {
                            nestedField.vid = newId();
                          }
                        });
                      }
                    });
                  }
                }
              });
            }
          });
        }
      });
    }
    for (const prop2 in config2) {
      if (Object.hasOwnProperty.call(config2, prop2)) {
        state2[prop2] = config2[prop2];
      }
    }
  },
  ADD_PAGE(state2, payload) {
    const { data } = payload;
    state2.pages.push(data);
  },
  UPDATE_PAGE(state2, payload) {
    const { pageIndex, data } = payload;
    for (const prop2 in data) {
      if (Object.hasOwnProperty.call(data, prop2)) {
        state2.pages[pageIndex][prop2] = data[prop2];
      }
    }
  },
  DELETE_PAGE(state2, payload) {
    const { pageIndex } = payload;
    state2.pages.splice(pageIndex, 1);
  },
  ADD_PAGE_SETTINGS(state2, payload) {
    const { pageIndex, data } = payload;
    state2.pages[pageIndex].settings = data;
  },
  APPEND_ROW(state2, payload) {
    const { rowIndex, data } = payload;
    const rows = getRows(payload).value;
    if (rowIndex) {
      rows.splice(rowIndex, 0, data);
    } else {
      rows.push(data);
    }
  },
  APPEND_ROW_TO_PAGE(state2, payload) {
    const { sourcePageIndex, sourceRowIndex, sourceColumnIndex, pageIndex, data } = payload;
    if (state2.pages[pageIndex].rows === void 0) {
      state2.pages[pageIndex].rows = [];
    }
    data.fields = state2.pages[sourcePageIndex].rows[sourceRowIndex].fields.splice(sourceColumnIndex, 1);
    if (state2.pages[sourcePageIndex].rows[sourceRowIndex].fields.length === 0) {
      state2.pages[sourcePageIndex].rows.splice(sourceRowIndex, 1);
    }
    state2.pages[pageIndex].rows.push(data);
  },
  ADD_ROW(state2, payload) {
    const { rowIndex, data } = payload;
    const rows = getRows(payload).value;
    rows.splice(rowIndex, 0, data);
  },
  MOVE_ROW(state2, payload) {
    let { sourceRowIndex, sourceColumnIndex, rowIndex, data } = payload;
    const rows = getRows(payload).value;
    if (sourceRowIndex === rowIndex || sourceRowIndex === rowIndex - 1) {
      if (rows[sourceRowIndex].fields.length === 1) {
        return;
      }
    }
    data.fields = rows[sourceRowIndex].fields.splice(sourceColumnIndex, 1);
    if (rows[sourceRowIndex].fields.length === 0) {
      rows.splice(sourceRowIndex, 1);
      if (sourceRowIndex < rowIndex) {
        rowIndex = rowIndex - 1;
      }
    }
    rows.splice(rowIndex, 0, data);
  },
  ADD_COLUMN(state2, payload) {
    const { rowIndex, columnIndex, data } = payload;
    const rows = getRows(payload).value;
    rows[rowIndex].fields.splice(columnIndex, 0, data);
  },
  MOVE_COLUMN(state2, payload) {
    let { sourceRowIndex, sourceColumnIndex, rowIndex, columnIndex } = payload;
    if (sourceRowIndex === rowIndex && sourceColumnIndex === columnIndex) {
      return;
    }
    if (sourceRowIndex === rowIndex && sourceColumnIndex === columnIndex - 1) {
      return;
    }
    const rows = getRows(payload).value;
    if (sourceRowIndex == rowIndex && rows[sourceRowIndex].fields.length === 1) {
      return;
    }
    const [fieldData] = rows[sourceRowIndex].fields.splice(sourceColumnIndex, 1);
    if (rows[sourceRowIndex].fields.length === 0) {
      rows.splice(sourceRowIndex, 1);
      if (sourceRowIndex < rowIndex) {
        rowIndex = rowIndex - 1;
      }
    }
    rows[rowIndex].fields.splice(columnIndex, 0, fieldData);
  },
  DELETE_FIELD(state2, payload) {
    const { id } = payload;
    forEach$1(state2.pages, (page) => {
      forEach$1(page.rows, (row) => {
        forEach$1(row.fields, (field, key) => {
          if (field && field.vid == id) {
            row.fields.splice(key, 1);
            return false;
          }
          if (field.supportsNested) {
            forEach$1(field.rows, (repeaterRow) => {
              forEach$1(repeaterRow.fields, (repeaterField, repeaterKey) => {
                if (repeaterField && repeaterField.vid == id) {
                  repeaterRow.fields.splice(repeaterKey, 1);
                  return false;
                }
              });
            });
          }
        });
      });
    });
    forEach$1(state2.pages, (page) => {
      forEach$1(page.rows, (row, key) => {
        if (row && row.fields.length === 0) {
          page.rows.splice(key, 1);
          return false;
        }
        forEach$1(row.fields, (field) => {
          if (field.supportsNested) {
            forEach$1(field.rows, (repeaterRow, repeaterKey) => {
              if (repeaterRow && repeaterRow.fields.length === 0) {
                field.rows.splice(repeaterKey, 1);
                return false;
              }
            });
          }
        });
      });
    });
  },
  UPDATE_FIELD_SETTINGS(state2, payload) {
    const { rowIndex, columnIndex, prop: prop2, value } = payload;
    const rows = getRows(payload).value;
    rows[rowIndex].fields[columnIndex].settings[prop2] = value;
  },
  SET_FIELD_PROP(state2, payload) {
    const { rowIndex, columnIndex, prop: prop2, value } = payload;
    const rows = getRows(payload).value;
    rows[rowIndex].fields[columnIndex][prop2] = value;
  },
  SET_VARIABLES(state2, config2) {
    state2.variables = config2;
  }
};
const actions$4 = {
  setFormConfig(context, config2) {
    context.commit("SET_FORM_CONFIG", config2);
  },
  addPage(context, payload) {
    context.commit("ADD_PAGE", payload);
  },
  updatePage(context, payload) {
    context.commit("UPDATE_PAGE", payload);
  },
  deletePage(context, payload) {
    context.commit("DELETE_PAGE", payload);
  },
  addPageSettings(context, payload) {
    context.commit("ADD_PAGE_SETTINGS", payload);
  },
  appendRow(context, payload) {
    context.commit("APPEND_ROW", payload);
  },
  appendRowToPage(context, payload) {
    context.commit("APPEND_ROW_TO_PAGE", payload);
  },
  addRow(context, payload) {
    context.commit("ADD_ROW", payload);
  },
  moveRow(context, payload) {
    context.commit("MOVE_ROW", payload);
  },
  addColumn(context, payload) {
    context.commit("ADD_COLUMN", payload);
  },
  moveColumn(context, payload) {
    context.commit("MOVE_COLUMN", payload);
  },
  deleteField(context, payload) {
    context.commit("DELETE_FIELD", payload);
  },
  updateFieldSettings(context, payload) {
    context.commit("UPDATE_FIELD_SETTINGS", payload);
  },
  setFieldProp(context, payload) {
    context.commit("SET_FIELD_PROP", payload);
  },
  setVariables(context, config2) {
    context.commit("SET_VARIABLES", config2);
  }
};
const getters$4 = {
  config: (state2) => {
    return state2;
  },
  formHash: (state2) => {
    return md5Hex(JSON.stringify(state2.pages));
  },
  pageSettings: (state2) => {
    return (pageId) => {
      const page = find$3(state2.pages, { id: pageId });
      if (page) {
        return page.settings;
      }
      return {};
    };
  },
  field: (state2) => {
    return (vid) => {
      const allFields = getters$4.fields(state2);
      return find$3(allFields, { vid });
    };
  },
  fields: (state2) => {
    const allRows = flatMap(state2.pages, "rows");
    let allFields = flatMap(allRows, "fields");
    const repeaterFields = filter(allFields, (field) => {
      return !!field.rows;
    });
    const repeaterRows = flatMap(repeaterFields, "rows");
    allFields = [
      ...allFields,
      ...flatMap(repeaterRows, "fields")
    ];
    return allFields.filter(Boolean);
  },
  generalFields: (state2) => {
    let fields = [];
    for (const key in state2.variables) {
      if (Object.hasOwnProperty.call(state2.variables, key)) {
        fields = [
          ...fields,
          ...state2.variables[key]
        ];
      }
    }
    return fields;
  },
  userFields: (state2) => {
    return state2.variables.users;
  },
  emailFields: (state2, getters2) => {
    return (includeGeneral = false) => {
      const allowedTypes = [
        "verbb\\formie\\fields\\formfields\\Email",
        "verbb\\formie\\fields\\formfields\\Hidden",
        "verbb\\formie\\fields\\formfields\\Recipients"
      ];
      let fields = [
        { label: Craft.t("formie", "Fields"), heading: true }
      ];
      getters2.fields.forEach((field) => {
        if (!toBoolean(field.isNested)) {
          if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((subfield) => {
                if (allowedTypes.includes(subfield.type)) {
                  fields.push({
                    label: `${field.label}: ${subfield.label}`,
                    value: `{field.${field.handle}.${subfield.handle}}`
                  });
                }
              });
            });
          } else if (allowedTypes.includes(field.type)) {
            fields.push({
              label: field.label,
              value: `{field.${field.handle}}`
            });
          }
        }
      });
      if (fields.length === 1) {
        fields = [];
      }
      if (includeGeneral) {
        fields = fields.concat(getters2.generalFields);
      } else {
        fields = fields.concat(state2.variables.email);
      }
      return fields;
    };
  },
  numberFields: (state2, getters2) => {
    return () => {
      const allowedTypes = [
        "verbb\\formie\\fields\\formfields\\Number",
        "verbb\\formie\\fields\\formfields\\Hidden"
      ];
      let fields = [
        { label: Craft.t("formie", "Fields"), heading: true }
      ];
      getters2.fields.forEach((field) => {
        if (!toBoolean(field.isNested)) {
          if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((subfield) => {
                if (allowedTypes.includes(subfield.type)) {
                  fields.push({
                    label: `${field.label}: ${subfield.label}`,
                    value: `{field.${field.handle}.${subfield.handle}}`
                  });
                }
              });
            });
          } else if (allowedTypes.includes(field.type)) {
            fields.push({
              label: field.label,
              value: `{field.${field.handle}}`
            });
          }
        }
      });
      if (fields.length === 1) {
        fields = [];
      }
      return fields;
    };
  },
  plainTextFields: (state2, getters2) => {
    return (includeGeneral = false) => {
      const allowedTypes = [
        "verbb\\formie\\fields\\formfields\\Date",
        "verbb\\formie\\fields\\formfields\\Dropdown",
        "verbb\\formie\\fields\\formfields\\Email",
        "verbb\\formie\\fields\\formfields\\Hidden",
        "verbb\\formie\\fields\\formfields\\Html",
        "verbb\\formie\\fields\\formfields\\Number",
        "verbb\\formie\\fields\\formfields\\Phone",
        "verbb\\formie\\fields\\formfields\\Radio",
        "verbb\\formie\\fields\\formfields\\SingleLineText",
        "verbb\\formie\\fields\\formfields\\Name"
      ];
      let fields = [
        { label: Craft.t("formie", "Fields"), heading: true }
      ];
      getters2.fields.forEach((field) => {
        if (!toBoolean(field.isNested)) {
          if (field.subfieldOptions && field.hasSubfields) {
            field.subfieldOptions.forEach((subfield) => {
              fields.push({
                label: `${field.label}: ${subfield.label}`,
                value: `{field.${field.handle}.${subfield.handle}}`
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((groupfield) => {
                if (groupfield.subfieldOptions && groupfield.hasSubfields) {
                  groupfield.subfieldOptions.forEach((subfield) => {
                    fields.push({
                      label: `${field.label}: ${groupfield.label}: ${subfield.label}`,
                      value: `{field.${field.handle}.${groupfield.handle}.${subfield.handle}}`
                    });
                  });
                } else if (allowedTypes.includes(groupfield.type)) {
                  fields.push({
                    label: `${field.label}: ${groupfield.label}`,
                    value: `{field.${field.handle}.${groupfield.handle}}`
                  });
                }
              });
            });
          } else if (allowedTypes.includes(field.type)) {
            fields.push({
              label: field.label,
              value: `{field.${field.handle}}`
            });
          }
        }
      });
      if (fields.length === 1) {
        fields = [];
      }
      if (includeGeneral) {
        fields = fields.concat(getters2.generalFields);
      }
      return fields;
    };
  },
  allFields: (state2, getters2) => {
    return (includeGeneral = false) => {
      let fields = [
        { label: Craft.t("formie", "Fields"), heading: true }
      ];
      getters2.fields.forEach((field) => {
        if (!toBoolean(field.isNested)) {
          if (field.subfieldOptions && field.hasSubfields) {
            field.subfieldOptions.forEach((subfield) => {
              fields.push({
                id: field.id,
                vid: field.vid,
                type: field.type,
                label: `${field.label}: ${subfield.label}`,
                value: `{field.${field.handle}.${subfield.handle}}`
              });
            });
          } else if (field.type === "verbb\\formie\\fields\\formfields\\Group" && field.rows) {
            field.rows.forEach((row) => {
              row.fields.forEach((groupfield) => {
                if (groupfield.subfieldOptions && groupfield.hasSubfields) {
                  groupfield.subfieldOptions.forEach((subfield) => {
                    fields.push({
                      id: field.id,
                      vid: field.vid,
                      type: field.type,
                      label: `${field.label}: ${groupfield.label}: ${subfield.label}`,
                      value: `{field.${field.handle}.${groupfield.handle}.${subfield.handle}}`
                    });
                  });
                } else {
                  fields.push({
                    id: field.id,
                    vid: field.vid,
                    type: field.type,
                    label: `${field.label}: ${groupfield.label}`,
                    value: `{field.${field.handle}.${groupfield.handle}}`
                  });
                }
              });
            });
          } else {
            fields.push({
              id: field.id,
              vid: field.vid,
              type: field.type,
              label: field.label,
              value: `{field.${field.handle}}`
            });
          }
        }
      });
      if (fields.length === 1) {
        fields = [];
      }
      if (includeGeneral) {
        fields = fields.concat(getters2.generalFields);
      }
      return fields;
    };
  },
  fieldsForType: (state2, getters2) => {
    return (type) => {
      let fields = [];
      fields = fields.concat(getters2.fields.filter((field) => {
        return field.type === type;
      }).map((field) => {
        return { label: field.label, value: `{${field.handle}}` };
      }));
      return fields;
    };
  },
  fieldsForPage: (state2) => {
    return (pageIndex) => {
      return flatMap(state2.pages[pageIndex].rows, "fields");
    };
  },
  fieldHandles: (state2) => {
    const allRows = flatMap(state2.pages, "rows");
    const allFields = flatMap(allRows, "fields");
    return flatMap(allFields, "handle");
  },
  fieldHandlesForField: (state2, getters2, rootState, rootGetters) => {
    return (vid) => {
      const field = getters2.fields.find((field2) => {
        return field2.vid === vid;
      });
      if (field) {
        const allFields = flatMap(field.rows, "fields");
        let fieldHandles = flatMap(allFields, "handle");
        const reservedHandles = rootGetters["formie/reservedHandles"]();
        fieldHandles = fieldHandles.concat(reservedHandles);
        return fieldHandles;
      }
      return [];
    };
  },
  fieldHandlesExcluding: (state2, getters2, rootState, rootGetters) => {
    return (vid, parentId) => {
      const allRows = flatMap(state2.pages, "rows");
      let allFields = flatMap(allRows, "fields");
      if (parentId) {
        const field = getters2.fields.find((field2) => {
          return field2.vid === parentId;
        });
        if (field) {
          allFields = flatMap(field.rows, "fields");
        }
      }
      allFields = omitBy(allFields, { vid });
      let fieldHandles = flatMap(allFields, "handle");
      const reservedHandles = rootGetters["formie/reservedHandles"]();
      fieldHandles = fieldHandles.concat(reservedHandles);
      return fieldHandles;
    };
  },
  notificationIds: (state2) => {
    return flatMap(state2.notifications, "id");
  }
};
var form = {
  namespaced: true,
  state: state$4,
  mutations: mutations$4,
  actions: actions$4,
  getters: getters$4
};
const clone = function(value) {
  if (value === void 0) {
    return void 0;
  }
  return JSON.parse(JSON.stringify(value));
};
const state$3 = [];
const mutations$3 = {
  SET_FIELDTYPES(state2, config2) {
    for (const groupIndex in config2) {
      if (Object.prototype.hasOwnProperty.call(config2, groupIndex)) {
        const { fields } = config2[groupIndex];
        for (const fieldIndex in fields) {
          if (Object.prototype.hasOwnProperty.call(fields, fieldIndex)) {
            const field = fields[fieldIndex];
            state2.push(field);
          }
        }
      }
    }
  }
};
const actions$3 = {
  setFieldtypes(context, config2) {
    context.commit("SET_FIELDTYPES", config2);
  }
};
const getters$3 = {
  fieldtype: (state2) => {
    return (type) => {
      let fieldtype = find$3(state2, { type });
      if (!fieldtype) {
        fieldtype = find$3(state2, { type: "verbb\\formie\\fields\\formfields\\MissingField" });
      }
      return fieldtype;
    };
  },
  newField: (state2) => {
    return (type, settings) => {
      let field = find$3(state2, { type });
      if (!field) {
        field = find$3(state2, { type: "verbb\\formie\\fields\\formfields\\MissingField" });
      }
      const newField = {
        vid: newId(),
        type,
        columnWidth: 12,
        hasLabel: field.hasLabel,
        settings: __spreadValues({}, clone(field.defaults))
      };
      if (field.supportsNested) {
        newField.rows = clone(field.rows);
        newField.supportsNested = true;
      }
      if (settings) {
        Object.assign(newField, settings);
      }
      return newField;
    };
  }
};
var fieldtypes = {
  namespaced: true,
  state: state$3,
  mutations: mutations$3,
  actions: actions$3,
  getters: getters$3
};
const state$2 = [];
const mutations$2 = {
  SET_FIELD_GROUPS(state2, config2) {
    for (const prop2 in config2) {
      state2[prop2] = config2[prop2];
    }
  }
};
const actions$2 = {
  setFieldGroups(context, config2) {
    context.commit("SET_FIELD_GROUPS", config2);
  }
};
const getters$2 = {};
var fieldGroups = {
  namespaced: true,
  state: state$2,
  mutations: mutations$2,
  actions: actions$2,
  getters: getters$2
};
const state$1 = [];
const mutations$1 = {
  SET_NOTIFICATIONS(state2, config2) {
    for (const prop2 in config2) {
      state2[prop2] = config2[prop2];
    }
  },
  ADD_NOTIFICATION(state2, payload) {
    const { data } = payload;
    state2.push(data);
  },
  DELETE_NOTIFICATION(state2, payload) {
    const { id } = payload;
    const index2 = findIndex(state2, { id });
    state2.splice(index2, 1);
  },
  SET_PROP(state2, payload) {
    const { id, prop: prop2, value } = payload;
    const index2 = findIndex(state2, { id });
    state2[index2][prop2] = value;
  }
};
const actions$1 = {
  setNotifications(context, config2) {
    context.commit("SET_NOTIFICATIONS", config2);
  },
  addNotification(context, config2) {
    context.commit("ADD_NOTIFICATION", config2);
  },
  deleteNotification(context, config2) {
    context.commit("DELETE_NOTIFICATION", config2);
  },
  setProp(context, payload) {
    context.commit("SET_PROP", payload);
  }
};
const getters$1 = {};
var notifications = {
  namespaced: true,
  state: state$1,
  mutations: mutations$1,
  actions: actions$1,
  getters: getters$1
};
const state = {
  editingField: null,
  editingNotification: null,
  maxFieldHandleLength: 64,
  maxFormHandleLength: 64,
  reservedHandles: [],
  emailTemplates: [],
  existingFields: [],
  existingNotifications: [],
  statuses: []
};
const mutations = {
  SET_EDITING_FIELD(state2, config2) {
    state2.editingField = config2;
  },
  SET_EDITING_NOTIFICATION(state2, config2) {
    state2.editingNotification = config2;
  },
  SET_MAX_FIELD_HANDLE_LENGTH(state2, config2) {
    state2.maxFieldHandleLength = config2;
  },
  SET_MAX_FORM_HANDLE_LENGTH(state2, config2) {
    state2.maxFormHandleLength = config2;
  },
  SET_RESERVED_HANDLES(state2, config2) {
    for (const prop2 in config2) {
      if (Object.hasOwnProperty.call(config2, prop2)) {
        state2.reservedHandles[prop2] = config2[prop2];
      }
    }
  },
  SET_EMAIL_TEMPLATES(state2, config2) {
    for (const prop2 in config2) {
      if (Object.hasOwnProperty.call(config2, prop2)) {
        state2.emailTemplates[prop2] = config2[prop2];
      }
    }
  },
  SET_EXISTING_FIELDS(state2, config2) {
    for (const prop2 in config2) {
      if (Object.hasOwnProperty.call(config2, prop2)) {
        state2.existingFields[prop2] = config2[prop2];
      }
    }
  },
  SET_EXISTING_NOTIFICATIONS(state2, config2) {
    for (const prop2 in config2) {
      if (Object.hasOwnProperty.call(config2, prop2)) {
        state2.existingNotifications[prop2] = config2[prop2];
      }
    }
  },
  SET_STATUSES(state2, config2) {
    for (const prop2 in config2) {
      if (Object.hasOwnProperty.call(config2, prop2)) {
        state2.statuses[prop2] = config2[prop2];
      }
    }
  }
};
const actions = {
  setEditingField(context, config2) {
    context.commit("SET_EDITING_FIELD", config2);
  },
  setEditingNotification(context, config2) {
    context.commit("SET_EDITING_NOTIFICATION", config2);
  },
  setMaxFieldHandleLength(context, config2) {
    context.commit("SET_MAX_FIELD_HANDLE_LENGTH", config2);
  },
  setMaxFormHandleLength(context, config2) {
    context.commit("SET_MAX_FORM_HANDLE_LENGTH", config2);
  },
  setReservedHandles(context, config2) {
    context.commit("SET_RESERVED_HANDLES", config2);
  },
  setEmailTemplates(context, config2) {
    context.commit("SET_EMAIL_TEMPLATES", config2);
  },
  setExistingFields(context, config2) {
    context.commit("SET_EXISTING_FIELDS", config2);
  },
  setExistingNotifications(context, config2) {
    context.commit("SET_EXISTING_NOTIFICATIONS", config2);
  },
  setStatuses(context, config2) {
    context.commit("SET_STATUSES", config2);
  }
};
const getters = {
  maxFieldHandleLength: (state2) => {
    return () => {
      return state2.maxFieldHandleLength;
    };
  },
  maxFormHandleLength: (state2) => {
    return () => {
      return state2.maxFormHandleLength;
    };
  },
  reservedHandles: (state2) => {
    return () => {
      return state2.reservedHandles;
    };
  },
  emailTemplates: (state2) => {
    return () => {
      return state2.emailTemplates;
    };
  },
  existingFields: (state2) => {
    return () => {
      return state2.existingFields;
    };
  },
  existingNotifications: (state2) => {
    return () => {
      return state2.existingNotifications;
    };
  },
  statuses: (state2) => {
    return () => {
      return state2.statuses;
    };
  }
};
var formie = {
  namespaced: true,
  state,
  mutations,
  actions,
  getters
};
var vuex = createStore({
  modules: {
    form,
    fieldtypes,
    fieldGroups,
    notifications,
    formie
  }
});
const t = function(category, message2, params) {
  if (typeof Craft.translations[category] !== "undefined" && typeof Craft.translations[category][message2] !== "undefined") {
    message2 = Craft.translations[category][message2];
  }
  if (params) {
    return template(message2, {
      interpolate: /{([\s\S]+?)}/g
    })(params);
  }
  return message2;
};
const events = mitt();
const store = vuex;
const createVueApp = (props2) => {
  const app = createApp(__spreadValues({
    delimiters: ["${", "}"]
  }, props2));
  app.config.unwrapInjectedRef = true;
  app.use(ze);
  app.use(install);
  app.use(plugin$1, {
    themes: {
      "fui-tooltip": {
        $extend: "tooltip",
        delay: {
          show: 0,
          hide: 0
        }
      },
      "fui-editor-tooltip": {
        $extend: "tooltip",
        delay: {
          show: 0,
          hide: 0
        }
      }
    }
  });
  app.use(vuex);
  app.use(plugin, formkitConfig);
  app.config.globalProperties.t = t;
  app.config.globalProperties.clone = clone, app.config.globalProperties.$events = events;
  app.config.globalProperties.$isDebug = false;
  return app;
};
export { markdownIt as $, isBuffer$1 as A, Stack as B, arrayEach as C, assignValue as D, getAllKeysIn as E, getAllKeys as F, toNumber as G, baseSet as H, h as I, createBlock as J, renderSlot as K, normalizeStyle as L, Modal as M, resolveDynamicComponent as N, isEmpty$1 as O, createCommentVNode as P, createTextVNode as Q, renderList as R, Symbol$2 as S, Fragment$1 as T, Uint8Array$1 as U, commonjsGlobal$1 as V, getAugmentedNamespace as W, mapState as X, parseDate as Y, compileToFunction as Z, _export_sfc as _, createBaseVNode as a, getDisplayName as a0, generateKebab as a1, newId as a2, withDirectives as a3, vShow as a4, createSlots as a5, mergeProps as a6, Draggable as a7, get2 as a8, pushScopeId as a9, HorizontalRule as aA, ListItem as aB, OrderedList as aC, History as aD, TextAlign as aE, Link as aF, toBoolean as aG, truncate as aH, vModelSelect as aI, store as aJ, ToggleBlock as aK, clone as aL, popScopeId as aa, findIndex as ab, vModelText as ac, reactive as ad, toRef as ae, EditorContent as af, Editor as ag, Document as ah, Dropcursor as ai, Gapcursor as aj, HardBreak as ak, Paragraph as al, Text$1 as am, FocusClasses as an, Bold as ao, Code as ap, Highlight as aq, Italic as ar, Strike as as, Subscript as at, Superscript as au, Underline as av, Blockquote as aw, BulletList as ax, CodeBlock as ay, Heading as az, createVNode as b, createElementBlock as c, withCtx as d, createVueApp as e, generateHandle as f, getNextAvailableHandle as g, copyObject as h, isObject$1 as i, keysIn as j, keys$1 as k, root$1 as l, getSymbols$1 as m, normalizeClass as n, openBlock as o, getSymbolsIn$1 as p, isPrototype as q, resolveComponent as r, getPrototype$1 as s, toDisplayString as t, isObjectLike as u, getTag$1 as v, withModifiers as w, nodeUtil$1 as x, baseUnary as y, isArray$1 as z };
//# sourceMappingURL=config.88043305.js.map
